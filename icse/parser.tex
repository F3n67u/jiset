\section{Parser Generation}

In this section, we introduce a way to automatically generate JavaScript parsers
from given ECMAScript specifications. First, we explain \( \bnfes \), an extension
of BNF used in ECMAScript to describe lexical and syntactic grammars of JavaScript.
We defined a recursive descent parser generator to support \( \bnfes \) notations.
We implemented our idea by extending the basic Scala parser combinator.
The implementation also support the automatic semicolon insertion,
one of the most distinct parsing feautres in ECMAScript.

\subsection{\( \bnfes \): Grammars for ECMAScripts}

ECMAScript provides their lexical and syntactic grammars using \( \bnfes \),
an extension of Backus-Naur form for ECMAScript.
\( \bnfes \) consists of a number of \textit{productions}
with the following forms:
\[
  \nt(\param_1, \cdots, \param_k) ::=
  (\cond_1 \Rightarrow)^? \rhs_1 \mid
  \cdots \mid
  (\cond_n \Rightarrow)^? \rhs_n
\]
The left-hand side represents a parametric nonterminal \( \nt \) with
multiple boolean parameters \( \param_1, \cdots, \param_n \).
A production has multiple right-hand sides with optional conditions.
The condition \( \cond \) is either \( \param_i \) or \( ! \param_i \),
the negation of \( \param_i \).
For example, consider the following production:
\[
  \nt(\param) ::= \param \Rightarrow \code{a}
  \mid \; !\param \Rightarrow \code{b}
  \mid  \code{c}
\]
Then, \( \nt(\kwt) \) means \( \code{a} \mid \code{c} \)
and \( \nt(\kwf) \) means \( \code{b} \mid \code{c} \).

Each right-hand side \( \rhs \) is a sequence of the following symbols:
\begin{itemize}
  \item \( \boxed{\symb} \):
    basic symbols; terminal \( \code{x} \) or
    non-terminal \( \nt(\argument_1, \cdots, \argument_k) \)
  \item \( \boxed{\symb?} \): optional symbols
  \item \( \boxed{\pm \symb} \): positive/negative lookahead symbols
  \item \( \boxed{\symb \butnot \symb'} \): exclusive symbols
  \item \( \boxed{\nolt} \): no line terminator symbols
\end{itemize}

Basic symbols are either terminal or non-terminal.
A non-terminal symbol \( \nt(\argument_1, \cdots, \argument_k) \)
takes multiple arguments and each of them \( \argument_i \) is
a boolean value \( \kwt \), \( \kwf \) or a parameter \( \param_i \).
An optional symbol \( \symb? \) is same with \( \epsilon \mid \symb \)
where \( \epsilon \) denotes the empty sequence.
A positive(negative) lookahead symbol \( +\symb \)(\( -\symb \))
checks that the symbol \( \symb \) succeeds(fails) and
\textit{never consumes any input}.
The exclusive symbols \( \symb \butnot \symb' \)
first checks that the symbol \( \symb \) succeeds
and then checks that the parsing result does not correspond to \( \symb' \).
The no line terminal symbol \( \nolt \) is a special symbol
that restricts the white spaces between two other symbols.

\subsection{SFDF-Backtrack Parsing}

Our goal is to automatically generate readable JavaScript parsers from ECMAScript
grammars written in \( \bnfes \). There are several options for existing paraser generators.
Among them, we decide to extend Packrat parsers~\cite{packrat} 
with 
to support \( \bnfes \) Packrat parsers are first proposed by 


assumptions:

Unambiguous

\begin{itemize}
  \item \textbf{Context-Sensitive Tokens} ECMAScript tokens are context-sensitive
    because of the regular expressions and template strings.
    For example, the code \( \code{/x/g} \) might be a regular expression token
    or four tokens that represent division by variables \( \code{x} \) and \( \code{g} \),
    depends on enclosing contexts. Thus, tokenizers should be evaluated during the parser
    not before the parser.
  \item \textbf{\( \bnfes \) Symbols} Several symbols notations in \( \bnfes \) are
    not trivial to be converted into normal BNF rules. 
\end{itemize}

%  Thus, we extend

% There are two different parsing approaches:
% ``top-down'' approach (LL-style parsing) and
% ``bottom-up'' approach (LR-style parsing).
% Top-down approach support 
% 
% There are two different kinds of parsers: top-down parsing, bottom-up parsing.
% 
% 
% 
% Such features could be easily represented in Parsing Expression Grammars (PEGs).
% 
% 
% 
% Backus–Naur form(BNF)에 다섯 가지의 방식을 추가한 형태로 lexical 및 syntactic grammar를 제공한다.
% 각각의 
combination of recursive descent parsers with predictive parsers

static first terms and dynamic follow terms

\paragraph{Static-first dynamic-follow}
% PEG를 그대로 사용하면 backtrack을 이미 성공한 곳에서는 하지 않기 때문에 lookahead를 추가함

% LL(1)-parser의 정의에서 사용하는 first / follow 개념을 확장하여

% static한 first를 구하고 dynamic하게 오는 follow를 통해 결정함

\subsection{Implementation}

% - 실제 EMCAScript production(필요?) -> Our definition -> AST / Parser
% - code size 줄이기 위해서 모두 풀어헤치지 않고 함수로 변환했다.
% - autmoatic semicolon insertion도 해주는데 fail한 token 중에 가장 나중에 나오는 부분을 찾아서
%   offending token으로 지정하고 이를 기반으로 semicolon insertion을 진행
%   => 넣었을 때 안넣었을 때 test262 parsing 성공률 비교하면 좋을 듯

\section{Semantic generation}

\subsection{Core language}
실행 가능한 specification을 만들기 위한 langauge.
algorithm들의 공통된 행동을 실행할 수 있게 잘 설계함
ex) let X be ... => let X = ...

\subsubsection{다른 rewriting system 또는 compiler와 다른 점}
특징으로는 Parser에서 만들어진 AST를 하나의 값으로 들고 다니면서 관련 함수를 호출하거나 subAST를 가져올수 있게 만들어짐. 이는 Syntax function 실행을 위해선데 이후 initial state organization에서 설명 
또한 ES specification에서 공통적으로 동작하는 복잡한 연산을 expression으로 지원함, 특히 문서에 covered by에 있는 것처럼 AST Value를 Goal symbol로 다시 parse해야 하는 경우도 있고, eval이나 Class creation 관련 함수에서처럼 string을 AST로 parse해야하는 경우도 있음. 그런 경우를 parse-syntax 를 넣어서 처리할 수 있게
해줌.

\subsection{semantic 컴파일하기 위해 하는 것 + specification 구조}
기본적인 원칙 :
\begin{itemize} 
\item 자바스크립트로 알고리즘 이름이랑 파라미터, 스텝을 가져와서 코어의 글로벌 ID에 매치 시켜줌
\item initial Heap을 생성해줌
\end{itemize}
매치를 시킨다는 뜻은 코어의 글로벌 ID에 코어 함수 형태로 알고리즘을 넣는 것임

\subsection{함수의 의미 번역 (algorithm => Function)}
Function은 parameter와 body로 나뉨
\subsubsection{parameter extraction} : HTML에 써있음 + 여러 특별한 말들 (with parameter * )
Builtin function의 경우 specification 내에서 implicit하게 전해지는 parameter들이 있는데, (thisValue, newTarget) 이것을
core에서 모두 명시적으로 받게 (지금은 javascript 단에서) 자동으로 고쳐준다.

\subsubsection{body extraction ( AlgoCompiler )} : 이부분이 Human resource 많이 들어감
여기서 rule에 따라 step을 만들어줌
나눌 수도 있을 것 같은데 지금은 일단 instruction, expression, condition, type, value, reference을 나타내는 position을 분리하고 거기에 맞춰서 case별로 parser를 짬
근데 똑같은 의미도 여러 다른 말로 표현하기 떄문에 지금은 모든 경우를 하나씩 써놓음
또 같은 말도 context에 따라 의미가 다른 경우가 있음 (Return할때), 지금은 알고리즘의 종류에만 dependent하므로 알고리즘에 flag를 둬서 구분

간단하지 않은 알고리즘의 경우는 1) core 내에서 표현될 수 있는 경우 Function을 만들어 모델링하거나 
2) 지원하지 않는 경우가 있다


\begin{itemize}
  \item Formal definition of Core language
    \begin{itemize}
      \item Syntax
      \item Semantics
    \end{itemize}
  \item Abstract algorithms
    \begin{itemize}
      \item syntax-directed / internal method
      \item Converted into Core
    \end{itemize}
\end{itemize}

\section{ Initial state configuration ( generator ) }

By above techniques, we can get the programming language's AST, Parser, and executable steps to run the abstract algorithm in the specification.
But, to run the program with these primitives, Many languages need initial environment to run the program. It is mostly about initialization of builtin types, and it also includes specifying entry point of the program (fetch main function and fill arguments in Java, C, ..)
These environments are sometimes described as steps of algorithm, but mostly it is not. 
In our diagram, we categorized these part as language-dependent environment. It is hard to generate environment automatically, but it is relativly not too heavy to model it compared to modeling numerous algorithms used in runtime.
In this section, we describre how to generate initial environment for ECMAScript to run defined semantics. 


Convert to
\begin{itemize}
\item algorithm name => Global Id
\item Builtin Object function name => Heap Object .Code
\item Type function name => Internal Map field
\item Syntax function name => Internal AST semantics field
\end{itemize}


For ECMAScript Specification, initial environment consists of the builtin objects, Intrinsincs, and binding environment of specification steps.

Builtin objects

 In ECMAScript, there is a initial object which have references of builtin object. Each Builtin Object provides fields and function, just as ordinary object. But when its function is called,
 the corresponding step specified in document should be called. To support global object, we make shape of builtin object and its attributes, and then we autoamtically match the step in specification to corresponding field in object by considering its function name.
 
 Intrinsics

 While Builtin objects can be used to refer itself in ECMAScript language, It is also frequently used in ECMAScript specification. But name of builtin objects
 are defiend for reference in Host language, it needs another name to refer it in specification langauge. Intrinsics are alias for built-in objects. 
 Correspondence between Intrinsic name and Builtin objects are shown in table, so we parse this table to generate global ID to object.

 Binding environment

 In specification, All algorithm has name to refer it, but some algorithms have same names and they are called in context-dependent way.
 \begin{itemize}
  \item Global Algorithm
  \item Type-dependent algorithm
  \item Syntax-dependent algorithm
  \item Builtin object algorithm
  \end{itemize}

 There is four types of algorithm. 
 First is global algorithm that can be called by just name, 
 second is set of algorithms which are bounded in specific type of object, 
 third is set of algorithms which are bounded in AST,
 and forth is set of algorithms which correspond to builtin object function.

 We set builtin object function algorithms when initialzing builtin object, so we descibe about rest three algorithms. 
  
First, we categorized sections by types of algorithm. Builtin object has several own sections to describe its functions,
so it is easy to extract builtin object algorithms. Type-dependent algorithms and syntax-dependent algorithms has their own layout, so it
can be extracted. Rest algorithms are considered as global algorithm.

We just convert global algorithms to function, and bind global identifier to that function to call it by algorithm name.

For type-denpendent algorithms, we organized map from algorithm name to function for each type,
 and we insert functions as propertiy of object when such type of object is created.

For syntax-dependent algorithm, we insert converted functions in AST structure, and add special expression to call AST-dependent algorithm which requires AST Value and algorithm name.
To insert functions, we gather which AST can be applied to a function. Also, to use subAST structure, we passes subAST in function as argument.



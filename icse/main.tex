\documentclass[sigconf,review,anonymous=true]{acmart}

\usepackage{kotex}
\usepackage[T1]{fontenc}
\usepackage{beramono}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{qtree}
\usepackage{colortbl}
\usepackage{ulem}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{booktabs}

% color
\definecolor{gainsboro}{rgb}{0.86, 0.86, 0.86}
\newcommand*{\belowrulesepcolor}[1]{%
  \noalign{%
    \kern-\belowrulesep
    \begingroup
      \color{#1}%
      \hrule height\belowrulesep
    \endgroup
  }%
}
\newcommand*{\aboverulesepcolor}[1]{%
  \noalign{%
    \begingroup
      \color{#1}%
      \hrule height\aboverulesep
    \endgroup
    \kern-\aboverulesep
  }%
}

% dashed line
\usepackage{array}
\usepackage{arydshln}
\setlength\dashlinedash{0.2pt}
\setlength\dashlinegap{1.5pt}
\setlength\arrayrulewidth{0.3pt}

% removed ACM references
\settopmatter{printacmref=false}

% Scala code style
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstdefinestyle{myScalastyle}{
  frame=tb,
  language=scala,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=fixed,
  basicstyle={\footnotesize\ttfamily},
  numbers=none,
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  frame=single,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
}

% ECMAScript Intermediate Reprentations
\lstdefinestyle{ires}{
  frame=tb,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=fixed,
  basicstyle={\footnotesize\ttfamily},
  numbers=none,
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  frame=single,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
}

% JavaScript code style
\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstdefinestyle{myJSstyle}{
  language=JavaScript,
  extendedchars=true,
  basicstyle=\footnotesize\ttfamily,
  showstringspaces=false,
  showspaces=false,
  numbers=none,
  tabsize=2,
  breaklines=true,
  showtabs=false,
  captionpos=b
}

% load macros
\input{macros}

\begin{document}

\title{\( \tool \): JavaScript IR-based Semantics Extraction Toolchain}

\author{Jihyeok Park}
\email{jhpark0223@kaist.ac.kr}
\affiliation{\institution{KAIST}}

\author{Jihee Park}
\email{j31d0@kaist.ac.kr}
\affiliation{\institution{KAIST}}

\author{Sukyoung Ryu}
\email{sryu.cs@kaist.ac.kr}
\affiliation{\institution{KAIST}}

\begin{abstract}
JavaScript was initially designed for client-side code in web browsers,
but its engine is now embedded in various kinds of host software.
Despite its popularity, since the JavaScript semantics is complex
especially due to its dynamic nature, understanding and reasoning
about JavaScript programs are challenging tasks.  Thus,
researchers have proposed several attempts to define the formal semantics
of JavaScript based on ECMAScript, the official JavaScript specification.
However, the existing approaches are manual, labor-intensive, and
error-prone, and they all target only the ECMAScript 5.1 version.
This problem is critical in understanding recent JavaScript programs
because ECMAScript has been annually released since 2015, which made
already five updates after ECMAScript 5.1.

To alleviate the problem, we propose \( \tool \), a JavaScript IR-based Semantics
Extraction Toolchain.  It \textit{automatically} extracts the JavaScript syntax and
semantics from ECMAScript specifications.  \( \tool \) generates a JavaScript
parser for a given grammar written in \( \bnfes \), an extended BNF
used in ECMAScript specifications.  It also converts each
abstract algorithm written in a structured natural language into
functions written in \( \ires \), an Intermediate Representation
for ECMAScript specifications.  The compilation from algorithms to
\( \ires \) functions is defined with \textit{compile rules}.
We applied \( \tool \) to the next proposed version, ECMAScript 2020,
and the automatically extracted semantics passed all \inred{XXXXX} tests 
in test262, the official ECMAScript conformance test suite.
\inred{Moreover, \( \tool \) also successfully extracts
semantics for \inred{XX} proposed features by adding only \inred{XX}
minor compile rules.}
\end{abstract}

\keywords{
  JavaScript,
  mechanized formal semantics,
  recursive descent parsing
}

\maketitle

\input{intro}
\input{overview}
\input{parser}
\input{compiler}
\input{framework}
\input{eval}
\input{related}
\input{conclusion}

\bibliographystyle{ACM-Reference-Format}
\bibliography{ref}

\end{document}

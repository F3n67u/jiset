{
  "algos": [{
    "code": ["          1. Assert: Type(_string_) is String.", "          1. Assert: Type(_searchValue_) is String.", "          1. Assert: _fromIndex_ is a non-negative integer.", "          1. Let _len_ be the length of _string_.", "          1. If _searchValue_ is the empty String and _fromIndex_ ≤ _len_, return _fromIndex_.", "          1. Let _searchLen_ be the length of _searchValue_.", "          1. For each integer _i_ starting with _fromIndex_ such that _i_ ≤ _len_ - _searchLen_, in ascending order, do", "            1. Let _candidate_ be the substring of _string_ from _i_ to _i_ + _searchLen_.", "            1. If _candidate_ is the same sequence of code units as _searchValue_, return _i_.", "          1. Return -1."],
    "head": {
      "name": "StringIndexOf",
      "params": [{
        "kind": "Normal",
        "name": "string"
      }, {
        "kind": "Normal",
        "name": "searchValue"
      }, {
        "kind": "Normal",
        "name": "fromIndex"
      }]
    },
    "ids": "sec-stringindexof",
    "rawBody": "{\n  0:assert (= (typeof string) String)\n  1:assert (= (typeof searchValue) String)\n  3:let len = string[\"length\"]\n  4:if (&& (= searchValue \"\") (! (< len fromIndex))) return fromIndex else 2:{}\n  5:let searchLen = searchValue[\"length\"]\n  6:let i = (+ fromIndex 0i)\n  6:let __x0__ = (+ (- len searchLen) 1i)\n  6:while (< i __x0__) {\n    let __x1__ = \"\"\n    let __x2__ = i\n    while (< __x2__ (+ (+ i searchLen) 1i)) {\n      (0) access __x3__ = (string __x2__)\n      __x1__ = (+ __x1__ __x3__)\n      __x2__ = (+ __x2__ 1i)\n    }\n    let candidate = __x1__\n    if (= candidate searchValue) return i else {}\n  }\n  9:return -1i\n}"
  }, {
    "code": ["            1. If _x_ is *NaN*, return *NaN*.", "            1. Return the result of negating _x_; that is, compute a Number with the same magnitude but opposite sign."],
    "head": {
      "name": "Number::unaryMinus",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }]
    },
    "ids": "sec-numeric-types-number-unaryMinus",
    "rawBody": "{\n  0:if (= x NaN) return NaN else 2:{}\n  1:return (- x)\n}"
  }, {
    "code": ["            1. Let _oldValue_ be ! ToInt32(_x_).", "            1. Return the result of applying bitwise complement to _oldValue_. The mathematical value of the result is exactly representable as a 32-bit two's complement bit string."],
    "head": {
      "name": "Number::bitwiseNOT",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }]
    },
    "ids": "sec-numeric-types-number-bitwiseNOT",
    "rawBody": "{\n  0:(0) app __x0__ = (ToInt32 x)\n  0:let oldValue = [! __x0__]\n  1:return (~ oldValue)\n}"
  }, {
    "code": ["            1. If _exponent_ is *NaN*, return *NaN*.", "            1. If _exponent_ is *+0*<sub>𝔽</sub> or _exponent_ is *-0*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>.", "            1. If _base_ is *NaN*, return *NaN*.", "            1. If _base_ is *+∞*<sub>𝔽</sub>, then", "              1. If _exponent_ > *+0*<sub>𝔽</sub>, return *+∞*<sub>𝔽</sub>. Otherwise, return *+0*<sub>𝔽</sub>.", "            1. If _base_ is *-∞*<sub>𝔽</sub>, then", "              1. If _exponent_ > *+0*<sub>𝔽</sub>, then", "                1. If _exponent_ is an odd integral Number, return *-∞*<sub>𝔽</sub>. Otherwise, return *+∞*<sub>𝔽</sub>.", "              1. Else,", "                1. If _exponent_ is an odd integral Number, return *-0*<sub>𝔽</sub>. Otherwise, return *+0*<sub>𝔽</sub>.", "            1. If _base_ is *+0*<sub>𝔽</sub>, then", "              1. If _exponent_ > *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>. Otherwise, return *+∞*<sub>𝔽</sub>.", "            1. If _base_ is *-0*<sub>𝔽</sub>, then", "              1. If _exponent_ > *+0*<sub>𝔽</sub>, then", "                1. If _exponent_ is an odd integral Number, return *-0*<sub>𝔽</sub>. Otherwise, return *+0*<sub>𝔽</sub>.", "              1. Else,", "                1. If _exponent_ is an odd integral Number, return *-∞*<sub>𝔽</sub>. Otherwise, return *+∞*<sub>𝔽</sub>.", "            1. Assert: _base_ is finite and is neither *+0*<sub>𝔽</sub> nor *-0*<sub>𝔽</sub>.", "            1. If _exponent_ is *+∞*<sub>𝔽</sub>, then", "              1. If abs(ℝ(_base_)) > 1, return *+∞*<sub>𝔽</sub>.", "              1. If abs(ℝ(_base_)) is 1, return *NaN*.", "              1. If abs(ℝ(_base_)) < 1, return *+0*<sub>𝔽</sub>.", "            1. If _exponent_ is *-∞*<sub>𝔽</sub>, then", "              1. If abs(ℝ(_base_)) > 1, return *+0*<sub>𝔽</sub>.", "              1. If abs(ℝ(_base_)) is 1, return *NaN*.", "              1. If abs(ℝ(_base_)) < 1, return *+∞*<sub>𝔽</sub>.", "            1. Assert: _exponent_ is finite and is neither *+0*<sub>𝔽</sub> nor *-0*<sub>𝔽</sub>.", "            1. If _base_ < *+0*<sub>𝔽</sub> and _exponent_ is not an integral Number, return *NaN*.", "            1. Return an implementation-approximated value representing the result of raising ℝ(_base_) to the ℝ(_exponent_) power."],
    "head": {
      "name": "Number::exponentiate",
      "params": [{
        "kind": "Normal",
        "name": "base"
      }, {
        "kind": "Normal",
        "name": "exponent"
      }]
    },
    "ids": "sec-numeric-types-number-exponentiate",
    "rawBody": "{\n  0:if (= exponent NaN) return NaN else 26:{}\n  1:if (|| (= exponent 0i) (= exponent -0.0)) return 1i else 26:{}\n  2:if (= base NaN) return NaN else 26:{}\n  3:if (= base Infinity) if (< 0i exponent) return Infinity else return 0i else 26:{}\n  5:if (= base -Infinity) if (< 0i exponent) (0) ??? \"If id:{exponent} is an odd integral Number , return value:{-∞} . Otherwise , return value:{+∞} .\" else (1) ??? \"If id:{exponent} is an odd integral Number , return value:{-0} . Otherwise , return value:{+0} .\" else 26:{}\n  10:if (= base 0i) if (< 0i exponent) return 0i else return Infinity else 26:{}\n  12:if (= base -0.0) if (< 0i exponent) (2) ??? \"If id:{exponent} is an odd integral Number , return value:{-0} . Otherwise , return value:{+0} .\" else (3) ??? \"If id:{exponent} is an odd integral Number , return value:{-∞} . Otherwise , return value:{+∞} .\" else 26:{}\n  18:if (= exponent Infinity) {\n    19:(0) app __x0__ = (abs base)\n    19:if (< 1i __x0__) return Infinity else 26:{}\n    20:(1) app __x1__ = (abs base)\n    20:if (= __x1__ 1i) return NaN else 26:{}\n    21:(2) app __x2__ = (abs base)\n    21:if (< __x2__ 1i) return 0i else 26:{}\n  } else 26:{}\n  22:if (= exponent -Infinity) {\n    23:(3) app __x3__ = (abs base)\n    23:if (< 1i __x3__) return 0i else 26:{}\n    24:(4) app __x4__ = (abs base)\n    24:if (= __x4__ 1i) return NaN else 26:{}\n    25:(5) app __x5__ = (abs base)\n    25:if (< __x5__ 1i) return Infinity else 26:{}\n  } else 26:{}\n  27:(4) ??? \"If id:{base} < value:{+0} and id:{exponent} is not an integral Number , return value:{NaN} .\"\n  28:(5) ??? \"Return an implementation - approximated value representing the result of raising ℝ ( id:{base} ) to the ℝ ( id:{exponent} ) power .\"\n}"
  }, {
    "code": ["            1. If _x_ is *NaN* or _y_ is *NaN*, return *NaN*.", "            1. If _x_ is *+∞*<sub>𝔽</sub> or _x_ is *-∞*<sub>𝔽</sub>, then", "              1. If _y_ is *+0*<sub>𝔽</sub> or _y_ is *-0*<sub>𝔽</sub>, return *NaN*.", "              1. If _y_ > *+0*<sub>𝔽</sub>, return _x_.", "              1. Return -_x_.", "            1. If _y_ is *+∞*<sub>𝔽</sub> or _y_ is *-∞*<sub>𝔽</sub>, then", "              1. If _x_ is *+0*<sub>𝔽</sub> or _x_ is *-0*<sub>𝔽</sub>, return *NaN*.", "              1. If _x_ > *+0*<sub>𝔽</sub>, return _y_.", "              1. Return -_y_.", "            1. Return 𝔽(ℝ(_x_) × ℝ(_y_))."],
    "head": {
      "name": "Number::multiply",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-numeric-types-number-multiply",
    "rawBody": "{\n  0:if (|| (= x NaN) (= y NaN)) return NaN else 26:{}\n  1:if (|| (= x Infinity) (= x -Infinity)) {\n    2:if (|| (= y 0i) (= y -0.0)) return NaN else 26:{}\n    3:if (< 0i y) return x else 26:{}\n    4:return (- x)\n  } else 26:{}\n  5:if (|| (= y Infinity) (= y -Infinity)) {\n    6:if (|| (= x 0i) (= x -0.0)) return NaN else 26:{}\n    7:if (< 0i x) return y else 26:{}\n    8:return (- y)\n  } else 26:{}\n  9:return (* x y)\n}"
  }, {
    "code": ["            1. If _x_ is *NaN* or _y_ is *NaN*, return *NaN*.", "            1. If _x_ is *+∞*<sub>𝔽</sub> or _x_ is *-∞*<sub>𝔽</sub>, then", "              1. If _y_ is *+∞*<sub>𝔽</sub> or _y_ is *-∞*<sub>𝔽</sub>, return *NaN*.", "              1. If _y_ is *+0*<sub>𝔽</sub> or _y_ > *+0*<sub>𝔽</sub>, return _x_.", "              1. Return -_x_.", "            1. If _y_ is *+∞*<sub>𝔽</sub>, then", "              1. If _x_ is *+0*<sub>𝔽</sub> or _x_ > *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>. Otherwise, return *-0*<sub>𝔽</sub>.", "            1. If _y_ is *-∞*<sub>𝔽</sub>, then", "              1. If _x_ is *+0*<sub>𝔽</sub> or _x_ > *+0*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>. Otherwise, return *+0*<sub>𝔽</sub>.", "            1. If _x_ is *+0*<sub>𝔽</sub> or _x_ is *-0*<sub>𝔽</sub>, then", "              1. If _y_ is *+0*<sub>𝔽</sub> or _y_ is *-0*<sub>𝔽</sub>, return *NaN*.", "              1. If _y_ > *+0*<sub>𝔽</sub>, return _x_.", "              1. Return -_x_.", "            1. If _y_ is *+0*<sub>𝔽</sub>, then", "              1. If _x_ > *+0*<sub>𝔽</sub>, return *+∞*<sub>𝔽</sub>. Otherwise, return *-∞*<sub>𝔽</sub>.", "            1. If _y_ is *-0*<sub>𝔽</sub>, then", "              1. If _x_ > *+0*<sub>𝔽</sub>, return *-∞*<sub>𝔽</sub>. Otherwise, return *+∞*<sub>𝔽</sub>.", "            1. Return 𝔽(ℝ(_x_) / ℝ(_y_))."],
    "head": {
      "name": "Number::divide",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-numeric-types-number-divide",
    "rawBody": "{\n  0:if (|| (= x NaN) (= y NaN)) return NaN else 26:{}\n  1:if (|| (= x Infinity) (= x -Infinity)) {\n    2:if (|| (= y Infinity) (= y -Infinity)) return NaN else 26:{}\n    3:if (|| (= y 0i) (< 0i y)) return x else 26:{}\n    4:return (- x)\n  } else 26:{}\n  5:if (= y Infinity) if (|| (= x 0i) (< 0i x)) return 0i else return -0.0 else 26:{}\n  7:if (= y -Infinity) if (|| (= x 0i) (< 0i x)) return -0.0 else return 0i else 26:{}\n  9:if (|| (= x 0i) (= x -0.0)) {\n    10:if (|| (= y 0i) (= y -0.0)) return NaN else 26:{}\n    11:if (< 0i y) return x else 26:{}\n    12:return (- x)\n  } else 26:{}\n  13:if (= y 0i) if (< 0i x) return Infinity else return -Infinity else 26:{}\n  15:if (= y -0.0) if (< 0i x) return -Infinity else return Infinity else 26:{}\n  17:return (/ x y)\n}"
  }, {
    "code": ["            1. If _n_ is *NaN* or _d_ is *NaN*, return *NaN*.", "            1. If _n_ is *+∞*<sub>𝔽</sub> or _n_ is *-∞*<sub>𝔽</sub>, return *NaN*.", "            1. If _d_ is *+∞*<sub>𝔽</sub> or _d_ is *-∞*<sub>𝔽</sub>, return _n_.", "            1. If _d_ is *+0*<sub>𝔽</sub> or _d_ is *-0*<sub>𝔽</sub>, return *NaN*.", "            1. If _n_ is *+0*<sub>𝔽</sub> or _n_ is *-0*<sub>𝔽</sub>, return _n_.", "            1. Assert: _n_ and _d_ are finite and non-zero.", "            1. Let _r_ be ℝ(_n_) - (ℝ(_d_) × _q_) where _q_ is an integer that is negative if and only if _n_ and _d_ have opposite sign, and whose magnitude is as large as possible without exceeding the magnitude of ℝ(_n_) / ℝ(_d_).", "            1. Return 𝔽(_r_)."],
    "head": {
      "name": "Number::remainder",
      "params": [{
        "kind": "Normal",
        "name": "n"
      }, {
        "kind": "Normal",
        "name": "d"
      }]
    },
    "ids": "sec-numeric-types-number-remainder",
    "rawBody": "{\n  0:if (|| (= n NaN) (= d NaN)) return NaN else 5:{}\n  1:if (|| (= n Infinity) (= n -Infinity)) return NaN else 5:{}\n  2:if (|| (= d Infinity) (= d -Infinity)) return n else 5:{}\n  3:if (|| (= d 0i) (= d -0.0)) return NaN else 5:{}\n  4:if (|| (= n 0i) (= n -0.0)) return n else 5:{}\n  6:(0) ??? \"Let id:{r} be ℝ ( id:{n} ) - ( ℝ ( id:{d} ) × id:{q} ) where id:{q} is an integer that is negative if and only if id:{n} and id:{d} have opposite sign , and whose magnitude is as large as possible without exceeding the magnitude of ℝ ( id:{n} ) / ℝ ( id:{d} ) .\"\n  7:return r\n}"
  }, {
    "code": ["            1. If _x_ is *NaN* or _y_ is *NaN*, return *NaN*.", "            1. If _x_ is *+∞*<sub>𝔽</sub> and _y_ is *-∞*<sub>𝔽</sub>, return *NaN*.", "            1. If _x_ is *-∞*<sub>𝔽</sub> and _y_ is *+∞*<sub>𝔽</sub>, return *NaN*.", "            1. If _x_ is *+∞*<sub>𝔽</sub> or _x_ is *-∞*<sub>𝔽</sub>, return _x_.", "            1. If _y_ is *+∞*<sub>𝔽</sub> or _y_ is *-∞*<sub>𝔽</sub>, return _y_.", "            1. Assert: _x_ and _y_ are both finite.", "            1. If _x_ is *-0*<sub>𝔽</sub> and _y_ is *-0*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.", "            1. Return 𝔽(ℝ(_x_) + ℝ(_y_))."],
    "head": {
      "name": "Number::add",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-numeric-types-number-add",
    "rawBody": "{\n  0:if (|| (= x NaN) (= y NaN)) return NaN else 5:{}\n  1:if (&& (= x Infinity) (= y -Infinity)) return NaN else 5:{}\n  2:if (&& (= x -Infinity) (= y Infinity)) return NaN else 5:{}\n  3:if (|| (= x Infinity) (= x -Infinity)) return x else 5:{}\n  4:if (|| (= y Infinity) (= y -Infinity)) return y else 5:{}\n  6:if (&& (= x -0.0) (= y -0.0)) return -0.0 else 5:{}\n  7:return (+ x y)\n}"
  }, {
    "code": ["            1. Return Number::add(_x_, Number::unaryMinus(_y_))."],
    "head": {
      "name": "Number::subtract",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-numeric-types-number-subtract",
    "rawBody": "{\n  0:(0) app __x0__ = (PRIMITIVE[Number][\"unaryMinus\"] y)\n  0:(1) app __x1__ = (PRIMITIVE[Number][\"add\"] x __x0__)\n  0:return __x1__\n}"
  }, {
    "code": ["            1. Let _lnum_ be ! ToInt32(_x_).", "            1. Let _rnum_ be ! ToUint32(_y_).", "            1. Let _shiftCount_ be ℝ(_rnum_) modulo 32.", "            1. Return the result of left shifting _lnum_ by _shiftCount_ bits. The mathematical value of the result is exactly representable as a 32-bit two's complement bit string."],
    "head": {
      "name": "Number::leftShift",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-numeric-types-number-leftShift",
    "rawBody": "{\n  0:(0) app __x0__ = (ToInt32 x)\n  0:let lnum = [! __x0__]\n  1:(1) app __x1__ = (ToUint32 y)\n  1:let rnum = [! __x1__]\n  2:let shiftCount = (%% rnum 32i)\n  3:return (<< lnum shiftCount)\n}"
  }, {
    "code": ["            1. Let _lnum_ be ! ToInt32(_x_).", "            1. Let _rnum_ be ! ToUint32(_y_).", "            1. Let _shiftCount_ be ℝ(_rnum_) modulo 32.", "            1. Return the result of performing a sign-extending right shift of _lnum_ by _shiftCount_ bits. The most significant bit is propagated. The mathematical value of the result is exactly representable as a 32-bit two's complement bit string."],
    "head": {
      "name": "Number::signedRightShift",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-numeric-types-number-signedRightShift",
    "rawBody": "{\n  0:(0) app __x0__ = (ToInt32 x)\n  0:let lnum = [! __x0__]\n  1:(1) app __x1__ = (ToUint32 y)\n  1:let rnum = [! __x1__]\n  2:let shiftCount = (%% rnum 32i)\n  3:return (>> lnum shiftCount)\n}"
  }, {
    "code": ["            1. Let _lnum_ be ! ToUint32(_x_).", "            1. Let _rnum_ be ! ToUint32(_y_).", "            1. Let _shiftCount_ be ℝ(_rnum_) modulo 32.", "            1. Return the result of performing a zero-filling right shift of _lnum_ by _shiftCount_ bits. Vacated bits are filled with zero. The mathematical value of the result is exactly representable as a 32-bit unsigned bit string."],
    "head": {
      "name": "Number::unsignedRightShift",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-numeric-types-number-unsignedRightShift",
    "rawBody": "{\n  0:(0) app __x0__ = (ToUint32 x)\n  0:let lnum = [! __x0__]\n  1:(1) app __x1__ = (ToUint32 y)\n  1:let rnum = [! __x1__]\n  2:let shiftCount = (%% rnum 32i)\n  3:return (>>> lnum shiftCount)\n}"
  }, {
    "code": ["            1. If _x_ is *NaN*, return *undefined*.", "            1. If _y_ is *NaN*, return *undefined*.", "            1. If _x_ and _y_ are the same Number value, return *false*.", "            1. If _x_ is *+0*<sub>𝔽</sub> and _y_ is *-0*<sub>𝔽</sub>, return *false*.", "            1. If _x_ is *-0*<sub>𝔽</sub> and _y_ is *+0*<sub>𝔽</sub>, return *false*.", "            1. If _x_ is *+∞*<sub>𝔽</sub>, return *false*.", "            1. If _y_ is *+∞*<sub>𝔽</sub>, return *true*.", "            1. If _y_ is *-∞*<sub>𝔽</sub>, return *false*.", "            1. If _x_ is *-∞*<sub>𝔽</sub>, return *true*.", "            1. Assert: _x_ and _y_ are finite and non-zero.", "            1. If ℝ(_x_) < ℝ(_y_), return *true*. Otherwise, return *false*."],
    "head": {
      "name": "Number::lessThan",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-numeric-types-number-lessThan",
    "rawBody": "{\n  0:if (= x NaN) return undefined else 9:{}\n  1:if (= y NaN) return undefined else 9:{}\n  2:if (= x y) return false else 9:{}\n  3:if (&& (= x 0i) (= y -0.0)) return false else 9:{}\n  4:if (&& (= x -0.0) (= y 0i)) return false else 9:{}\n  5:if (= x Infinity) return false else 9:{}\n  6:if (= y Infinity) return true else 9:{}\n  7:if (= y -Infinity) return false else 9:{}\n  8:if (= x -Infinity) return true else 9:{}\n  10:if (< x y) return true else return false\n}"
  }, {
    "code": ["            1. If _x_ is *NaN*, return *false*.", "            1. If _y_ is *NaN*, return *false*.", "            1. If _x_ is the same Number value as _y_, return *true*.", "            1. If _x_ is *+0*<sub>𝔽</sub> and _y_ is *-0*<sub>𝔽</sub>, return *true*.", "            1. If _x_ is *-0*<sub>𝔽</sub> and _y_ is *+0*<sub>𝔽</sub>, return *true*.", "            1. Return *false*."],
    "head": {
      "name": "Number::equal",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-numeric-types-number-equal",
    "rawBody": "{\n  0:if (= x NaN) return false else 9:{}\n  1:if (= y NaN) return false else 9:{}\n  2:if (= x y) return true else 9:{}\n  3:if (&& (= x 0i) (= y -0.0)) return true else 9:{}\n  4:if (&& (= x -0.0) (= y 0i)) return true else 9:{}\n  5:return false\n}"
  }, {
    "code": ["            1. If _x_ is *NaN* and _y_ is *NaN*, return *true*.", "            1. If _x_ is *+0*<sub>𝔽</sub> and _y_ is *-0*<sub>𝔽</sub>, return *false*.", "            1. If _x_ is *-0*<sub>𝔽</sub> and _y_ is *+0*<sub>𝔽</sub>, return *false*.", "            1. If _x_ is the same Number value as _y_, return *true*.", "            1. Return *false*."],
    "head": {
      "name": "Number::sameValue",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-numeric-types-number-sameValue",
    "rawBody": "{\n  0:if (&& (= x NaN) (= y NaN)) return true else 9:{}\n  1:if (&& (= x 0i) (= y -0.0)) return false else 9:{}\n  2:if (&& (= x -0.0) (= y 0i)) return false else 9:{}\n  3:if (= x y) return true else 9:{}\n  4:return false\n}"
  }, {
    "code": ["            1. If _x_ is *NaN* and _y_ is *NaN*, return *true*.", "            1. If _x_ is *+0*<sub>𝔽</sub> and _y_ is *-0*<sub>𝔽</sub>, return *true*.", "            1. If _x_ is *-0*<sub>𝔽</sub> and _y_ is *+0*<sub>𝔽</sub>, return *true*.", "            1. If _x_ is the same Number value as _y_, return *true*.", "            1. Return *false*."],
    "head": {
      "name": "Number::sameValueZero",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-numeric-types-number-sameValueZero",
    "rawBody": "{\n  0:if (&& (= x NaN) (= y NaN)) return true else 9:{}\n  1:if (&& (= x 0i) (= y -0.0)) return true else 9:{}\n  2:if (&& (= x -0.0) (= y 0i)) return true else 9:{}\n  3:if (= x y) return true else 9:{}\n  4:return false\n}"
  }, {
    "code": ["            1. Assert: _op_ is `&`, `^`, or `|`.", "            1. Let _lnum_ be ! ToInt32(_x_).", "            1. Let _rnum_ be ! ToInt32(_y_).", "            1. Let _lbits_ be the 32-bit two's complement bit string representing ℝ(_lnum_).", "            1. Let _rbits_ be the 32-bit two's complement bit string representing ℝ(_rnum_).", "            1. If _op_ is `&`, let _result_ be the result of applying the bitwise AND operation to _lbits_ and _rbits_.", "            1. Else if _op_ is `^`, let _result_ be the result of applying the bitwise exclusive OR (XOR) operation to _lbits_ and _rbits_.", "            1. Else, _op_ is `|`. Let _result_ be the result of applying the bitwise inclusive OR operation to _lbits_ and _rbits_.", "            1. Return the Number value for the integer represented by the 32-bit two's complement bit string _result_."],
    "head": {
      "name": "NumberBitwiseOp",
      "params": [{
        "kind": "Normal",
        "name": "op"
      }, {
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-numberbitwiseop",
    "rawBody": "{\n  0:assert (|| (|| (= op \"&\") (= op \"^\")) (= op \"|\"))\n  1:(0) app __x0__ = (ToInt32 x)\n  1:let lnum = [! __x0__]\n  2:(1) app __x1__ = (ToInt32 y)\n  2:let rnum = [! __x1__]\n  3:let lbits = lnum\n  4:let rbits = rnum\n  6:if (= op \"&\") let result = (& lbits rbits) else if (= op \"^\") let result = (^ lbits rbits) else 9:{}\n  7:if (= op \"|\") let result = (| lbits rbits) else let result = 0i\n  8:return result\n}"
  }, {
    "code": ["            1. Return NumberBitwiseOp(`&`, _x_, _y_)."],
    "head": {
      "name": "Number::bitwiseAND",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-numeric-types-number-bitwiseAND",
    "rawBody": "{\n  0:(0) app __x0__ = (NumberBitwiseOp \"&\" x y)\n  0:return __x0__\n}"
  }, {
    "code": ["            1. Return NumberBitwiseOp(`^`, _x_, _y_)."],
    "head": {
      "name": "Number::bitwiseXOR",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-numeric-types-number-bitwiseXOR",
    "rawBody": "{\n  0:(0) app __x0__ = (NumberBitwiseOp \"^\" x y)\n  0:return __x0__\n}"
  }, {
    "code": ["            1. Return NumberBitwiseOp(`|`, _x_, _y_)."],
    "head": {
      "name": "Number::bitwiseOR",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-numeric-types-number-bitwiseOR",
    "rawBody": "{\n  0:(0) app __x0__ = (NumberBitwiseOp \"|\" x y)\n  0:return __x0__\n}"
  }, {
    "code": ["            1. If _x_ is *NaN*, return the String *\"NaN\"*.", "            1. If _x_ is *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return the String *\"0\"*.", "            1. If _x_ < *+0*<sub>𝔽</sub>, return the string-concatenation of *\"-\"* and ! Number::toString(-_x_).", "            1. If _x_ is *+∞*<sub>𝔽</sub>, return the String *\"Infinity\"*.", "            1. [id=\"step-number-tostring-intermediate-values\"] Otherwise, let _n_, _k_, and _s_ be integers such that _k_ ≥ 1, 10<sup>_k_ - 1</sup> ≤ _s_ < 10<sup>_k_</sup>, _s_ × 10<sup>_n_ - _k_</sup> is ℝ(_x_), and _k_ is as small as possible. Note that _k_ is the number of digits in the decimal representation of _s_, that _s_ is not divisible by 10, and that the least significant digit of _s_ is not necessarily uniquely determined by these criteria.", "            1. If _k_ ≤ _n_ ≤ 21, return the string-concatenation of:", "              * the code units of the _k_ digits of the decimal representation of _s_ (in order, with no leading zeroes)", "              * _n_ - _k_ occurrences of the code unit 0x0030 (DIGIT ZERO)", "            1. If 0 < _n_ ≤ 21, return the string-concatenation of:", "              * the code units of the most significant _n_ digits of the decimal representation of _s_", "              * the code unit 0x002E (FULL STOP)", "              * the code units of the remaining _k_ - _n_ digits of the decimal representation of _s_", "            1. If -6 < _n_ ≤ 0, return the string-concatenation of:", "              * the code unit 0x0030 (DIGIT ZERO)", "              * the code unit 0x002E (FULL STOP)", "              * -_n_ occurrences of the code unit 0x0030 (DIGIT ZERO)", "              * the code units of the _k_ digits of the decimal representation of _s_", "            1. Otherwise, if _k_ = 1, return the string-concatenation of:", "              * the code unit of the single digit of _s_", "              * the code unit 0x0065 (LATIN SMALL LETTER E)", "              * the code unit 0x002B (PLUS SIGN) or the code unit 0x002D (HYPHEN-MINUS) according to whether _n_ - 1 is positive or negative", "              * the code units of the decimal representation of the integer abs(_n_ - 1) (with no leading zeroes)", "            1. Return the string-concatenation of:", "              * the code units of the most significant digit of the decimal representation of _s_", "              * the code unit 0x002E (FULL STOP)", "              * the code units of the remaining _k_ - 1 digits of the decimal representation of _s_", "              * the code unit 0x0065 (LATIN SMALL LETTER E)", "              * the code unit 0x002B (PLUS SIGN) or the code unit 0x002D (HYPHEN-MINUS) according to whether _n_ - 1 is positive or negative", "              * the code units of the decimal representation of the integer abs(_n_ - 1) (with no leading zeroes)"],
    "head": {
      "name": "Number::toString",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }]
    },
    "ids": "sec-numeric-types-number-tostring",
    "rawBody": "{\n  0:if (= x NaN) return \"NaN\" else 9:{}\n  1:if (|| (= x 0i) (= x -0.0)) return \"0\" else 9:{}\n  2:if (< x 0i) {\n    (0) app __x0__ = (PRIMITIVE[Number][\"toString\"] (- x))\n    return (+ \"-\" [! __x0__])\n  } else 9:{}\n  3:if (= x Infinity) return \"Infinity\" else 9:{}\n  4:(0) ??? \"Otherwise , let id:{n} , id:{k} , and id:{s} be integers such that id:{k} ≥ 1 , 10 sup:{id:{k} - 1} ≤ id:{s} < 10 sup:{id:{k}} , id:{s} × 10 sup:{id:{n} - id:{k}} is ℝ ( id:{x} ) , and id:{k} is as small as possible . Note that id:{k} is the number of digits in the decimal representation of id:{s} , that id:{s} is not divisible by 10 , and that the least significant digit of id:{s} is not necessarily uniquely determined by these criteria .\"\n  5:if (&& (! (< n k)) (! (< 21i n))) return (+ (1) ??? \"StringOp\" (2) ??? \"StringOp\") else 9:{}\n  8:if (&& (< 0i n) (! (< 21i n))) return (+ (+ (3) ??? \"StringOp\" \".\") (4) ??? \"StringOp\") else 9:{}\n  17:if (&& (< -6i n) (! (< 0i n))) return (+ (+ (+ \"0\" \".\") (5) ??? \"StringOp\") (6) ??? \"StringOp\") else if (== k 1i) return (+ (+ (+ (7) ??? \"StringOp\" \"e\") (8) ??? \"StringOp\") (9) ??? \"StringOp\") else 9:{}\n  22:return (+ (+ (+ (+ (+ (10) ??? \"StringOp\" \".\") (11) ??? \"StringOp\") \"e\") (12) ??? \"StringOp\") (13) ??? \"StringOp\")\n}"
  }, {
    "code": ["            1. If _x_ is *0*<sub>ℤ</sub>, return *0*<sub>ℤ</sub>.", "            1. Return the BigInt value that represents the negation of ℝ(_x_)."],
    "head": {
      "name": "BigInt::unaryMinus",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }]
    },
    "ids": "sec-numeric-types-bigint-unaryMinus",
    "rawBody": "{\n  0:if (= x 0i) return 0i else 9:{}\n  1:return (convert (- x) num2bigint )\n}"
  }, {
    "code": ["            1. If _exponent_ < *0*<sub>ℤ</sub>, throw a *RangeError* exception.", "            1. If _base_ is *0*<sub>ℤ</sub> and _exponent_ is *0*<sub>ℤ</sub>, return *1*<sub>ℤ</sub>.", "            1. Return the BigInt value that represents ℝ(_base_) raised to the power ℝ(_exponent_)."],
    "head": {
      "name": "BigInt::exponentiate",
      "params": [{
        "kind": "Normal",
        "name": "base"
      }, {
        "kind": "Normal",
        "name": "exponent"
      }]
    },
    "ids": "sec-numeric-types-bigint-exponentiate",
    "rawBody": "{\n  0:if (< exponent 0i) (0) throw RangeError else 9:{}\n  1:if (&& (= base 0i) (= exponent 0i)) return 1i else 9:{}\n  2:return (convert (** base exponent) num2bigint )\n}"
  }, {
    "code": ["            1. If _y_ is *0*<sub>ℤ</sub>, throw a *RangeError* exception.", "            1. Let _quotient_ be ℝ(_x_) / ℝ(_y_).", "            1. Return the BigInt value that represents _quotient_ rounded towards 0 to the next integer value."],
    "head": {
      "name": "BigInt::divide",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-numeric-types-bigint-divide",
    "rawBody": "{\n  0:if (= y 0i) (0) throw RangeError else 9:{}\n  1:let quotient = (/ x y)\n  2:(1) ??? \"Return the BigInt value that represents id:{quotient} rounded towards 0 to the next integer value .\"\n}"
  }, {
    "code": ["            1. If _d_ is *0*<sub>ℤ</sub>, throw a *RangeError* exception.", "            1. If _n_ is *0*<sub>ℤ</sub>, return *0*<sub>ℤ</sub>.", "            1. Let _r_ be the BigInt defined by the mathematical relation _r_ = _n_ - (_d_ × _q_) where _q_ is a BigInt that is negative only if _n_/_d_ is negative and positive only if _n_/_d_ is positive, and whose magnitude is as large as possible without exceeding the magnitude of the true mathematical quotient of _n_ and _d_.", "            1. Return _r_."],
    "head": {
      "name": "BigInt::remainder",
      "params": [{
        "kind": "Normal",
        "name": "n"
      }, {
        "kind": "Normal",
        "name": "d"
      }]
    },
    "ids": "sec-numeric-types-bigint-remainder",
    "rawBody": "{\n  0:if (= d 0i) (0) throw RangeError else 9:{}\n  1:if (= n 0i) return 0i else 9:{}\n  2:let r = (% n d)\n  3:return r\n}"
  }, {
    "code": ["            1. If _y_ < *0*<sub>ℤ</sub>, then", "              1. Return the BigInt value that represents ℝ(_x_) / 2<sup>-_y_</sup>, rounding down to the nearest integer, including for negative numbers.", "            1. Return the BigInt value that represents ℝ(_x_) × 2<sup>_y_</sup>."],
    "head": {
      "name": "BigInt::leftShift",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-numeric-types-bigint-leftShift",
    "rawBody": "{\n  0:if (< y 0i) (0) ??? \"Return the BigInt value that represents ℝ ( id:{x} ) / 2 sup:{- id:{y}} , rounding down to the nearest integer , including for negative numbers .\" else 9:{}\n  2:return (convert (* x (** 2.0 y)) num2bigint )\n}"
  }, {
    "code": ["            1. Return BigInt::leftShift(_x_, -_y_)."],
    "head": {
      "name": "BigInt::signedRightShift",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-numeric-types-bigint-signedRightShift",
    "rawBody": "{\n  0:(0) app __x0__ = (PRIMITIVE[BigInt][\"leftShift\"] x (- y))\n  0:return __x0__\n}"
  }, {
    "code": ["            1. Throw a *TypeError* exception."],
    "head": {
      "name": "BigInt::unsignedRightShift",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-numeric-types-bigint-unsignedRightShift",
    "rawBody": "(0) throw TypeError"
  }, {
    "code": ["            1. Return BigInt::equal(_x_, _y_)."],
    "head": {
      "name": "BigInt::sameValue",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-numeric-types-bigint-sameValue",
    "rawBody": "{\n  0:(0) app __x0__ = (PRIMITIVE[BigInt][\"equal\"] x y)\n  0:return __x0__\n}"
  }, {
    "code": ["            1. Return BigInt::equal(_x_, _y_)."],
    "head": {
      "name": "BigInt::sameValueZero",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-numeric-types-bigint-sameValueZero",
    "rawBody": "{\n  0:(0) app __x0__ = (PRIMITIVE[BigInt][\"equal\"] x y)\n  0:return __x0__\n}"
  }, {
    "code": ["            1. Assert: _x_ is 0 or 1.", "            1. Assert: _y_ is 0 or 1.", "            1. If _x_ is 1 and _y_ is 1, return 1.", "            1. Else, return 0."],
    "head": {
      "name": "BinaryAnd",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-binaryand",
    "rawBody": "{\n  0:assert (|| (= x 0i) (= x 1i))\n  1:assert (|| (= y 0i) (= y 1i))\n  3:if (&& (= x 1i) (= y 1i)) return 1i else return 0i\n}"
  }, {
    "code": ["            1. Assert: _x_ is 0 or 1.", "            1. Assert: _y_ is 0 or 1.", "            1. If _x_ is 1 or _y_ is 1, return 1.", "            1. Else, return 0."],
    "head": {
      "name": "BinaryOr",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-binaryor",
    "rawBody": "{\n  0:assert (|| (= x 0i) (= x 1i))\n  1:assert (|| (= y 0i) (= y 1i))\n  3:if (|| (= x 1i) (= y 1i)) return 1i else return 0i\n}"
  }, {
    "code": ["            1. Assert: _x_ is 0 or 1.", "            1. Assert: _y_ is 0 or 1.", "            1. If _x_ is 1 and _y_ is 0, return 1.", "            1. Else if _x_ is 0 and _y_ is 1, return 1.", "            1. Else, return 0."],
    "head": {
      "name": "BinaryXor",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-binaryxor",
    "rawBody": "{\n  0:assert (|| (= x 0i) (= x 1i))\n  1:assert (|| (= y 0i) (= y 1i))\n  4:if (&& (= x 1i) (= y 0i)) return 1i else if (&& (= x 0i) (= y 1i)) return 1i else return 0i\n}"
  }, {
    "code": ["            1. Assert: _op_ is `&`, `^`, or `|`.", "            1. Set _x_ to ℝ(_x_).", "            1. Set _y_ to ℝ(_y_).", "            1. Let _result_ be 0.", "            1. Let _shift_ be 0.", "            1. Repeat, until (_x_ = 0 or _x_ = -1) and (_y_ = 0 or _y_ = -1),", "              1. Let _xDigit_ be _x_ modulo 2.", "              1. Let _yDigit_ be _y_ modulo 2.", "              1. If _op_ is `&`, set _result_ to _result_ + 2<sup>_shift_</sup> × BinaryAnd(_xDigit_, _yDigit_).", "              1. Else if _op_ is `|`, set _result_ to _result_ + 2<sup>_shift_</sup> × BinaryOr(_xDigit_, _yDigit_).", "              1. Else,", "                1. Assert: _op_ is `^`.", "                1. Set _result_ to _result_ + 2<sup>_shift_</sup> × BinaryXor(_xDigit_, _yDigit_).", "              1. Set _shift_ to _shift_ + 1.", "              1. Set _x_ to (_x_ - _xDigit_) / 2.", "              1. Set _y_ to (_y_ - _yDigit_) / 2.", "            1. If _op_ is `&`, let _tmp_ be BinaryAnd(_x_ modulo 2, _y_ modulo 2).", "            1. Else if _op_ is `|`, let _tmp_ be BinaryOr(_x_ modulo 2, _y_ modulo 2).", "            1. Else,", "              1. Assert: _op_ is `^`.", "              1. Let _tmp_ be BinaryXor(_x_ modulo 2, _y_ modulo 2).", "            1. If _tmp_ ≠ 0, then", "              1. Set _result_ to _result_ - 2<sup>_shift_</sup>.", "              1. NOTE: This extends the sign.", "            1. Return the BigInt value for _result_."],
    "head": {
      "name": "BigIntBitwiseOp",
      "params": [{
        "kind": "Normal",
        "name": "op"
      }, {
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-bigintbitwiseop",
    "rawBody": "{\n  0:assert (|| (|| (= op \"&\") (= op \"^\")) (= op \"|\"))\n  1:x = x\n  2:y = y\n  3:let result = 0i\n  4:let shift = 0i\n  5:while AnyBool {\n    6:let xDigit = (%% x 2i)\n    7:let yDigit = (%% y 2i)\n    10:if (= op \"&\") {\n      (0) app __x0__ = (BinaryAnd xDigit yDigit)\n      result = (* (+ result (** 2.0 shift)) __x0__)\n    } else if (= op \"|\") {\n      (1) app __x1__ = (BinaryOr xDigit yDigit)\n      result = (* (+ result (** 2.0 shift)) __x1__)\n    } else {\n      11:assert (= op \"^\")\n      12:(2) app __x2__ = (BinaryXor xDigit yDigit)\n      12:result = (* (+ result (** 2.0 shift)) __x2__)\n    }\n    13:shift = (+ shift 1i)\n    14:x = (/ (- x xDigit) 2i)\n    15:y = (/ (- y yDigit) 2i)\n  }\n  18:if (= op \"&\") {\n    (3) app __x3__ = (BinaryAnd (%% x 2i) (%% y 2i))\n    let tmp = __x3__\n  } else if (= op \"|\") {\n    (4) app __x4__ = (BinaryOr (%% x 2i) (%% y 2i))\n    let tmp = __x4__\n  } else {\n    19:assert (= op \"^\")\n    20:(5) app __x5__ = (BinaryXor (%% x 2i) (%% y 2i))\n    20:let tmp = __x5__\n  }\n  21:if (! (== tmp 0i)) result = (- result (** 2.0 shift)) else 23:{}\n  24:return (convert result num2bigint )\n}"
  }, {
    "code": ["            1. Return BigIntBitwiseOp(`&`, _x_, _y_)."],
    "head": {
      "name": "BigInt::bitwiseAND",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-numeric-types-bigint-bitwiseAND",
    "rawBody": "{\n  0:(0) app __x0__ = (BigIntBitwiseOp \"&\" x y)\n  0:return __x0__\n}"
  }, {
    "code": ["            1. Return BigIntBitwiseOp(`^`, _x_, _y_)."],
    "head": {
      "name": "BigInt::bitwiseXOR",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-numeric-types-bigint-bitwiseXOR",
    "rawBody": "{\n  0:(0) app __x0__ = (BigIntBitwiseOp \"^\" x y)\n  0:return __x0__\n}"
  }, {
    "code": ["            1. Return BigIntBitwiseOp(`|`, _x_, _y_)."],
    "head": {
      "name": "BigInt::bitwiseOR",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-numeric-types-bigint-bitwiseOR",
    "rawBody": "{\n  0:(0) app __x0__ = (BigIntBitwiseOp \"|\" x y)\n  0:return __x0__\n}"
  }, {
    "code": ["            1. If _x_ < *0*<sub>ℤ</sub>, return the string-concatenation of the String *\"-\"* and ! BigInt::toString(-_x_).", "            1. Return the String value consisting of the code units of the digits of the decimal representation of _x_."],
    "head": {
      "name": "BigInt::toString",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }]
    },
    "ids": "sec-numeric-types-bigint-tostring",
    "rawBody": "{\n  0:if (< x 0i) {\n    (0) app __x0__ = (PRIMITIVE[BigInt][\"toString\"] (- x))\n    return (+ \"-\" [! __x0__])\n  } else 23:{}\n  1:return (convert x num2str )\n}"
  }, {
    "code": ["          1. Let _asyncContext_ be the running execution context.", "          1. Let _promise_ be ? PromiseResolve(%Promise%, _value_).", "          1. Let _stepsFulfilled_ be the algorithm steps defined in <emu-xref href=\"#await-fulfilled\" title></emu-xref>.", "          1. Let _lengthFulfilled_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#await-fulfilled\" title></emu-xref>.", "          1. Let _onFulfilled_ be ! CreateBuiltinFunction(_stepsFulfilled_, _lengthFulfilled_, *\"\"*, « [[AsyncContext]] »).", "          1. Set _onFulfilled_.[[AsyncContext]] to _asyncContext_.", "          1. Let _stepsRejected_ be the algorithm steps defined in <emu-xref href=\"#await-rejected\" title></emu-xref>.", "          1. Let _lengthRejected_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#await-rejected\" title></emu-xref>.", "          1. Let _onRejected_ be ! CreateBuiltinFunction(_stepsRejected_, _lengthRejected_, *\"\"*, « [[AsyncContext]] »).", "          1. Set _onRejected_.[[AsyncContext]] to _asyncContext_.", "          1. Perform ! PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_).", "          1. Remove _asyncContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.", "          1. Set the code evaluation state of _asyncContext_ such that when evaluation is resumed with a Completion _completion_, the following steps of the algorithm that invoked Await will be performed, with _completion_ available.", "          1. Return.", "          1. NOTE: This returns to the evaluation of the operation that had most previously resumed evaluation of _asyncContext_."],
    "head": {
      "name": "Await",
      "params": [{
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "await",
    "rawBody": "{\n  0:let asyncContext = CONTEXT\n  1:(0) app __x0__ = (PromiseResolve INTRINSIC_Promise value)\n  1:let promise = [? __x0__]\n  2:(0) ??? \"Let id:{stepsFulfilled} be the algorithm steps defined in link:{await-fulfilled} .\"\n  3:(1) ??? \"Let id:{lengthFulfilled} be the number of non - optional parameters of the function definition in link:{await-fulfilled} .\"\n  4:(1) app __x1__ = (CreateBuiltinFunction stepsFulfilled lengthFulfilled \"\" (2) (new [\"AsyncContext\"]))\n  4:let onFulfilled = [! __x1__]\n  5:onFulfilled[\"AsyncContext\"] = asyncContext\n  6:(3) ??? \"Let id:{stepsRejected} be the algorithm steps defined in link:{await-rejected} .\"\n  7:(4) ??? \"Let id:{lengthRejected} be the number of non - optional parameters of the function definition in link:{await-rejected} .\"\n  8:(2) app __x2__ = (CreateBuiltinFunction stepsRejected lengthRejected \"\" (5) (new [\"AsyncContext\"]))\n  8:let onRejected = [! __x2__]\n  9:onRejected[\"AsyncContext\"] = asyncContext\n  10:(3) app __x3__ = (PerformPromiseThen promise onFulfilled onRejected)\n  10:[! __x3__]\n  11:if (= EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)] asyncContext) {\n    let __x4__ = (- EXECUTION_STACK[\"length\"] 1i)\n    (pop EXECUTION_STACK __x4__)\n  } else {}\n  11:CONTEXT = EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)]\n  12:(6) ??? \"Set the code evaluation state of id:{asyncContext} such that when evaluation is resumed with a Completion id:{completion} , the following steps of the algorithm that invoked Await will be performed , with id:{completion} available .\"\n  13:return undefined\n}"
  }, {
    "code": ["            1. Let _F_ be the active function object.", "            1. Let _asyncContext_ be _F_.[[AsyncContext]].", "            1. Let _prevContext_ be the running execution context.", "            1. Suspend _prevContext_.", "            1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.", "            1. Resume the suspended evaluation of _asyncContext_ using NormalCompletion(_value_) as the result of the operation that suspended it.", "            1. Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context.", "            1. Return *undefined*."],
    "head": {
      "name": "AwaitFulfilledFunctions",
      "params": []
    },
    "ids": "await-fulfilled",
    "rawBody": "{\n  0:let F = CONTEXT[\"Function\"]\n  1:let asyncContext = F[\"AsyncContext\"]\n  2:let prevContext = CONTEXT\n  3:CONTEXT = null\n  4:append asyncContext -> EXECUTION_STACK\n  4:CONTEXT = EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)]\n  5:(0) ??? \"Resume the suspended evaluation of asyncContext using (NormalCompletion~value) as the result of the operation that suspended it\"\n  7:return undefined\n}"
  }, {
    "code": ["            1. Let _F_ be the active function object.", "            1. Let _asyncContext_ be _F_.[[AsyncContext]].", "            1. Let _prevContext_ be the running execution context.", "            1. Suspend _prevContext_.", "            1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.", "            1. Resume the suspended evaluation of _asyncContext_ using ThrowCompletion(_reason_) as the result of the operation that suspended it.", "            1. Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context.", "            1. Return *undefined*."],
    "head": {
      "name": "AwaitRejectedFunctions",
      "params": []
    },
    "ids": "await-rejected",
    "rawBody": "{\n  0:let F = CONTEXT[\"Function\"]\n  1:let asyncContext = F[\"AsyncContext\"]\n  2:let prevContext = CONTEXT\n  3:CONTEXT = null\n  4:append asyncContext -> EXECUTION_STACK\n  4:CONTEXT = EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)]\n  5:(0) ??? \"Resume the suspended evaluation of asyncContext using (ThrowCompletion~reason) as the result of the operation that suspended it\"\n  7:return undefined\n}"
  }, {
    "code": ["          1. Return NormalCompletion(_argument_)."],
    "head": {
      "name": "NormalCompletion",
      "params": []
    },
    "ids": "sec-normalcompletion",
    "rawBody": "return argument"
  }, {
    "code": ["          1. Return Completion { [[Type]]: ~normal~, [[Value]]: _argument_, [[Target]]: ~empty~ }."],
    "head": {
      "name": "NormalCompletion",
      "params": []
    },
    "ids": "sec-normalcompletion",
    "rawBody": "return (0) (new Completion(\"Type\" -> CONST_normal, \"Value\" -> argument, \"Target\" -> CONST_empty))"
  }, {
    "code": ["          1. Return ThrowCompletion(_argument_)."],
    "head": {
      "name": "ThrowCompletion",
      "params": []
    },
    "ids": "sec-throwcompletion",
    "rawBody": "{\n  0:(0) app __x0__ = (ThrowCompletion argument)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return Completion { [[Type]]: ~throw~, [[Value]]: _argument_, [[Target]]: ~empty~ }."],
    "head": {
      "name": "ThrowCompletion",
      "params": []
    },
    "ids": "sec-throwcompletion",
    "rawBody": "return (0) (new Completion(\"Type\" -> CONST_throw, \"Value\" -> argument, \"Target\" -> CONST_empty))"
  }, {
    "code": ["          1. Assert: If _completionRecord_.[[Type]] is either ~return~ or ~throw~, then _completionRecord_.[[Value]] is not ~empty~.", "          1. If _completionRecord_.[[Value]] is not ~empty~, return Completion(_completionRecord_).", "          1. Return Completion { [[Type]]: _completionRecord_.[[Type]], [[Value]]: _value_, [[Target]]: _completionRecord_.[[Target]] }."],
    "head": {
      "name": "UpdateEmpty",
      "params": [{
        "kind": "Normal",
        "name": "completionRecord"
      }, {
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "sec-updateempty",
    "rawBody": "{\n  1:if (! (= completionRecord[\"Value\"] CONST_empty)) return completionRecord else 0:{}\n  2:return (0) (new Completion(\"Type\" -> completionRecord[\"Type\"], \"Value\" -> value, \"Target\" -> completionRecord[\"Target\"]))\n}"
  }, {
    "code": ["          1. Assert: _V_ is a Reference Record.", "          1. If _V_.[[Base]] is ~unresolvable~, return *false*.", "          1. If Type(_V_.[[Base]]) is Boolean, String, Symbol, BigInt, Number, or Object, return *true*; otherwise return *false*."],
    "head": {
      "name": "IsPropertyReference",
      "params": [{
        "kind": "Normal",
        "name": "V"
      }]
    },
    "ids": "sec-ispropertyreference",
    "rawBody": "{\n  0:assert (0) (is-instance-of V ReferenceRecord)\n  1:if (= V[\"Base\"] CONST_unresolvable) return false else 0:{}\n  2:if (|| (|| (|| (|| (|| (= (typeof V[\"Base\"]) Boolean) (= (typeof V[\"Base\"]) String)) (= (typeof V[\"Base\"]) Symbol)) (= (typeof V[\"Base\"]) BigInt)) (= (typeof V[\"Base\"]) Number)) (= (typeof V[\"Base\"]) Object)) return true else return false\n}"
  }, {
    "code": ["          1. Assert: _V_ is a Reference Record.", "          1. If _V_.[[Base]] is ~unresolvable~, return *true*; otherwise return *false*."],
    "head": {
      "name": "IsUnresolvableReference",
      "params": [{
        "kind": "Normal",
        "name": "V"
      }]
    },
    "ids": "sec-isunresolvablereference",
    "rawBody": "{\n  0:assert (0) (is-instance-of V ReferenceRecord)\n  1:if (= V[\"Base\"] CONST_unresolvable) return true else return false\n}"
  }, {
    "code": ["          1. Assert: _V_ is a Reference Record.", "          1. If _V_.[[ThisValue]] is not ~empty~, return *true*; otherwise return *false*."],
    "head": {
      "name": "IsSuperReference",
      "params": [{
        "kind": "Normal",
        "name": "V"
      }]
    },
    "ids": "sec-issuperreference",
    "rawBody": "{\n  0:assert (0) (is-instance-of V ReferenceRecord)\n  1:if (! (= V[\"ThisValue\"] CONST_empty)) return true else return false\n}"
  }, {
    "code": ["          1. ReturnIfAbrupt(_V_).", "          1. If _V_ is not a Reference Record, return _V_.", "          1. If IsUnresolvableReference(_V_) is *true*, throw a *ReferenceError* exception.", "          1. If IsPropertyReference(_V_) is *true*, then", "            1. [id=\"step-getvalue-toobject\"] Let _baseObj_ be ! ToObject(_V_.[[Base]]).", "            1. Return ? _baseObj_.[[Get]](_V_.[[ReferencedName]], GetThisValue(_V_)).", "          1. Else,", "            1. Let _base_ be _V_.[[Base]].", "            1. Assert: _base_ is an Environment Record.", "            1. Return ? _base_.GetBindingValue(_V_.[[ReferencedName]], _V_.[[Strict]]) (see <emu-xref href=\"#sec-environment-records\"></emu-xref>)."],
    "head": {
      "name": "GetValue",
      "params": [{
        "kind": "Normal",
        "name": "V"
      }]
    },
    "ids": "sec-getvalue",
    "rawBody": "{\n  0:[? V]\n  1:if (! (0) (is-instance-of V ReferenceRecord)) return V else 0:{}\n  2:(0) app __x0__ = (IsUnresolvableReference V)\n  2:if (= __x0__ true) (1) throw ReferenceError else 0:{}\n  6:(1) app __x1__ = (IsPropertyReference V)\n  6:if (= __x1__ true) {\n    4:(2) app __x2__ = (ToObject V[\"Base\"])\n    4:let baseObj = [! __x2__]\n    5:(3) app __x3__ = (GetThisValue V)\n    5:(4) app __x4__ = (baseObj[\"Get\"] baseObj V[\"ReferencedName\"] __x3__)\n    5:return [? __x4__]\n  } else {\n    7:let base = V[\"Base\"]\n    8:assert (2) (is-instance-of base EnvironmentRecord)\n    9:(5) app __x5__ = (base[\"GetBindingValue\"] base V[\"ReferencedName\"] V[\"Strict\"])\n    9:return [? __x5__]\n  }\n}"
  }, {
    "code": ["          1. ReturnIfAbrupt(_V_).", "          1. ReturnIfAbrupt(_W_).", "          1. If _V_ is not a Reference Record, throw a *ReferenceError* exception.", "          1. If IsUnresolvableReference(_V_) is *true*, then", "            1. If _V_.[[Strict]] is *true*, throw a *ReferenceError* exception.", "            1. Let _globalObj_ be GetGlobalObject().", "            1. Return ? Set(_globalObj_, _V_.[[ReferencedName]], _W_, *false*).", "          1. If IsPropertyReference(_V_) is *true*, then", "            1. [id=\"step-putvalue-toobject\"] Let _baseObj_ be ! ToObject(_V_.[[Base]]).", "            1. Let _succeeded_ be ? _baseObj_.[[Set]](_V_.[[ReferencedName]], _W_, GetThisValue(_V_)).", "            1. If _succeeded_ is *false* and _V_.[[Strict]] is *true*, throw a *TypeError* exception.", "            1. Return.", "          1. Else,", "            1. Let _base_ be _V_.[[Base]].", "            1. Assert: _base_ is an Environment Record.", "            1. Return ? _base_.SetMutableBinding(_V_.[[ReferencedName]], _W_, _V_.[[Strict]]) (see <emu-xref href=\"#sec-environment-records\"></emu-xref>)."],
    "head": {
      "name": "PutValue",
      "params": [{
        "kind": "Normal",
        "name": "V"
      }, {
        "kind": "Normal",
        "name": "W"
      }]
    },
    "ids": "sec-putvalue",
    "rawBody": "{\n  0:[? V]\n  1:[? W]\n  2:if (! (0) (is-instance-of V ReferenceRecord)) (1) throw ReferenceError else 0:{}\n  3:(0) app __x0__ = (IsUnresolvableReference V)\n  3:if (= __x0__ true) {\n    4:if (= V[\"Strict\"] true) (2) throw ReferenceError else 0:{}\n    5:(1) app __x1__ = (GetGlobalObject)\n    5:let globalObj = __x1__\n    6:(2) app __x2__ = (Set globalObj V[\"ReferencedName\"] W false)\n    6:return [? __x2__]\n  } else 0:{}\n  12:(3) app __x3__ = (IsPropertyReference V)\n  12:if (= __x3__ true) {\n    8:(4) app __x4__ = (ToObject V[\"Base\"])\n    8:let baseObj = [! __x4__]\n    9:(5) app __x5__ = (GetThisValue V)\n    9:(6) app __x6__ = (baseObj[\"Set\"] baseObj V[\"ReferencedName\"] W __x5__)\n    9:let succeeded = [? __x6__]\n    10:if (&& (= succeeded false) (= V[\"Strict\"] true)) (3) throw TypeError else 0:{}\n    11:return undefined\n  } else {\n    13:let base = V[\"Base\"]\n    14:assert (4) (is-instance-of base EnvironmentRecord)\n    15:(7) app __x7__ = (base[\"SetMutableBinding\"] base V[\"ReferencedName\"] W V[\"Strict\"])\n    15:return [? __x7__]\n  }\n}"
  }, {
    "code": ["          1. Assert: IsPropertyReference(_V_) is *true*.", "          1. If IsSuperReference(_V_) is *true*, return _V_.[[ThisValue]]; otherwise return _V_.[[Base]]."],
    "head": {
      "name": "GetThisValue",
      "params": [{
        "kind": "Normal",
        "name": "V"
      }]
    },
    "ids": "sec-getthisvalue",
    "rawBody": "{\n  0:(0) app __x0__ = (IsPropertyReference V)\n  0:assert (= __x0__ true)\n  1:(1) app __x1__ = (IsSuperReference V)\n  1:if (= __x1__ true) return V[\"ThisValue\"] else return V[\"Base\"]\n}"
  }, {
    "code": ["          1. ReturnIfAbrupt(_V_).", "          1. ReturnIfAbrupt(_W_).", "          1. Assert: _V_ is a Reference Record.", "          1. Assert: IsUnresolvableReference(_V_) is *false*.", "          1. Let _base_ be _V_.[[Base]].", "          1. Assert: _base_ is an Environment Record.", "          1. Return _base_.InitializeBinding(_V_.[[ReferencedName]], _W_)."],
    "head": {
      "name": "InitializeReferencedBinding",
      "params": [{
        "kind": "Normal",
        "name": "V"
      }, {
        "kind": "Normal",
        "name": "W"
      }]
    },
    "ids": "sec-initializereferencedbinding",
    "rawBody": "{\n  0:[? V]\n  1:[? W]\n  2:assert (0) (is-instance-of V ReferenceRecord)\n  3:(0) app __x0__ = (IsUnresolvableReference V)\n  3:assert (= __x0__ false)\n  4:let base = V[\"Base\"]\n  5:assert (1) (is-instance-of base EnvironmentRecord)\n  6:(1) app __x1__ = (base[\"InitializeBinding\"] base V[\"ReferencedName\"] W)\n  6:return __x1__\n}"
  }, {
    "code": ["          1. If _Desc_ is *undefined*, return *false*.", "          1. If both _Desc_.[[Get]] and _Desc_.[[Set]] are absent, return *false*.", "          1. Return *true*."],
    "head": {
      "name": "IsAccessorDescriptor",
      "params": [{
        "kind": "Normal",
        "name": "Desc"
      }]
    },
    "ids": "sec-isaccessordescriptor",
    "rawBody": "{\n  0:if (= Desc undefined) return false else 0:{}\n  1:if (&& (= Desc[\"Get\"] absent) (= Desc[\"Set\"] absent)) return false else 0:{}\n  2:return true\n}"
  }, {
    "code": ["          1. If _Desc_ is *undefined*, return *false*.", "          1. If both _Desc_.[[Value]] and _Desc_.[[Writable]] are absent, return *false*.", "          1. Return *true*."],
    "head": {
      "name": "IsDataDescriptor",
      "params": [{
        "kind": "Normal",
        "name": "Desc"
      }]
    },
    "ids": "sec-isdatadescriptor",
    "rawBody": "{\n  0:if (= Desc undefined) return false else 0:{}\n  1:if (&& (= Desc[\"Value\"] absent) (= Desc[\"Writable\"] absent)) return false else 0:{}\n  2:return true\n}"
  }, {
    "code": ["          1. If _Desc_ is *undefined*, return *false*.", "          1. If IsAccessorDescriptor(_Desc_) and IsDataDescriptor(_Desc_) are both *false*, return *true*.", "          1. Return *false*."],
    "head": {
      "name": "IsGenericDescriptor",
      "params": [{
        "kind": "Normal",
        "name": "Desc"
      }]
    },
    "ids": "sec-isgenericdescriptor",
    "rawBody": "{\n  0:if (= Desc undefined) return false else 0:{}\n  1:(0) app __x0__ = (IsAccessorDescriptor Desc)\n  1:(1) app __x1__ = (IsDataDescriptor Desc)\n  1:if (&& (= __x0__ false) (= __x1__ false)) return true else 0:{}\n  2:return false\n}"
  }, {
    "code": ["          1. If _Desc_ is *undefined*, return *undefined*.", "          1. Let _obj_ be ! OrdinaryObjectCreate(%Object.prototype%).", "          1. Assert: _obj_ is an extensible ordinary object with no own properties.", "          1. If _Desc_ has a [[Value]] field, then", "            1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"value\"*, _Desc_.[[Value]]).", "          1. If _Desc_ has a [[Writable]] field, then", "            1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"writable\"*, _Desc_.[[Writable]]).", "          1. If _Desc_ has a [[Get]] field, then", "            1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"get\"*, _Desc_.[[Get]]).", "          1. If _Desc_ has a [[Set]] field, then", "            1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"set\"*, _Desc_.[[Set]]).", "          1. If _Desc_ has an [[Enumerable]] field, then", "            1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"enumerable\"*, _Desc_.[[Enumerable]]).", "          1. If _Desc_ has a [[Configurable]] field, then", "            1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"configurable\"*, _Desc_.[[Configurable]]).", "          1. Return _obj_."],
    "head": {
      "name": "FromPropertyDescriptor",
      "params": [{
        "kind": "Normal",
        "name": "Desc"
      }]
    },
    "ids": "sec-frompropertydescriptor",
    "rawBody": "{\n  0:if (= Desc undefined) return undefined else 2:{}\n  1:(0) app __x0__ = (OrdinaryObjectCreate INTRINSIC_Object_prototype)\n  1:let obj = [! __x0__]\n  3:if (! (= Desc[\"Value\"] absent)) {\n    4:(1) app __x1__ = (CreateDataPropertyOrThrow obj \"value\" Desc[\"Value\"])\n    4:[! __x1__]\n  } else 2:{}\n  5:if (! (= Desc[\"Writable\"] absent)) {\n    6:(2) app __x2__ = (CreateDataPropertyOrThrow obj \"writable\" Desc[\"Writable\"])\n    6:[! __x2__]\n  } else 2:{}\n  7:if (! (= Desc[\"Get\"] absent)) {\n    8:(3) app __x3__ = (CreateDataPropertyOrThrow obj \"get\" Desc[\"Get\"])\n    8:[! __x3__]\n  } else 2:{}\n  9:if (! (= Desc[\"Set\"] absent)) {\n    10:(4) app __x4__ = (CreateDataPropertyOrThrow obj \"set\" Desc[\"Set\"])\n    10:[! __x4__]\n  } else 2:{}\n  11:if (! (= Desc[\"Enumerable\"] absent)) {\n    12:(5) app __x5__ = (CreateDataPropertyOrThrow obj \"enumerable\" Desc[\"Enumerable\"])\n    12:[! __x5__]\n  } else 2:{}\n  13:if (! (= Desc[\"Configurable\"] absent)) {\n    14:(6) app __x6__ = (CreateDataPropertyOrThrow obj \"configurable\" Desc[\"Configurable\"])\n    14:[! __x6__]\n  } else 2:{}\n  15:return obj\n}"
  }, {
    "code": ["          1. If Type(_Obj_) is not Object, throw a *TypeError* exception.", "          1. Let _desc_ be a new Property Descriptor that initially has no fields.", "          1. Let _hasEnumerable_ be ? HasProperty(_Obj_, *\"enumerable\"*).", "          1. If _hasEnumerable_ is *true*, then", "            1. Let _enumerable_ be ! ToBoolean(? Get(_Obj_, *\"enumerable\"*)).", "            1. Set _desc_.[[Enumerable]] to _enumerable_.", "          1. Let _hasConfigurable_ be ? HasProperty(_Obj_, *\"configurable\"*).", "          1. If _hasConfigurable_ is *true*, then", "            1. Let _configurable_ be ! ToBoolean(? Get(_Obj_, *\"configurable\"*)).", "            1. Set _desc_.[[Configurable]] to _configurable_.", "          1. Let _hasValue_ be ? HasProperty(_Obj_, *\"value\"*).", "          1. If _hasValue_ is *true*, then", "            1. Let _value_ be ? Get(_Obj_, *\"value\"*).", "            1. Set _desc_.[[Value]] to _value_.", "          1. Let _hasWritable_ be ? HasProperty(_Obj_, *\"writable\"*).", "          1. If _hasWritable_ is *true*, then", "            1. Let _writable_ be ! ToBoolean(? Get(_Obj_, *\"writable\"*)).", "            1. Set _desc_.[[Writable]] to _writable_.", "          1. Let _hasGet_ be ? HasProperty(_Obj_, *\"get\"*).", "          1. If _hasGet_ is *true*, then", "            1. Let _getter_ be ? Get(_Obj_, *\"get\"*).", "            1. If IsCallable(_getter_) is *false* and _getter_ is not *undefined*, throw a *TypeError* exception.", "            1. Set _desc_.[[Get]] to _getter_.", "          1. Let _hasSet_ be ? HasProperty(_Obj_, *\"set\"*).", "          1. If _hasSet_ is *true*, then", "            1. Let _setter_ be ? Get(_Obj_, *\"set\"*).", "            1. If IsCallable(_setter_) is *false* and _setter_ is not *undefined*, throw a *TypeError* exception.", "            1. Set _desc_.[[Set]] to _setter_.", "          1. If _desc_.[[Get]] is present or _desc_.[[Set]] is present, then", "            1. If _desc_.[[Value]] is present or _desc_.[[Writable]] is present, throw a *TypeError* exception.", "          1. Return _desc_."],
    "head": {
      "name": "ToPropertyDescriptor",
      "params": [{
        "kind": "Normal",
        "name": "Obj"
      }]
    },
    "ids": "sec-topropertydescriptor",
    "rawBody": "{\n  0:if (! (= (typeof Obj) Object)) (0) throw TypeError else 2:{}\n  1:let desc = (1) (new PropertyDescriptor())\n  2:(0) app __x0__ = (HasProperty Obj \"enumerable\")\n  2:let hasEnumerable = [? __x0__]\n  3:if (= hasEnumerable true) {\n    4:(1) app __x1__ = (Get Obj \"enumerable\")\n    4:(2) app __x2__ = (ToBoolean [? __x1__])\n    4:let enumerable = [! __x2__]\n    5:desc[\"Enumerable\"] = enumerable\n  } else 2:{}\n  6:(3) app __x3__ = (HasProperty Obj \"configurable\")\n  6:let hasConfigurable = [? __x3__]\n  7:if (= hasConfigurable true) {\n    8:(4) app __x4__ = (Get Obj \"configurable\")\n    8:(5) app __x5__ = (ToBoolean [? __x4__])\n    8:let configurable = [! __x5__]\n    9:desc[\"Configurable\"] = configurable\n  } else 2:{}\n  10:(6) app __x6__ = (HasProperty Obj \"value\")\n  10:let hasValue = [? __x6__]\n  11:if (= hasValue true) {\n    12:(7) app __x7__ = (Get Obj \"value\")\n    12:let value = [? __x7__]\n    13:desc[\"Value\"] = value\n  } else 2:{}\n  14:(8) app __x8__ = (HasProperty Obj \"writable\")\n  14:let hasWritable = [? __x8__]\n  15:if (= hasWritable true) {\n    16:(9) app __x9__ = (Get Obj \"writable\")\n    16:(10) app __x10__ = (ToBoolean [? __x9__])\n    16:let writable = [! __x10__]\n    17:desc[\"Writable\"] = writable\n  } else 2:{}\n  18:(11) app __x11__ = (HasProperty Obj \"get\")\n  18:let hasGet = [? __x11__]\n  19:if (= hasGet true) {\n    20:(12) app __x12__ = (Get Obj \"get\")\n    20:let getter = [? __x12__]\n    21:(13) app __x13__ = (IsCallable getter)\n    21:if (&& (= __x13__ false) (! (= getter undefined))) (2) throw TypeError else 2:{}\n    22:desc[\"Get\"] = getter\n  } else 2:{}\n  23:(14) app __x14__ = (HasProperty Obj \"set\")\n  23:let hasSet = [? __x14__]\n  24:if (= hasSet true) {\n    25:(15) app __x15__ = (Get Obj \"set\")\n    25:let setter = [? __x15__]\n    26:(16) app __x16__ = (IsCallable setter)\n    26:if (&& (= __x16__ false) (! (= setter undefined))) (3) throw TypeError else 2:{}\n    27:desc[\"Set\"] = setter\n  } else 2:{}\n  28:if (|| (! (= desc[\"Get\"] absent)) (! (= desc[\"Set\"] absent))) if (|| (! (= desc[\"Value\"] absent)) (! (= desc[\"Writable\"] absent))) (4) throw TypeError else 2:{} else 2:{}\n  30:return desc\n}"
  }, {
    "code": ["          1. Assert: _Desc_ is a Property Descriptor.", "          1. Let _like_ be the Record { [[Value]]: *undefined*, [[Writable]]: *false*, [[Get]]: *undefined*, [[Set]]: *undefined*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.", "          1. If IsGenericDescriptor(_Desc_) is *true* or IsDataDescriptor(_Desc_) is *true*, then", "            1. If _Desc_ does not have a [[Value]] field, set _Desc_.[[Value]] to _like_.[[Value]].", "            1. If _Desc_ does not have a [[Writable]] field, set _Desc_.[[Writable]] to _like_.[[Writable]].", "          1. Else,", "            1. If _Desc_ does not have a [[Get]] field, set _Desc_.[[Get]] to _like_.[[Get]].", "            1. If _Desc_ does not have a [[Set]] field, set _Desc_.[[Set]] to _like_.[[Set]].", "          1. If _Desc_ does not have an [[Enumerable]] field, set _Desc_.[[Enumerable]] to _like_.[[Enumerable]].", "          1. If _Desc_ does not have a [[Configurable]] field, set _Desc_.[[Configurable]] to _like_.[[Configurable]].", "          1. Return _Desc_."],
    "head": {
      "name": "CompletePropertyDescriptor",
      "params": [{
        "kind": "Normal",
        "name": "Desc"
      }]
    },
    "ids": "sec-completepropertydescriptor",
    "rawBody": "{\n  0:assert (0) (is-instance-of Desc PropertyDescriptor)\n  1:let like = (1) (new Record(\"Value\" -> undefined, \"Writable\" -> false, \"Get\" -> undefined, \"Set\" -> undefined, \"Enumerable\" -> false, \"Configurable\" -> false))\n  5:let __x0__ = true\n  5:(0) app __x1__ = (IsGenericDescriptor Desc)\n  5:__x0__ = (= __x1__ true)\n  5:if __x0__ 2:{} else {\n    (1) app __x2__ = (IsDataDescriptor Desc)\n    __x0__ = (= __x2__ true)\n  }\n  5:if __x0__ {\n    3:if (= Desc[\"Value\"] absent) Desc[\"Value\"] = like[\"Value\"] else 2:{}\n    4:if (= Desc[\"Writable\"] absent) Desc[\"Writable\"] = like[\"Writable\"] else 2:{}\n  } else {\n    6:if (= Desc[\"Get\"] absent) Desc[\"Get\"] = like[\"Get\"] else 2:{}\n    7:if (= Desc[\"Set\"] absent) Desc[\"Set\"] = like[\"Set\"] else 2:{}\n  }\n  8:if (= Desc[\"Enumerable\"] absent) Desc[\"Enumerable\"] = like[\"Enumerable\"] else 2:{}\n  9:if (= Desc[\"Configurable\"] absent) Desc[\"Configurable\"] = like[\"Configurable\"] else 2:{}\n  10:return Desc\n}"
  }, {
    "code": ["        1. Let _addend_ be 41.", "        1. Let _closure_ be a new Abstract Closure with parameters (_x_) that captures _addend_ and performs the following steps when called:", "          1. Return _x_ + _addend_.", "        1. Let _val_ be _closure_(1).", "        1. Assert: _val_ is 42."],
    "head": {
      "name": "TheAbstractClosureSpecificationType",
      "params": []
    },
    "ids": "sec-abstract-closure",
    "rawBody": "{\n  0:let addend = 41i\n  1:(0) ??? \"Let id:{closure} be a new Abstract Closure with parameters ( id:{x} ) that captures id:{addend} and performs the following steps when called : in:{} out:{}\"\n  3:(0) app __x0__ = (closure 1i)\n  3:let val = __x0__\n  4:assert (= val 42i)\n}"
  }, {
    "code": ["          1. Assert: _size_ ≥ 0.", "          1. Let _db_ be a new Data Block value consisting of _size_ bytes. If it is impossible to create such a Data Block, throw a *RangeError* exception.", "          1. Set all of the bytes of _db_ to 0.", "          1. Return _db_."],
    "head": {
      "name": "CreateByteDataBlock",
      "params": [{
        "kind": "Normal",
        "name": "size"
      }]
    },
    "ids": "sec-createbytedatablock",
    "rawBody": "{\n  0:assert (! (< size 0i))\n  1:(0) ??? \"Let id:{db} be a new Data Block value consisting of id:{size} bytes . If it is impossible to create such a Data Block , throw a value:{RangeError} exception .\"\n  2:(1) ??? \"Set all of the bytes of id:{db} to 0 .\"\n  3:return db\n}"
  }, {
    "code": ["          1. Assert: _size_ ≥ 0.", "          1. Let _db_ be a new Shared Data Block value consisting of _size_ bytes. If it is impossible to create such a Shared Data Block, throw a *RangeError* exception.", "          1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.", "          1. Let _eventList_ be the [[EventList]] field of the element in _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().", "          1. Let _zero_ be « 0 ».", "          1. For each index _i_ of _db_, do", "            1. Append WriteSharedMemory { [[Order]]: ~Init~, [[NoTear]]: *true*, [[Block]]: _db_, [[ByteIndex]]: _i_, [[ElementSize]]: 1, [[Payload]]: _zero_ } to _eventList_.", "          1. Return _db_."],
    "head": {
      "name": "CreateSharedByteDataBlock",
      "params": [{
        "kind": "Normal",
        "name": "size"
      }]
    },
    "ids": "sec-createsharedbytedatablock",
    "rawBody": "{\n  0:assert (! (< size 0i))\n  1:(0) ??? \"Let id:{db} be a new Shared Data Block value consisting of id:{size} bytes . If it is impossible to create such a Shared Data Block , throw a value:{RangeError} exception .\"\n  2:let execution = AGENT[\"CandidateExecution\"]\n  3:(1) ??? \"Let id:{eventList} be the [ [ EventList ] ] field of the element in id:{execution} . [ [ EventsRecords ] ] whose [ [ AgentSignifier ] ] is AgentSignifier ( ) .\"\n  4:let zero = (2) (new [0i])\n  5:let __x0__ = db\n  5:let __x1__ = 0i\n  5:while (< __x1__ __x0__[\"length\"]) {\n    let i = __x0__[__x1__]\n    6:append (3) (new WriteSharedMemory(\"Order\" -> CONST_Init, \"NoTear\" -> true, \"Block\" -> db, \"ByteIndex\" -> i, \"ElementSize\" -> 1i, \"Payload\" -> zero)) -> eventList\n    __x1__ = (+ __x1__ 1i)\n  }\n  7:return db\n}"
  }, {
    "code": ["          1. Assert: _fromBlock_ and _toBlock_ are distinct Data Block or Shared Data Block values.", "          1. Let _fromSize_ be the number of bytes in _fromBlock_.", "          1. Assert: _fromIndex_ + _count_ ≤ _fromSize_.", "          1. Let _toSize_ be the number of bytes in _toBlock_.", "          1. Assert: _toIndex_ + _count_ ≤ _toSize_.", "          1. Repeat, while _count_ > 0,", "            1. If _fromBlock_ is a Shared Data Block, then", "              1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.", "              1. Let _eventList_ be the [[EventList]] field of the element in _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().", "              1. Let _bytes_ be a List whose sole element is a nondeterministically chosen byte value.", "              1. NOTE: In implementations, _bytes_ is the result of a non-atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.", "              1. Let _readEvent_ be ReadSharedMemory { [[Order]]: ~Unordered~, [[NoTear]]: *true*, [[Block]]: _fromBlock_, [[ByteIndex]]: _fromIndex_, [[ElementSize]]: 1 }.", "              1. Append _readEvent_ to _eventList_.", "              1. Append Chosen Value Record { [[Event]]: _readEvent_, [[ChosenValue]]: _bytes_ } to _execution_.[[ChosenValues]].", "              1. If _toBlock_ is a Shared Data Block, then", "                1. Append WriteSharedMemory { [[Order]]: ~Unordered~, [[NoTear]]: *true*, [[Block]]: _toBlock_, [[ByteIndex]]: _toIndex_, [[ElementSize]]: 1, [[Payload]]: _bytes_ } to _eventList_.", "              1. Else,", "                1. Set _toBlock_[_toIndex_] to _bytes_[0].", "            1. Else,", "              1. Assert: _toBlock_ is not a Shared Data Block.", "              1. Set _toBlock_[_toIndex_] to _fromBlock_[_fromIndex_].", "            1. Set _toIndex_ to _toIndex_ + 1.", "            1. Set _fromIndex_ to _fromIndex_ + 1.", "            1. Set _count_ to _count_ - 1.", "          1. Return NormalCompletion(~empty~)."],
    "head": {
      "name": "CopyDataBlockBytes",
      "params": [{
        "kind": "Normal",
        "name": "toBlock"
      }, {
        "kind": "Normal",
        "name": "toIndex"
      }, {
        "kind": "Normal",
        "name": "fromBlock"
      }, {
        "kind": "Normal",
        "name": "fromIndex"
      }, {
        "kind": "Normal",
        "name": "count"
      }]
    },
    "ids": "sec-copydatablockbytes",
    "rawBody": "{\n  1:(0) ??? \"Let id:{fromSize} be the number of bytes in id:{fromBlock} .\"\n  2:assert (! (< fromSize (+ fromIndex count)))\n  3:(1) ??? \"Let id:{toSize} be the number of bytes in id:{toBlock} .\"\n  4:assert (! (< toSize (+ toIndex count)))\n  5:while (< 0i count) {\n    18:if (2) (is-instance-of fromBlock SharedDataBlock) {\n      7:let execution = AGENT[\"CandidateExecution\"]\n      8:(3) ??? \"Let id:{eventList} be the [ [ EventList ] ] field of the element in id:{execution} . [ [ EventsRecords ] ] whose [ [ AgentSignifier ] ] is AgentSignifier ( ) .\"\n      9:(4) ??? \"Let id:{bytes} be a List whose sole element is a nondeterministically chosen byte value .\"\n      11:let readEvent = (5) (new ReadSharedMemory(\"Order\" -> CONST_Unordered, \"NoTear\" -> true, \"Block\" -> fromBlock, \"ByteIndex\" -> fromIndex, \"ElementSize\" -> 1i))\n      12:append readEvent -> eventList\n      13:append (6) (new ChosenValueRecord(\"Event\" -> readEvent, \"ChosenValue\" -> bytes)) -> execution[\"ChosenValues\"]\n      16:if (7) (is-instance-of toBlock SharedDataBlock) append (8) (new WriteSharedMemory(\"Order\" -> CONST_Unordered, \"NoTear\" -> true, \"Block\" -> toBlock, \"ByteIndex\" -> toIndex, \"ElementSize\" -> 1i, \"Payload\" -> bytes)) -> eventList else toBlock[toIndex] = bytes[0i]\n    } else {\n      19:assert (! (9) (is-instance-of toBlock SharedDataBlock))\n      20:toBlock[toIndex] = fromBlock[fromIndex]\n    }\n    21:toIndex = (+ toIndex 1i)\n    22:fromIndex = (+ fromIndex 1i)\n    23:count = (- count 1i)\n  }\n  24:return CONST_empty\n}"
  }, {
    "code": ["        1. Assert: _input_ is an ECMAScript language value.", "        1. If Type(_input_) is Object, then", "          1. Let _exoticToPrim_ be ? GetMethod(_input_, @@toPrimitive).", "          1. If _exoticToPrim_ is not *undefined*, then", "            1. If _preferredType_ is not present, let _hint_ be *\"default\"*.", "            1. Else if _preferredType_ is ~string~, let _hint_ be *\"string\"*.", "            1. Else,", "              1. Assert: _preferredType_ is ~number~.", "              1. Let _hint_ be *\"number\"*.", "            1. Let _result_ be ? Call(_exoticToPrim_, _input_, « _hint_ »).", "            1. If Type(_result_) is not Object, return _result_.", "            1. Throw a *TypeError* exception.", "          1. If _preferredType_ is not present, let _preferredType_ be ~number~.", "          1. Return ? OrdinaryToPrimitive(_input_, _preferredType_).", "        1. Return _input_."],
    "head": {
      "name": "ToPrimitive",
      "params": [{
        "kind": "Normal",
        "name": "input"
      }, {
        "kind": "Optional",
        "name": "preferredType"
      }]
    },
    "ids": "sec-toprimitive",
    "rawBody": "{\n  1:if (= (typeof input) Object) {\n    2:(0) app __x0__ = (GetMethod input SYMBOL_toPrimitive)\n    2:let exoticToPrim = [? __x0__]\n    3:if (! (= exoticToPrim undefined)) {\n      6:if (= preferredType absent) let hint = \"default\" else if (= preferredType CONST_string) let hint = \"string\" else {\n        7:assert (= preferredType CONST_number)\n        8:let hint = \"number\"\n      }\n      9:(1) app __x1__ = (Call exoticToPrim input (0) (new [hint]))\n      9:let result = [? __x1__]\n      10:if (! (= (typeof result) Object)) return result else 0:{}\n      11:(1) throw TypeError\n    } else 0:{}\n    12:if (= preferredType absent) let preferredType = CONST_number else 0:{}\n    13:(2) app __x2__ = (OrdinaryToPrimitive input preferredType)\n    13:return [? __x2__]\n  } else 0:{}\n  14:return input\n}"
  }, {
    "code": ["          1. Assert: Type(_O_) is Object.", "          1. Assert: _hint_ is either ~string~ or ~number~.", "          1. If _hint_ is ~string~, then", "            1. Let _methodNames_ be « *\"toString\"*, *\"valueOf\"* ».", "          1. Else,", "            1. Let _methodNames_ be « *\"valueOf\"*, *\"toString\"* ».", "          1. For each element _name_ of _methodNames_, do", "            1. Let _method_ be ? Get(_O_, _name_).", "            1. If IsCallable(_method_) is *true*, then", "              1. Let _result_ be ? Call(_method_, _O_).", "              1. If Type(_result_) is not Object, return _result_.", "          1. Throw a *TypeError* exception."],
    "head": {
      "name": "OrdinaryToPrimitive",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "hint"
      }]
    },
    "ids": "sec-ordinarytoprimitive",
    "rawBody": "{\n  0:assert (= (typeof O) Object)\n  1:assert (|| (= hint CONST_string) (= hint CONST_number))\n  4:if (= hint CONST_string) let methodNames = (0) (new [\"toString\", \"valueOf\"]) else let methodNames = (1) (new [\"valueOf\", \"toString\"])\n  6:let __x0__ = methodNames\n  6:let __x1__ = 0i\n  6:while (< __x1__ __x0__[\"length\"]) {\n    let name = __x0__[__x1__]\n    7:(0) app __x2__ = (Get O name)\n    7:let method = [? __x2__]\n    8:(1) app __x3__ = (IsCallable method)\n    8:if (= __x3__ true) {\n      9:(2) app __x4__ = (Call method O)\n      9:let result = [? __x4__]\n      10:if (! (= (typeof result) Object)) return result else 0:{}\n    } else 0:{}\n    __x1__ = (+ __x1__ 1i)\n  }\n  11:(2) throw TypeError\n}"
  }, {
    "code": ["        1. Let _primValue_ be ? ToPrimitive(_value_, ~number~).", "        1. If Type(_primValue_) is BigInt, return _primValue_.", "        1. Return ? ToNumber(_primValue_)."],
    "head": {
      "name": "ToNumeric",
      "params": [{
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "sec-tonumeric",
    "rawBody": "{\n  0:(0) app __x0__ = (ToPrimitive value CONST_number)\n  0:let primValue = [? __x0__]\n  1:if (= (typeof primValue) BigInt) return primValue else 0:{}\n  2:(1) app __x1__ = (ToNumber primValue)\n  2:return [? __x1__]\n}"
  }, {
    "code": ["        1. Let _number_ be ? ToNumber(_argument_).", "        1. If _number_ is *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return 0.", "        1. If _number_ is *+∞*<sub>𝔽</sub>, return +∞.", "        1. If _number_ is *-∞*<sub>𝔽</sub>, return -∞.", "        1. Let _integer_ be floor(abs(ℝ(_number_))).", "        1. If _number_ < *+0*<sub>𝔽</sub>, set _integer_ to -_integer_.", "        1. Return _integer_."],
    "head": {
      "name": "ToIntegerOrInfinity",
      "params": [{
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "sec-tointegerorinfinity",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber argument)\n  0:let number = [? __x0__]\n  1:if (|| (|| (= number NaN) (= number 0i)) (= number -0.0)) return 0i else 0:{}\n  2:if (= number Infinity) return Infinity else 0:{}\n  3:if (= number -Infinity) return -Infinity else 0:{}\n  4:(1) app __x1__ = (abs number)\n  4:(2) app __x2__ = (floor __x1__)\n  4:let integer = __x2__\n  5:if (< number 0i) integer = (- integer) else 0:{}\n  6:return integer\n}"
  }, {
    "code": ["        1. Let _number_ be ? ToNumber(_argument_).", "        1. If _number_ is *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, *+∞*<sub>𝔽</sub>, or *-∞*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.", "        1. Let _int_ be the mathematical value that is the same sign as _number_ and whose magnitude is floor(abs(ℝ(_number_))).", "        1. Let _int32bit_ be _int_ modulo 2<sup>32</sup>.", "        1. If _int32bit_ ≥ 2<sup>31</sup>, return 𝔽(_int32bit_ - 2<sup>32</sup>); otherwise return 𝔽(_int32bit_)."],
    "head": {
      "name": "ToInt32",
      "params": [{
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "sec-toint32",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber argument)\n  0:let number = [? __x0__]\n  1:if (|| (|| (|| (|| (= number NaN) (= number 0i)) (= number -0.0)) (= number Infinity)) (= number -Infinity)) return 0i else 0:{}\n  2:let int = (convert number num2int )\n  3:let int32bit = (%% int (** 2.0 32i))\n  4:if (! (< int32bit (** 2.0 31i))) return (- int32bit (** 2.0 32i)) else return int32bit\n}"
  }, {
    "code": ["        1. Let _number_ be ? ToNumber(_argument_).", "        1. If _number_ is *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, *+∞*<sub>𝔽</sub>, or *-∞*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.", "        1. Let _int_ be the mathematical value that is the same sign as _number_ and whose magnitude is floor(abs(ℝ(_number_))).", "        1. Let _int32bit_ be _int_ modulo 2<sup>32</sup>.", "        1. [id=\"step-touint32-return\"] Return 𝔽(_int32bit_)."],
    "head": {
      "name": "ToUint32",
      "params": [{
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "sec-touint32",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber argument)\n  0:let number = [? __x0__]\n  1:if (|| (|| (|| (|| (= number NaN) (= number 0i)) (= number -0.0)) (= number Infinity)) (= number -Infinity)) return 0i else 0:{}\n  2:let int = (convert number num2int )\n  3:let int32bit = (%% int (** 2.0 32i))\n  4:return int32bit\n}"
  }, {
    "code": ["        1. Let _number_ be ? ToNumber(_argument_).", "        1. If _number_ is *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, *+∞*<sub>𝔽</sub>, or *-∞*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.", "        1. Let _int_ be the mathematical value that is the same sign as _number_ and whose magnitude is floor(abs(ℝ(_number_))).", "        1. Let _int16bit_ be _int_ modulo 2<sup>16</sup>.", "        1. If _int16bit_ ≥ 2<sup>15</sup>, return 𝔽(_int16bit_ - 2<sup>16</sup>); otherwise return 𝔽(_int16bit_)."],
    "head": {
      "name": "ToInt16",
      "params": [{
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "sec-toint16",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber argument)\n  0:let number = [? __x0__]\n  1:if (|| (|| (|| (|| (= number NaN) (= number 0i)) (= number -0.0)) (= number Infinity)) (= number -Infinity)) return 0i else 0:{}\n  2:let int = (convert number num2int )\n  3:let int16bit = (%% int (** 2.0 16i))\n  4:if (! (< int16bit (** 2.0 15i))) return (- int16bit (** 2.0 16i)) else return int16bit\n}"
  }, {
    "code": ["        1. Let _number_ be ? ToNumber(_argument_).", "        1. If _number_ is *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, *+∞*<sub>𝔽</sub>, or *-∞*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.", "        1. Let _int_ be the mathematical value that is the same sign as _number_ and whose magnitude is floor(abs(ℝ(_number_))).", "        1. [id=\"step-touint16-mod\"] Let _int16bit_ be _int_ modulo 2<sup>16</sup>.", "        1. Return 𝔽(_int16bit_)."],
    "head": {
      "name": "ToUint16",
      "params": [{
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "sec-touint16",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber argument)\n  0:let number = [? __x0__]\n  1:if (|| (|| (|| (|| (= number NaN) (= number 0i)) (= number -0.0)) (= number Infinity)) (= number -Infinity)) return 0i else 0:{}\n  2:let int = (convert number num2int )\n  3:let int16bit = (%% int (** 2.0 16i))\n  4:return int16bit\n}"
  }, {
    "code": ["        1. Let _number_ be ? ToNumber(_argument_).", "        1. If _number_ is *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, *+∞*<sub>𝔽</sub>, or *-∞*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.", "        1. Let _int_ be the mathematical value that is the same sign as _number_ and whose magnitude is floor(abs(ℝ(_number_))).", "        1. Let _int8bit_ be _int_ modulo 2<sup>8</sup>.", "        1. If _int8bit_ ≥ 2<sup>7</sup>, return 𝔽(_int8bit_ - 2<sup>8</sup>); otherwise return 𝔽(_int8bit_)."],
    "head": {
      "name": "ToInt8",
      "params": [{
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "sec-toint8",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber argument)\n  0:let number = [? __x0__]\n  1:if (|| (|| (|| (|| (= number NaN) (= number 0i)) (= number -0.0)) (= number Infinity)) (= number -Infinity)) return 0i else 0:{}\n  2:let int = (convert number num2int )\n  3:let int8bit = (%% int (** 2.0 8i))\n  4:if (! (< int8bit (** 2.0 7i))) return (- int8bit (** 2.0 8i)) else return int8bit\n}"
  }, {
    "code": ["        1. Let _number_ be ? ToNumber(_argument_).", "        1. If _number_ is *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, *+∞*<sub>𝔽</sub>, or *-∞*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.", "        1. Let _int_ be the mathematical value that is the same sign as _number_ and whose magnitude is floor(abs(ℝ(_number_))).", "        1. Let _int8bit_ be _int_ modulo 2<sup>8</sup>.", "        1. Return 𝔽(_int8bit_)."],
    "head": {
      "name": "ToUint8",
      "params": [{
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "sec-touint8",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber argument)\n  0:let number = [? __x0__]\n  1:if (|| (|| (|| (|| (= number NaN) (= number 0i)) (= number -0.0)) (= number Infinity)) (= number -Infinity)) return 0i else 0:{}\n  2:let int = (convert number num2int )\n  3:let int8bit = (%% int (** 2.0 8i))\n  4:return int8bit\n}"
  }, {
    "code": ["        1. Let _number_ be ? ToNumber(_argument_).", "        1. If _number_ is *NaN*, return *+0*<sub>𝔽</sub>.", "        1. If ℝ(_number_) ≤ 0, return *+0*<sub>𝔽</sub>.", "        1. If ℝ(_number_) ≥ 255, return *255*<sub>𝔽</sub>.", "        1. Let _f_ be floor(ℝ(_number_)).", "        1. If _f_ + 0.5 < ℝ(_number_), return 𝔽(_f_ + 1).", "        1. If ℝ(_number_) < _f_ + 0.5, return 𝔽(_f_).", "        1. If _f_ is odd, return 𝔽(_f_ + 1).", "        1. Return 𝔽(_f_)."],
    "head": {
      "name": "ToUint8Clamp",
      "params": [{
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "sec-touint8clamp",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber argument)\n  0:let number = [? __x0__]\n  1:if (= number NaN) return 0i else 0:{}\n  2:if (! (< 0i number)) return 0i else 0:{}\n  3:if (! (< number 255i)) return 255i else 0:{}\n  4:(1) app __x1__ = (floor number)\n  4:let f = __x1__\n  5:if (< (+ f 0.5) number) return (+ f 1i) else 0:{}\n  6:if (< number (+ f 0.5)) return f else 0:{}\n  7:if (= (% f 2i) 1i) return (+ f 1i) else 0:{}\n  8:return f\n}"
  }, {
    "code": ["        1. Let _prim_ be ? ToPrimitive(_argument_, ~number~).", "        1. Return the value that _prim_ corresponds to in <emu-xref href=\"#table-tobigint\"></emu-xref>."],
    "head": {
      "name": "ToBigInt",
      "params": [{
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "sec-tobigint",
    "rawBody": "{\n  0:(0) app __x0__ = (ToPrimitive argument CONST_number)\n  0:let prim = [? __x0__]\n  1:(0) ??? \"Return the value that id:{prim} corresponds to in link:{table-tobigint} .\"\n}"
  }, {
    "code": ["        1. Let _n_ be ? ToBigInt(_argument_).", "        1. Let _int64bit_ be ℝ(_n_) modulo 2<sup>64</sup>.", "        1. If _int64bit_ ≥ 2<sup>63</sup>, return ℤ(_int64bit_ - 2<sup>64</sup>); otherwise return ℤ(_int64bit_)."],
    "head": {
      "name": "ToBigInt64",
      "params": [{
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "sec-tobigint64",
    "rawBody": "{\n  0:(0) app __x0__ = (ToBigInt argument)\n  0:let n = [? __x0__]\n  1:let int64bit = (%% n (** 2.0 64i))\n  2:if (! (< int64bit (** 2.0 63i))) return (convert (- int64bit (** 2.0 64i)) num2bigint ) else return (convert int64bit num2bigint )\n}"
  }, {
    "code": ["        1. Let _n_ be ? ToBigInt(_argument_).", "        1. Let _int64bit_ be ℝ(_n_) modulo 2<sup>64</sup>.", "        1. Return ℤ(_int64bit_)."],
    "head": {
      "name": "ToBigUint64",
      "params": [{
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "sec-tobiguint64",
    "rawBody": "{\n  0:(0) app __x0__ = (ToBigInt argument)\n  0:let n = [? __x0__]\n  1:let int64bit = (%% n (** 2.0 64i))\n  2:return (convert int64bit num2bigint )\n}"
  }, {
    "code": ["        1. Let _key_ be ? ToPrimitive(_argument_, ~string~).", "        1. If Type(_key_) is Symbol, then", "          1. Return _key_.", "        1. Return ! ToString(_key_)."],
    "head": {
      "name": "ToPropertyKey",
      "params": [{
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "sec-topropertykey",
    "rawBody": "{\n  0:(0) app __x0__ = (ToPrimitive argument CONST_string)\n  0:let key = [? __x0__]\n  1:if (= (typeof key) Symbol) return key else 0:{}\n  3:(1) app __x1__ = (ToString key)\n  3:return [! __x1__]\n}"
  }, {
    "code": ["        1. Let _len_ be ? ToIntegerOrInfinity(_argument_).", "        1. If _len_ ≤ 0, return *+0*<sub>𝔽</sub>.", "        1. Return 𝔽(min(_len_, 2<sup>53</sup> - 1))."],
    "head": {
      "name": "ToLength",
      "params": [{
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "sec-tolength",
    "rawBody": "{\n  0:(0) app __x0__ = (ToIntegerOrInfinity argument)\n  0:let len = [? __x0__]\n  1:if (! (< 0i len)) return 0i else 0:{}\n  2:(1) app __x1__ = (min len (- (** 2.0 53i) 1i))\n  2:return __x1__\n}"
  }, {
    "code": ["        1. Assert: Type(_argument_) is String.", "        1. If _argument_ is *\"-0\"*, return *-0*<sub>𝔽</sub>.", "        1. Let _n_ be ! ToNumber(_argument_).", "        1. If SameValue(! ToString(_n_), _argument_) is *false*, return *undefined*.", "        1. Return _n_."],
    "head": {
      "name": "CanonicalNumericIndexString",
      "params": [{
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "sec-canonicalnumericindexstring",
    "rawBody": "{\n  0:assert (= (typeof argument) String)\n  1:if (= argument \"-0\") return -0.0 else 0:{}\n  2:(0) app __x0__ = (ToNumber argument)\n  2:let n = [! __x0__]\n  3:(1) app __x1__ = (ToString n)\n  3:(2) app __x2__ = (SameValue [! __x1__] argument)\n  3:if (= __x2__ false) return undefined else 0:{}\n  4:return n\n}"
  }, {
    "code": ["        1. If _value_ is *undefined*, then", "          1. Return 0.", "        1. Else,", "          1. Let _integerIndex_ be 𝔽(? ToIntegerOrInfinity(_value_)).", "          1. If _integerIndex_ < *+0*<sub>𝔽</sub>, throw a *RangeError* exception.", "          1. Let _index_ be ! ToLength(_integerIndex_).", "          1. If ! SameValue(_integerIndex_, _index_) is *false*, throw a *RangeError* exception.", "          1. Return ℝ(_index_)."],
    "head": {
      "name": "ToIndex",
      "params": [{
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "sec-toindex",
    "rawBody": "if (= value undefined) return 0i else {\n  3:(0) app __x0__ = (ToIntegerOrInfinity value)\n  3:let integerIndex = [? __x0__]\n  4:if (< integerIndex 0i) (0) throw RangeError else 0:{}\n  5:(1) app __x1__ = (ToLength integerIndex)\n  5:let index = [! __x1__]\n  6:(2) app __x2__ = (SameValue integerIndex index)\n  6:if (= [! __x2__] false) (1) throw RangeError else 0:{}\n  7:return index\n}"
  }, {
    "code": ["        1. If Type(_argument_) is not Object, return *false*.", "        1. If _argument_ is an Array exotic object, return *true*.", "        1. If _argument_ is a Proxy exotic object, then", "          1. If _argument_.[[ProxyHandler]] is *null*, throw a *TypeError* exception.", "          1. Let _target_ be _argument_.[[ProxyTarget]].", "          1. Return ? IsArray(_target_).", "        1. Return *false*."],
    "head": {
      "name": "IsArray",
      "params": [{
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "sec-isarray",
    "rawBody": "{\n  0:if (! (= (typeof argument) Object)) return false else 0:{}\n  1:if (0) (is-instance-of argument ArrayExoticObject) return true else 0:{}\n  2:if (1) (is-instance-of argument ProxyExoticObject) {\n    3:if (= argument[\"ProxyHandler\"] null) (2) throw TypeError else 0:{}\n    4:let target = argument[\"ProxyTarget\"]\n    5:(0) app __x0__ = (IsArray target)\n    5:return [? __x0__]\n  } else 0:{}\n  6:return false\n}"
  }, {
    "code": ["        1. If Type(_argument_) is not Object, return *false*.", "        1. If _argument_ has a [[Call]] internal method, return *true*.", "        1. Return *false*."],
    "head": {
      "name": "IsCallable",
      "params": [{
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "sec-iscallable",
    "rawBody": "{\n  0:if (! (= (typeof argument) Object)) return false else 0:{}\n  1:if (! (= argument[\"Call\"] absent)) return true else 0:{}\n  2:return false\n}"
  }, {
    "code": ["        1. If Type(_argument_) is not Object, return *false*.", "        1. If _argument_ has a [[Construct]] internal method, return *true*.", "        1. Return *false*."],
    "head": {
      "name": "IsConstructor",
      "params": [{
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "sec-isconstructor",
    "rawBody": "{\n  0:if (! (= (typeof argument) Object)) return false else 0:{}\n  1:if (! (= argument[\"Construct\"] absent)) return true else 0:{}\n  2:return false\n}"
  }, {
    "code": ["        1. Assert: Type(_O_) is Object.", "        1. Return ? _O_.[[IsExtensible]]()."],
    "head": {
      "name": "IsExtensible",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }]
    },
    "ids": "sec-isextensible-o",
    "rawBody": "{\n  0:assert (= (typeof O) Object)\n  1:(0) app __x0__ = (O[\"IsExtensible\"] O)\n  1:return [? __x0__]\n}"
  }, {
    "code": ["        1. If Type(_argument_) is not Number, return *false*.", "        1. If _argument_ is *NaN*, *+∞*<sub>𝔽</sub>, or *-∞*<sub>𝔽</sub>, return *false*.", "        1. If floor(abs(ℝ(_argument_))) ≠ abs(ℝ(_argument_)), return *false*.", "        1. Return *true*."],
    "head": {
      "name": "IsIntegralNumber",
      "params": [{
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "sec-isintegralnumber",
    "rawBody": "{\n  0:if (! (= (typeof argument) Number)) return false else 0:{}\n  1:if (|| (|| (= argument NaN) (= argument Infinity)) (= argument -Infinity)) return false else 0:{}\n  2:(0) app __x0__ = (abs argument)\n  2:(1) app __x1__ = (floor __x0__)\n  2:(2) app __x2__ = (abs argument)\n  2:if (! (== __x1__ __x2__)) return false else 0:{}\n  3:return true\n}"
  }, {
    "code": ["        1. If Type(_argument_) is String, return *true*.", "        1. If Type(_argument_) is Symbol, return *true*.", "        1. Return *false*."],
    "head": {
      "name": "IsPropertyKey",
      "params": [{
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "sec-ispropertykey",
    "rawBody": "{\n  0:if (= (typeof argument) String) return true else 0:{}\n  1:if (= (typeof argument) Symbol) return true else 0:{}\n  2:return false\n}"
  }, {
    "code": ["        1. If Type(_argument_) is not Object, return *false*.", "        1. Let _matcher_ be ? Get(_argument_, @@match).", "        1. If _matcher_ is not *undefined*, return ! ToBoolean(_matcher_).", "        1. If _argument_ has a [[RegExpMatcher]] internal slot, return *true*.", "        1. Return *false*."],
    "head": {
      "name": "IsRegExp",
      "params": [{
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "sec-isregexp",
    "rawBody": "{\n  0:if (! (= (typeof argument) Object)) return false else 0:{}\n  1:(0) app __x0__ = (Get argument SYMBOL_match)\n  1:let matcher = [? __x0__]\n  2:if (! (= matcher undefined)) {\n    (1) app __x1__ = (ToBoolean matcher)\n    return [! __x1__]\n  } else 0:{}\n  3:if (! (= argument[\"RegExpMatcher\"] absent)) return true else 0:{}\n  4:return false\n}"
  }, {
    "code": ["        1. Assert: Type(_p_) is String.", "        1. Assert: Type(_q_) is String.", "        1. If _q_ can be the string-concatenation of _p_ and some other String _r_, return *true*. Otherwise, return *false*."],
    "head": {
      "name": "IsStringPrefix",
      "params": [{
        "kind": "Normal",
        "name": "p"
      }, {
        "kind": "Normal",
        "name": "q"
      }]
    },
    "ids": "sec-isstringprefix",
    "rawBody": "{\n  0:assert (= (typeof p) String)\n  1:assert (= (typeof q) String)\n  2:(0) ??? \"If id:{q} can be the string - concatenation of id:{p} and some other String id:{r} , return value:{true} . Otherwise , return value:{false} .\"\n}"
  }, {
    "code": ["        1. If Type(_x_) is different from Type(_y_), return *false*.", "        1. If Type(_x_) is Number or BigInt, then", "          1. Return ! Type(_x_)::sameValue(_x_, _y_).", "        1. Return ! SameValueNonNumeric(_x_, _y_)."],
    "head": {
      "name": "SameValue",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-samevalue",
    "rawBody": "{\n  0:if (! (= (typeof x) (typeof y))) return false else 0:{}\n  1:if (|| (= (typeof x) Number) (= (typeof x) BigInt)) {\n    2:(0) app __x0__ = (PRIMITIVE[(typeof x)][\"sameValue\"] x y)\n    2:return [! __x0__]\n  } else 0:{}\n  3:(1) app __x1__ = (SameValueNonNumeric x y)\n  3:return [! __x1__]\n}"
  }, {
    "code": ["        1. If Type(_x_) is different from Type(_y_), return *false*.", "        1. If Type(_x_) is Number or BigInt, then", "          1. Return ! Type(_x_)::sameValueZero(_x_, _y_).", "        1. Return ! SameValueNonNumeric(_x_, _y_)."],
    "head": {
      "name": "SameValueZero",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-samevaluezero",
    "rawBody": "{\n  0:if (! (= (typeof x) (typeof y))) return false else 0:{}\n  1:if (|| (= (typeof x) Number) (= (typeof x) BigInt)) {\n    2:(0) app __x0__ = (PRIMITIVE[(typeof x)][\"sameValueZero\"] x y)\n    2:return [! __x0__]\n  } else 0:{}\n  3:(1) app __x1__ = (SameValueNonNumeric x y)\n  3:return [! __x1__]\n}"
  }, {
    "code": ["        1. Assert: Type(_x_) is not Number or BigInt.", "        1. Assert: Type(_x_) is the same as Type(_y_).", "        1. If Type(_x_) is Undefined, return *true*.", "        1. If Type(_x_) is Null, return *true*.", "        1. If Type(_x_) is String, then", "          1. If _x_ and _y_ are exactly the same sequence of code units (same length and same code units at corresponding indices), return *true*; otherwise, return *false*.", "        1. If Type(_x_) is Boolean, then", "          1. If _x_ and _y_ are both *true* or both *false*, return *true*; otherwise, return *false*.", "        1. If Type(_x_) is Symbol, then", "          1. If _x_ and _y_ are both the same Symbol value, return *true*; otherwise, return *false*.", "        1. If _x_ and _y_ are the same Object value, return *true*. Otherwise, return *false*."],
    "head": {
      "name": "SameValueNonNumeric",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-samevaluenonnumeric",
    "rawBody": "{\n  0:assert (! (|| (= (typeof x) Number) (= (typeof x) BigInt)))\n  1:assert (= (typeof x) (typeof y))\n  2:if (= (typeof x) Undefined) return true else 0:{}\n  3:if (= (typeof x) Null) return true else 0:{}\n  4:if (= (typeof x) String) return (= x y) else 0:{}\n  6:if (= (typeof x) Boolean) if (|| (&& (= x true) (= y true)) (&& (= x false) (= y false))) return true else return false else 0:{}\n  8:if (= (typeof x) Symbol) if (= x y) return true else return false else 0:{}\n  10:if (= x y) return true else return false\n}"
  }, {
    "code": ["        1. If the _LeftFirst_ flag is *true*, then", "          1. Let _px_ be ? ToPrimitive(_x_, ~number~).", "          1. Let _py_ be ? ToPrimitive(_y_, ~number~).", "        1. Else,", "          1. NOTE: The order of evaluation needs to be reversed to preserve left to right evaluation.", "          1. Let _py_ be ? ToPrimitive(_y_, ~number~).", "          1. Let _px_ be ? ToPrimitive(_x_, ~number~).", "        1. [id=\"step-arc-string-check\"] If Type(_px_) is String and Type(_py_) is String, then", "          1. If IsStringPrefix(_py_, _px_) is *true*, return *false*.", "          1. If IsStringPrefix(_px_, _py_) is *true*, return *true*.", "          1. Let _k_ be the smallest non-negative integer such that the code unit at index _k_ within _px_ is different from the code unit at index _k_ within _py_. (There must be such a _k_, for neither String is a prefix of the other.)", "          1. Let _m_ be the integer that is the numeric value of the code unit at index _k_ within _px_.", "          1. Let _n_ be the integer that is the numeric value of the code unit at index _k_ within _py_.", "          1. If _m_ < _n_, return *true*. Otherwise, return *false*.", "        1. Else,", "          1. If Type(_px_) is BigInt and Type(_py_) is String, then", "            1. Let _ny_ be ! StringToBigInt(_py_).", "            1. If _ny_ is *NaN*, return *undefined*.", "            1. Return BigInt::lessThan(_px_, _ny_).", "          1. If Type(_px_) is String and Type(_py_) is BigInt, then", "            1. Let _nx_ be ! StringToBigInt(_px_).", "            1. If _nx_ is *NaN*, return *undefined*.", "            1. Return BigInt::lessThan(_nx_, _py_).", "          1. NOTE: Because _px_ and _py_ are primitive values, evaluation order is not important.", "          1. Let _nx_ be ! ToNumeric(_px_).", "          1. Let _ny_ be ! ToNumeric(_py_).", "          1. If Type(_nx_) is the same as Type(_ny_), return Type(_nx_)::lessThan(_nx_, _ny_).", "          1. Assert: Type(_nx_) is BigInt and Type(_ny_) is Number, or Type(_nx_) is Number and Type(_ny_) is BigInt.", "          1. If _nx_ or _ny_ is *NaN*, return *undefined*.", "          1. If _nx_ is *-∞*<sub>𝔽</sub> or _ny_ is *+∞*<sub>𝔽</sub>, return *true*.", "          1. If _nx_ is *+∞*<sub>𝔽</sub> or _ny_ is *-∞*<sub>𝔽</sub>, return *false*.", "          1. If ℝ(_nx_) < ℝ(_ny_), return *true*; otherwise return *false*."],
    "head": {
      "name": "AbstractRelationalComparison",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }, {
        "kind": "Optional",
        "name": "LeftFirst"
      }]
    },
    "ids": "sec-abstract-relational-comparison",
    "rawBody": "{\n  3:if (= LeftFirst true) {\n    1:(0) app __x0__ = (ToPrimitive x CONST_number)\n    1:let px = [? __x0__]\n    2:(1) app __x1__ = (ToPrimitive y CONST_number)\n    2:let py = [? __x1__]\n  } else {\n    5:(2) app __x2__ = (ToPrimitive y CONST_number)\n    5:let py = [? __x2__]\n    6:(3) app __x3__ = (ToPrimitive x CONST_number)\n    6:let px = [? __x3__]\n  }\n  14:if (&& (= (typeof px) String) (= (typeof py) String)) {\n    8:(4) app __x4__ = (IsStringPrefix py px)\n    8:if (= __x4__ true) return false else 23:{}\n    9:(5) app __x5__ = (IsStringPrefix px py)\n    9:if (= __x5__ true) return true else 23:{}\n    10:(0) ??? \"Let id:{k} be the smallest non - negative integer such that the code unit at index id:{k} within id:{px} is different from the code unit at index id:{k} within id:{py} . ( There must be such a id:{k} , for neither String is a prefix of the other . )\"\n    11:(1) ??? \"Let id:{m} be the integer that is the numeric value of the code unit at index id:{k} within id:{px} .\"\n    12:(2) ??? \"Let id:{n} be the integer that is the numeric value of the code unit at index id:{k} within id:{py} .\"\n    13:if (< m n) return true else return false\n  } else {\n    15:if (&& (= (typeof px) BigInt) (= (typeof py) String)) {\n      16:(6) app __x6__ = (StringToBigInt py)\n      16:let ny = [! __x6__]\n      17:if (= ny NaN) return undefined else 23:{}\n      18:(7) app __x7__ = (PRIMITIVE[BigInt][\"lessThan\"] px ny)\n      18:return __x7__\n    } else 23:{}\n    19:if (&& (= (typeof px) String) (= (typeof py) BigInt)) {\n      20:(8) app __x8__ = (StringToBigInt px)\n      20:let nx = [! __x8__]\n      21:if (= nx NaN) return undefined else 23:{}\n      22:(9) app __x9__ = (PRIMITIVE[BigInt][\"lessThan\"] nx py)\n      22:return __x9__\n    } else 23:{}\n    24:(10) app __x10__ = (ToNumeric px)\n    24:let nx = [! __x10__]\n    25:(11) app __x11__ = (ToNumeric py)\n    25:let ny = [! __x11__]\n    26:if (= (typeof nx) (typeof ny)) {\n      (12) app __x12__ = (PRIMITIVE[(typeof nx)][\"lessThan\"] nx ny)\n      return __x12__\n    } else 23:{}\n    27:assert (|| (&& (= (typeof nx) BigInt) (= (typeof ny) Number)) (&& (= (typeof nx) Number) (= (typeof ny) BigInt)))\n    28:if (|| (= nx NaN) (= ny NaN)) return undefined else 23:{}\n    29:if (|| (= nx -Infinity) (= ny Infinity)) return true else 23:{}\n    30:if (|| (= nx Infinity) (= ny -Infinity)) return false else 23:{}\n    31:if (< nx ny) return true else return false\n  }\n}"
  }, {
    "code": ["        1. If Type(_x_) is the same as Type(_y_), then", "          1. Return the result of performing Strict Equality Comparison _x_ === _y_.", "        1. If _x_ is *null* and _y_ is *undefined*, return *true*.", "        1. If _x_ is *undefined* and _y_ is *null*, return *true*.", "        1. [id=\"step-abstract-equality-comparison-web-compat-insertion-point\"] NOTE: This step is replaced in section <emu-xref href=\"#sec-IsHTMLDDA-internal-slot-aec\"></emu-xref>.", "        1. If Type(_x_) is Number and Type(_y_) is String, return the result of the comparison _x_ == ! ToNumber(_y_).", "        1. If Type(_x_) is String and Type(_y_) is Number, return the result of the comparison ! ToNumber(_x_) == _y_.", "        1. If Type(_x_) is BigInt and Type(_y_) is String, then", "          1. Let _n_ be ! StringToBigInt(_y_).", "          1. If _n_ is *NaN*, return *false*.", "          1. Return the result of the comparison _x_ == _n_.", "        1. If Type(_x_) is String and Type(_y_) is BigInt, return the result of the comparison _y_ == _x_.", "        1. If Type(_x_) is Boolean, return the result of the comparison ! ToNumber(_x_) == _y_.", "        1. If Type(_y_) is Boolean, return the result of the comparison _x_ == ! ToNumber(_y_).", "        1. If Type(_x_) is either String, Number, BigInt, or Symbol and Type(_y_) is Object, return the result of the comparison _x_ == ? ToPrimitive(_y_).", "        1. If Type(_x_) is Object and Type(_y_) is either String, Number, BigInt, or Symbol, return the result of the comparison ? ToPrimitive(_x_) == _y_.", "        1. If Type(_x_) is BigInt and Type(_y_) is Number, or if Type(_x_) is Number and Type(_y_) is BigInt, then", "          1. If _x_ or _y_ are any of *NaN*, *+∞*<sub>𝔽</sub>, or *-∞*<sub>𝔽</sub>, return *false*.", "          1. If ℝ(_x_) = ℝ(_y_), return *true*; otherwise return *false*.", "        1. Return *false*."],
    "head": {
      "name": "AbstractEqualityComparison",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-abstract-equality-comparison",
    "rawBody": "{\n  0:if (= (typeof x) (typeof y)) {\n    1:(0) app __x0__ = (StrictEqualityComparison x y)\n    1:return __x0__\n  } else 4:{}\n  2:if (&& (= x null) (= y undefined)) return true else 4:{}\n  3:if (&& (= x undefined) (= y null)) return true else 4:{}\n  5:if (&& (= (typeof x) Number) (= (typeof y) String)) {\n    (1) app __x1__ = (ToNumber y)\n    (2) app __x2__ = (AbstractEqualityComparison x [! __x1__])\n    return __x2__\n  } else 4:{}\n  6:if (&& (= (typeof x) String) (= (typeof y) Number)) {\n    (3) app __x3__ = (ToNumber x)\n    (4) app __x4__ = (AbstractEqualityComparison [! __x3__] y)\n    return __x4__\n  } else 4:{}\n  7:if (&& (= (typeof x) BigInt) (= (typeof y) String)) {\n    8:(5) app __x5__ = (StringToBigInt y)\n    8:let n = [! __x5__]\n    9:if (= n NaN) return false else 4:{}\n    10:(6) app __x6__ = (AbstractEqualityComparison x n)\n    10:return __x6__\n  } else 4:{}\n  11:if (&& (= (typeof x) String) (= (typeof y) BigInt)) {\n    (7) app __x7__ = (AbstractEqualityComparison y x)\n    return __x7__\n  } else 4:{}\n  12:if (= (typeof x) Boolean) {\n    (8) app __x8__ = (ToNumber x)\n    (9) app __x9__ = (AbstractEqualityComparison [! __x8__] y)\n    return __x9__\n  } else 4:{}\n  13:if (= (typeof y) Boolean) {\n    (10) app __x10__ = (ToNumber y)\n    (11) app __x11__ = (AbstractEqualityComparison x [! __x10__])\n    return __x11__\n  } else 4:{}\n  14:if (&& (|| (|| (|| (= (typeof x) String) (= (typeof x) Number)) (= (typeof x) BigInt)) (= (typeof x) Symbol)) (= (typeof y) Object)) {\n    (12) app __x12__ = (ToPrimitive y)\n    (13) app __x13__ = (AbstractEqualityComparison x [? __x12__])\n    return __x13__\n  } else 4:{}\n  15:if (&& (= (typeof x) Object) (|| (|| (|| (= (typeof y) String) (= (typeof y) Number)) (= (typeof y) BigInt)) (= (typeof y) Symbol))) {\n    (14) app __x14__ = (ToPrimitive x)\n    (15) app __x15__ = (AbstractEqualityComparison [? __x14__] y)\n    return __x15__\n  } else 4:{}\n  16:if (|| (&& (= (typeof x) BigInt) (= (typeof y) Number)) (&& (= (typeof x) Number) (= (typeof y) BigInt))) {\n    17:if (|| (|| (|| (= x NaN) (= x Infinity)) (= x -Infinity)) (|| (|| (= y NaN) (= y Infinity)) (= y -Infinity))) return false else 4:{}\n    18:if (== x y) return true else return false\n  } else 4:{}\n  19:return false\n}"
  }, {
    "code": ["        1. If Type(_x_) is different from Type(_y_), return *false*.", "        1. If Type(_x_) is Number or BigInt, then", "          1. Return ! Type(_x_)::equal(_x_, _y_).", "        1. Return ! SameValueNonNumeric(_x_, _y_)."],
    "head": {
      "name": "StrictEqualityComparison",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-strict-equality-comparison",
    "rawBody": "{\n  0:if (! (= (typeof x) (typeof y))) return false else 4:{}\n  1:if (|| (= (typeof x) Number) (= (typeof x) BigInt)) {\n    2:(0) app __x0__ = (PRIMITIVE[(typeof x)][\"equal\"] x y)\n    2:return [! __x0__]\n  } else 4:{}\n  3:(1) app __x1__ = (SameValueNonNumeric x y)\n  3:return [! __x1__]\n}"
  }, {
    "code": ["        1. Assert: _internalSlotsList_ is a List of internal slot names.", "        1. Let _obj_ be a newly created object with an internal slot for each name in _internalSlotsList_.", "        1. Set _obj_'s essential internal methods to the default ordinary object definitions specified in <emu-xref href=\"#sec-ordinary-object-internal-methods-and-internal-slots\"></emu-xref>.", "        1. Assert: If the caller will not be overriding both _obj_'s [[GetPrototypeOf]] and [[SetPrototypeOf]] essential internal methods, then _internalSlotsList_ contains [[Prototype]].", "        1. Assert: If the caller will not be overriding all of _obj_'s [[SetPrototypeOf]], [[IsExtensible]], and [[PreventExtensions]] essential internal methods, then _internalSlotsList_ contains [[Extensible]].", "        1. If _internalSlotsList_ contains [[Extensible]], set _obj_.[[Extensible]] to *true*.", "        1. Return _obj_."],
    "head": {
      "name": "MakeBasicObject",
      "params": [{
        "kind": "Normal",
        "name": "internalSlotsList"
      }]
    },
    "ids": "sec-makebasicobject",
    "rawBody": "{\n  1:let obj = (0) (new OrdinaryObject())\n  1:let __x0__ = internalSlotsList\n  1:let __x1__ = 0i\n  1:while (< __x1__ __x0__[\"length\"]) {\n    let __x2__ = __x0__[__x1__]\n    obj[__x2__] = undefined\n    __x1__ = (+ __x1__ 1i)\n  }\n  5:if (contains internalSlotsList \"Extensible\") obj[\"Extensible\"] = true else 4:{}\n  6:return obj\n}"
  }, {
    "code": ["        1. Assert: Type(_O_) is Object.", "        1. Assert: IsPropertyKey(_P_) is *true*.", "        1. Return ? _O_.[[Get]](_P_, _O_)."],
    "head": {
      "name": "Get",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "P"
      }]
    },
    "ids": "sec-get-o-p",
    "rawBody": "{\n  0:assert (= (typeof O) Object)\n  1:(0) app __x0__ = (IsPropertyKey P)\n  1:assert (= __x0__ true)\n  2:(1) app __x1__ = (O[\"Get\"] O P O)\n  2:return [? __x1__]\n}"
  }, {
    "code": ["        1. Assert: IsPropertyKey(_P_) is *true*.", "        1. Let _O_ be ? ToObject(_V_).", "        1. Return ? _O_.[[Get]](_P_, _V_)."],
    "head": {
      "name": "GetV",
      "params": [{
        "kind": "Normal",
        "name": "V"
      }, {
        "kind": "Normal",
        "name": "P"
      }]
    },
    "ids": "sec-getv",
    "rawBody": "{\n  0:(0) app __x0__ = (IsPropertyKey P)\n  0:assert (= __x0__ true)\n  1:(1) app __x1__ = (ToObject V)\n  1:let O = [? __x1__]\n  2:(2) app __x2__ = (O[\"Get\"] O P V)\n  2:return [? __x2__]\n}"
  }, {
    "code": ["        1. Assert: Type(_O_) is Object.", "        1. Assert: IsPropertyKey(_P_) is *true*.", "        1. Assert: Type(_Throw_) is Boolean.", "        1. Let _success_ be ? _O_.[[Set]](_P_, _V_, _O_).", "        1. If _success_ is *false* and _Throw_ is *true*, throw a *TypeError* exception.", "        1. Return _success_."],
    "head": {
      "name": "Set",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Normal",
        "name": "V"
      }, {
        "kind": "Normal",
        "name": "Throw"
      }]
    },
    "ids": "sec-set-o-p-v-throw",
    "rawBody": "{\n  0:assert (= (typeof O) Object)\n  1:(0) app __x0__ = (IsPropertyKey P)\n  1:assert (= __x0__ true)\n  2:assert (= (typeof Throw) Boolean)\n  3:(1) app __x1__ = (O[\"Set\"] O P V O)\n  3:let success = [? __x1__]\n  4:if (&& (= success false) (= Throw true)) (0) throw TypeError else 4:{}\n  5:return success\n}"
  }, {
    "code": ["        1. Assert: Type(_O_) is Object.", "        1. Assert: IsPropertyKey(_P_) is *true*.", "        1. Let _newDesc_ be the PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true* }.", "        1. Return ? _O_.[[DefineOwnProperty]](_P_, _newDesc_)."],
    "head": {
      "name": "CreateDataProperty",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Normal",
        "name": "V"
      }]
    },
    "ids": "sec-createdataproperty",
    "rawBody": "{\n  0:assert (= (typeof O) Object)\n  1:(0) app __x0__ = (IsPropertyKey P)\n  1:assert (= __x0__ true)\n  2:let newDesc = (0) (new PropertyDescriptor(\"Value\" -> V, \"Writable\" -> true, \"Enumerable\" -> true, \"Configurable\" -> true))\n  3:(1) app __x1__ = (O[\"DefineOwnProperty\"] O P newDesc)\n  3:return [? __x1__]\n}"
  }, {
    "code": ["        1. Assert: Type(_O_) is Object.", "        1. Assert: IsPropertyKey(_P_) is *true*.", "        1. Let _newDesc_ be the PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.", "        1. Return ? _O_.[[DefineOwnProperty]](_P_, _newDesc_)."],
    "head": {
      "name": "CreateMethodProperty",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Normal",
        "name": "V"
      }]
    },
    "ids": "sec-createmethodproperty",
    "rawBody": "{\n  0:assert (= (typeof O) Object)\n  1:(0) app __x0__ = (IsPropertyKey P)\n  1:assert (= __x0__ true)\n  2:let newDesc = (0) (new PropertyDescriptor(\"Value\" -> V, \"Writable\" -> true, \"Enumerable\" -> false, \"Configurable\" -> true))\n  3:(1) app __x1__ = (O[\"DefineOwnProperty\"] O P newDesc)\n  3:return [? __x1__]\n}"
  }, {
    "code": ["        1. Assert: Type(_O_) is Object.", "        1. Assert: IsPropertyKey(_P_) is *true*.", "        1. Let _success_ be ? CreateDataProperty(_O_, _P_, _V_).", "        1. If _success_ is *false*, throw a *TypeError* exception.", "        1. Return _success_."],
    "head": {
      "name": "CreateDataPropertyOrThrow",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Normal",
        "name": "V"
      }]
    },
    "ids": "sec-createdatapropertyorthrow",
    "rawBody": "{\n  0:assert (= (typeof O) Object)\n  1:(0) app __x0__ = (IsPropertyKey P)\n  1:assert (= __x0__ true)\n  2:(1) app __x1__ = (CreateDataProperty O P V)\n  2:let success = [? __x1__]\n  3:if (= success false) (0) throw TypeError else 4:{}\n  4:return success\n}"
  }, {
    "code": ["        1. Assert: Type(_O_) is Object.", "        1. Assert: IsPropertyKey(_P_) is *true*.", "        1. Let _success_ be ? _O_.[[DefineOwnProperty]](_P_, _desc_).", "        1. If _success_ is *false*, throw a *TypeError* exception.", "        1. Return _success_."],
    "head": {
      "name": "DefinePropertyOrThrow",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Normal",
        "name": "desc"
      }]
    },
    "ids": "sec-definepropertyorthrow",
    "rawBody": "{\n  0:assert (= (typeof O) Object)\n  1:(0) app __x0__ = (IsPropertyKey P)\n  1:assert (= __x0__ true)\n  2:(1) app __x1__ = (O[\"DefineOwnProperty\"] O P desc)\n  2:let success = [? __x1__]\n  3:if (= success false) (0) throw TypeError else 4:{}\n  4:return success\n}"
  }, {
    "code": ["        1. Assert: Type(_O_) is Object.", "        1. Assert: IsPropertyKey(_P_) is *true*.", "        1. Let _success_ be ? _O_.[[Delete]](_P_).", "        1. If _success_ is *false*, throw a *TypeError* exception.", "        1. Return _success_."],
    "head": {
      "name": "DeletePropertyOrThrow",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "P"
      }]
    },
    "ids": "sec-deletepropertyorthrow",
    "rawBody": "{\n  0:assert (= (typeof O) Object)\n  1:(0) app __x0__ = (IsPropertyKey P)\n  1:assert (= __x0__ true)\n  2:(1) app __x1__ = (O[\"Delete\"] O P)\n  2:let success = [? __x1__]\n  3:if (= success false) (0) throw TypeError else 4:{}\n  4:return success\n}"
  }, {
    "code": ["        1. Assert: IsPropertyKey(_P_) is *true*.", "        1. Let _func_ be ? GetV(_V_, _P_).", "        1. If _func_ is either *undefined* or *null*, return *undefined*.", "        1. If IsCallable(_func_) is *false*, throw a *TypeError* exception.", "        1. Return _func_."],
    "head": {
      "name": "GetMethod",
      "params": [{
        "kind": "Normal",
        "name": "V"
      }, {
        "kind": "Normal",
        "name": "P"
      }]
    },
    "ids": "sec-getmethod",
    "rawBody": "{\n  0:(0) app __x0__ = (IsPropertyKey P)\n  0:assert (= __x0__ true)\n  1:(1) app __x1__ = (GetV V P)\n  1:let func = [? __x1__]\n  2:if (|| (= func undefined) (= func null)) return undefined else 4:{}\n  3:(2) app __x2__ = (IsCallable func)\n  3:if (= __x2__ false) (0) throw TypeError else 4:{}\n  4:return func\n}"
  }, {
    "code": ["        1. Assert: Type(_O_) is Object.", "        1. Assert: IsPropertyKey(_P_) is *true*.", "        1. Return ? _O_.[[HasProperty]](_P_)."],
    "head": {
      "name": "HasProperty",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "P"
      }]
    },
    "ids": "sec-hasproperty",
    "rawBody": "{\n  0:assert (= (typeof O) Object)\n  1:(0) app __x0__ = (IsPropertyKey P)\n  1:assert (= __x0__ true)\n  2:(1) app __x1__ = (O[\"HasProperty\"] O P)\n  2:return [? __x1__]\n}"
  }, {
    "code": ["        1. Assert: Type(_O_) is Object.", "        1. Assert: IsPropertyKey(_P_) is *true*.", "        1. Let _desc_ be ? _O_.[[GetOwnProperty]](_P_).", "        1. If _desc_ is *undefined*, return *false*.", "        1. Return *true*."],
    "head": {
      "name": "HasOwnProperty",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "P"
      }]
    },
    "ids": "sec-hasownproperty",
    "rawBody": "{\n  0:assert (= (typeof O) Object)\n  1:(0) app __x0__ = (IsPropertyKey P)\n  1:assert (= __x0__ true)\n  2:(1) app __x1__ = (O[\"GetOwnProperty\"] O P)\n  2:let desc = [? __x1__]\n  3:if (= desc undefined) return false else 4:{}\n  4:return true\n}"
  }, {
    "code": ["        1. If _argumentsList_ is not present, set _argumentsList_ to a new empty List.", "        1. If IsCallable(_F_) is *false*, throw a *TypeError* exception.", "        1. Return ? _F_.[[Call]](_V_, _argumentsList_)."],
    "head": {
      "name": "Call",
      "params": [{
        "kind": "Normal",
        "name": "F"
      }, {
        "kind": "Normal",
        "name": "V"
      }, {
        "kind": "Optional",
        "name": "argumentsList"
      }]
    },
    "ids": "sec-call",
    "rawBody": "{\n  0:if (= argumentsList absent) argumentsList = (0) (new []) else 4:{}\n  1:(0) app __x0__ = (IsCallable F)\n  1:if (= __x0__ false) (1) throw TypeError else 4:{}\n  2:(1) app __x1__ = (F[\"Call\"] F V argumentsList)\n  2:return [? __x1__]\n}"
  }, {
    "code": ["        1. If _newTarget_ is not present, set _newTarget_ to _F_.", "        1. If _argumentsList_ is not present, set _argumentsList_ to a new empty List.", "        1. Assert: IsConstructor(_F_) is *true*.", "        1. Assert: IsConstructor(_newTarget_) is *true*.", "        1. Return ? _F_.[[Construct]](_argumentsList_, _newTarget_)."],
    "head": {
      "name": "Construct",
      "params": [{
        "kind": "Normal",
        "name": "F"
      }, {
        "kind": "Optional",
        "name": "argumentsList"
      }, {
        "kind": "Optional",
        "name": "newTarget"
      }]
    },
    "ids": "sec-construct",
    "rawBody": "{\n  0:if (= newTarget absent) newTarget = F else 4:{}\n  1:if (= argumentsList absent) argumentsList = (0) (new []) else 4:{}\n  2:(0) app __x0__ = (IsConstructor F)\n  2:assert (= __x0__ true)\n  3:(1) app __x1__ = (IsConstructor newTarget)\n  3:assert (= __x1__ true)\n  4:(2) app __x2__ = (F[\"Construct\"] F argumentsList newTarget)\n  4:return [? __x2__]\n}"
  }, {
    "code": ["        1. Assert: Type(_O_) is Object.", "        1. Assert: _level_ is either ~sealed~ or ~frozen~.", "        1. Let _status_ be ? _O_.[[PreventExtensions]]().", "        1. If _status_ is *false*, return *false*.", "        1. Let _keys_ be ? _O_.[[OwnPropertyKeys]]().", "        1. If _level_ is ~sealed~, then", "          1. For each element _k_ of _keys_, do", "            1. Perform ? DefinePropertyOrThrow(_O_, _k_, PropertyDescriptor { [[Configurable]]: *false* }).", "        1. Else,", "          1. Assert: _level_ is ~frozen~.", "          1. For each element _k_ of _keys_, do", "            1. Let _currentDesc_ be ? _O_.[[GetOwnProperty]](_k_).", "            1. If _currentDesc_ is not *undefined*, then", "              1. If IsAccessorDescriptor(_currentDesc_) is *true*, then", "                1. Let _desc_ be the PropertyDescriptor { [[Configurable]]: *false* }.", "              1. Else,", "                1. Let _desc_ be the PropertyDescriptor { [[Configurable]]: *false*, [[Writable]]: *false* }.", "              1. Perform ? DefinePropertyOrThrow(_O_, _k_, _desc_).", "        1. Return *true*."],
    "head": {
      "name": "SetIntegrityLevel",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "level"
      }]
    },
    "ids": "sec-setintegritylevel",
    "rawBody": "{\n  0:assert (= (typeof O) Object)\n  1:assert (|| (= level CONST_sealed) (= level CONST_frozen))\n  2:(0) app __x0__ = (O[\"PreventExtensions\"] O)\n  2:let status = [? __x0__]\n  3:if (= status false) return false else 4:{}\n  4:(1) app __x1__ = (O[\"OwnPropertyKeys\"] O)\n  4:let keys = [? __x1__]\n  8:if (= level CONST_sealed) {\n    6:let __x2__ = keys\n    6:let __x3__ = 0i\n    6:while (< __x3__ __x2__[\"length\"]) {\n      let k = __x2__[__x3__]\n      7:(2) app __x4__ = (DefinePropertyOrThrow O k (0) (new PropertyDescriptor(\"Configurable\" -> false)))\n      7:[? __x4__]\n      __x3__ = (+ __x3__ 1i)\n    }\n  } else {\n    9:assert (= level CONST_frozen)\n    10:let __x5__ = keys\n    10:let __x6__ = 0i\n    10:while (< __x6__ __x5__[\"length\"]) {\n      let k = __x5__[__x6__]\n      11:(3) app __x7__ = (O[\"GetOwnProperty\"] O k)\n      11:let currentDesc = [? __x7__]\n      12:if (! (= currentDesc undefined)) {\n        15:(4) app __x8__ = (IsAccessorDescriptor currentDesc)\n        15:if (= __x8__ true) let desc = (1) (new PropertyDescriptor(\"Configurable\" -> false)) else let desc = (2) (new PropertyDescriptor(\"Configurable\" -> false, \"Writable\" -> false))\n        17:(5) app __x9__ = (DefinePropertyOrThrow O k desc)\n        17:[? __x9__]\n      } else 4:{}\n      __x6__ = (+ __x6__ 1i)\n    }\n  }\n  18:return true\n}"
  }, {
    "code": ["        1. Assert: Type(_O_) is Object.", "        1. Assert: _level_ is either ~sealed~ or ~frozen~.", "        1. Let _extensible_ be ? IsExtensible(_O_).", "        1. If _extensible_ is *true*, return *false*.", "        1. NOTE: If the object is extensible, none of its properties are examined.", "        1. Let _keys_ be ? _O_.[[OwnPropertyKeys]]().", "        1. For each element _k_ of _keys_, do", "          1. Let _currentDesc_ be ? _O_.[[GetOwnProperty]](_k_).", "          1. If _currentDesc_ is not *undefined*, then", "            1. If _currentDesc_.[[Configurable]] is *true*, return *false*.", "            1. If _level_ is ~frozen~ and IsDataDescriptor(_currentDesc_) is *true*, then", "              1. If _currentDesc_.[[Writable]] is *true*, return *false*.", "        1. Return *true*."],
    "head": {
      "name": "TestIntegrityLevel",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "level"
      }]
    },
    "ids": "sec-testintegritylevel",
    "rawBody": "{\n  0:assert (= (typeof O) Object)\n  1:assert (|| (= level CONST_sealed) (= level CONST_frozen))\n  2:(0) app __x0__ = (IsExtensible O)\n  2:let extensible = [? __x0__]\n  3:if (= extensible true) return false else 4:{}\n  5:(1) app __x1__ = (O[\"OwnPropertyKeys\"] O)\n  5:let keys = [? __x1__]\n  6:let __x2__ = keys\n  6:let __x3__ = 0i\n  6:while (< __x3__ __x2__[\"length\"]) {\n    let k = __x2__[__x3__]\n    7:(2) app __x4__ = (O[\"GetOwnProperty\"] O k)\n    7:let currentDesc = [? __x4__]\n    8:if (! (= currentDesc undefined)) {\n      9:if (= currentDesc[\"Configurable\"] true) return false else 4:{}\n      10:let __x5__ = true\n      10:__x5__ = (= level CONST_frozen)\n      10:if __x5__ {\n        (3) app __x6__ = (IsDataDescriptor currentDesc)\n        __x5__ = (= __x6__ true)\n      } else 4:{}\n      10:if __x5__ if (= currentDesc[\"Writable\"] true) return false else 4:{} else 4:{}\n    } else 4:{}\n    __x3__ = (+ __x3__ 1i)\n  }\n  12:return true\n}"
  }, {
    "code": ["        1. Assert: _elements_ is a List whose elements are all ECMAScript language values.", "        1. Let _array_ be ! ArrayCreate(0).", "        1. Let _n_ be 0.", "        1. For each element _e_ of _elements_, do", "          1. Perform ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_n_)), _e_).", "          1. Set _n_ to _n_ + 1.", "        1. Return _array_."],
    "head": {
      "name": "CreateArrayFromList",
      "params": [{
        "kind": "Normal",
        "name": "elements"
      }]
    },
    "ids": "sec-createarrayfromlist",
    "rawBody": "{\n  1:(0) app __x0__ = (ArrayCreate 0i)\n  1:let array = [! __x0__]\n  2:let n = 0i\n  3:let __x1__ = elements\n  3:let __x2__ = 0i\n  3:while (< __x2__ __x1__[\"length\"]) {\n    let e = __x1__[__x2__]\n    4:(1) app __x3__ = (ToString n)\n    4:(2) app __x4__ = (CreateDataPropertyOrThrow array [! __x3__] e)\n    4:[! __x4__]\n    5:n = (+ n 1i)\n    __x2__ = (+ __x2__ 1i)\n  }\n  6:return array\n}"
  }, {
    "code": ["        1. Assert: Type(_obj_) is Object.", "        1. Return ℝ(? ToLength(? Get(_obj_, *\"length\"*)))."],
    "head": {
      "name": "LengthOfArrayLike",
      "params": [{
        "kind": "Normal",
        "name": "obj"
      }]
    },
    "ids": "sec-lengthofarraylike",
    "rawBody": "{\n  0:assert (= (typeof obj) Object)\n  1:(0) app __x0__ = (Get obj \"length\")\n  1:(1) app __x1__ = (ToLength [? __x0__])\n  1:return [? __x1__]\n}"
  }, {
    "code": ["        1. If _elementTypes_ is not present, set _elementTypes_ to « Undefined, Null, Boolean, String, Symbol, Number, BigInt, Object ».", "        1. If Type(_obj_) is not Object, throw a *TypeError* exception.", "        1. Let _len_ be ? LengthOfArrayLike(_obj_).", "        1. Let _list_ be a new empty List.", "        1. Let _index_ be 0.", "        1. Repeat, while _index_ < _len_,", "          1. Let _indexName_ be ! ToString(𝔽(_index_)).", "          1. Let _next_ be ? Get(_obj_, _indexName_).", "          1. If Type(_next_) is not an element of _elementTypes_, throw a *TypeError* exception.", "          1. Append _next_ as the last element of _list_.", "          1. Set _index_ to _index_ + 1.", "        1. Return _list_."],
    "head": {
      "name": "CreateListFromArrayLike",
      "params": [{
        "kind": "Normal",
        "name": "obj"
      }, {
        "kind": "Optional",
        "name": "elementTypes"
      }]
    },
    "ids": "sec-createlistfromarraylike",
    "rawBody": "{\n  0:if (= elementTypes absent) elementTypes = (0) (new [Undefined, Null, Boolean, String, Symbol, Number, BigInt, Object]) else 0:{}\n  1:if (! (= (typeof obj) Object)) (1) throw TypeError else 0:{}\n  2:(0) app __x0__ = (LengthOfArrayLike obj)\n  2:let len = [? __x0__]\n  3:let list = (2) (new [])\n  4:let index = 0i\n  5:while (< index len) {\n    6:(1) app __x1__ = (ToString index)\n    6:let indexName = [! __x1__]\n    7:(2) app __x2__ = (Get obj indexName)\n    7:let next = [? __x2__]\n    8:if (! (contains elementTypes (typeof next))) (3) throw TypeError else 0:{}\n    9:append next -> list\n    10:index = (+ index 1i)\n  }\n  11:return list\n}"
  }, {
    "code": ["        1. Assert: IsPropertyKey(_P_) is *true*.", "        1. If _argumentsList_ is not present, set _argumentsList_ to a new empty List.", "        1. Let _func_ be ? GetV(_V_, _P_).", "        1. Return ? Call(_func_, _V_, _argumentsList_)."],
    "head": {
      "name": "Invoke",
      "params": [{
        "kind": "Normal",
        "name": "V"
      }, {
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Optional",
        "name": "argumentsList"
      }]
    },
    "ids": "sec-invoke",
    "rawBody": "{\n  0:(0) app __x0__ = (IsPropertyKey P)\n  0:assert (= __x0__ true)\n  1:if (= argumentsList absent) argumentsList = (0) (new []) else 0:{}\n  2:(1) app __x1__ = (GetV V P)\n  2:let func = [? __x1__]\n  3:(2) app __x2__ = (Call func V argumentsList)\n  3:return [? __x2__]\n}"
  }, {
    "code": ["        1. If IsCallable(_C_) is *false*, return *false*.", "        1. If _C_ has a [[BoundTargetFunction]] internal slot, then", "          1. Let _BC_ be _C_.[[BoundTargetFunction]].", "          1. Return ? InstanceofOperator(_O_, _BC_).", "        1. If Type(_O_) is not Object, return *false*.", "        1. Let _P_ be ? Get(_C_, *\"prototype\"*).", "        1. If Type(_P_) is not Object, throw a *TypeError* exception.", "        1. Repeat,", "          1. Set _O_ to ? _O_.[[GetPrototypeOf]]().", "          1. If _O_ is *null*, return *false*.", "          1. If SameValue(_P_, _O_) is *true*, return *true*."],
    "head": {
      "name": "OrdinaryHasInstance",
      "params": [{
        "kind": "Normal",
        "name": "C"
      }, {
        "kind": "Normal",
        "name": "O"
      }]
    },
    "ids": "sec-ordinaryhasinstance",
    "rawBody": "{\n  0:(0) app __x0__ = (IsCallable C)\n  0:if (= __x0__ false) return false else 0:{}\n  1:if (! (= C[\"BoundTargetFunction\"] absent)) {\n    2:let BC = C[\"BoundTargetFunction\"]\n    3:(1) app __x1__ = (InstanceofOperator O BC)\n    3:return [? __x1__]\n  } else 0:{}\n  4:if (! (= (typeof O) Object)) return false else 0:{}\n  5:(2) app __x2__ = (Get C \"prototype\")\n  5:let P = [? __x2__]\n  6:if (! (= (typeof P) Object)) (0) throw TypeError else 0:{}\n  7:while true {\n    8:(3) app __x3__ = (O[\"GetPrototypeOf\"] O)\n    8:O = [? __x3__]\n    9:if (= O null) return false else 0:{}\n    10:(4) app __x4__ = (SameValue P O)\n    10:if (= __x4__ true) return true else 0:{}\n  }\n}"
  }, {
    "code": ["        1. Assert: Type(_O_) is Object.", "        1. Let _C_ be ? Get(_O_, *\"constructor\"*).", "        1. If _C_ is *undefined*, return _defaultConstructor_.", "        1. If Type(_C_) is not Object, throw a *TypeError* exception.", "        1. Let _S_ be ? Get(_C_, @@species).", "        1. If _S_ is either *undefined* or *null*, return _defaultConstructor_.", "        1. If IsConstructor(_S_) is *true*, return _S_.", "        1. Throw a *TypeError* exception."],
    "head": {
      "name": "SpeciesConstructor",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "defaultConstructor"
      }]
    },
    "ids": "sec-speciesconstructor",
    "rawBody": "{\n  0:assert (= (typeof O) Object)\n  1:(0) app __x0__ = (Get O \"constructor\")\n  1:let C = [? __x0__]\n  2:if (= C undefined) return defaultConstructor else 0:{}\n  3:if (! (= (typeof C) Object)) (0) throw TypeError else 0:{}\n  4:(1) app __x1__ = (Get C SYMBOL_species)\n  4:let S = [? __x1__]\n  5:if (|| (= S undefined) (= S null)) return defaultConstructor else 0:{}\n  6:(2) app __x2__ = (IsConstructor S)\n  6:if (= __x2__ true) return S else 0:{}\n  7:(1) throw TypeError\n}"
  }, {
    "code": ["        1. Assert: Type(_O_) is Object.", "        1. Let _ownKeys_ be ? _O_.[[OwnPropertyKeys]]().", "        1. Let _properties_ be a new empty List.", "        1. For each element _key_ of _ownKeys_, do", "          1. If Type(_key_) is String, then", "            1. Let _desc_ be ? _O_.[[GetOwnProperty]](_key_).", "            1. If _desc_ is not *undefined* and _desc_.[[Enumerable]] is *true*, then", "              1. If _kind_ is ~key~, append _key_ to _properties_.", "              1. Else,", "                1. Let _value_ be ? Get(_O_, _key_).", "                1. If _kind_ is ~value~, append _value_ to _properties_.", "                1. Else,", "                  1. Assert: _kind_ is ~key+value~.", "                  1. Let _entry_ be ! CreateArrayFromList(« _key_, _value_ »).", "                  1. Append _entry_ to _properties_.", "        1. Return _properties_."],
    "head": {
      "name": "EnumerableOwnPropertyNames",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "kind"
      }]
    },
    "ids": "sec-enumerableownpropertynames",
    "rawBody": "{\n  0:assert (= (typeof O) Object)\n  1:(0) app __x0__ = (O[\"OwnPropertyKeys\"] O)\n  1:let ownKeys = [? __x0__]\n  2:let properties = (0) (new [])\n  3:let __x1__ = ownKeys\n  3:let __x2__ = 0i\n  3:while (< __x2__ __x1__[\"length\"]) {\n    let key = __x1__[__x2__]\n    4:if (= (typeof key) String) {\n      5:(1) app __x3__ = (O[\"GetOwnProperty\"] O key)\n      5:let desc = [? __x3__]\n      6:if (&& (! (= desc undefined)) (= desc[\"Enumerable\"] true)) if (= kind CONST_key) append key -> properties else {\n        9:(2) app __x4__ = (Get O key)\n        9:let value = [? __x4__]\n        11:if (= kind CONST_value) append value -> properties else {\n          12:assert (= kind CONST_keyPLUSvalue)\n          13:(3) app __x5__ = (CreateArrayFromList (1) (new [key, value]))\n          13:let entry = [! __x5__]\n          14:append entry -> properties\n        }\n      } else 0:{}\n    } else 0:{}\n    __x2__ = (+ __x2__ 1i)\n  }\n  15:return properties\n}"
  }, {
    "code": ["        1. Assert: ! IsCallable(_obj_) is *true*.", "        1. If _obj_ has a [[Realm]] internal slot, then", "          1. Return _obj_.[[Realm]].", "        1. If _obj_ is a bound function exotic object, then", "          1. Let _target_ be _obj_.[[BoundTargetFunction]].", "          1. Return ? GetFunctionRealm(_target_).", "        1. If _obj_ is a Proxy exotic object, then", "          1. If _obj_.[[ProxyHandler]] is *null*, throw a *TypeError* exception.", "          1. Let _proxyTarget_ be _obj_.[[ProxyTarget]].", "          1. Return ? GetFunctionRealm(_proxyTarget_).", "        1. [id=\"step-getfunctionrealm-default-return\"] Return the current Realm Record."],
    "head": {
      "name": "GetFunctionRealm",
      "params": [{
        "kind": "Normal",
        "name": "obj"
      }]
    },
    "ids": "sec-getfunctionrealm",
    "rawBody": "{\n  0:(0) app __x0__ = (IsCallable obj)\n  0:assert (= [! __x0__] true)\n  1:if (! (= obj[\"Realm\"] absent)) return obj[\"Realm\"] else 0:{}\n  3:if (0) (is-instance-of obj BoundFunctionExoticObject) {\n    4:let target = obj[\"BoundTargetFunction\"]\n    5:(1) app __x1__ = (GetFunctionRealm target)\n    5:return [? __x1__]\n  } else 0:{}\n  6:if (1) (is-instance-of obj ProxyExoticObject) {\n    7:if (= obj[\"ProxyHandler\"] null) (2) throw TypeError else 0:{}\n    8:let proxyTarget = obj[\"ProxyTarget\"]\n    9:(2) app __x2__ = (GetFunctionRealm proxyTarget)\n    9:return [? __x2__]\n  } else 0:{}\n  10:return REALM\n}"
  }, {
    "code": ["        1. Assert: Type(_target_) is Object.", "        1. Assert: _excludedItems_ is a List of property keys.", "        1. If _source_ is *undefined* or *null*, return _target_.", "        1. Let _from_ be ! ToObject(_source_).", "        1. Let _keys_ be ? _from_.[[OwnPropertyKeys]]().", "        1. For each element _nextKey_ of _keys_, do", "          1. Let _excluded_ be *false*.", "          1. For each element _e_ of _excludedItems_, do", "            1. If SameValue(_e_, _nextKey_) is *true*, then", "              1. Set _excluded_ to *true*.", "          1. If _excluded_ is *false*, then", "            1. Let _desc_ be ? _from_.[[GetOwnProperty]](_nextKey_).", "            1. If _desc_ is not *undefined* and _desc_.[[Enumerable]] is *true*, then", "              1. Let _propValue_ be ? Get(_from_, _nextKey_).", "              1. Perform ! CreateDataPropertyOrThrow(_target_, _nextKey_, _propValue_).", "        1. Return _target_."],
    "head": {
      "name": "CopyDataProperties",
      "params": [{
        "kind": "Normal",
        "name": "target"
      }, {
        "kind": "Normal",
        "name": "source"
      }, {
        "kind": "Normal",
        "name": "excludedItems"
      }]
    },
    "ids": "sec-copydataproperties",
    "rawBody": "{\n  0:assert (= (typeof target) Object)\n  2:if (|| (= source undefined) (= source null)) return target else 1:{}\n  3:(0) app __x0__ = (ToObject source)\n  3:let from = [! __x0__]\n  4:(1) app __x1__ = (from[\"OwnPropertyKeys\"] from)\n  4:let keys = [? __x1__]\n  5:let __x2__ = keys\n  5:let __x3__ = 0i\n  5:while (< __x3__ __x2__[\"length\"]) {\n    let nextKey = __x2__[__x3__]\n    6:let excluded = false\n    7:let __x4__ = excludedItems\n    7:let __x5__ = 0i\n    7:while (< __x5__ __x4__[\"length\"]) {\n      let e = __x4__[__x5__]\n      8:(2) app __x6__ = (SameValue e nextKey)\n      8:if (= __x6__ true) excluded = true else 1:{}\n      __x5__ = (+ __x5__ 1i)\n    }\n    10:if (= excluded false) {\n      11:(3) app __x7__ = (from[\"GetOwnProperty\"] from nextKey)\n      11:let desc = [? __x7__]\n      12:if (&& (! (= desc undefined)) (= desc[\"Enumerable\"] true)) {\n        13:(4) app __x8__ = (Get from nextKey)\n        13:let propValue = [? __x8__]\n        14:(5) app __x9__ = (CreateDataPropertyOrThrow target nextKey propValue)\n        14:[! __x9__]\n      } else 1:{}\n    } else 1:{}\n    __x3__ = (+ __x3__ 1i)\n  }\n  15:return target\n}"
  }, {
    "code": ["        1. If _hint_ is not present, set _hint_ to ~sync~.", "        1. Assert: _hint_ is either ~sync~ or ~async~.", "        1. If _method_ is not present, then", "          1. If _hint_ is ~async~, then", "            1. Set _method_ to ? GetMethod(_obj_, @@asyncIterator).", "            1. If _method_ is *undefined*, then", "              1. Let _syncMethod_ be ? GetMethod(_obj_, @@iterator).", "              1. Let _syncIteratorRecord_ be ? GetIterator(_obj_, ~sync~, _syncMethod_).", "              1. Return ! CreateAsyncFromSyncIterator(_syncIteratorRecord_).", "          1. Otherwise, set _method_ to ? GetMethod(_obj_, @@iterator).", "        1. Let _iterator_ be ? Call(_method_, _obj_).", "        1. If Type(_iterator_) is not Object, throw a *TypeError* exception.", "        1. Let _nextMethod_ be ? GetV(_iterator_, *\"next\"*).", "        1. Let _iteratorRecord_ be the Record { [[Iterator]]: _iterator_, [[NextMethod]]: _nextMethod_, [[Done]]: *false* }.", "        1. Return _iteratorRecord_."],
    "head": {
      "name": "GetIterator",
      "params": [{
        "kind": "Normal",
        "name": "obj"
      }, {
        "kind": "Optional",
        "name": "hint"
      }, {
        "kind": "Optional",
        "name": "method"
      }]
    },
    "ids": "sec-getiterator",
    "rawBody": "{\n  0:if (= hint absent) hint = CONST_sync else 1:{}\n  1:assert (|| (= hint CONST_sync) (= hint CONST_async))\n  2:if (= method absent) if (= hint CONST_async) {\n    4:(0) app __x0__ = (GetMethod obj SYMBOL_asyncIterator)\n    4:method = [? __x0__]\n    5:if (= method undefined) {\n      6:(1) app __x1__ = (GetMethod obj SYMBOL_iterator)\n      6:let syncMethod = [? __x1__]\n      7:(2) app __x2__ = (GetIterator obj CONST_sync syncMethod)\n      7:let syncIteratorRecord = [? __x2__]\n      8:(3) app __x3__ = (CreateAsyncFromSyncIterator syncIteratorRecord)\n      8:return [! __x3__]\n    } else 1:{}\n  } else {\n    (4) app __x4__ = (GetMethod obj SYMBOL_iterator)\n    method = [? __x4__]\n  } else 1:{}\n  10:(5) app __x5__ = (Call method obj)\n  10:let iterator = [? __x5__]\n  11:if (! (= (typeof iterator) Object)) (0) throw TypeError else 1:{}\n  12:(6) app __x6__ = (GetV iterator \"next\")\n  12:let nextMethod = [? __x6__]\n  13:let iteratorRecord = (1) (new Record(\"Iterator\" -> iterator, \"NextMethod\" -> nextMethod, \"Done\" -> false))\n  14:return iteratorRecord\n}"
  }, {
    "code": ["        1. If _value_ is not present, then", "          1. Let _result_ be ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]]).", "        1. Else,", "          1. Let _result_ be ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]], « _value_ »).", "        1. If Type(_result_) is not Object, throw a *TypeError* exception.", "        1. Return _result_."],
    "head": {
      "name": "IteratorNext",
      "params": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }, {
        "kind": "Optional",
        "name": "value"
      }]
    },
    "ids": "sec-iteratornext",
    "rawBody": "{\n  2:if (= value absent) {\n    1:(0) app __x0__ = (Call iteratorRecord[\"NextMethod\"] iteratorRecord[\"Iterator\"])\n    1:let result = [? __x0__]\n  } else {\n    3:(1) app __x1__ = (Call iteratorRecord[\"NextMethod\"] iteratorRecord[\"Iterator\"] (0) (new [value]))\n    3:let result = [? __x1__]\n  }\n  4:if (! (= (typeof result) Object)) (1) throw TypeError else 1:{}\n  5:return result\n}"
  }, {
    "code": ["        1. Assert: Type(_iterResult_) is Object.", "        1. Return ! ToBoolean(? Get(_iterResult_, *\"done\"*))."],
    "head": {
      "name": "IteratorComplete",
      "params": [{
        "kind": "Normal",
        "name": "iterResult"
      }]
    },
    "ids": "sec-iteratorcomplete",
    "rawBody": "{\n  0:assert (= (typeof iterResult) Object)\n  1:(0) app __x0__ = (Get iterResult \"done\")\n  1:(1) app __x1__ = (ToBoolean [? __x0__])\n  1:return [! __x1__]\n}"
  }, {
    "code": ["        1. Assert: Type(_iterResult_) is Object.", "        1. Return ? Get(_iterResult_, *\"value\"*)."],
    "head": {
      "name": "IteratorValue",
      "params": [{
        "kind": "Normal",
        "name": "iterResult"
      }]
    },
    "ids": "sec-iteratorvalue",
    "rawBody": "{\n  0:assert (= (typeof iterResult) Object)\n  1:(0) app __x0__ = (Get iterResult \"value\")\n  1:return [? __x0__]\n}"
  }, {
    "code": ["        1. Let _result_ be ? IteratorNext(_iteratorRecord_).", "        1. Let _done_ be ? IteratorComplete(_result_).", "        1. If _done_ is *true*, return *false*.", "        1. Return _result_."],
    "head": {
      "name": "IteratorStep",
      "params": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }]
    },
    "ids": "sec-iteratorstep",
    "rawBody": "{\n  0:(0) app __x0__ = (IteratorNext iteratorRecord)\n  0:let result = [? __x0__]\n  1:(1) app __x1__ = (IteratorComplete result)\n  1:let done = [? __x1__]\n  2:if (= done true) return false else 1:{}\n  3:return result\n}"
  }, {
    "code": ["        1. Assert: Type(_iteratorRecord_.[[Iterator]]) is Object.", "        1. Assert: _completion_ is a Completion Record.", "        1. Let _iterator_ be _iteratorRecord_.[[Iterator]].", "        1. Let _innerResult_ be GetMethod(_iterator_, *\"return\"*).", "        1. If _innerResult_.[[Type]] is ~normal~, then", "          1. Let _return_ be _innerResult_.[[Value]].", "          1. If _return_ is *undefined*, return Completion(_completion_).", "          1. Set _innerResult_ to Call(_return_, _iterator_).", "        1. If _completion_.[[Type]] is ~throw~, return Completion(_completion_).", "        1. If _innerResult_.[[Type]] is ~throw~, return Completion(_innerResult_).", "        1. If Type(_innerResult_.[[Value]]) is not Object, throw a *TypeError* exception.", "        1. Return Completion(_completion_)."],
    "head": {
      "name": "IteratorClose",
      "params": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }, {
        "kind": "Normal",
        "name": "completion"
      }]
    },
    "ids": "sec-iteratorclose",
    "rawBody": "{\n  0:assert (= (typeof iteratorRecord[\"Iterator\"]) Object)\n  1:assert (is-completion completion)\n  2:let iterator = iteratorRecord[\"Iterator\"]\n  3:(0) app __x0__ = (GetMethod iterator \"return\")\n  3:let innerResult = __x0__\n  4:if (= innerResult[\"Type\"] CONST_normal) {\n    5:let return = innerResult[\"Value\"]\n    6:if (= return undefined) return completion else 1:{}\n    7:(1) app __x1__ = (Call return iterator)\n    7:innerResult = __x1__\n  } else 1:{}\n  8:if (= completion[\"Type\"] CONST_throw) return completion else 1:{}\n  9:if (= innerResult[\"Type\"] CONST_throw) return innerResult else 1:{}\n  10:if (! (= (typeof innerResult[\"Value\"]) Object)) (0) throw TypeError else 1:{}\n  11:return completion\n}"
  }, {
    "code": ["        1. Assert: Type(_iteratorRecord_.[[Iterator]]) is Object.", "        1. Assert: _completion_ is a Completion Record.", "        1. Let _iterator_ be _iteratorRecord_.[[Iterator]].", "        1. Let _innerResult_ be GetMethod(_iterator_, *\"return\"*).", "        1. If _innerResult_.[[Type]] is ~normal~, then", "          1. Let _return_ be _innerResult_.[[Value]].", "          1. If _return_ is *undefined*, return Completion(_completion_).", "          1. Set _innerResult_ to Call(_return_, _iterator_).", "          1. If _innerResult_.[[Type]] is ~normal~, set _innerResult_ to Await(_innerResult_.[[Value]]).", "        1. If _completion_.[[Type]] is ~throw~, return Completion(_completion_).", "        1. If _innerResult_.[[Type]] is ~throw~, return Completion(_innerResult_).", "        1. If Type(_innerResult_.[[Value]]) is not Object, throw a *TypeError* exception.", "        1. Return Completion(_completion_)."],
    "head": {
      "name": "AsyncIteratorClose",
      "params": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }, {
        "kind": "Normal",
        "name": "completion"
      }]
    },
    "ids": "sec-asynciteratorclose",
    "rawBody": "{\n  0:assert (= (typeof iteratorRecord[\"Iterator\"]) Object)\n  1:assert (is-completion completion)\n  2:let iterator = iteratorRecord[\"Iterator\"]\n  3:(0) app __x0__ = (GetMethod iterator \"return\")\n  3:let innerResult = __x0__\n  4:if (= innerResult[\"Type\"] CONST_normal) {\n    5:let return = innerResult[\"Value\"]\n    6:if (= return undefined) return completion else 1:{}\n    7:(1) app __x1__ = (Call return iterator)\n    7:innerResult = __x1__\n    8:if (= innerResult[\"Type\"] CONST_normal) {\n      (2) app __x2__ = (Await innerResult[\"Value\"])\n      innerResult = __x2__\n    } else 1:{}\n  } else 1:{}\n  9:if (= completion[\"Type\"] CONST_throw) return completion else 1:{}\n  10:if (= innerResult[\"Type\"] CONST_throw) return innerResult else 1:{}\n  11:if (! (= (typeof innerResult[\"Value\"]) Object)) (0) throw TypeError else 1:{}\n  12:return completion\n}"
  }, {
    "code": ["        1. Assert: Type(_done_) is Boolean.", "        1. Let _obj_ be ! OrdinaryObjectCreate(%Object.prototype%).", "        1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"value\"*, _value_).", "        1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"done\"*, _done_).", "        1. Return _obj_."],
    "head": {
      "name": "CreateIterResultObject",
      "params": [{
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "done"
      }]
    },
    "ids": "sec-createiterresultobject",
    "rawBody": "{\n  0:assert (= (typeof done) Boolean)\n  1:(0) app __x0__ = (OrdinaryObjectCreate INTRINSIC_Object_prototype)\n  1:let obj = [! __x0__]\n  2:(1) app __x1__ = (CreateDataPropertyOrThrow obj \"value\" value)\n  2:[! __x1__]\n  3:(2) app __x2__ = (CreateDataPropertyOrThrow obj \"done\" done)\n  3:[! __x2__]\n  4:return obj\n}"
  }, {
    "code": ["        1. Let _closure_ be a new Abstract Closure with no parameters that captures _list_ and performs the following steps when called:", "          1. For each element _E_ of _list_, do", "            1. Perform ? Yield(_E_).", "          1. Return *undefined*.", "        1. Let _iterator_ be ! CreateIteratorFromClosure(_closure_, ~empty~, %IteratorPrototype%).", "        1. Return Record { [[Iterator]]: _iterator_, [[NextMethod]]: %GeneratorFunction.prototype.prototype.next%, [[Done]]: *false* }."],
    "head": {
      "name": "CreateListIteratorRecord",
      "params": [{
        "kind": "Normal",
        "name": "list"
      }]
    },
    "ids": "sec-createlistiteratorRecord",
    "rawBody": "{\n  0:(0) ??? \"Let id:{closure} be a new Abstract Closure with no parameters that captures id:{list} and performs the following steps when called : in:{} out:{}\"\n  4:(0) app __x0__ = (CreateIteratorFromClosure closure CONST_empty INTRINSIC_IteratorPrototype)\n  4:let iterator = [! __x0__]\n  5:return (1) (new Record(\"Iterator\" -> iterator, \"NextMethod\" -> INTRINSIC_GeneratorFunction_prototype_prototype_next, \"Done\" -> false))\n}"
  }, {
    "code": ["        1. If _method_ is present, then", "          1. Let _iteratorRecord_ be ? GetIterator(_items_, ~sync~, _method_).", "        1. Else,", "          1. Let _iteratorRecord_ be ? GetIterator(_items_, ~sync~).", "        1. Let _values_ be a new empty List.", "        1. Let _next_ be *true*.", "        1. Repeat, while _next_ is not *false*,", "          1. Set _next_ to ? IteratorStep(_iteratorRecord_).", "          1. If _next_ is not *false*, then", "            1. Let _nextValue_ be ? IteratorValue(_next_).", "            1. Append _nextValue_ to the end of the List _values_.", "        1. Return _values_."],
    "head": {
      "name": "IterableToList",
      "params": [{
        "kind": "Normal",
        "name": "items"
      }, {
        "kind": "Optional",
        "name": "method"
      }]
    },
    "ids": "sec-iterabletolist",
    "rawBody": "{\n  2:if (! (= method absent)) {\n    1:(0) app __x0__ = (GetIterator items CONST_sync method)\n    1:let iteratorRecord = [? __x0__]\n  } else {\n    3:(1) app __x1__ = (GetIterator items CONST_sync)\n    3:let iteratorRecord = [? __x1__]\n  }\n  4:let values = (0) (new [])\n  5:let next = true\n  6:while (! (= next false)) {\n    7:(2) app __x2__ = (IteratorStep iteratorRecord)\n    7:next = [? __x2__]\n    8:if (! (= next false)) {\n      9:(3) app __x3__ = (IteratorValue next)\n      9:let nextValue = [? __x3__]\n      10:append nextValue -> values\n    } else 1:{}\n  }\n  11:return values\n}"
  }, {
    "code": ["        1. Return a List whose sole element is the StringValue of |Identifier|."],
    "head": {
      "idx": 0,
      "methodName": "BoundNames",
      "prod": "BindingIdentifier",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Identifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (Identifier \"StringValue\")\n  0:return (0) (new [__x0__])\n}"
  }, {
    "code": ["        1. Return a List whose sole element is *\"yield\"*."],
    "head": {
      "idx": 1,
      "methodName": "BoundNames",
      "prod": "BindingIdentifier",
      "rhs": {
        "tokens": [{
          "term": "yield"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "return (0) (new [\"yield\"])"
  }, {
    "code": ["        1. Return a List whose sole element is *\"await\"*."],
    "head": {
      "idx": 2,
      "methodName": "BoundNames",
      "prod": "BindingIdentifier",
      "rhs": {
        "tokens": [{
          "term": "await"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "return (0) (new [\"await\"])"
  }, {
    "code": ["        1. Return the BoundNames of |BindingList|."],
    "head": {
      "idx": 0,
      "methodName": "BoundNames",
      "prod": "LexicalDeclaration",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LetOrConst",
          "optional": false
        }, {
          "args": [],
          "name": "BindingList",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingList \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Let _names_ be the BoundNames of |BindingList|.", "        1. Append to _names_ the elements of the BoundNames of |LexicalBinding|.", "        1. Return _names_."],
    "head": {
      "idx": 1,
      "methodName": "BoundNames",
      "prod": "BindingList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "LexicalBinding",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingList \"BoundNames\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (LexicalBinding \"BoundNames\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["        1. Return the BoundNames of |BindingIdentifier|."],
    "head": {
      "idx": 0,
      "methodName": "BoundNames",
      "prod": "LexicalBinding",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "args": [],
          "name": "Initializer",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingIdentifier \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the BoundNames of |BindingPattern|."],
    "head": {
      "idx": 1,
      "methodName": "BoundNames",
      "prod": "LexicalBinding",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingPattern",
          "optional": false
        }, {
          "args": [],
          "name": "Initializer",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingPattern \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Let _names_ be BoundNames of |VariableDeclarationList|.", "        1. Append to _names_ the elements of BoundNames of |VariableDeclaration|.", "        1. Return _names_."],
    "head": {
      "idx": 1,
      "methodName": "BoundNames",
      "prod": "VariableDeclarationList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "VariableDeclarationList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "VariableDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (VariableDeclarationList \"BoundNames\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (VariableDeclaration \"BoundNames\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["        1. Return the BoundNames of |BindingIdentifier|."],
    "head": {
      "idx": 0,
      "methodName": "BoundNames",
      "prod": "VariableDeclaration",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "args": [],
          "name": "Initializer",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingIdentifier \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the BoundNames of |BindingPattern|."],
    "head": {
      "idx": 1,
      "methodName": "BoundNames",
      "prod": "VariableDeclaration",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingPattern",
          "optional": false
        }, {
          "args": [],
          "name": "Initializer",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingPattern \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "BoundNames",
      "prod": "ObjectBindingPattern",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Let _names_ be BoundNames of |BindingPropertyList|.", "        1. Append to _names_ the elements of BoundNames of |BindingRestProperty|.", "        1. Return _names_."],
    "head": {
      "idx": 3,
      "methodName": "BoundNames",
      "prod": "ObjectBindingPattern",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "BindingPropertyList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "BindingRestProperty",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingPropertyList \"BoundNames\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (BindingRestProperty \"BoundNames\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "BoundNames",
      "prod": "ArrayBindingPattern",
      "rhs": {
        "tokens": [{
          "term": "["
        }, {
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "term": "]"
        }]
      },
      "subIdx": 2,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return the BoundNames of |BindingRestElement|."],
    "head": {
      "idx": 0,
      "methodName": "BoundNames",
      "prod": "ArrayBindingPattern",
      "rhs": {
        "tokens": [{
          "term": "["
        }, {
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "args": [],
          "name": "BindingRestElement",
          "optional": false
        }, {
          "term": "]"
        }]
      },
      "subIdx": 3,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingRestElement \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the BoundNames of |BindingElementList|."],
    "head": {
      "idx": 2,
      "methodName": "BoundNames",
      "prod": "ArrayBindingPattern",
      "rhs": {
        "tokens": [{
          "term": "["
        }, {
          "args": [],
          "name": "BindingElementList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "term": "]"
        }]
      },
      "subIdx": 2,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingElementList \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Let _names_ be BoundNames of |BindingElementList|.", "        1. Append to _names_ the elements of BoundNames of |BindingRestElement|.", "        1. Return _names_."],
    "head": {
      "idx": 2,
      "methodName": "BoundNames",
      "prod": "ArrayBindingPattern",
      "rhs": {
        "tokens": [{
          "term": "["
        }, {
          "args": [],
          "name": "BindingElementList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "args": [],
          "name": "BindingRestElement",
          "optional": false
        }, {
          "term": "]"
        }]
      },
      "subIdx": 3,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingElementList \"BoundNames\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (BindingRestElement \"BoundNames\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["        1. Let _names_ be BoundNames of |BindingPropertyList|.", "        1. Append to _names_ the elements of BoundNames of |BindingProperty|.", "        1. Return _names_."],
    "head": {
      "idx": 1,
      "methodName": "BoundNames",
      "prod": "BindingPropertyList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingPropertyList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "BindingProperty",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingPropertyList \"BoundNames\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (BindingProperty \"BoundNames\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["        1. Let _names_ be BoundNames of |BindingElementList|.", "        1. Append to _names_ the elements of BoundNames of |BindingElisionElement|.", "        1. Return _names_."],
    "head": {
      "idx": 1,
      "methodName": "BoundNames",
      "prod": "BindingElementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingElementList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "BindingElisionElement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingElementList \"BoundNames\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (BindingElisionElement \"BoundNames\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["        1. Return BoundNames of |BindingElement|."],
    "head": {
      "idx": 0,
      "methodName": "BoundNames",
      "prod": "BindingElisionElement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "args": [],
          "name": "BindingElement",
          "optional": false
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingElement \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the BoundNames of |BindingElement|."],
    "head": {
      "idx": 1,
      "methodName": "BoundNames",
      "prod": "BindingProperty",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "BindingElement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingElement \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the BoundNames of |BindingIdentifier|."],
    "head": {
      "idx": 0,
      "methodName": "BoundNames",
      "prod": "SingleNameBinding",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "args": [],
          "name": "Initializer",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingIdentifier \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the BoundNames of |BindingPattern|."],
    "head": {
      "idx": 1,
      "methodName": "BoundNames",
      "prod": "BindingElement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingPattern",
          "optional": false
        }, {
          "args": [],
          "name": "Initializer",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingPattern \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the BoundNames of |ForBinding|."],
    "head": {
      "idx": 0,
      "methodName": "BoundNames",
      "prod": "ForDeclaration",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LetOrConst",
          "optional": false
        }, {
          "args": [],
          "name": "ForBinding",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (ForBinding \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the BoundNames of |BindingIdentifier|."],
    "head": {
      "idx": 0,
      "methodName": "BoundNames",
      "prod": "FunctionDeclaration",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingIdentifier \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return « *\"\\*default\\*\"* »."],
    "head": {
      "idx": 1,
      "methodName": "BoundNames",
      "prod": "FunctionDeclaration",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "return (0) (new [\"*default*\"])"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "BoundNames",
      "prod": "FormalParameters",
      "rhs": {
        "tokens": [{
          "empty": null
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Let _names_ be BoundNames of |FormalParameterList|.", "        1. Append to _names_ the BoundNames of |FunctionRestParameter|.", "        1. Return _names_."],
    "head": {
      "idx": 4,
      "methodName": "BoundNames",
      "prod": "FormalParameters",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FormalParameterList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "FunctionRestParameter",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (FormalParameterList \"BoundNames\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (FunctionRestParameter \"BoundNames\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["        1. Let _names_ be BoundNames of |FormalParameterList|.", "        1. Append to _names_ the BoundNames of |FormalParameter|.", "        1. Return _names_."],
    "head": {
      "idx": 1,
      "methodName": "BoundNames",
      "prod": "FormalParameterList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FormalParameterList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "FormalParameter",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (FormalParameterList \"BoundNames\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (FormalParameter \"BoundNames\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["        1. Let _formals_ be CoveredFormalsList of |CoverParenthesizedExpressionAndArrowParameterList|.", "        1. Return the BoundNames of _formals_."],
    "head": {
      "idx": 1,
      "methodName": "BoundNames",
      "prod": "ArrowParameters",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CoverParenthesizedExpressionAndArrowParameterList",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (CoverParenthesizedExpressionAndArrowParameterList \"CoveredFormalsList\")\n  0:let formals = __x0__\n  1:(1) access __x1__ = (formals \"BoundNames\")\n  1:return __x1__\n}"
  }, {
    "code": ["        1. Return the BoundNames of |BindingIdentifier|."],
    "head": {
      "idx": 0,
      "methodName": "BoundNames",
      "prod": "GeneratorDeclaration",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingIdentifier \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return « *\"\\*default\\*\"* »."],
    "head": {
      "idx": 1,
      "methodName": "BoundNames",
      "prod": "GeneratorDeclaration",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "*"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "return (0) (new [\"*default*\"])"
  }, {
    "code": ["        1. Return the BoundNames of |BindingIdentifier|."],
    "head": {
      "idx": 0,
      "methodName": "BoundNames",
      "prod": "AsyncGeneratorDeclaration",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingIdentifier \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return « *\"\\*default\\*\"* »."],
    "head": {
      "idx": 1,
      "methodName": "BoundNames",
      "prod": "AsyncGeneratorDeclaration",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "*"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "return (0) (new [\"*default*\"])"
  }, {
    "code": ["        1. Return the BoundNames of |BindingIdentifier|."],
    "head": {
      "idx": 0,
      "methodName": "BoundNames",
      "prod": "ClassDeclaration",
      "rhs": {
        "tokens": [{
          "term": "class"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "args": [],
          "name": "ClassTail",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingIdentifier \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return « *\"\\*default\\*\"* »."],
    "head": {
      "idx": 1,
      "methodName": "BoundNames",
      "prod": "ClassDeclaration",
      "rhs": {
        "tokens": [{
          "term": "class"
        }, {
          "args": [],
          "name": "ClassTail",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "return (0) (new [\"*default*\"])"
  }, {
    "code": ["        1. Return the BoundNames of |BindingIdentifier|."],
    "head": {
      "idx": 0,
      "methodName": "BoundNames",
      "prod": "AsyncFunctionDeclaration",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingIdentifier \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return « *\"\\*default\\*\"* »."],
    "head": {
      "idx": 1,
      "methodName": "BoundNames",
      "prod": "AsyncFunctionDeclaration",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "return (0) (new [\"*default*\"])"
  }, {
    "code": ["        1. Let _head_ be CoveredAsyncArrowHead of |CoverCallExpressionAndAsyncArrowHead|.", "        1. Return the BoundNames of _head_."],
    "head": {
      "idx": 0,
      "methodName": "BoundNames",
      "prod": "CoverCallExpressionAndAsyncArrowHead",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "args": [],
          "name": "Arguments",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (CoverCallExpressionAndAsyncArrowHead \"CoveredAsyncArrowHead\")\n  0:let head = __x0__\n  1:(1) access __x1__ = (head \"BoundNames\")\n  1:return __x1__\n}"
  }, {
    "code": ["        1. Return the BoundNames of |ImportClause|."],
    "head": {
      "idx": 0,
      "methodName": "BoundNames",
      "prod": "ImportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "import"
        }, {
          "args": [],
          "name": "ImportClause",
          "optional": false
        }, {
          "args": [],
          "name": "FromClause",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (ImportClause \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 1,
      "methodName": "BoundNames",
      "prod": "ImportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "import"
        }, {
          "args": [],
          "name": "ModuleSpecifier",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Let _names_ be the BoundNames of |ImportedDefaultBinding|.", "        1. Append to _names_ the elements of the BoundNames of |NameSpaceImport|.", "        1. Return _names_."],
    "head": {
      "idx": 3,
      "methodName": "BoundNames",
      "prod": "ImportClause",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ImportedDefaultBinding",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "NameSpaceImport",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (ImportedDefaultBinding \"BoundNames\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (NameSpaceImport \"BoundNames\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["        1. Let _names_ be the BoundNames of |ImportedDefaultBinding|.", "        1. Append to _names_ the elements of the BoundNames of |NamedImports|.", "        1. Return _names_."],
    "head": {
      "idx": 4,
      "methodName": "BoundNames",
      "prod": "ImportClause",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ImportedDefaultBinding",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "NamedImports",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (ImportedDefaultBinding \"BoundNames\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (NamedImports \"BoundNames\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "BoundNames",
      "prod": "NamedImports",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Let _names_ be the BoundNames of |ImportsList|.", "        1. Append to _names_ the elements of the BoundNames of |ImportSpecifier|.", "        1. Return _names_."],
    "head": {
      "idx": 1,
      "methodName": "BoundNames",
      "prod": "ImportsList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ImportsList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "ImportSpecifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (ImportsList \"BoundNames\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (ImportSpecifier \"BoundNames\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["        1. Return the BoundNames of |ImportedBinding|."],
    "head": {
      "idx": 1,
      "methodName": "BoundNames",
      "prod": "ImportSpecifier",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }, {
          "term": "as"
        }, {
          "args": [],
          "name": "ImportedBinding",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (ImportedBinding \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "BoundNames",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "ExportFromClause",
          "optional": false
        }, {
          "args": [],
          "name": "FromClause",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 1,
      "methodName": "BoundNames",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "NamedExports",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return the BoundNames of |VariableStatement|."],
    "head": {
      "idx": 2,
      "methodName": "BoundNames",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "VariableStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (VariableStatement \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the BoundNames of |Declaration|."],
    "head": {
      "idx": 3,
      "methodName": "BoundNames",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "Declaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (Declaration \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Let _declarationNames_ be the BoundNames of |HoistableDeclaration|.", "        1. If _declarationNames_ does not include the element *\"\\*default\\*\"*, append *\"\\*default\\*\"* to _declarationNames_.", "        1. Return _declarationNames_."],
    "head": {
      "idx": 4,
      "methodName": "BoundNames",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "term": "default"
        }, {
          "args": [],
          "name": "HoistableDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (HoistableDeclaration \"BoundNames\")\n  0:let declarationNames = __x0__\n  1:if (contains declarationNames \"*default*\") {} else append \"*default*\" -> declarationNames\n  2:return declarationNames\n}"
  }, {
    "code": ["        1. Let _declarationNames_ be the BoundNames of |ClassDeclaration|.", "        1. If _declarationNames_ does not include the element *\"\\*default\\*\"*, append *\"\\*default\\*\"* to _declarationNames_.", "        1. Return _declarationNames_."],
    "head": {
      "idx": 5,
      "methodName": "BoundNames",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "term": "default"
        }, {
          "args": [],
          "name": "ClassDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "{\n  0:(0) access __x0__ = (ClassDeclaration \"BoundNames\")\n  0:let declarationNames = __x0__\n  1:if (contains declarationNames \"*default*\") {} else append \"*default*\" -> declarationNames\n  2:return declarationNames\n}"
  }, {
    "code": ["        1. Return « *\"\\*default\\*\"* »."],
    "head": {
      "idx": 6,
      "methodName": "BoundNames",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "term": "default"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-boundnames",
    "rawBody": "return (0) (new [\"*default*\"])"
  }, {
    "code": ["        1. Return |FunctionDeclaration|."],
    "head": {
      "idx": 0,
      "methodName": "DeclarationPart",
      "prod": "HoistableDeclaration",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FunctionDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-declarationpart",
    "rawBody": "return FunctionDeclaration"
  }, {
    "code": ["        1. Return |GeneratorDeclaration|."],
    "head": {
      "idx": 1,
      "methodName": "DeclarationPart",
      "prod": "HoistableDeclaration",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "GeneratorDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-declarationpart",
    "rawBody": "return GeneratorDeclaration"
  }, {
    "code": ["        1. Return |AsyncFunctionDeclaration|."],
    "head": {
      "idx": 2,
      "methodName": "DeclarationPart",
      "prod": "HoistableDeclaration",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AsyncFunctionDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-declarationpart",
    "rawBody": "return AsyncFunctionDeclaration"
  }, {
    "code": ["        1. Return |AsyncGeneratorDeclaration|."],
    "head": {
      "idx": 3,
      "methodName": "DeclarationPart",
      "prod": "HoistableDeclaration",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AsyncGeneratorDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-declarationpart",
    "rawBody": "return AsyncGeneratorDeclaration"
  }, {
    "code": ["        1. Return |ClassDeclaration|."],
    "head": {
      "idx": 1,
      "methodName": "DeclarationPart",
      "prod": "Declaration",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ClassDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-declarationpart",
    "rawBody": "return ClassDeclaration"
  }, {
    "code": ["        1. Return |LexicalDeclaration|."],
    "head": {
      "idx": 2,
      "methodName": "DeclarationPart",
      "prod": "Declaration",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LexicalDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-declarationpart",
    "rawBody": "return LexicalDeclaration"
  }, {
    "code": ["        1. Return IsConstantDeclaration of |LetOrConst|."],
    "head": {
      "idx": 0,
      "methodName": "IsConstantDeclaration",
      "prod": "LexicalDeclaration",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LetOrConst",
          "optional": false
        }, {
          "args": [],
          "name": "BindingList",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isconstantdeclaration",
    "rawBody": "{\n  0:(0) access __x0__ = (LetOrConst \"IsConstantDeclaration\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "IsConstantDeclaration",
      "prod": "LetOrConst",
      "rhs": {
        "tokens": [{
          "term": "let"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isconstantdeclaration",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *true*."],
    "head": {
      "idx": 1,
      "methodName": "IsConstantDeclaration",
      "prod": "LetOrConst",
      "rhs": {
        "tokens": [{
          "term": "const"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isconstantdeclaration",
    "rawBody": "return true"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "IsConstantDeclaration",
      "prod": "FunctionDeclaration",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isconstantdeclaration",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsConstantDeclaration",
      "prod": "FunctionDeclaration",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isconstantdeclaration",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "IsConstantDeclaration",
      "prod": "GeneratorDeclaration",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isconstantdeclaration",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsConstantDeclaration",
      "prod": "GeneratorDeclaration",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "*"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isconstantdeclaration",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "IsConstantDeclaration",
      "prod": "AsyncGeneratorDeclaration",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isconstantdeclaration",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsConstantDeclaration",
      "prod": "AsyncGeneratorDeclaration",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "*"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isconstantdeclaration",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "IsConstantDeclaration",
      "prod": "AsyncFunctionDeclaration",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isconstantdeclaration",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsConstantDeclaration",
      "prod": "AsyncFunctionDeclaration",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isconstantdeclaration",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "IsConstantDeclaration",
      "prod": "ClassDeclaration",
      "rhs": {
        "tokens": [{
          "term": "class"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "args": [],
          "name": "ClassTail",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isconstantdeclaration",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsConstantDeclaration",
      "prod": "ClassDeclaration",
      "rhs": {
        "tokens": [{
          "term": "class"
        }, {
          "args": [],
          "name": "ClassTail",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isconstantdeclaration",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "IsConstantDeclaration",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "ExportFromClause",
          "optional": false
        }, {
          "args": [],
          "name": "FromClause",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isconstantdeclaration",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsConstantDeclaration",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "NamedExports",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isconstantdeclaration",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 6,
      "methodName": "IsConstantDeclaration",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "term": "default"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isconstantdeclaration",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "LexicallyDeclaredNames",
      "prod": "Block",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallydeclarednames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Let _names_ be LexicallyDeclaredNames of |StatementList|.", "        1. Append to _names_ the elements of the LexicallyDeclaredNames of |StatementListItem|.", "        1. Return _names_."],
    "head": {
      "idx": 1,
      "methodName": "LexicallyDeclaredNames",
      "prod": "StatementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StatementList",
          "optional": false
        }, {
          "args": [],
          "name": "StatementListItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallydeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (StatementList \"LexicallyDeclaredNames\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (StatementListItem \"LexicallyDeclaredNames\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["        1. If |Statement| is <emu-grammar>Statement : LabelledStatement</emu-grammar> , return LexicallyDeclaredNames of |LabelledStatement|.", "        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "LexicallyDeclaredNames",
      "prod": "StatementListItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallydeclarednames",
    "rawBody": "{\n  0:if (0) (is-instance-of Statement Statement10) {\n    (0) access LabelledStatement = (Statement \"LabelledStatement\")\n    (1) access __x0__ = (LabelledStatement \"LexicallyDeclaredNames\")\n    return __x0__\n  } else 1:{}\n  1:return (1) (new [])\n}"
  }, {
    "code": ["        1. Return the BoundNames of |Declaration|."],
    "head": {
      "idx": 1,
      "methodName": "LexicallyDeclaredNames",
      "prod": "StatementListItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Declaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallydeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (Declaration \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "LexicallyDeclaredNames",
      "prod": "CaseBlock",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallydeclarednames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. If the first |CaseClauses| is present, let _names_ be the LexicallyDeclaredNames of the first |CaseClauses|.", "        1. Else, let _names_ be a new empty List.", "        1. Append to _names_ the elements of the LexicallyDeclaredNames of |DefaultClause|.", "        1. If the second |CaseClauses| is not present, return _names_.", "        1. Return the result of appending to _names_ the elements of the LexicallyDeclaredNames of the second |CaseClauses|."],
    "head": {
      "idx": 1,
      "methodName": "LexicallyDeclaredNames",
      "prod": "CaseBlock",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "CaseClauses",
          "optional": true
        }, {
          "args": [],
          "name": "DefaultClause",
          "optional": false
        }, {
          "args": [],
          "name": "CaseClauses",
          "optional": true
        }, {
          "term": "}"
        }]
      },
      "subIdx": 3,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallydeclarednames",
    "rawBody": "{\n  1:if (! (= CaseClauses0 absent)) {\n    (0) access __x0__ = (CaseClauses0 \"LexicallyDeclaredNames\")\n    let names = __x0__\n  } else let names = (0) (new [])\n  2:(1) access __x1__ = (DefaultClause \"LexicallyDeclaredNames\")\n  2:let __x2__ = __x1__\n  2:let __x3__ = 0i\n  2:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  3:if (= CaseClauses1 absent) return names else 1:{}\n  4:(1) ??? \"Return the result of appending to id:{names} the elements of the LexicallyDeclaredNames of the second nt:{CaseClauses} .\"\n}"
  }, {
    "code": ["        1. Let _names_ be LexicallyDeclaredNames of |CaseClauses|.", "        1. Append to _names_ the elements of the LexicallyDeclaredNames of |CaseClause|.", "        1. Return _names_."],
    "head": {
      "idx": 1,
      "methodName": "LexicallyDeclaredNames",
      "prod": "CaseClauses",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CaseClauses",
          "optional": false
        }, {
          "args": [],
          "name": "CaseClause",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallydeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (CaseClauses \"LexicallyDeclaredNames\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (CaseClause \"LexicallyDeclaredNames\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["        1. If the |StatementList| is present, return the LexicallyDeclaredNames of |StatementList|.", "        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "LexicallyDeclaredNames",
      "prod": "CaseClause",
      "rhs": {
        "tokens": [{
          "term": "case"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "StatementList",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallydeclarednames",
    "rawBody": "{\n  0:if (! (= StatementList absent)) {\n    (0) access __x0__ = (StatementList \"LexicallyDeclaredNames\")\n    return __x0__\n  } else 1:{}\n  1:return (0) (new [])\n}"
  }, {
    "code": ["        1. If the |StatementList| is present, return the LexicallyDeclaredNames of |StatementList|.", "        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "LexicallyDeclaredNames",
      "prod": "DefaultClause",
      "rhs": {
        "tokens": [{
          "term": "default"
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "StatementList",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallydeclarednames",
    "rawBody": "{\n  0:if (! (= StatementList absent)) {\n    (0) access __x0__ = (StatementList \"LexicallyDeclaredNames\")\n    return __x0__\n  } else 1:{}\n  1:return (0) (new [])\n}"
  }, {
    "code": ["        1. Return the LexicallyDeclaredNames of |LabelledItem|."],
    "head": {
      "idx": 0,
      "methodName": "LexicallyDeclaredNames",
      "prod": "LabelledStatement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LabelIdentifier",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "LabelledItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallydeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (LabelledItem \"LexicallyDeclaredNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "LexicallyDeclaredNames",
      "prod": "LabelledItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallydeclarednames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return BoundNames of |FunctionDeclaration|."],
    "head": {
      "idx": 1,
      "methodName": "LexicallyDeclaredNames",
      "prod": "LabelledItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FunctionDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallydeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (FunctionDeclaration \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "LexicallyDeclaredNames",
      "prod": "FunctionStatementList",
      "rhs": {
        "tokens": [{
          "empty": null
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallydeclarednames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return TopLevelLexicallyDeclaredNames of |StatementList|."],
    "head": {
      "idx": 0,
      "methodName": "LexicallyDeclaredNames",
      "prod": "FunctionStatementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StatementList",
          "optional": false
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallydeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (StatementList \"TopLevelLexicallyDeclaredNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "LexicallyDeclaredNames",
      "prod": "ConciseBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExpressionBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallydeclarednames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "LexicallyDeclaredNames",
      "prod": "AsyncConciseBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExpressionBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallydeclarednames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return TopLevelLexicallyDeclaredNames of |StatementList|."],
    "head": {
      "idx": 0,
      "methodName": "LexicallyDeclaredNames",
      "prod": "ScriptBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StatementList",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallydeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (StatementList \"TopLevelLexicallyDeclaredNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Let _names_ be LexicallyDeclaredNames of |ModuleItemList|.", "        1. Append to _names_ the elements of the LexicallyDeclaredNames of |ModuleItem|.", "        1. Return _names_."],
    "head": {
      "idx": 1,
      "methodName": "LexicallyDeclaredNames",
      "prod": "ModuleItemList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ModuleItemList",
          "optional": false
        }, {
          "args": [],
          "name": "ModuleItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallydeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (ModuleItemList \"LexicallyDeclaredNames\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (ModuleItem \"LexicallyDeclaredNames\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["        1. Return the BoundNames of |ImportDeclaration|."],
    "head": {
      "idx": 0,
      "methodName": "LexicallyDeclaredNames",
      "prod": "ModuleItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ImportDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallydeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (ImportDeclaration \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. If |ExportDeclaration| is `export` |VariableStatement|, return a new empty List.", "        1. Return the BoundNames of |ExportDeclaration|."],
    "head": {
      "idx": 1,
      "methodName": "LexicallyDeclaredNames",
      "prod": "ModuleItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExportDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallydeclarednames",
    "rawBody": "{\n  0:(0) ??? \"If nt:{ExportDeclaration} is code:{export} nt:{VariableStatement} , return a new empty List .\"\n  1:(0) access __x0__ = (ExportDeclaration \"BoundNames\")\n  1:return __x0__\n}"
  }, {
    "code": ["        1. Return LexicallyDeclaredNames of |StatementListItem|."],
    "head": {
      "idx": 2,
      "methodName": "LexicallyDeclaredNames",
      "prod": "ModuleItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StatementListItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallydeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (StatementListItem \"LexicallyDeclaredNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Let _declarations_ be LexicallyScopedDeclarations of |StatementList|.", "        1. Append to _declarations_ the elements of the LexicallyScopedDeclarations of |StatementListItem|.", "        1. Return _declarations_."],
    "head": {
      "idx": 1,
      "methodName": "LexicallyScopedDeclarations",
      "prod": "StatementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StatementList",
          "optional": false
        }, {
          "args": [],
          "name": "StatementListItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallyscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (StatementList \"LexicallyScopedDeclarations\")\n  0:let declarations = __x0__\n  1:(1) access __x1__ = (StatementListItem \"LexicallyScopedDeclarations\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> declarations\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return declarations\n}"
  }, {
    "code": ["        1. If |Statement| is <emu-grammar>Statement : LabelledStatement</emu-grammar> , return LexicallyScopedDeclarations of |LabelledStatement|.", "        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "LexicallyScopedDeclarations",
      "prod": "StatementListItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallyscopeddeclarations",
    "rawBody": "{\n  0:if (0) (is-instance-of Statement Statement10) {\n    (0) access LabelledStatement = (Statement \"LabelledStatement\")\n    (1) access __x0__ = (LabelledStatement \"LexicallyScopedDeclarations\")\n    return __x0__\n  } else 1:{}\n  1:return (1) (new [])\n}"
  }, {
    "code": ["        1. Return a List whose sole element is DeclarationPart of |Declaration|."],
    "head": {
      "idx": 1,
      "methodName": "LexicallyScopedDeclarations",
      "prod": "StatementListItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Declaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallyscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (Declaration \"DeclarationPart\")\n  0:return (0) (new [__x0__])\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "LexicallyScopedDeclarations",
      "prod": "CaseBlock",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallyscopeddeclarations",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. If the first |CaseClauses| is present, let _declarations_ be the LexicallyScopedDeclarations of the first |CaseClauses|.", "        1. Else, let _declarations_ be a new empty List.", "        1. Append to _declarations_ the elements of the LexicallyScopedDeclarations of |DefaultClause|.", "        1. If the second |CaseClauses| is not present, return _declarations_.", "        1. Return the result of appending to _declarations_ the elements of the LexicallyScopedDeclarations of the second |CaseClauses|."],
    "head": {
      "idx": 1,
      "methodName": "LexicallyScopedDeclarations",
      "prod": "CaseBlock",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "CaseClauses",
          "optional": true
        }, {
          "args": [],
          "name": "DefaultClause",
          "optional": false
        }, {
          "args": [],
          "name": "CaseClauses",
          "optional": true
        }, {
          "term": "}"
        }]
      },
      "subIdx": 3,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallyscopeddeclarations",
    "rawBody": "{\n  1:if (! (= CaseClauses0 absent)) {\n    (0) access __x0__ = (CaseClauses0 \"LexicallyScopedDeclarations\")\n    let declarations = __x0__\n  } else let declarations = (0) (new [])\n  2:(1) access __x1__ = (DefaultClause \"LexicallyScopedDeclarations\")\n  2:let __x2__ = __x1__\n  2:let __x3__ = 0i\n  2:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> declarations\n    __x3__ = (+ __x3__ 1i)\n  }\n  3:if (= CaseClauses1 absent) return declarations else 1:{}\n  4:(1) ??? \"Return the result of appending to id:{declarations} the elements of the LexicallyScopedDeclarations of the second nt:{CaseClauses} .\"\n}"
  }, {
    "code": ["        1. Let _declarations_ be LexicallyScopedDeclarations of |CaseClauses|.", "        1. Append to _declarations_ the elements of the LexicallyScopedDeclarations of |CaseClause|.", "        1. Return _declarations_."],
    "head": {
      "idx": 1,
      "methodName": "LexicallyScopedDeclarations",
      "prod": "CaseClauses",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CaseClauses",
          "optional": false
        }, {
          "args": [],
          "name": "CaseClause",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallyscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (CaseClauses \"LexicallyScopedDeclarations\")\n  0:let declarations = __x0__\n  1:(1) access __x1__ = (CaseClause \"LexicallyScopedDeclarations\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> declarations\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return declarations\n}"
  }, {
    "code": ["        1. If the |StatementList| is present, return the LexicallyScopedDeclarations of |StatementList|.", "        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "LexicallyScopedDeclarations",
      "prod": "CaseClause",
      "rhs": {
        "tokens": [{
          "term": "case"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "StatementList",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallyscopeddeclarations",
    "rawBody": "{\n  0:if (! (= StatementList absent)) {\n    (0) access __x0__ = (StatementList \"LexicallyScopedDeclarations\")\n    return __x0__\n  } else 1:{}\n  1:return (0) (new [])\n}"
  }, {
    "code": ["        1. If the |StatementList| is present, return the LexicallyScopedDeclarations of |StatementList|.", "        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "LexicallyScopedDeclarations",
      "prod": "DefaultClause",
      "rhs": {
        "tokens": [{
          "term": "default"
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "StatementList",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallyscopeddeclarations",
    "rawBody": "{\n  0:if (! (= StatementList absent)) {\n    (0) access __x0__ = (StatementList \"LexicallyScopedDeclarations\")\n    return __x0__\n  } else 1:{}\n  1:return (0) (new [])\n}"
  }, {
    "code": ["        1. Return the LexicallyScopedDeclarations of |LabelledItem|."],
    "head": {
      "idx": 0,
      "methodName": "LexicallyScopedDeclarations",
      "prod": "LabelledStatement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LabelIdentifier",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "LabelledItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallyscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (LabelledItem \"LexicallyScopedDeclarations\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "LexicallyScopedDeclarations",
      "prod": "LabelledItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallyscopeddeclarations",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return a List whose sole element is |FunctionDeclaration|."],
    "head": {
      "idx": 1,
      "methodName": "LexicallyScopedDeclarations",
      "prod": "LabelledItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FunctionDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallyscopeddeclarations",
    "rawBody": "return (0) (new [FunctionDeclaration])"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "LexicallyScopedDeclarations",
      "prod": "FunctionStatementList",
      "rhs": {
        "tokens": [{
          "empty": null
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallyscopeddeclarations",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return the TopLevelLexicallyScopedDeclarations of |StatementList|."],
    "head": {
      "idx": 0,
      "methodName": "LexicallyScopedDeclarations",
      "prod": "FunctionStatementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StatementList",
          "optional": false
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallyscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (StatementList \"TopLevelLexicallyScopedDeclarations\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "LexicallyScopedDeclarations",
      "prod": "ConciseBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExpressionBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallyscopeddeclarations",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "LexicallyScopedDeclarations",
      "prod": "AsyncConciseBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExpressionBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallyscopeddeclarations",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return TopLevelLexicallyScopedDeclarations of |StatementList|."],
    "head": {
      "idx": 0,
      "methodName": "LexicallyScopedDeclarations",
      "prod": "ScriptBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StatementList",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallyscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (StatementList \"TopLevelLexicallyScopedDeclarations\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "LexicallyScopedDeclarations",
      "prod": "Module",
      "rhs": {
        "tokens": [{
          "empty": null
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallyscopeddeclarations",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Let _declarations_ be LexicallyScopedDeclarations of |ModuleItemList|.", "        1. Append to _declarations_ the elements of the LexicallyScopedDeclarations of |ModuleItem|.", "        1. Return _declarations_."],
    "head": {
      "idx": 1,
      "methodName": "LexicallyScopedDeclarations",
      "prod": "ModuleItemList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ModuleItemList",
          "optional": false
        }, {
          "args": [],
          "name": "ModuleItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallyscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (ModuleItemList \"LexicallyScopedDeclarations\")\n  0:let declarations = __x0__\n  1:(1) access __x1__ = (ModuleItem \"LexicallyScopedDeclarations\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> declarations\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return declarations\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "LexicallyScopedDeclarations",
      "prod": "ModuleItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ImportDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallyscopeddeclarations",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "LexicallyScopedDeclarations",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "ExportFromClause",
          "optional": false
        }, {
          "args": [],
          "name": "FromClause",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallyscopeddeclarations",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 1,
      "methodName": "LexicallyScopedDeclarations",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "NamedExports",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallyscopeddeclarations",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 2,
      "methodName": "LexicallyScopedDeclarations",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "VariableStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallyscopeddeclarations",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return a List whose sole element is DeclarationPart of |Declaration|."],
    "head": {
      "idx": 3,
      "methodName": "LexicallyScopedDeclarations",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "Declaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallyscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (Declaration \"DeclarationPart\")\n  0:return (0) (new [__x0__])\n}"
  }, {
    "code": ["        1. Return a List whose sole element is DeclarationPart of |HoistableDeclaration|."],
    "head": {
      "idx": 4,
      "methodName": "LexicallyScopedDeclarations",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "term": "default"
        }, {
          "args": [],
          "name": "HoistableDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallyscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (HoistableDeclaration \"DeclarationPart\")\n  0:return (0) (new [__x0__])\n}"
  }, {
    "code": ["        1. Return a List whose sole element is |ClassDeclaration|."],
    "head": {
      "idx": 5,
      "methodName": "LexicallyScopedDeclarations",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "term": "default"
        }, {
          "args": [],
          "name": "ClassDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallyscopeddeclarations",
    "rawBody": "return (0) (new [ClassDeclaration])"
  }, {
    "code": ["        1. Return a List whose sole element is this |ExportDeclaration|."],
    "head": {
      "idx": 6,
      "methodName": "LexicallyScopedDeclarations",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "term": "default"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-lexicallyscopeddeclarations",
    "rawBody": "return (0) (new [this])"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 2,
      "methodName": "VarDeclaredNames",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "EmptyStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 3,
      "methodName": "VarDeclaredNames",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExpressionStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 6,
      "methodName": "VarDeclaredNames",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ContinueStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 7,
      "methodName": "VarDeclaredNames",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BreakStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 8,
      "methodName": "VarDeclaredNames",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ReturnStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 11,
      "methodName": "VarDeclaredNames",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ThrowStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 13,
      "methodName": "VarDeclaredNames",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "DebuggerStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "VarDeclaredNames",
      "prod": "Block",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Let _names_ be VarDeclaredNames of |StatementList|.", "        1. Append to _names_ the elements of the VarDeclaredNames of |StatementListItem|.", "        1. Return _names_."],
    "head": {
      "idx": 1,
      "methodName": "VarDeclaredNames",
      "prod": "StatementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StatementList",
          "optional": false
        }, {
          "args": [],
          "name": "StatementListItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (StatementList \"VarDeclaredNames\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (StatementListItem \"VarDeclaredNames\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 1,
      "methodName": "VarDeclaredNames",
      "prod": "StatementListItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Declaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return BoundNames of |VariableDeclarationList|."],
    "head": {
      "idx": 0,
      "methodName": "VarDeclaredNames",
      "prod": "VariableStatement",
      "rhs": {
        "tokens": [{
          "term": "var"
        }, {
          "args": [],
          "name": "VariableDeclarationList",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (VariableDeclarationList \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Let _names_ be VarDeclaredNames of the first |Statement|.", "        1. Append to _names_ the elements of the VarDeclaredNames of the second |Statement|.", "        1. Return _names_."],
    "head": {
      "idx": 0,
      "methodName": "VarDeclaredNames",
      "prod": "IfStatement",
      "rhs": {
        "tokens": [{
          "term": "if"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }, {
          "term": "else"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement0 \"VarDeclaredNames\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (Statement1 \"VarDeclaredNames\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["        1. Return the VarDeclaredNames of |Statement|."],
    "head": {
      "idx": 1,
      "methodName": "VarDeclaredNames",
      "prod": "IfStatement",
      "rhs": {
        "tokens": [{
          "term": "if"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"VarDeclaredNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the VarDeclaredNames of |Statement|."],
    "head": {
      "idx": 0,
      "methodName": "VarDeclaredNames",
      "prod": "DoWhileStatement",
      "rhs": {
        "tokens": [{
          "term": "do"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }, {
          "term": "while"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"VarDeclaredNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the VarDeclaredNames of |Statement|."],
    "head": {
      "idx": 0,
      "methodName": "VarDeclaredNames",
      "prod": "WhileStatement",
      "rhs": {
        "tokens": [{
          "term": "while"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"VarDeclaredNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the VarDeclaredNames of |Statement|."],
    "head": {
      "idx": 0,
      "methodName": "VarDeclaredNames",
      "prod": "ForStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 7,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"VarDeclaredNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Let _names_ be BoundNames of |VariableDeclarationList|.", "        1. Append to _names_ the elements of the VarDeclaredNames of |Statement|.", "        1. Return _names_."],
    "head": {
      "idx": 1,
      "methodName": "VarDeclaredNames",
      "prod": "ForStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "VariableDeclarationList",
          "optional": false
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 3,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (VariableDeclarationList \"BoundNames\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (Statement \"VarDeclaredNames\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["        1. Return the VarDeclaredNames of |Statement|."],
    "head": {
      "idx": 2,
      "methodName": "VarDeclaredNames",
      "prod": "ForStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LexicalDeclaration",
          "optional": false
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 3,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"VarDeclaredNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the VarDeclaredNames of |Statement|."],
    "head": {
      "idx": 0,
      "methodName": "VarDeclaredNames",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"VarDeclaredNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the VarDeclaredNames of |Statement|."],
    "head": {
      "idx": 2,
      "methodName": "VarDeclaredNames",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "ForDeclaration",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"VarDeclaredNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the VarDeclaredNames of |Statement|."],
    "head": {
      "idx": 3,
      "methodName": "VarDeclaredNames",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"VarDeclaredNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the VarDeclaredNames of |Statement|."],
    "head": {
      "idx": 5,
      "methodName": "VarDeclaredNames",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "ForDeclaration",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"VarDeclaredNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the VarDeclaredNames of |Statement|."],
    "head": {
      "idx": 6,
      "methodName": "VarDeclaredNames",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "await"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"VarDeclaredNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the VarDeclaredNames of |Statement|."],
    "head": {
      "idx": 8,
      "methodName": "VarDeclaredNames",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "await"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "ForDeclaration",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"VarDeclaredNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Let _names_ be the BoundNames of |ForBinding|.", "        1. Append to _names_ the elements of the VarDeclaredNames of |Statement|.", "        1. Return _names_."],
    "head": {
      "idx": 1,
      "methodName": "VarDeclaredNames",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "ForBinding",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (ForBinding \"BoundNames\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (Statement \"VarDeclaredNames\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["        1. Let _names_ be the BoundNames of |ForBinding|.", "        1. Append to _names_ the elements of the VarDeclaredNames of |Statement|.", "        1. Return _names_."],
    "head": {
      "idx": 4,
      "methodName": "VarDeclaredNames",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "ForBinding",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (ForBinding \"BoundNames\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (Statement \"VarDeclaredNames\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["        1. Let _names_ be the BoundNames of |ForBinding|.", "        1. Append to _names_ the elements of the VarDeclaredNames of |Statement|.", "        1. Return _names_."],
    "head": {
      "idx": 7,
      "methodName": "VarDeclaredNames",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "await"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "ForBinding",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (ForBinding \"BoundNames\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (Statement \"VarDeclaredNames\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["        1. Return the VarDeclaredNames of |Statement|."],
    "head": {
      "idx": 0,
      "methodName": "VarDeclaredNames",
      "prod": "WithStatement",
      "rhs": {
        "tokens": [{
          "term": "with"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"VarDeclaredNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the VarDeclaredNames of |CaseBlock|."],
    "head": {
      "idx": 0,
      "methodName": "VarDeclaredNames",
      "prod": "SwitchStatement",
      "rhs": {
        "tokens": [{
          "term": "switch"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "CaseBlock",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (CaseBlock \"VarDeclaredNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "VarDeclaredNames",
      "prod": "CaseBlock",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. If the first |CaseClauses| is present, let _names_ be the VarDeclaredNames of the first |CaseClauses|.", "        1. Else, let _names_ be a new empty List.", "        1. Append to _names_ the elements of the VarDeclaredNames of |DefaultClause|.", "        1. If the second |CaseClauses| is not present, return _names_.", "        1. Return the result of appending to _names_ the elements of the VarDeclaredNames of the second |CaseClauses|."],
    "head": {
      "idx": 1,
      "methodName": "VarDeclaredNames",
      "prod": "CaseBlock",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "CaseClauses",
          "optional": true
        }, {
          "args": [],
          "name": "DefaultClause",
          "optional": false
        }, {
          "args": [],
          "name": "CaseClauses",
          "optional": true
        }, {
          "term": "}"
        }]
      },
      "subIdx": 3,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  1:if (! (= CaseClauses0 absent)) {\n    (0) access __x0__ = (CaseClauses0 \"VarDeclaredNames\")\n    let names = __x0__\n  } else let names = (0) (new [])\n  2:(1) access __x1__ = (DefaultClause \"VarDeclaredNames\")\n  2:let __x2__ = __x1__\n  2:let __x3__ = 0i\n  2:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  3:if (= CaseClauses1 absent) return names else 1:{}\n  4:(2) access __names__ = (CaseClauses1 \"VarDeclaredNames\")\n  4:let __i__ = 0i\n  4:while (< __i__ __names__[\"length\"]) {\n    append __names__[__i__] -> names\n    __i__ = (+ __i__ 1i)\n  }\n  4:return names\n}"
  }, {
    "code": ["        1. Let _names_ be VarDeclaredNames of |CaseClauses|.", "        1. Append to _names_ the elements of the VarDeclaredNames of |CaseClause|.", "        1. Return _names_."],
    "head": {
      "idx": 1,
      "methodName": "VarDeclaredNames",
      "prod": "CaseClauses",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CaseClauses",
          "optional": false
        }, {
          "args": [],
          "name": "CaseClause",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (CaseClauses \"VarDeclaredNames\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (CaseClause \"VarDeclaredNames\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["        1. If the |StatementList| is present, return the VarDeclaredNames of |StatementList|.", "        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "VarDeclaredNames",
      "prod": "CaseClause",
      "rhs": {
        "tokens": [{
          "term": "case"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "StatementList",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:if (! (= StatementList absent)) {\n    (0) access __x0__ = (StatementList \"VarDeclaredNames\")\n    return __x0__\n  } else 1:{}\n  1:return (0) (new [])\n}"
  }, {
    "code": ["        1. If the |StatementList| is present, return the VarDeclaredNames of |StatementList|.", "        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "VarDeclaredNames",
      "prod": "DefaultClause",
      "rhs": {
        "tokens": [{
          "term": "default"
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "StatementList",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:if (! (= StatementList absent)) {\n    (0) access __x0__ = (StatementList \"VarDeclaredNames\")\n    return __x0__\n  } else 1:{}\n  1:return (0) (new [])\n}"
  }, {
    "code": ["        1. Return the VarDeclaredNames of |LabelledItem|."],
    "head": {
      "idx": 0,
      "methodName": "VarDeclaredNames",
      "prod": "LabelledStatement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LabelIdentifier",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "LabelledItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (LabelledItem \"VarDeclaredNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 1,
      "methodName": "VarDeclaredNames",
      "prod": "LabelledItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FunctionDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Let _names_ be VarDeclaredNames of |Block|.", "        1. Append to _names_ the elements of the VarDeclaredNames of |Catch|.", "        1. Return _names_."],
    "head": {
      "idx": 0,
      "methodName": "VarDeclaredNames",
      "prod": "TryStatement",
      "rhs": {
        "tokens": [{
          "term": "try"
        }, {
          "args": [],
          "name": "Block",
          "optional": false
        }, {
          "args": [],
          "name": "Catch",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (Block \"VarDeclaredNames\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (Catch \"VarDeclaredNames\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["        1. Let _names_ be VarDeclaredNames of |Block|.", "        1. Append to _names_ the elements of the VarDeclaredNames of |Finally|.", "        1. Return _names_."],
    "head": {
      "idx": 1,
      "methodName": "VarDeclaredNames",
      "prod": "TryStatement",
      "rhs": {
        "tokens": [{
          "term": "try"
        }, {
          "args": [],
          "name": "Block",
          "optional": false
        }, {
          "args": [],
          "name": "Finally",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (Block \"VarDeclaredNames\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (Finally \"VarDeclaredNames\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["        1. Let _names_ be VarDeclaredNames of |Block|.", "        1. Append to _names_ the elements of the VarDeclaredNames of |Catch|.", "        1. Append to _names_ the elements of the VarDeclaredNames of |Finally|.", "        1. Return _names_."],
    "head": {
      "idx": 2,
      "methodName": "VarDeclaredNames",
      "prod": "TryStatement",
      "rhs": {
        "tokens": [{
          "term": "try"
        }, {
          "args": [],
          "name": "Block",
          "optional": false
        }, {
          "args": [],
          "name": "Catch",
          "optional": false
        }, {
          "args": [],
          "name": "Finally",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (Block \"VarDeclaredNames\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (Catch \"VarDeclaredNames\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:(2) access __x5__ = (Finally \"VarDeclaredNames\")\n  2:let __x6__ = __x5__\n  2:let __x7__ = 0i\n  2:while (< __x7__ __x6__[\"length\"]) {\n    let __x8__ = __x6__[__x7__]\n    append __x8__ -> names\n    __x7__ = (+ __x7__ 1i)\n  }\n  3:return names\n}"
  }, {
    "code": ["        1. Return the VarDeclaredNames of |Block|."],
    "head": {
      "idx": 0,
      "methodName": "VarDeclaredNames",
      "prod": "Catch",
      "rhs": {
        "tokens": [{
          "term": "catch"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "CatchParameter",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Block",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (Block \"VarDeclaredNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "VarDeclaredNames",
      "prod": "FunctionStatementList",
      "rhs": {
        "tokens": [{
          "empty": null
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return TopLevelVarDeclaredNames of |StatementList|."],
    "head": {
      "idx": 0,
      "methodName": "VarDeclaredNames",
      "prod": "FunctionStatementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StatementList",
          "optional": false
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (StatementList \"TopLevelVarDeclaredNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "VarDeclaredNames",
      "prod": "ConciseBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExpressionBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "VarDeclaredNames",
      "prod": "AsyncConciseBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExpressionBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return TopLevelVarDeclaredNames of |StatementList|."],
    "head": {
      "idx": 0,
      "methodName": "VarDeclaredNames",
      "prod": "ScriptBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StatementList",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (StatementList \"TopLevelVarDeclaredNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "VarDeclaredNames",
      "prod": "Module",
      "rhs": {
        "tokens": [{
          "empty": null
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Let _names_ be VarDeclaredNames of |ModuleItemList|.", "        1. Append to _names_ the elements of the VarDeclaredNames of |ModuleItem|.", "        1. Return _names_."],
    "head": {
      "idx": 1,
      "methodName": "VarDeclaredNames",
      "prod": "ModuleItemList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ModuleItemList",
          "optional": false
        }, {
          "args": [],
          "name": "ModuleItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (ModuleItemList \"VarDeclaredNames\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (ModuleItem \"VarDeclaredNames\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "VarDeclaredNames",
      "prod": "ModuleItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ImportDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. If |ExportDeclaration| is `export` |VariableStatement|, return BoundNames of |ExportDeclaration|.", "        1. Return a new empty List."],
    "head": {
      "idx": 1,
      "methodName": "VarDeclaredNames",
      "prod": "ModuleItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExportDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-vardeclarednames",
    "rawBody": "{\n  0:(0) ??? \"If nt:{ExportDeclaration} is code:{export} nt:{VariableStatement} , return BoundNames of nt:{ExportDeclaration} .\"\n  1:return (1) (new [])\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 2,
      "methodName": "VarScopedDeclarations",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "EmptyStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 3,
      "methodName": "VarScopedDeclarations",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExpressionStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 6,
      "methodName": "VarScopedDeclarations",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ContinueStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 7,
      "methodName": "VarScopedDeclarations",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BreakStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 8,
      "methodName": "VarScopedDeclarations",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ReturnStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 11,
      "methodName": "VarScopedDeclarations",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ThrowStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 13,
      "methodName": "VarScopedDeclarations",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "DebuggerStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "VarScopedDeclarations",
      "prod": "Block",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Let _declarations_ be VarScopedDeclarations of |StatementList|.", "        1. Append to _declarations_ the elements of the VarScopedDeclarations of |StatementListItem|.", "        1. Return _declarations_."],
    "head": {
      "idx": 1,
      "methodName": "VarScopedDeclarations",
      "prod": "StatementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StatementList",
          "optional": false
        }, {
          "args": [],
          "name": "StatementListItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (StatementList \"VarScopedDeclarations\")\n  0:let declarations = __x0__\n  1:(1) access __x1__ = (StatementListItem \"VarScopedDeclarations\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> declarations\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return declarations\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 1,
      "methodName": "VarScopedDeclarations",
      "prod": "StatementListItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Declaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return a List whose sole element is |VariableDeclaration|."],
    "head": {
      "idx": 0,
      "methodName": "VarScopedDeclarations",
      "prod": "VariableDeclarationList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "VariableDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "return (0) (new [VariableDeclaration])"
  }, {
    "code": ["        1. Let _declarations_ be VarScopedDeclarations of |VariableDeclarationList|.", "        1. Append |VariableDeclaration| to _declarations_.", "        1. Return _declarations_."],
    "head": {
      "idx": 1,
      "methodName": "VarScopedDeclarations",
      "prod": "VariableDeclarationList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "VariableDeclarationList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "VariableDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (VariableDeclarationList \"VarScopedDeclarations\")\n  0:let declarations = __x0__\n  1:append VariableDeclaration -> declarations\n  2:return declarations\n}"
  }, {
    "code": ["        1. Let _declarations_ be VarScopedDeclarations of the first |Statement|.", "        1. Append to _declarations_ the elements of the VarScopedDeclarations of the second |Statement|.", "        1. Return _declarations_."],
    "head": {
      "idx": 0,
      "methodName": "VarScopedDeclarations",
      "prod": "IfStatement",
      "rhs": {
        "tokens": [{
          "term": "if"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }, {
          "term": "else"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement0 \"VarScopedDeclarations\")\n  0:let declarations = __x0__\n  1:(1) access __x1__ = (Statement1 \"VarScopedDeclarations\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> declarations\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return declarations\n}"
  }, {
    "code": ["        1. Return the VarScopedDeclarations of |Statement|."],
    "head": {
      "idx": 1,
      "methodName": "VarScopedDeclarations",
      "prod": "IfStatement",
      "rhs": {
        "tokens": [{
          "term": "if"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"VarScopedDeclarations\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the VarScopedDeclarations of |Statement|."],
    "head": {
      "idx": 0,
      "methodName": "VarScopedDeclarations",
      "prod": "DoWhileStatement",
      "rhs": {
        "tokens": [{
          "term": "do"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }, {
          "term": "while"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"VarScopedDeclarations\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the VarScopedDeclarations of |Statement|."],
    "head": {
      "idx": 0,
      "methodName": "VarScopedDeclarations",
      "prod": "WhileStatement",
      "rhs": {
        "tokens": [{
          "term": "while"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"VarScopedDeclarations\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the VarScopedDeclarations of |Statement|."],
    "head": {
      "idx": 0,
      "methodName": "VarScopedDeclarations",
      "prod": "ForStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 7,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"VarScopedDeclarations\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Let _declarations_ be VarScopedDeclarations of |VariableDeclarationList|.", "        1. Append to _declarations_ the elements of the VarScopedDeclarations of |Statement|.", "        1. Return _declarations_."],
    "head": {
      "idx": 1,
      "methodName": "VarScopedDeclarations",
      "prod": "ForStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "VariableDeclarationList",
          "optional": false
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 3,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (VariableDeclarationList \"VarScopedDeclarations\")\n  0:let declarations = __x0__\n  1:(1) access __x1__ = (Statement \"VarScopedDeclarations\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> declarations\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return declarations\n}"
  }, {
    "code": ["        1. Return the VarScopedDeclarations of |Statement|."],
    "head": {
      "idx": 2,
      "methodName": "VarScopedDeclarations",
      "prod": "ForStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LexicalDeclaration",
          "optional": false
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 3,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"VarScopedDeclarations\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the VarScopedDeclarations of |Statement|."],
    "head": {
      "idx": 0,
      "methodName": "VarScopedDeclarations",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"VarScopedDeclarations\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the VarScopedDeclarations of |Statement|."],
    "head": {
      "idx": 2,
      "methodName": "VarScopedDeclarations",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "ForDeclaration",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"VarScopedDeclarations\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the VarScopedDeclarations of |Statement|."],
    "head": {
      "idx": 3,
      "methodName": "VarScopedDeclarations",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"VarScopedDeclarations\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the VarScopedDeclarations of |Statement|."],
    "head": {
      "idx": 5,
      "methodName": "VarScopedDeclarations",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "ForDeclaration",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"VarScopedDeclarations\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the VarScopedDeclarations of |Statement|."],
    "head": {
      "idx": 6,
      "methodName": "VarScopedDeclarations",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "await"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"VarScopedDeclarations\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the VarScopedDeclarations of |Statement|."],
    "head": {
      "idx": 8,
      "methodName": "VarScopedDeclarations",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "await"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "ForDeclaration",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"VarScopedDeclarations\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Let _declarations_ be a List whose sole element is |ForBinding|.", "        1. Append to _declarations_ the elements of the VarScopedDeclarations of |Statement|.", "        1. Return _declarations_."],
    "head": {
      "idx": 1,
      "methodName": "VarScopedDeclarations",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "ForBinding",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:let declarations = (0) (new [ForBinding])\n  1:(0) access __x0__ = (Statement \"VarScopedDeclarations\")\n  1:let __x1__ = __x0__\n  1:let __x2__ = 0i\n  1:while (< __x2__ __x1__[\"length\"]) {\n    let __x3__ = __x1__[__x2__]\n    append __x3__ -> declarations\n    __x2__ = (+ __x2__ 1i)\n  }\n  2:return declarations\n}"
  }, {
    "code": ["        1. Let _declarations_ be a List whose sole element is |ForBinding|.", "        1. Append to _declarations_ the elements of the VarScopedDeclarations of |Statement|.", "        1. Return _declarations_."],
    "head": {
      "idx": 4,
      "methodName": "VarScopedDeclarations",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "ForBinding",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:let declarations = (0) (new [ForBinding])\n  1:(0) access __x0__ = (Statement \"VarScopedDeclarations\")\n  1:let __x1__ = __x0__\n  1:let __x2__ = 0i\n  1:while (< __x2__ __x1__[\"length\"]) {\n    let __x3__ = __x1__[__x2__]\n    append __x3__ -> declarations\n    __x2__ = (+ __x2__ 1i)\n  }\n  2:return declarations\n}"
  }, {
    "code": ["        1. Let _declarations_ be a List whose sole element is |ForBinding|.", "        1. Append to _declarations_ the elements of the VarScopedDeclarations of |Statement|.", "        1. Return _declarations_."],
    "head": {
      "idx": 7,
      "methodName": "VarScopedDeclarations",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "await"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "ForBinding",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:let declarations = (0) (new [ForBinding])\n  1:(0) access __x0__ = (Statement \"VarScopedDeclarations\")\n  1:let __x1__ = __x0__\n  1:let __x2__ = 0i\n  1:while (< __x2__ __x1__[\"length\"]) {\n    let __x3__ = __x1__[__x2__]\n    append __x3__ -> declarations\n    __x2__ = (+ __x2__ 1i)\n  }\n  2:return declarations\n}"
  }, {
    "code": ["        1. Return the VarScopedDeclarations of |Statement|."],
    "head": {
      "idx": 0,
      "methodName": "VarScopedDeclarations",
      "prod": "WithStatement",
      "rhs": {
        "tokens": [{
          "term": "with"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"VarScopedDeclarations\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the VarScopedDeclarations of |CaseBlock|."],
    "head": {
      "idx": 0,
      "methodName": "VarScopedDeclarations",
      "prod": "SwitchStatement",
      "rhs": {
        "tokens": [{
          "term": "switch"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "CaseBlock",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (CaseBlock \"VarScopedDeclarations\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "VarScopedDeclarations",
      "prod": "CaseBlock",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. If the first |CaseClauses| is present, let _declarations_ be the VarScopedDeclarations of the first |CaseClauses|.", "        1. Else, let _declarations_ be a new empty List.", "        1. Append to _declarations_ the elements of the VarScopedDeclarations of |DefaultClause|.", "        1. If the second |CaseClauses| is not present, return _declarations_.", "        1. Return the result of appending to _declarations_ the elements of the VarScopedDeclarations of the second |CaseClauses|."],
    "head": {
      "idx": 1,
      "methodName": "VarScopedDeclarations",
      "prod": "CaseBlock",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "CaseClauses",
          "optional": true
        }, {
          "args": [],
          "name": "DefaultClause",
          "optional": false
        }, {
          "args": [],
          "name": "CaseClauses",
          "optional": true
        }, {
          "term": "}"
        }]
      },
      "subIdx": 3,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  1:if (! (= CaseClauses0 absent)) {\n    (0) access __x0__ = (CaseClauses0 \"VarScopedDeclarations\")\n    let declarations = __x0__\n  } else let declarations = (0) (new [])\n  2:(1) access __x1__ = (DefaultClause \"VarScopedDeclarations\")\n  2:let __x2__ = __x1__\n  2:let __x3__ = 0i\n  2:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> declarations\n    __x3__ = (+ __x3__ 1i)\n  }\n  3:if (= CaseClauses1 absent) return declarations else 1:{}\n  4:(2) access decls = (CaseClauses1 \"VarScopedDeclarations\")\n  4:let __i__ = 0i\n  4:while (< __i__ decls[\"length\"]) {\n    append decls[__i__] -> declarations\n    __i__ = (+ __i__ 1i)\n  }\n  4:return decls\n}"
  }, {
    "code": ["        1. Let _declarations_ be VarScopedDeclarations of |CaseClauses|.", "        1. Append to _declarations_ the elements of the VarScopedDeclarations of |CaseClause|.", "        1. Return _declarations_."],
    "head": {
      "idx": 1,
      "methodName": "VarScopedDeclarations",
      "prod": "CaseClauses",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CaseClauses",
          "optional": false
        }, {
          "args": [],
          "name": "CaseClause",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (CaseClauses \"VarScopedDeclarations\")\n  0:let declarations = __x0__\n  1:(1) access __x1__ = (CaseClause \"VarScopedDeclarations\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> declarations\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return declarations\n}"
  }, {
    "code": ["        1. If the |StatementList| is present, return the VarScopedDeclarations of |StatementList|.", "        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "VarScopedDeclarations",
      "prod": "CaseClause",
      "rhs": {
        "tokens": [{
          "term": "case"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "StatementList",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:if (! (= StatementList absent)) {\n    (0) access __x0__ = (StatementList \"VarScopedDeclarations\")\n    return __x0__\n  } else 1:{}\n  1:return (0) (new [])\n}"
  }, {
    "code": ["        1. If the |StatementList| is present, return the VarScopedDeclarations of |StatementList|.", "        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "VarScopedDeclarations",
      "prod": "DefaultClause",
      "rhs": {
        "tokens": [{
          "term": "default"
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "StatementList",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:if (! (= StatementList absent)) {\n    (0) access __x0__ = (StatementList \"VarScopedDeclarations\")\n    return __x0__\n  } else 1:{}\n  1:return (0) (new [])\n}"
  }, {
    "code": ["        1. Return the VarScopedDeclarations of |LabelledItem|."],
    "head": {
      "idx": 0,
      "methodName": "VarScopedDeclarations",
      "prod": "LabelledStatement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LabelIdentifier",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "LabelledItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (LabelledItem \"VarScopedDeclarations\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 1,
      "methodName": "VarScopedDeclarations",
      "prod": "LabelledItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FunctionDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Let _declarations_ be VarScopedDeclarations of |Block|.", "        1. Append to _declarations_ the elements of the VarScopedDeclarations of |Catch|.", "        1. Return _declarations_."],
    "head": {
      "idx": 0,
      "methodName": "VarScopedDeclarations",
      "prod": "TryStatement",
      "rhs": {
        "tokens": [{
          "term": "try"
        }, {
          "args": [],
          "name": "Block",
          "optional": false
        }, {
          "args": [],
          "name": "Catch",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (Block \"VarScopedDeclarations\")\n  0:let declarations = __x0__\n  1:(1) access __x1__ = (Catch \"VarScopedDeclarations\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> declarations\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return declarations\n}"
  }, {
    "code": ["        1. Let _declarations_ be VarScopedDeclarations of |Block|.", "        1. Append to _declarations_ the elements of the VarScopedDeclarations of |Finally|.", "        1. Return _declarations_."],
    "head": {
      "idx": 1,
      "methodName": "VarScopedDeclarations",
      "prod": "TryStatement",
      "rhs": {
        "tokens": [{
          "term": "try"
        }, {
          "args": [],
          "name": "Block",
          "optional": false
        }, {
          "args": [],
          "name": "Finally",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (Block \"VarScopedDeclarations\")\n  0:let declarations = __x0__\n  1:(1) access __x1__ = (Finally \"VarScopedDeclarations\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> declarations\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return declarations\n}"
  }, {
    "code": ["        1. Let _declarations_ be VarScopedDeclarations of |Block|.", "        1. Append to _declarations_ the elements of the VarScopedDeclarations of |Catch|.", "        1. Append to _declarations_ the elements of the VarScopedDeclarations of |Finally|.", "        1. Return _declarations_."],
    "head": {
      "idx": 2,
      "methodName": "VarScopedDeclarations",
      "prod": "TryStatement",
      "rhs": {
        "tokens": [{
          "term": "try"
        }, {
          "args": [],
          "name": "Block",
          "optional": false
        }, {
          "args": [],
          "name": "Catch",
          "optional": false
        }, {
          "args": [],
          "name": "Finally",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (Block \"VarScopedDeclarations\")\n  0:let declarations = __x0__\n  1:(1) access __x1__ = (Catch \"VarScopedDeclarations\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> declarations\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:(2) access __x5__ = (Finally \"VarScopedDeclarations\")\n  2:let __x6__ = __x5__\n  2:let __x7__ = 0i\n  2:while (< __x7__ __x6__[\"length\"]) {\n    let __x8__ = __x6__[__x7__]\n    append __x8__ -> declarations\n    __x7__ = (+ __x7__ 1i)\n  }\n  3:return declarations\n}"
  }, {
    "code": ["        1. Return the VarScopedDeclarations of |Block|."],
    "head": {
      "idx": 0,
      "methodName": "VarScopedDeclarations",
      "prod": "Catch",
      "rhs": {
        "tokens": [{
          "term": "catch"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "CatchParameter",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Block",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (Block \"VarScopedDeclarations\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "VarScopedDeclarations",
      "prod": "FunctionStatementList",
      "rhs": {
        "tokens": [{
          "empty": null
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return the TopLevelVarScopedDeclarations of |StatementList|."],
    "head": {
      "idx": 0,
      "methodName": "VarScopedDeclarations",
      "prod": "FunctionStatementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StatementList",
          "optional": false
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (StatementList \"TopLevelVarScopedDeclarations\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "VarScopedDeclarations",
      "prod": "ConciseBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExpressionBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "VarScopedDeclarations",
      "prod": "AsyncConciseBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExpressionBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return TopLevelVarScopedDeclarations of |StatementList|."],
    "head": {
      "idx": 0,
      "methodName": "VarScopedDeclarations",
      "prod": "ScriptBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StatementList",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (StatementList \"TopLevelVarScopedDeclarations\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "VarScopedDeclarations",
      "prod": "Module",
      "rhs": {
        "tokens": [{
          "empty": null
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Let _declarations_ be VarScopedDeclarations of |ModuleItemList|.", "        1. Append to _declarations_ the elements of the VarScopedDeclarations of |ModuleItem|.", "        1. Return _declarations_."],
    "head": {
      "idx": 1,
      "methodName": "VarScopedDeclarations",
      "prod": "ModuleItemList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ModuleItemList",
          "optional": false
        }, {
          "args": [],
          "name": "ModuleItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (ModuleItemList \"VarScopedDeclarations\")\n  0:let declarations = __x0__\n  1:(1) access __x1__ = (ModuleItem \"VarScopedDeclarations\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> declarations\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return declarations\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "VarScopedDeclarations",
      "prod": "ModuleItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ImportDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. If |ExportDeclaration| is `export` |VariableStatement|, return VarScopedDeclarations of |VariableStatement|.", "        1. Return a new empty List."],
    "head": {
      "idx": 1,
      "methodName": "VarScopedDeclarations",
      "prod": "ModuleItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExportDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-varscopeddeclarations",
    "rawBody": "{\n  0:(0) ??? \"If nt:{ExportDeclaration} is code:{export} nt:{VariableStatement} , return VarScopedDeclarations of nt:{VariableStatement} .\"\n  1:return (1) (new [])\n}"
  }, {
    "code": ["        1. Let _names_ be TopLevelLexicallyDeclaredNames of |StatementList|.", "        1. Append to _names_ the elements of the TopLevelLexicallyDeclaredNames of |StatementListItem|.", "        1. Return _names_."],
    "head": {
      "idx": 1,
      "methodName": "TopLevelLexicallyDeclaredNames",
      "prod": "StatementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StatementList",
          "optional": false
        }, {
          "args": [],
          "name": "StatementListItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-toplevellexicallydeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (StatementList \"TopLevelLexicallyDeclaredNames\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (StatementListItem \"TopLevelLexicallyDeclaredNames\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "TopLevelLexicallyDeclaredNames",
      "prod": "StatementListItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-toplevellexicallydeclarednames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. If |Declaration| is <emu-grammar>Declaration : HoistableDeclaration</emu-grammar> , then", "          1. Return « ».", "        1. Return the BoundNames of |Declaration|."],
    "head": {
      "idx": 1,
      "methodName": "TopLevelLexicallyDeclaredNames",
      "prod": "StatementListItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Declaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-toplevellexicallydeclarednames",
    "rawBody": "{\n  0:if (0) (is-instance-of Declaration Declaration0) {\n    (0) access HoistableDeclaration = (Declaration \"HoistableDeclaration\")\n    1:return (1) (new [])\n  } else 1:{}\n  2:(1) access __x0__ = (Declaration \"BoundNames\")\n  2:return __x0__\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "TopLevelLexicallyDeclaredNames",
      "prod": "LabelledStatement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LabelIdentifier",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "LabelledItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-toplevellexicallydeclarednames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "TopLevelLexicallyScopedDeclarations",
      "prod": "Block",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-toplevellexicallyscopeddeclarations",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Let _declarations_ be TopLevelLexicallyScopedDeclarations of |StatementList|.", "        1. Append to _declarations_ the elements of the TopLevelLexicallyScopedDeclarations of |StatementListItem|.", "        1. Return _declarations_."],
    "head": {
      "idx": 1,
      "methodName": "TopLevelLexicallyScopedDeclarations",
      "prod": "StatementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StatementList",
          "optional": false
        }, {
          "args": [],
          "name": "StatementListItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-toplevellexicallyscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (StatementList \"TopLevelLexicallyScopedDeclarations\")\n  0:let declarations = __x0__\n  1:(1) access __x1__ = (StatementListItem \"TopLevelLexicallyScopedDeclarations\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> declarations\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return declarations\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "TopLevelLexicallyScopedDeclarations",
      "prod": "StatementListItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-toplevellexicallyscopeddeclarations",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. If |Declaration| is <emu-grammar>Declaration : HoistableDeclaration</emu-grammar> , then", "          1. Return « ».", "        1. Return a List whose sole element is |Declaration|."],
    "head": {
      "idx": 1,
      "methodName": "TopLevelLexicallyScopedDeclarations",
      "prod": "StatementListItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Declaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-toplevellexicallyscopeddeclarations",
    "rawBody": "{\n  0:if (0) (is-instance-of Declaration Declaration0) {\n    (0) access HoistableDeclaration = (Declaration \"HoistableDeclaration\")\n    1:return (1) (new [])\n  } else 1:{}\n  2:return (2) (new [Declaration])\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "TopLevelLexicallyScopedDeclarations",
      "prod": "LabelledStatement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LabelIdentifier",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "LabelledItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-toplevellexicallyscopeddeclarations",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "TopLevelVarDeclaredNames",
      "prod": "Block",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-toplevelvardeclarednames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Let _names_ be TopLevelVarDeclaredNames of |StatementList|.", "        1. Append to _names_ the elements of the TopLevelVarDeclaredNames of |StatementListItem|.", "        1. Return _names_."],
    "head": {
      "idx": 1,
      "methodName": "TopLevelVarDeclaredNames",
      "prod": "StatementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StatementList",
          "optional": false
        }, {
          "args": [],
          "name": "StatementListItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-toplevelvardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (StatementList \"TopLevelVarDeclaredNames\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (StatementListItem \"TopLevelVarDeclaredNames\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["        1. If |Declaration| is <emu-grammar>Declaration : HoistableDeclaration</emu-grammar> , then", "          1. Return the BoundNames of |HoistableDeclaration|.", "        1. Return a new empty List."],
    "head": {
      "idx": 1,
      "methodName": "TopLevelVarDeclaredNames",
      "prod": "StatementListItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Declaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-toplevelvardeclarednames",
    "rawBody": "{\n  0:if (0) (is-instance-of Declaration Declaration0) {\n    (0) access HoistableDeclaration = (Declaration \"HoistableDeclaration\")\n    1:(1) access __x0__ = (HoistableDeclaration \"BoundNames\")\n    1:return __x0__\n  } else 1:{}\n  2:return (1) (new [])\n}"
  }, {
    "code": ["        1. If |Statement| is <emu-grammar>Statement : LabelledStatement</emu-grammar> , return TopLevelVarDeclaredNames of |Statement|.", "        1. Return VarDeclaredNames of |Statement|."],
    "head": {
      "idx": 0,
      "methodName": "TopLevelVarDeclaredNames",
      "prod": "StatementListItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-toplevelvardeclarednames",
    "rawBody": "{\n  0:if (0) (is-instance-of Statement Statement10) {\n    (0) access LabelledStatement = (Statement \"LabelledStatement\")\n    (1) access __x0__ = (Statement \"TopLevelVarDeclaredNames\")\n    return __x0__\n  } else 1:{}\n  1:(2) access __x1__ = (Statement \"VarDeclaredNames\")\n  1:return __x1__\n}"
  }, {
    "code": ["        1. Return the TopLevelVarDeclaredNames of |LabelledItem|."],
    "head": {
      "idx": 0,
      "methodName": "TopLevelVarDeclaredNames",
      "prod": "LabelledStatement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LabelIdentifier",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "LabelledItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-toplevelvardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (LabelledItem \"TopLevelVarDeclaredNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. If |Statement| is <emu-grammar>Statement : LabelledStatement</emu-grammar> , return TopLevelVarDeclaredNames of |Statement|.", "        1. Return VarDeclaredNames of |Statement|."],
    "head": {
      "idx": 0,
      "methodName": "TopLevelVarDeclaredNames",
      "prod": "LabelledItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-toplevelvardeclarednames",
    "rawBody": "{\n  0:if (0) (is-instance-of Statement Statement10) {\n    (0) access LabelledStatement = (Statement \"LabelledStatement\")\n    (1) access __x0__ = (Statement \"TopLevelVarDeclaredNames\")\n    return __x0__\n  } else 1:{}\n  1:(2) access __x1__ = (Statement \"VarDeclaredNames\")\n  1:return __x1__\n}"
  }, {
    "code": ["        1. Return BoundNames of |FunctionDeclaration|."],
    "head": {
      "idx": 1,
      "methodName": "TopLevelVarDeclaredNames",
      "prod": "LabelledItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FunctionDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-toplevelvardeclarednames",
    "rawBody": "{\n  0:(0) access __x0__ = (FunctionDeclaration \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "TopLevelVarScopedDeclarations",
      "prod": "Block",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-toplevelvarscopeddeclarations",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["        1. Let _declarations_ be TopLevelVarScopedDeclarations of |StatementList|.", "        1. Append to _declarations_ the elements of the TopLevelVarScopedDeclarations of |StatementListItem|.", "        1. Return _declarations_."],
    "head": {
      "idx": 1,
      "methodName": "TopLevelVarScopedDeclarations",
      "prod": "StatementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StatementList",
          "optional": false
        }, {
          "args": [],
          "name": "StatementListItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-toplevelvarscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (StatementList \"TopLevelVarScopedDeclarations\")\n  0:let declarations = __x0__\n  1:(1) access __x1__ = (StatementListItem \"TopLevelVarScopedDeclarations\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> declarations\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return declarations\n}"
  }, {
    "code": ["        1. If |Statement| is <emu-grammar>Statement : LabelledStatement</emu-grammar> , return TopLevelVarScopedDeclarations of |Statement|.", "        1. Return VarScopedDeclarations of |Statement|."],
    "head": {
      "idx": 0,
      "methodName": "TopLevelVarScopedDeclarations",
      "prod": "StatementListItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-toplevelvarscopeddeclarations",
    "rawBody": "{\n  0:if (0) (is-instance-of Statement Statement10) {\n    (0) access LabelledStatement = (Statement \"LabelledStatement\")\n    (1) access __x0__ = (Statement \"TopLevelVarScopedDeclarations\")\n    return __x0__\n  } else 1:{}\n  1:(2) access __x1__ = (Statement \"VarScopedDeclarations\")\n  1:return __x1__\n}"
  }, {
    "code": ["        1. If |Declaration| is <emu-grammar>Declaration : HoistableDeclaration</emu-grammar> , then", "          1. Let _declaration_ be DeclarationPart of |HoistableDeclaration|.", "          1. Return « _declaration_ ».", "        1. Return a new empty List."],
    "head": {
      "idx": 1,
      "methodName": "TopLevelVarScopedDeclarations",
      "prod": "StatementListItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Declaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-toplevelvarscopeddeclarations",
    "rawBody": "{\n  0:if (0) (is-instance-of Declaration Declaration0) {\n    (0) access HoistableDeclaration = (Declaration \"HoistableDeclaration\")\n    1:(1) access __x0__ = (HoistableDeclaration \"DeclarationPart\")\n    1:let declaration = __x0__\n    2:return (1) (new [declaration])\n  } else 1:{}\n  3:return (2) (new [])\n}"
  }, {
    "code": ["        1. Return the TopLevelVarScopedDeclarations of |LabelledItem|."],
    "head": {
      "idx": 0,
      "methodName": "TopLevelVarScopedDeclarations",
      "prod": "LabelledStatement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LabelIdentifier",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "LabelledItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-toplevelvarscopeddeclarations",
    "rawBody": "{\n  0:(0) access __x0__ = (LabelledItem \"TopLevelVarScopedDeclarations\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. If |Statement| is <emu-grammar>Statement : LabelledStatement</emu-grammar> , return TopLevelVarScopedDeclarations of |Statement|.", "        1. Return VarScopedDeclarations of |Statement|."],
    "head": {
      "idx": 0,
      "methodName": "TopLevelVarScopedDeclarations",
      "prod": "LabelledItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-toplevelvarscopeddeclarations",
    "rawBody": "{\n  0:if (0) (is-instance-of Statement Statement10) {\n    (0) access LabelledStatement = (Statement \"LabelledStatement\")\n    (1) access __x0__ = (Statement \"TopLevelVarScopedDeclarations\")\n    return __x0__\n  } else 1:{}\n  1:(2) access __x1__ = (Statement \"VarScopedDeclarations\")\n  1:return __x1__\n}"
  }, {
    "code": ["        1. Return a List whose sole element is |FunctionDeclaration|."],
    "head": {
      "idx": 1,
      "methodName": "TopLevelVarScopedDeclarations",
      "prod": "LabelledItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FunctionDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-toplevelvarscopeddeclarations",
    "rawBody": "return (0) (new [FunctionDeclaration])"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "ContainsDuplicateLabels",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "VariableStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "ContainsDuplicateLabels",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "EmptyStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 3,
      "methodName": "ContainsDuplicateLabels",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExpressionStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 6,
      "methodName": "ContainsDuplicateLabels",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ContinueStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 7,
      "methodName": "ContainsDuplicateLabels",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BreakStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 8,
      "methodName": "ContainsDuplicateLabels",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ReturnStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 11,
      "methodName": "ContainsDuplicateLabels",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ThrowStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 13,
      "methodName": "ContainsDuplicateLabels",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "DebuggerStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "ContainsDuplicateLabels",
      "prod": "Block",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "ContainsDuplicateLabels",
      "prod": "StatementListItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Declaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "return false"
  }, {
    "code": ["        1. Let _hasDuplicates_ be ContainsDuplicateLabels of |StatementList| with argument _labelSet_.", "        1. If _hasDuplicates_ is *true*, return *true*.", "        1. Return ContainsDuplicateLabels of |StatementListItem| with argument _labelSet_."],
    "head": {
      "idx": 1,
      "methodName": "ContainsDuplicateLabels",
      "prod": "StatementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StatementList",
          "optional": false
        }, {
          "args": [],
          "name": "StatementListItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "{\n  0:(0) access __x0__ = (StatementList \"ContainsDuplicateLabels\" labelSet)\n  0:let hasDuplicates = __x0__\n  1:if (= hasDuplicates true) return true else 1:{}\n  2:(1) access __x1__ = (StatementListItem \"ContainsDuplicateLabels\" labelSet)\n  2:return __x1__\n}"
  }, {
    "code": ["        1. Let _hasDuplicate_ be ContainsDuplicateLabels of the first |Statement| with argument _labelSet_.", "        1. If _hasDuplicate_ is *true*, return *true*.", "        1. Return ContainsDuplicateLabels of the second |Statement| with argument _labelSet_."],
    "head": {
      "idx": 0,
      "methodName": "ContainsDuplicateLabels",
      "prod": "IfStatement",
      "rhs": {
        "tokens": [{
          "term": "if"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }, {
          "term": "else"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement0 \"ContainsDuplicateLabels\" labelSet)\n  0:let hasDuplicate = __x0__\n  1:if (= hasDuplicate true) return true else 1:{}\n  2:(1) access __x1__ = (Statement1 \"ContainsDuplicateLabels\" labelSet)\n  2:return __x1__\n}"
  }, {
    "code": ["        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 1,
      "methodName": "ContainsDuplicateLabels",
      "prod": "IfStatement",
      "rhs": {
        "tokens": [{
          "term": "if"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsDuplicateLabels\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 0,
      "methodName": "ContainsDuplicateLabels",
      "prod": "DoWhileStatement",
      "rhs": {
        "tokens": [{
          "term": "do"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }, {
          "term": "while"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsDuplicateLabels\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 0,
      "methodName": "ContainsDuplicateLabels",
      "prod": "WhileStatement",
      "rhs": {
        "tokens": [{
          "term": "while"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsDuplicateLabels\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 0,
      "methodName": "ContainsDuplicateLabels",
      "prod": "ForStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 7,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsDuplicateLabels\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 1,
      "methodName": "ContainsDuplicateLabels",
      "prod": "ForStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "VariableDeclarationList",
          "optional": false
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 3,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsDuplicateLabels\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 2,
      "methodName": "ContainsDuplicateLabels",
      "prod": "ForStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LexicalDeclaration",
          "optional": false
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 3,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsDuplicateLabels\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 0,
      "methodName": "ContainsDuplicateLabels",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsDuplicateLabels\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 1,
      "methodName": "ContainsDuplicateLabels",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "ForBinding",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsDuplicateLabels\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 2,
      "methodName": "ContainsDuplicateLabels",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "ForDeclaration",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsDuplicateLabels\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 3,
      "methodName": "ContainsDuplicateLabels",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsDuplicateLabels\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 4,
      "methodName": "ContainsDuplicateLabels",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "ForBinding",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsDuplicateLabels\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 5,
      "methodName": "ContainsDuplicateLabels",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "ForDeclaration",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsDuplicateLabels\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 6,
      "methodName": "ContainsDuplicateLabels",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "await"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsDuplicateLabels\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 7,
      "methodName": "ContainsDuplicateLabels",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "await"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "ForBinding",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsDuplicateLabels\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 8,
      "methodName": "ContainsDuplicateLabels",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "await"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "ForDeclaration",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsDuplicateLabels\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 0,
      "methodName": "ContainsDuplicateLabels",
      "prod": "WithStatement",
      "rhs": {
        "tokens": [{
          "term": "with"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsDuplicateLabels\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsDuplicateLabels of |CaseBlock| with argument _labelSet_."],
    "head": {
      "idx": 0,
      "methodName": "ContainsDuplicateLabels",
      "prod": "SwitchStatement",
      "rhs": {
        "tokens": [{
          "term": "switch"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "CaseBlock",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "{\n  0:(0) access __x0__ = (CaseBlock \"ContainsDuplicateLabels\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "ContainsDuplicateLabels",
      "prod": "CaseBlock",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "return false"
  }, {
    "code": ["        1. If the first |CaseClauses| is present, then", "          1. Let _hasDuplicates_ be ContainsDuplicateLabels of the first |CaseClauses| with argument _labelSet_.", "          1. If _hasDuplicates_ is *true*, return *true*.", "        1. Let _hasDuplicates_ be ContainsDuplicateLabels of |DefaultClause| with argument _labelSet_.", "        1. If _hasDuplicates_ is *true*, return *true*.", "        1. If the second |CaseClauses| is not present, return *false*.", "        1. Return ContainsDuplicateLabels of the second |CaseClauses| with argument _labelSet_."],
    "head": {
      "idx": 1,
      "methodName": "ContainsDuplicateLabels",
      "prod": "CaseBlock",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "CaseClauses",
          "optional": true
        }, {
          "args": [],
          "name": "DefaultClause",
          "optional": false
        }, {
          "args": [],
          "name": "CaseClauses",
          "optional": true
        }, {
          "term": "}"
        }]
      },
      "subIdx": 3,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "{\n  0:if (! (= CaseClauses0 absent)) {\n    1:(0) access __x0__ = (CaseClauses0 \"ContainsDuplicateLabels\" labelSet)\n    1:let hasDuplicates = __x0__\n    2:if (= hasDuplicates true) return true else 1:{}\n  } else 1:{}\n  3:(1) access __x1__ = (DefaultClause \"ContainsDuplicateLabels\" labelSet)\n  3:let hasDuplicates = __x1__\n  4:if (= hasDuplicates true) return true else 1:{}\n  5:if (= CaseClauses1 absent) return false else 1:{}\n  6:(2) access __x2__ = (CaseClauses1 \"ContainsDuplicateLabels\" labelSet)\n  6:return __x2__\n}"
  }, {
    "code": ["        1. Let _hasDuplicates_ be ContainsDuplicateLabels of |CaseClauses| with argument _labelSet_.", "        1. If _hasDuplicates_ is *true*, return *true*.", "        1. Return ContainsDuplicateLabels of |CaseClause| with argument _labelSet_."],
    "head": {
      "idx": 1,
      "methodName": "ContainsDuplicateLabels",
      "prod": "CaseClauses",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CaseClauses",
          "optional": false
        }, {
          "args": [],
          "name": "CaseClause",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "{\n  0:(0) access __x0__ = (CaseClauses \"ContainsDuplicateLabels\" labelSet)\n  0:let hasDuplicates = __x0__\n  1:if (= hasDuplicates true) return true else 1:{}\n  2:(1) access __x1__ = (CaseClause \"ContainsDuplicateLabels\" labelSet)\n  2:return __x1__\n}"
  }, {
    "code": ["        1. If the |StatementList| is present, return ContainsDuplicateLabels of |StatementList| with argument _labelSet_.", "        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "ContainsDuplicateLabels",
      "prod": "CaseClause",
      "rhs": {
        "tokens": [{
          "term": "case"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "StatementList",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "{\n  0:if (! (= StatementList absent)) {\n    (0) access __x0__ = (StatementList \"ContainsDuplicateLabels\" labelSet)\n    return __x0__\n  } else 1:{}\n  1:return false\n}"
  }, {
    "code": ["        1. If the |StatementList| is present, return ContainsDuplicateLabels of |StatementList| with argument _labelSet_.", "        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "ContainsDuplicateLabels",
      "prod": "DefaultClause",
      "rhs": {
        "tokens": [{
          "term": "default"
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "StatementList",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "{\n  0:if (! (= StatementList absent)) {\n    (0) access __x0__ = (StatementList \"ContainsDuplicateLabels\" labelSet)\n    return __x0__\n  } else 1:{}\n  1:return false\n}"
  }, {
    "code": ["        1. Let _label_ be the StringValue of |LabelIdentifier|.", "        1. If _label_ is an element of _labelSet_, return *true*.", "        1. Let _newLabelSet_ be a copy of _labelSet_ with _label_ appended.", "        1. Return ContainsDuplicateLabels of |LabelledItem| with argument _newLabelSet_."],
    "head": {
      "idx": 0,
      "methodName": "ContainsDuplicateLabels",
      "prod": "LabelledStatement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LabelIdentifier",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "LabelledItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "{\n  0:(0) access __x0__ = (LabelIdentifier \"StringValue\")\n  0:let label = __x0__\n  1:if (contains labelSet label) return true else 1:{}\n  2:let __x1__ = (0) (copy-obj labelSet)\n  2:append label -> __x1__\n  2:let newLabelSet = __x1__\n  3:(1) access __x2__ = (LabelledItem \"ContainsDuplicateLabels\" newLabelSet)\n  3:return __x2__\n}"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "ContainsDuplicateLabels",
      "prod": "LabelledItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FunctionDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "return false"
  }, {
    "code": ["        1. Let _hasDuplicates_ be ContainsDuplicateLabels of |Block| with argument _labelSet_.", "        1. If _hasDuplicates_ is *true*, return *true*.", "        1. Return ContainsDuplicateLabels of |Catch| with argument _labelSet_."],
    "head": {
      "idx": 0,
      "methodName": "ContainsDuplicateLabels",
      "prod": "TryStatement",
      "rhs": {
        "tokens": [{
          "term": "try"
        }, {
          "args": [],
          "name": "Block",
          "optional": false
        }, {
          "args": [],
          "name": "Catch",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "{\n  0:(0) access __x0__ = (Block \"ContainsDuplicateLabels\" labelSet)\n  0:let hasDuplicates = __x0__\n  1:if (= hasDuplicates true) return true else 1:{}\n  2:(1) access __x1__ = (Catch \"ContainsDuplicateLabels\" labelSet)\n  2:return __x1__\n}"
  }, {
    "code": ["        1. Let _hasDuplicates_ be ContainsDuplicateLabels of |Block| with argument _labelSet_.", "        1. If _hasDuplicates_ is *true*, return *true*.", "        1. Return ContainsDuplicateLabels of |Finally| with argument _labelSet_."],
    "head": {
      "idx": 1,
      "methodName": "ContainsDuplicateLabels",
      "prod": "TryStatement",
      "rhs": {
        "tokens": [{
          "term": "try"
        }, {
          "args": [],
          "name": "Block",
          "optional": false
        }, {
          "args": [],
          "name": "Finally",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "{\n  0:(0) access __x0__ = (Block \"ContainsDuplicateLabels\" labelSet)\n  0:let hasDuplicates = __x0__\n  1:if (= hasDuplicates true) return true else 1:{}\n  2:(1) access __x1__ = (Finally \"ContainsDuplicateLabels\" labelSet)\n  2:return __x1__\n}"
  }, {
    "code": ["        1. Let _hasDuplicates_ be ContainsDuplicateLabels of |Block| with argument _labelSet_.", "        1. If _hasDuplicates_ is *true*, return *true*.", "        1. Let _hasDuplicates_ be ContainsDuplicateLabels of |Catch| with argument _labelSet_.", "        1. If _hasDuplicates_ is *true*, return *true*.", "        1. Return ContainsDuplicateLabels of |Finally| with argument _labelSet_."],
    "head": {
      "idx": 2,
      "methodName": "ContainsDuplicateLabels",
      "prod": "TryStatement",
      "rhs": {
        "tokens": [{
          "term": "try"
        }, {
          "args": [],
          "name": "Block",
          "optional": false
        }, {
          "args": [],
          "name": "Catch",
          "optional": false
        }, {
          "args": [],
          "name": "Finally",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "{\n  0:(0) access __x0__ = (Block \"ContainsDuplicateLabels\" labelSet)\n  0:let hasDuplicates = __x0__\n  1:if (= hasDuplicates true) return true else 1:{}\n  2:(1) access __x1__ = (Catch \"ContainsDuplicateLabels\" labelSet)\n  2:let hasDuplicates = __x1__\n  3:if (= hasDuplicates true) return true else 1:{}\n  4:(2) access __x2__ = (Finally \"ContainsDuplicateLabels\" labelSet)\n  4:return __x2__\n}"
  }, {
    "code": ["        1. Return ContainsDuplicateLabels of |Block| with argument _labelSet_."],
    "head": {
      "idx": 0,
      "methodName": "ContainsDuplicateLabels",
      "prod": "Catch",
      "rhs": {
        "tokens": [{
          "term": "catch"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "CatchParameter",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Block",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "{\n  0:(0) access __x0__ = (Block \"ContainsDuplicateLabels\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "ContainsDuplicateLabels",
      "prod": "FunctionStatementList",
      "rhs": {
        "tokens": [{
          "empty": null
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "return false"
  }, {
    "code": ["        1. Let _hasDuplicates_ be ContainsDuplicateLabels of |ModuleItemList| with argument _labelSet_.", "        1. If _hasDuplicates_ is *true*, return *true*.", "        1. Return ContainsDuplicateLabels of |ModuleItem| with argument _labelSet_."],
    "head": {
      "idx": 1,
      "methodName": "ContainsDuplicateLabels",
      "prod": "ModuleItemList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ModuleItemList",
          "optional": false
        }, {
          "args": [],
          "name": "ModuleItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "{\n  0:(0) access __x0__ = (ModuleItemList \"ContainsDuplicateLabels\" labelSet)\n  0:let hasDuplicates = __x0__\n  1:if (= hasDuplicates true) return true else 1:{}\n  2:(1) access __x1__ = (ModuleItem \"ContainsDuplicateLabels\" labelSet)\n  2:return __x1__\n}"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "ContainsDuplicateLabels",
      "prod": "ModuleItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ImportDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "ContainsDuplicateLabels",
      "prod": "ModuleItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExportDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsduplicatelabels",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "VariableStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "EmptyStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 3,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExpressionStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 6,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ContinueStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 8,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ReturnStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 11,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ThrowStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 13,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "DebuggerStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "Block",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "StatementListItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Declaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "return false"
  }, {
    "code": ["        1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |StatementList| with argument _labelSet_.", "        1. If _hasUndefinedLabels_ is *true*, return *true*.", "        1. Return ContainsUndefinedBreakTarget of |StatementListItem| with argument _labelSet_."],
    "head": {
      "idx": 1,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "StatementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StatementList",
          "optional": false
        }, {
          "args": [],
          "name": "StatementListItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "{\n  0:(0) access __x0__ = (StatementList \"ContainsUndefinedBreakTarget\" labelSet)\n  0:let hasUndefinedLabels = __x0__\n  1:if (= hasUndefinedLabels true) return true else 1:{}\n  2:(1) access __x1__ = (StatementListItem \"ContainsUndefinedBreakTarget\" labelSet)\n  2:return __x1__\n}"
  }, {
    "code": ["        1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of the first |Statement| with argument _labelSet_.", "        1. If _hasUndefinedLabels_ is *true*, return *true*.", "        1. Return ContainsUndefinedBreakTarget of the second |Statement| with argument _labelSet_."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "IfStatement",
      "rhs": {
        "tokens": [{
          "term": "if"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }, {
          "term": "else"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement0 \"ContainsUndefinedBreakTarget\" labelSet)\n  0:let hasUndefinedLabels = __x0__\n  1:if (= hasUndefinedLabels true) return true else 1:{}\n  2:(1) access __x1__ = (Statement1 \"ContainsUndefinedBreakTarget\" labelSet)\n  2:return __x1__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 1,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "IfStatement",
      "rhs": {
        "tokens": [{
          "term": "if"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedBreakTarget\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "DoWhileStatement",
      "rhs": {
        "tokens": [{
          "term": "do"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }, {
          "term": "while"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedBreakTarget\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "WhileStatement",
      "rhs": {
        "tokens": [{
          "term": "while"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedBreakTarget\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "ForStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 7,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedBreakTarget\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 1,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "ForStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "VariableDeclarationList",
          "optional": false
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 3,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedBreakTarget\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 2,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "ForStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LexicalDeclaration",
          "optional": false
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 3,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedBreakTarget\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedBreakTarget\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 1,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "ForBinding",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedBreakTarget\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 2,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "ForDeclaration",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedBreakTarget\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 3,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedBreakTarget\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 4,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "ForBinding",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedBreakTarget\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 5,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "ForDeclaration",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedBreakTarget\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 6,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "await"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedBreakTarget\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 7,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "await"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "ForBinding",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedBreakTarget\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 8,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "await"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "ForDeclaration",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedBreakTarget\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "BreakStatement",
      "rhs": {
        "tokens": [{
          "term": "break"
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "return false"
  }, {
    "code": ["        1. If the StringValue of |LabelIdentifier| is not an element of _labelSet_, return *true*.", "        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "BreakStatement",
      "rhs": {
        "tokens": [{
          "term": "break"
        }, {
          "args": [],
          "name": "LabelIdentifier",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "{\n  0:(0) access __x0__ = (LabelIdentifier \"StringValue\")\n  0:if (! (contains labelSet __x0__)) return true else 1:{}\n  1:return false\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "WithStatement",
      "rhs": {
        "tokens": [{
          "term": "with"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedBreakTarget\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedBreakTarget of |CaseBlock| with argument _labelSet_."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "SwitchStatement",
      "rhs": {
        "tokens": [{
          "term": "switch"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "CaseBlock",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "{\n  0:(0) access __x0__ = (CaseBlock \"ContainsUndefinedBreakTarget\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "CaseBlock",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "return false"
  }, {
    "code": ["        1. If the first |CaseClauses| is present, then", "          1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of the first |CaseClauses| with argument _labelSet_.", "          1. If _hasUndefinedLabels_ is *true*, return *true*.", "        1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |DefaultClause| with argument _labelSet_.", "        1. If _hasUndefinedLabels_ is *true*, return *true*.", "        1. If the second |CaseClauses| is not present, return *false*.", "        1. Return ContainsUndefinedBreakTarget of the second |CaseClauses| with argument _labelSet_."],
    "head": {
      "idx": 1,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "CaseBlock",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "CaseClauses",
          "optional": true
        }, {
          "args": [],
          "name": "DefaultClause",
          "optional": false
        }, {
          "args": [],
          "name": "CaseClauses",
          "optional": true
        }, {
          "term": "}"
        }]
      },
      "subIdx": 3,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "{\n  0:if (! (= CaseClauses0 absent)) {\n    1:(0) access __x0__ = (CaseClauses0 \"ContainsUndefinedBreakTarget\" labelSet)\n    1:let hasUndefinedLabels = __x0__\n    2:if (= hasUndefinedLabels true) return true else 1:{}\n  } else 1:{}\n  3:(1) access __x1__ = (DefaultClause \"ContainsUndefinedBreakTarget\" labelSet)\n  3:let hasUndefinedLabels = __x1__\n  4:if (= hasUndefinedLabels true) return true else 1:{}\n  5:if (= CaseClauses1 absent) return false else 1:{}\n  6:(2) access __x2__ = (CaseClauses1 \"ContainsUndefinedBreakTarget\" labelSet)\n  6:return __x2__\n}"
  }, {
    "code": ["        1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |CaseClauses| with argument _labelSet_.", "        1. If _hasUndefinedLabels_ is *true*, return *true*.", "        1. Return ContainsUndefinedBreakTarget of |CaseClause| with argument _labelSet_."],
    "head": {
      "idx": 1,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "CaseClauses",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CaseClauses",
          "optional": false
        }, {
          "args": [],
          "name": "CaseClause",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "{\n  0:(0) access __x0__ = (CaseClauses \"ContainsUndefinedBreakTarget\" labelSet)\n  0:let hasUndefinedLabels = __x0__\n  1:if (= hasUndefinedLabels true) return true else 1:{}\n  2:(1) access __x1__ = (CaseClause \"ContainsUndefinedBreakTarget\" labelSet)\n  2:return __x1__\n}"
  }, {
    "code": ["        1. If the |StatementList| is present, return ContainsUndefinedBreakTarget of |StatementList| with argument _labelSet_.", "        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "CaseClause",
      "rhs": {
        "tokens": [{
          "term": "case"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "StatementList",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "{\n  0:if (! (= StatementList absent)) {\n    (0) access __x0__ = (StatementList \"ContainsUndefinedBreakTarget\" labelSet)\n    return __x0__\n  } else 1:{}\n  1:return false\n}"
  }, {
    "code": ["        1. If the |StatementList| is present, return ContainsUndefinedBreakTarget of |StatementList| with argument _labelSet_.", "        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "DefaultClause",
      "rhs": {
        "tokens": [{
          "term": "default"
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "StatementList",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "{\n  0:if (! (= StatementList absent)) {\n    (0) access __x0__ = (StatementList \"ContainsUndefinedBreakTarget\" labelSet)\n    return __x0__\n  } else 1:{}\n  1:return false\n}"
  }, {
    "code": ["        1. Let _label_ be the StringValue of |LabelIdentifier|.", "        1. Let _newLabelSet_ be a copy of _labelSet_ with _label_ appended.", "        1. Return ContainsUndefinedBreakTarget of |LabelledItem| with argument _newLabelSet_."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "LabelledStatement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LabelIdentifier",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "LabelledItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "{\n  0:(0) access __x0__ = (LabelIdentifier \"StringValue\")\n  0:let label = __x0__\n  1:let __x1__ = (0) (copy-obj labelSet)\n  1:append label -> __x1__\n  1:let newLabelSet = __x1__\n  2:(1) access __x2__ = (LabelledItem \"ContainsUndefinedBreakTarget\" newLabelSet)\n  2:return __x2__\n}"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "LabelledItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FunctionDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "return false"
  }, {
    "code": ["        1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |Block| with argument _labelSet_.", "        1. If _hasUndefinedLabels_ is *true*, return *true*.", "        1. Return ContainsUndefinedBreakTarget of |Catch| with argument _labelSet_."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "TryStatement",
      "rhs": {
        "tokens": [{
          "term": "try"
        }, {
          "args": [],
          "name": "Block",
          "optional": false
        }, {
          "args": [],
          "name": "Catch",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Block \"ContainsUndefinedBreakTarget\" labelSet)\n  0:let hasUndefinedLabels = __x0__\n  1:if (= hasUndefinedLabels true) return true else 1:{}\n  2:(1) access __x1__ = (Catch \"ContainsUndefinedBreakTarget\" labelSet)\n  2:return __x1__\n}"
  }, {
    "code": ["        1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |Block| with argument _labelSet_.", "        1. If _hasUndefinedLabels_ is *true*, return *true*.", "        1. Return ContainsUndefinedBreakTarget of |Finally| with argument _labelSet_."],
    "head": {
      "idx": 1,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "TryStatement",
      "rhs": {
        "tokens": [{
          "term": "try"
        }, {
          "args": [],
          "name": "Block",
          "optional": false
        }, {
          "args": [],
          "name": "Finally",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Block \"ContainsUndefinedBreakTarget\" labelSet)\n  0:let hasUndefinedLabels = __x0__\n  1:if (= hasUndefinedLabels true) return true else 1:{}\n  2:(1) access __x1__ = (Finally \"ContainsUndefinedBreakTarget\" labelSet)\n  2:return __x1__\n}"
  }, {
    "code": ["        1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |Block| with argument _labelSet_.", "        1. If _hasUndefinedLabels_ is *true*, return *true*.", "        1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |Catch| with argument _labelSet_.", "        1. If _hasUndefinedLabels_ is *true*, return *true*.", "        1. Return ContainsUndefinedBreakTarget of |Finally| with argument _labelSet_."],
    "head": {
      "idx": 2,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "TryStatement",
      "rhs": {
        "tokens": [{
          "term": "try"
        }, {
          "args": [],
          "name": "Block",
          "optional": false
        }, {
          "args": [],
          "name": "Catch",
          "optional": false
        }, {
          "args": [],
          "name": "Finally",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Block \"ContainsUndefinedBreakTarget\" labelSet)\n  0:let hasUndefinedLabels = __x0__\n  1:if (= hasUndefinedLabels true) return true else 1:{}\n  2:(1) access __x1__ = (Catch \"ContainsUndefinedBreakTarget\" labelSet)\n  2:let hasUndefinedLabels = __x1__\n  3:if (= hasUndefinedLabels true) return true else 1:{}\n  4:(2) access __x2__ = (Finally \"ContainsUndefinedBreakTarget\" labelSet)\n  4:return __x2__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedBreakTarget of |Block| with argument _labelSet_."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "Catch",
      "rhs": {
        "tokens": [{
          "term": "catch"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "CatchParameter",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Block",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Block \"ContainsUndefinedBreakTarget\" labelSet)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "FunctionStatementList",
      "rhs": {
        "tokens": [{
          "empty": null
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "return false"
  }, {
    "code": ["        1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |ModuleItemList| with argument _labelSet_.", "        1. If _hasUndefinedLabels_ is *true*, return *true*.", "        1. Return ContainsUndefinedBreakTarget of |ModuleItem| with argument _labelSet_."],
    "head": {
      "idx": 1,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "ModuleItemList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ModuleItemList",
          "optional": false
        }, {
          "args": [],
          "name": "ModuleItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "{\n  0:(0) access __x0__ = (ModuleItemList \"ContainsUndefinedBreakTarget\" labelSet)\n  0:let hasUndefinedLabels = __x0__\n  1:if (= hasUndefinedLabels true) return true else 1:{}\n  2:(1) access __x1__ = (ModuleItem \"ContainsUndefinedBreakTarget\" labelSet)\n  2:return __x1__\n}"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "ModuleItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ImportDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "ContainsUndefinedBreakTarget",
      "prod": "ModuleItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExportDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedbreaktarget",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "VariableStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "EmptyStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 3,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExpressionStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 7,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BreakStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 8,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ReturnStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 11,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ThrowStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 13,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "DebuggerStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "Block",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "StatementListItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Declaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "return false"
  }, {
    "code": ["        1. Let _newIterationSet_ be a copy of _iterationSet_ with all the elements of _labelSet_ appended.", "        1. Return ContainsUndefinedContinueTarget of |IterationStatement| with arguments _newIterationSet_ and « »."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "BreakableStatement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "IterationStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:let __x0__ = (0) (copy-obj iterationSet)\n  0:let __x1__ = labelSet\n  0:let __x2__ = 0i\n  0:while (< __x2__ __x1__[\"length\"]) {\n    let __x3__ = __x1__[__x2__]\n    append __x3__ -> __x0__\n    __x2__ = (+ __x2__ 1i)\n  }\n  0:let newIterationSet = __x0__\n  1:(0) access __x4__ = (IterationStatement \"ContainsUndefinedContinueTarget\" newIterationSet (1) (new []))\n  1:return __x4__\n}"
  }, {
    "code": ["        1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |StatementList| with arguments _iterationSet_ and « ».", "        1. If _hasUndefinedLabels_ is *true*, return *true*.", "        1. Return ContainsUndefinedContinueTarget of |StatementListItem| with arguments _iterationSet_ and « »."],
    "head": {
      "idx": 1,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "StatementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StatementList",
          "optional": false
        }, {
          "args": [],
          "name": "StatementListItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:(0) access __x0__ = (StatementList \"ContainsUndefinedContinueTarget\" iterationSet (0) (new []))\n  0:let hasUndefinedLabels = __x0__\n  1:if (= hasUndefinedLabels true) return true else 1:{}\n  2:(1) access __x1__ = (StatementListItem \"ContainsUndefinedContinueTarget\" iterationSet (1) (new []))\n  2:return __x1__\n}"
  }, {
    "code": ["        1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of the first |Statement| with arguments _iterationSet_ and « ».", "        1. If _hasUndefinedLabels_ is *true*, return *true*.", "        1. Return ContainsUndefinedContinueTarget of the second |Statement| with arguments _iterationSet_ and « »."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "IfStatement",
      "rhs": {
        "tokens": [{
          "term": "if"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }, {
          "term": "else"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement0 \"ContainsUndefinedContinueTarget\" iterationSet (0) (new []))\n  0:let hasUndefinedLabels = __x0__\n  1:if (= hasUndefinedLabels true) return true else 1:{}\n  2:(1) access __x1__ = (Statement1 \"ContainsUndefinedContinueTarget\" iterationSet (1) (new []))\n  2:return __x1__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « »."],
    "head": {
      "idx": 1,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "IfStatement",
      "rhs": {
        "tokens": [{
          "term": "if"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedContinueTarget\" iterationSet (0) (new []))\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « »."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "DoWhileStatement",
      "rhs": {
        "tokens": [{
          "term": "do"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }, {
          "term": "while"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedContinueTarget\" iterationSet (0) (new []))\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « »."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "WhileStatement",
      "rhs": {
        "tokens": [{
          "term": "while"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedContinueTarget\" iterationSet (0) (new []))\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « »."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "ForStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 7,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedContinueTarget\" iterationSet (0) (new []))\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « »."],
    "head": {
      "idx": 1,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "ForStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "VariableDeclarationList",
          "optional": false
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 3,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedContinueTarget\" iterationSet (0) (new []))\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « »."],
    "head": {
      "idx": 2,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "ForStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LexicalDeclaration",
          "optional": false
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 3,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedContinueTarget\" iterationSet (0) (new []))\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « »."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedContinueTarget\" iterationSet (0) (new []))\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « »."],
    "head": {
      "idx": 1,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "ForBinding",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedContinueTarget\" iterationSet (0) (new []))\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « »."],
    "head": {
      "idx": 2,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "ForDeclaration",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedContinueTarget\" iterationSet (0) (new []))\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « »."],
    "head": {
      "idx": 3,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedContinueTarget\" iterationSet (0) (new []))\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « »."],
    "head": {
      "idx": 4,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "ForBinding",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedContinueTarget\" iterationSet (0) (new []))\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « »."],
    "head": {
      "idx": 5,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "ForDeclaration",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedContinueTarget\" iterationSet (0) (new []))\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « »."],
    "head": {
      "idx": 6,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "await"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedContinueTarget\" iterationSet (0) (new []))\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « »."],
    "head": {
      "idx": 7,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "await"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "ForBinding",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedContinueTarget\" iterationSet (0) (new []))\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « »."],
    "head": {
      "idx": 8,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "await"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "ForDeclaration",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedContinueTarget\" iterationSet (0) (new []))\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "ContinueStatement",
      "rhs": {
        "tokens": [{
          "term": "continue"
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "return false"
  }, {
    "code": ["        1. If the StringValue of |LabelIdentifier| is not an element of _iterationSet_, return *true*.", "        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "ContinueStatement",
      "rhs": {
        "tokens": [{
          "term": "continue"
        }, {
          "args": [],
          "name": "LabelIdentifier",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:(0) access __x0__ = (LabelIdentifier \"StringValue\")\n  0:if (! (contains iterationSet __x0__)) return true else 1:{}\n  1:return false\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « »."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "WithStatement",
      "rhs": {
        "tokens": [{
          "term": "with"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"ContainsUndefinedContinueTarget\" iterationSet (0) (new []))\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedContinueTarget of |CaseBlock| with arguments _iterationSet_ and « »."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "SwitchStatement",
      "rhs": {
        "tokens": [{
          "term": "switch"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "CaseBlock",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:(0) access __x0__ = (CaseBlock \"ContainsUndefinedContinueTarget\" iterationSet (0) (new []))\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "CaseBlock",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "return false"
  }, {
    "code": ["        1. If the first |CaseClauses| is present, then", "          1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of the first |CaseClauses| with arguments _iterationSet_ and « ».", "          1. If _hasUndefinedLabels_ is *true*, return *true*.", "        1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |DefaultClause| with arguments _iterationSet_ and « ».", "        1. If _hasUndefinedLabels_ is *true*, return *true*.", "        1. If the second |CaseClauses| is not present, return *false*.", "        1. Return ContainsUndefinedContinueTarget of the second |CaseClauses| with arguments _iterationSet_ and « »."],
    "head": {
      "idx": 1,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "CaseBlock",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "CaseClauses",
          "optional": true
        }, {
          "args": [],
          "name": "DefaultClause",
          "optional": false
        }, {
          "args": [],
          "name": "CaseClauses",
          "optional": true
        }, {
          "term": "}"
        }]
      },
      "subIdx": 3,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:if (! (= CaseClauses0 absent)) {\n    1:(0) access __x0__ = (CaseClauses0 \"ContainsUndefinedContinueTarget\" iterationSet (0) (new []))\n    1:let hasUndefinedLabels = __x0__\n    2:if (= hasUndefinedLabels true) return true else 1:{}\n  } else 1:{}\n  3:(1) access __x1__ = (DefaultClause \"ContainsUndefinedContinueTarget\" iterationSet (1) (new []))\n  3:let hasUndefinedLabels = __x1__\n  4:if (= hasUndefinedLabels true) return true else 1:{}\n  5:if (= CaseClauses1 absent) return false else 1:{}\n  6:(2) access __x2__ = (CaseClauses1 \"ContainsUndefinedContinueTarget\" iterationSet (2) (new []))\n  6:return __x2__\n}"
  }, {
    "code": ["        1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |CaseClauses| with arguments _iterationSet_ and « ».", "        1. If _hasUndefinedLabels_ is *true*, return *true*.", "        1. Return ContainsUndefinedContinueTarget of |CaseClause| with arguments _iterationSet_ and « »."],
    "head": {
      "idx": 1,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "CaseClauses",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CaseClauses",
          "optional": false
        }, {
          "args": [],
          "name": "CaseClause",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:(0) access __x0__ = (CaseClauses \"ContainsUndefinedContinueTarget\" iterationSet (0) (new []))\n  0:let hasUndefinedLabels = __x0__\n  1:if (= hasUndefinedLabels true) return true else 1:{}\n  2:(1) access __x1__ = (CaseClause \"ContainsUndefinedContinueTarget\" iterationSet (1) (new []))\n  2:return __x1__\n}"
  }, {
    "code": ["        1. If the |StatementList| is present, return ContainsUndefinedContinueTarget of |StatementList| with arguments _iterationSet_ and « ».", "        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "CaseClause",
      "rhs": {
        "tokens": [{
          "term": "case"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "StatementList",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:if (! (= StatementList absent)) {\n    (0) access __x0__ = (StatementList \"ContainsUndefinedContinueTarget\" iterationSet (0) (new []))\n    return __x0__\n  } else 1:{}\n  1:return false\n}"
  }, {
    "code": ["        1. If the |StatementList| is present, return ContainsUndefinedContinueTarget of |StatementList| with arguments _iterationSet_ and « ».", "        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "DefaultClause",
      "rhs": {
        "tokens": [{
          "term": "default"
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "StatementList",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:if (! (= StatementList absent)) {\n    (0) access __x0__ = (StatementList \"ContainsUndefinedContinueTarget\" iterationSet (0) (new []))\n    return __x0__\n  } else 1:{}\n  1:return false\n}"
  }, {
    "code": ["        1. Let _label_ be the StringValue of |LabelIdentifier|.", "        1. Let _newLabelSet_ be a copy of _labelSet_ with _label_ appended.", "        1. Return ContainsUndefinedContinueTarget of |LabelledItem| with arguments _iterationSet_ and _newLabelSet_."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "LabelledStatement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LabelIdentifier",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "LabelledItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:(0) access __x0__ = (LabelIdentifier \"StringValue\")\n  0:let label = __x0__\n  1:let __x1__ = (0) (copy-obj labelSet)\n  1:append label -> __x1__\n  1:let newLabelSet = __x1__\n  2:(1) access __x2__ = (LabelledItem \"ContainsUndefinedContinueTarget\" iterationSet newLabelSet)\n  2:return __x2__\n}"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "LabelledItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FunctionDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "return false"
  }, {
    "code": ["        1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |Block| with arguments _iterationSet_ and « ».", "        1. If _hasUndefinedLabels_ is *true*, return *true*.", "        1. Return ContainsUndefinedContinueTarget of |Catch| with arguments _iterationSet_ and « »."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "TryStatement",
      "rhs": {
        "tokens": [{
          "term": "try"
        }, {
          "args": [],
          "name": "Block",
          "optional": false
        }, {
          "args": [],
          "name": "Catch",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Block \"ContainsUndefinedContinueTarget\" iterationSet (0) (new []))\n  0:let hasUndefinedLabels = __x0__\n  1:if (= hasUndefinedLabels true) return true else 1:{}\n  2:(1) access __x1__ = (Catch \"ContainsUndefinedContinueTarget\" iterationSet (1) (new []))\n  2:return __x1__\n}"
  }, {
    "code": ["        1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |Block| with arguments _iterationSet_ and « ».", "        1. If _hasUndefinedLabels_ is *true*, return *true*.", "        1. Return ContainsUndefinedContinueTarget of |Finally| with arguments _iterationSet_ and « »."],
    "head": {
      "idx": 1,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "TryStatement",
      "rhs": {
        "tokens": [{
          "term": "try"
        }, {
          "args": [],
          "name": "Block",
          "optional": false
        }, {
          "args": [],
          "name": "Finally",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Block \"ContainsUndefinedContinueTarget\" iterationSet (0) (new []))\n  0:let hasUndefinedLabels = __x0__\n  1:if (= hasUndefinedLabels true) return true else 1:{}\n  2:(1) access __x1__ = (Finally \"ContainsUndefinedContinueTarget\" iterationSet (1) (new []))\n  2:return __x1__\n}"
  }, {
    "code": ["        1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |Block| with arguments _iterationSet_ and « ».", "        1. If _hasUndefinedLabels_ is *true*, return *true*.", "        1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |Catch| with arguments _iterationSet_ and « ».", "        1. If _hasUndefinedLabels_ is *true*, return *true*.", "        1. Return ContainsUndefinedContinueTarget of |Finally| with arguments _iterationSet_ and « »."],
    "head": {
      "idx": 2,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "TryStatement",
      "rhs": {
        "tokens": [{
          "term": "try"
        }, {
          "args": [],
          "name": "Block",
          "optional": false
        }, {
          "args": [],
          "name": "Catch",
          "optional": false
        }, {
          "args": [],
          "name": "Finally",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Block \"ContainsUndefinedContinueTarget\" iterationSet (0) (new []))\n  0:let hasUndefinedLabels = __x0__\n  1:if (= hasUndefinedLabels true) return true else 1:{}\n  2:(1) access __x1__ = (Catch \"ContainsUndefinedContinueTarget\" iterationSet (1) (new []))\n  2:let hasUndefinedLabels = __x1__\n  3:if (= hasUndefinedLabels true) return true else 1:{}\n  4:(2) access __x2__ = (Finally \"ContainsUndefinedContinueTarget\" iterationSet (2) (new []))\n  4:return __x2__\n}"
  }, {
    "code": ["        1. Return ContainsUndefinedContinueTarget of |Block| with arguments _iterationSet_ and « »."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "Catch",
      "rhs": {
        "tokens": [{
          "term": "catch"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "CatchParameter",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Block",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:(0) access __x0__ = (Block \"ContainsUndefinedContinueTarget\" iterationSet (0) (new []))\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "FunctionStatementList",
      "rhs": {
        "tokens": [{
          "empty": null
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "return false"
  }, {
    "code": ["        1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |ModuleItemList| with arguments _iterationSet_ and « ».", "        1. If _hasUndefinedLabels_ is *true*, return *true*.", "        1. Return ContainsUndefinedContinueTarget of |ModuleItem| with arguments _iterationSet_ and « »."],
    "head": {
      "idx": 1,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "ModuleItemList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ModuleItemList",
          "optional": false
        }, {
          "args": [],
          "name": "ModuleItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "{\n  0:(0) access __x0__ = (ModuleItemList \"ContainsUndefinedContinueTarget\" iterationSet (0) (new []))\n  0:let hasUndefinedLabels = __x0__\n  1:if (= hasUndefinedLabels true) return true else 1:{}\n  2:(1) access __x1__ = (ModuleItem \"ContainsUndefinedContinueTarget\" iterationSet (1) (new []))\n  2:return __x1__\n}"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "ModuleItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ImportDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "ContainsUndefinedContinueTarget",
      "prod": "ModuleItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExportDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iterationSet"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-static-semantics-containsundefinedcontinuetarget",
    "rawBody": "return false"
  }, {
    "code": ["        1. Let _expr_ be CoveredParenthesizedExpression of |CoverParenthesizedExpressionAndArrowParameterList|.", "        1. If IsFunctionDefinition of _expr_ is *false*, return *false*.", "        1. Return HasName of _expr_."],
    "head": {
      "idx": 12,
      "methodName": "HasName",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CoverParenthesizedExpressionAndArrowParameterList",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-hasname",
    "rawBody": "{\n  0:(0) access __x0__ = (CoverParenthesizedExpressionAndArrowParameterList \"CoveredParenthesizedExpression\")\n  0:let expr = __x0__\n  1:(1) access __x1__ = (expr \"IsFunctionDefinition\")\n  1:if (= __x1__ false) return false else 1:{}\n  2:(2) access __x2__ = (expr \"HasName\")\n  2:return __x2__\n}"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "HasName",
      "prod": "FunctionExpression",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-hasname",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "HasName",
      "prod": "GeneratorExpression",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "*"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-hasname",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "HasName",
      "prod": "AsyncGeneratorExpression",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "*"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-hasname",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "HasName",
      "prod": "AsyncFunctionExpression",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-hasname",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "HasName",
      "prod": "ArrowFunction",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ArrowParameters",
          "optional": false
        }, {
          "term": "=>"
        }, {
          "args": [],
          "name": "ConciseBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-hasname",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "HasName",
      "prod": "AsyncArrowFunction",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "args": [],
          "name": "AsyncArrowBindingIdentifier",
          "optional": false
        }, {
          "term": "=>"
        }, {
          "args": [],
          "name": "AsyncConciseBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-hasname",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "HasName",
      "prod": "AsyncArrowFunction",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CoverCallExpressionAndAsyncArrowHead",
          "optional": false
        }, {
          "term": "=>"
        }, {
          "args": [],
          "name": "AsyncConciseBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-hasname",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "HasName",
      "prod": "ClassExpression",
      "rhs": {
        "tokens": [{
          "term": "class"
        }, {
          "args": [],
          "name": "ClassTail",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-hasname",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *true*."],
    "head": {
      "idx": 0,
      "methodName": "HasName",
      "prod": "FunctionExpression",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-hasname",
    "rawBody": "return true"
  }, {
    "code": ["        1. Return *true*."],
    "head": {
      "idx": 0,
      "methodName": "HasName",
      "prod": "GeneratorExpression",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-hasname",
    "rawBody": "return true"
  }, {
    "code": ["        1. Return *true*."],
    "head": {
      "idx": 0,
      "methodName": "HasName",
      "prod": "AsyncGeneratorExpression",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-hasname",
    "rawBody": "return true"
  }, {
    "code": ["        1. Return *true*."],
    "head": {
      "idx": 0,
      "methodName": "HasName",
      "prod": "AsyncFunctionExpression",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-hasname",
    "rawBody": "return true"
  }, {
    "code": ["        1. Return *true*."],
    "head": {
      "idx": 0,
      "methodName": "HasName",
      "prod": "ClassExpression",
      "rhs": {
        "tokens": [{
          "term": "class"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "args": [],
          "name": "ClassTail",
          "optional": false
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-hasname",
    "rawBody": "return true"
  }, {
    "code": ["        1. Let _expr_ be CoveredParenthesizedExpression of |CoverParenthesizedExpressionAndArrowParameterList|.", "        1. Return IsFunctionDefinition of _expr_."],
    "head": {
      "idx": 12,
      "methodName": "IsFunctionDefinition",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CoverParenthesizedExpressionAndArrowParameterList",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "{\n  0:(0) access __x0__ = (CoverParenthesizedExpressionAndArrowParameterList \"CoveredParenthesizedExpression\")\n  0:let expr = __x0__\n  1:(1) access __x1__ = (expr \"IsFunctionDefinition\")\n  1:return __x1__\n}"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "IsFunctionDefinition",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "term": "this"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsFunctionDefinition",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "IdentifierReference",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "IsFunctionDefinition",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Literal",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 3,
      "methodName": "IsFunctionDefinition",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ArrayLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 4,
      "methodName": "IsFunctionDefinition",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ObjectLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 10,
      "methodName": "IsFunctionDefinition",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RegularExpressionLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 11,
      "methodName": "IsFunctionDefinition",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "TemplateLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsFunctionDefinition",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "term": "["
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": "]"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "IsFunctionDefinition",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "term": "."
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 3,
      "methodName": "IsFunctionDefinition",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "args": [],
          "name": "TemplateLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 4,
      "methodName": "IsFunctionDefinition",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "SuperProperty",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 5,
      "methodName": "IsFunctionDefinition",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MetaProperty",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 6,
      "methodName": "IsFunctionDefinition",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "term": "new"
        }, {
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "args": [],
          "name": "Arguments",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsFunctionDefinition",
      "prod": "NewExpression",
      "rhs": {
        "tokens": [{
          "term": "new"
        }, {
          "args": [],
          "name": "NewExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsFunctionDefinition",
      "prod": "LeftHandSideExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CallExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "IsFunctionDefinition",
      "prod": "LeftHandSideExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "OptionalExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsFunctionDefinition",
      "prod": "UpdateExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "++"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "IsFunctionDefinition",
      "prod": "UpdateExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "--"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 3,
      "methodName": "IsFunctionDefinition",
      "prod": "UpdateExpression",
      "rhs": {
        "tokens": [{
          "term": "++"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 4,
      "methodName": "IsFunctionDefinition",
      "prod": "UpdateExpression",
      "rhs": {
        "tokens": [{
          "term": "--"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsFunctionDefinition",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "term": "delete"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "IsFunctionDefinition",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "term": "void"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 3,
      "methodName": "IsFunctionDefinition",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "term": "typeof"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 4,
      "methodName": "IsFunctionDefinition",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "term": "+"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 5,
      "methodName": "IsFunctionDefinition",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "term": "-"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 6,
      "methodName": "IsFunctionDefinition",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "term": "~"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 7,
      "methodName": "IsFunctionDefinition",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "term": "!"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 8,
      "methodName": "IsFunctionDefinition",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AwaitExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsFunctionDefinition",
      "prod": "ExponentiationExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "UpdateExpression",
          "optional": false
        }, {
          "term": "**"
        }, {
          "args": [],
          "name": "ExponentiationExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsFunctionDefinition",
      "prod": "MultiplicativeExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MultiplicativeExpression",
          "optional": false
        }, {
          "args": [],
          "name": "MultiplicativeOperator",
          "optional": false
        }, {
          "args": [],
          "name": "ExponentiationExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsFunctionDefinition",
      "prod": "AdditiveExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AdditiveExpression",
          "optional": false
        }, {
          "term": "+"
        }, {
          "args": [],
          "name": "MultiplicativeExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "IsFunctionDefinition",
      "prod": "AdditiveExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AdditiveExpression",
          "optional": false
        }, {
          "term": "-"
        }, {
          "args": [],
          "name": "MultiplicativeExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsFunctionDefinition",
      "prod": "ShiftExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }, {
          "term": "<<"
        }, {
          "args": [],
          "name": "AdditiveExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "IsFunctionDefinition",
      "prod": "ShiftExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }, {
          "term": ">>"
        }, {
          "args": [],
          "name": "AdditiveExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 3,
      "methodName": "IsFunctionDefinition",
      "prod": "ShiftExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }, {
          "term": ">>>"
        }, {
          "args": [],
          "name": "AdditiveExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsFunctionDefinition",
      "prod": "RelationalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }, {
          "term": "<"
        }, {
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "IsFunctionDefinition",
      "prod": "RelationalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }, {
          "term": ">"
        }, {
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 3,
      "methodName": "IsFunctionDefinition",
      "prod": "RelationalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }, {
          "term": "<="
        }, {
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 4,
      "methodName": "IsFunctionDefinition",
      "prod": "RelationalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }, {
          "term": ">="
        }, {
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 5,
      "methodName": "IsFunctionDefinition",
      "prod": "RelationalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }, {
          "term": "instanceof"
        }, {
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 6,
      "methodName": "IsFunctionDefinition",
      "prod": "RelationalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsFunctionDefinition",
      "prod": "EqualityExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "EqualityExpression",
          "optional": false
        }, {
          "term": "=="
        }, {
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "IsFunctionDefinition",
      "prod": "EqualityExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "EqualityExpression",
          "optional": false
        }, {
          "term": "!="
        }, {
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 3,
      "methodName": "IsFunctionDefinition",
      "prod": "EqualityExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "EqualityExpression",
          "optional": false
        }, {
          "term": "==="
        }, {
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 4,
      "methodName": "IsFunctionDefinition",
      "prod": "EqualityExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "EqualityExpression",
          "optional": false
        }, {
          "term": "!=="
        }, {
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsFunctionDefinition",
      "prod": "BitwiseANDExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BitwiseANDExpression",
          "optional": false
        }, {
          "term": "&"
        }, {
          "args": [],
          "name": "EqualityExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsFunctionDefinition",
      "prod": "BitwiseXORExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BitwiseXORExpression",
          "optional": false
        }, {
          "term": "^"
        }, {
          "args": [],
          "name": "BitwiseANDExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsFunctionDefinition",
      "prod": "BitwiseORExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BitwiseORExpression",
          "optional": false
        }, {
          "term": "|"
        }, {
          "args": [],
          "name": "BitwiseXORExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsFunctionDefinition",
      "prod": "LogicalANDExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LogicalANDExpression",
          "optional": false
        }, {
          "term": "&&"
        }, {
          "args": [],
          "name": "BitwiseORExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsFunctionDefinition",
      "prod": "LogicalORExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LogicalORExpression",
          "optional": false
        }, {
          "term": "||"
        }, {
          "args": [],
          "name": "LogicalANDExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "IsFunctionDefinition",
      "prod": "CoalesceExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CoalesceExpressionHead",
          "optional": false
        }, {
          "term": "??"
        }, {
          "args": [],
          "name": "BitwiseORExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsFunctionDefinition",
      "prod": "ConditionalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ShortCircuitExpression",
          "optional": false
        }, {
          "term": "?"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsFunctionDefinition",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "YieldExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 4,
      "methodName": "IsFunctionDefinition",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "="
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 5,
      "methodName": "IsFunctionDefinition",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "args": [],
          "name": "AssignmentOperator",
          "optional": false
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 6,
      "methodName": "IsFunctionDefinition",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "&&="
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 7,
      "methodName": "IsFunctionDefinition",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "||="
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 8,
      "methodName": "IsFunctionDefinition",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "??="
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsFunctionDefinition",
      "prod": "Expression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *true*."],
    "head": {
      "idx": 2,
      "methodName": "IsFunctionDefinition",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ArrowFunction",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return true"
  }, {
    "code": ["        1. Return *true*."],
    "head": {
      "idx": 3,
      "methodName": "IsFunctionDefinition",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AsyncArrowFunction",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return true"
  }, {
    "code": ["        1. Return *true*."],
    "head": {
      "idx": 0,
      "methodName": "IsFunctionDefinition",
      "prod": "FunctionExpression",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": true
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return true"
  }, {
    "code": ["        1. Return *true*."],
    "head": {
      "idx": 0,
      "methodName": "IsFunctionDefinition",
      "prod": "GeneratorExpression",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": true
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return true"
  }, {
    "code": ["        1. Return *true*."],
    "head": {
      "idx": 0,
      "methodName": "IsFunctionDefinition",
      "prod": "AsyncGeneratorExpression",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": true
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return true"
  }, {
    "code": ["        1. Return *true*."],
    "head": {
      "idx": 0,
      "methodName": "IsFunctionDefinition",
      "prod": "AsyncFunctionExpression",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": true
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return true"
  }, {
    "code": ["        1. Return *true*."],
    "head": {
      "idx": 0,
      "methodName": "IsFunctionDefinition",
      "prod": "ClassExpression",
      "rhs": {
        "tokens": [{
          "term": "class"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": true
        }, {
          "args": [],
          "name": "ClassTail",
          "optional": false
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-isfunctiondefinition",
    "rawBody": "return true"
  }, {
    "code": ["        1. If IsFunctionDefinition of _expr_ is *false*, return *false*.", "        1. Let _hasName_ be HasName of _expr_.", "        1. If _hasName_ is *true*, return *false*.", "        1. Return *true*."],
    "head": {
      "name": "IsAnonymousFunctionDefinition",
      "params": [{
        "kind": "Normal",
        "name": "expr"
      }]
    },
    "ids": "sec-isanonymousfunctiondefinition",
    "rawBody": "{\n  0:(0) access __x0__ = (expr \"IsFunctionDefinition\")\n  0:if (= __x0__ false) return false else 1:{}\n  1:(1) access __x1__ = (expr \"HasName\")\n  1:let hasName = __x1__\n  2:if (= hasName true) return false else 1:{}\n  3:return true\n}"
  }, {
    "code": ["        1. Return *true*."],
    "head": {
      "idx": 1,
      "methodName": "IsIdentifierRef",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "IdentifierReference",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isidentifierref",
    "rawBody": "return true"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "IsIdentifierRef",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "term": "this"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isidentifierref",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "IsIdentifierRef",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Literal",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isidentifierref",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 3,
      "methodName": "IsIdentifierRef",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ArrayLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isidentifierref",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 4,
      "methodName": "IsIdentifierRef",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ObjectLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isidentifierref",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 5,
      "methodName": "IsIdentifierRef",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FunctionExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isidentifierref",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 6,
      "methodName": "IsIdentifierRef",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ClassExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isidentifierref",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 7,
      "methodName": "IsIdentifierRef",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "GeneratorExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isidentifierref",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 8,
      "methodName": "IsIdentifierRef",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AsyncFunctionExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isidentifierref",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 9,
      "methodName": "IsIdentifierRef",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AsyncGeneratorExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isidentifierref",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 10,
      "methodName": "IsIdentifierRef",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RegularExpressionLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isidentifierref",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 11,
      "methodName": "IsIdentifierRef",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "TemplateLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isidentifierref",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 12,
      "methodName": "IsIdentifierRef",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CoverParenthesizedExpressionAndArrowParameterList",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isidentifierref",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsIdentifierRef",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "term": "["
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": "]"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isidentifierref",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "IsIdentifierRef",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "term": "."
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isidentifierref",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 3,
      "methodName": "IsIdentifierRef",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "args": [],
          "name": "TemplateLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isidentifierref",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 4,
      "methodName": "IsIdentifierRef",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "SuperProperty",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isidentifierref",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 5,
      "methodName": "IsIdentifierRef",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MetaProperty",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isidentifierref",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 6,
      "methodName": "IsIdentifierRef",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "term": "new"
        }, {
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "args": [],
          "name": "Arguments",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isidentifierref",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsIdentifierRef",
      "prod": "NewExpression",
      "rhs": {
        "tokens": [{
          "term": "new"
        }, {
          "args": [],
          "name": "NewExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isidentifierref",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsIdentifierRef",
      "prod": "LeftHandSideExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CallExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isidentifierref",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "IsIdentifierRef",
      "prod": "LeftHandSideExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "OptionalExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isidentifierref",
    "rawBody": "return false"
  }, {
    "code": ["        1. Let _expr_ be CoveredParenthesizedExpression of |CoverParenthesizedExpressionAndArrowParameterList|.", "        1. Return the result of performing NamedEvaluation for _expr_ with argument _name_."],
    "head": {
      "idx": 12,
      "methodName": "NamedEvaluation",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CoverParenthesizedExpressionAndArrowParameterList",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "name"
      }]
    },
    "ids": "sec-runtime-semantics-namedevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (CoverParenthesizedExpressionAndArrowParameterList \"CoveredParenthesizedExpression\")\n  0:let expr = __x0__\n  1:(1) access __x1__ = (expr \"NamedEvaluation\" name)\n  1:return __x1__\n}"
  }, {
    "code": ["        1. Assert: IsAnonymousFunctionDefinition(|Expression|) is *true*.", "        1. Return the result of performing NamedEvaluation for |Expression| with argument _name_."],
    "head": {
      "idx": 0,
      "methodName": "NamedEvaluation",
      "prod": "ParenthesizedExpression",
      "rhs": {
        "tokens": [{
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "name"
      }]
    },
    "ids": "sec-runtime-semantics-namedevaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (IsAnonymousFunctionDefinition Expression)\n  0:assert (= __x0__ true)\n  1:(1) access __x1__ = (Expression \"NamedEvaluation\" name)\n  1:return __x1__\n}"
  }, {
    "code": ["        1. Return InstantiateOrdinaryFunctionExpression of |FunctionExpression| with argument _name_."],
    "head": {
      "idx": 0,
      "methodName": "NamedEvaluation",
      "prod": "FunctionExpression",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "name"
      }]
    },
    "ids": "sec-runtime-semantics-namedevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (FunctionExpression \"InstantiateOrdinaryFunctionExpression\" name)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return InstantiateGeneratorFunctionExpression of |GeneratorExpression| with argument _name_."],
    "head": {
      "idx": 0,
      "methodName": "NamedEvaluation",
      "prod": "GeneratorExpression",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "*"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "name"
      }]
    },
    "ids": "sec-runtime-semantics-namedevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (GeneratorExpression \"InstantiateGeneratorFunctionExpression\" name)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return InstantiateAsyncGeneratorFunctionExpression of |AsyncGeneratorExpression| with argument _name_."],
    "head": {
      "idx": 0,
      "methodName": "NamedEvaluation",
      "prod": "AsyncGeneratorExpression",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "*"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "name"
      }]
    },
    "ids": "sec-runtime-semantics-namedevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (AsyncGeneratorExpression \"InstantiateAsyncGeneratorFunctionExpression\" name)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return InstantiateAsyncFunctionExpression of |AsyncFunctionExpression| with argument _name_."],
    "head": {
      "idx": 0,
      "methodName": "NamedEvaluation",
      "prod": "AsyncFunctionExpression",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "name"
      }]
    },
    "ids": "sec-runtime-semantics-namedevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (AsyncFunctionExpression \"InstantiateAsyncFunctionExpression\" name)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return InstantiateArrowFunctionExpression of |ArrowFunction| with argument _name_."],
    "head": {
      "idx": 0,
      "methodName": "NamedEvaluation",
      "prod": "ArrowFunction",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ArrowParameters",
          "optional": false
        }, {
          "term": "=>"
        }, {
          "args": [],
          "name": "ConciseBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "name"
      }]
    },
    "ids": "sec-runtime-semantics-namedevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (ArrowFunction \"InstantiateArrowFunctionExpression\" name)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return InstantiateAsyncArrowFunctionExpression of |AsyncArrowFunction| with argument _name_."],
    "head": {
      "idx": 0,
      "methodName": "NamedEvaluation",
      "prod": "AsyncArrowFunction",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "args": [],
          "name": "AsyncArrowBindingIdentifier",
          "optional": false
        }, {
          "term": "=>"
        }, {
          "args": [],
          "name": "AsyncConciseBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "name"
      }]
    },
    "ids": "sec-runtime-semantics-namedevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (AsyncArrowFunction \"InstantiateAsyncArrowFunctionExpression\" name)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return InstantiateAsyncArrowFunctionExpression of |AsyncArrowFunction| with argument _name_."],
    "head": {
      "idx": 1,
      "methodName": "NamedEvaluation",
      "prod": "AsyncArrowFunction",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CoverCallExpressionAndAsyncArrowHead",
          "optional": false
        }, {
          "term": "=>"
        }, {
          "args": [],
          "name": "AsyncConciseBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "name"
      }]
    },
    "ids": "sec-runtime-semantics-namedevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (AsyncArrowFunction \"InstantiateAsyncArrowFunctionExpression\" name)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Let _value_ be the result of ClassDefinitionEvaluation of |ClassTail| with arguments *undefined* and _name_.", "        1. ReturnIfAbrupt(_value_).", "        1. Set _value_.[[SourceText]] to the source text matched by |ClassExpression|.", "        1. Return _value_."],
    "head": {
      "idx": 0,
      "methodName": "NamedEvaluation",
      "prod": "ClassExpression",
      "rhs": {
        "tokens": [{
          "term": "class"
        }, {
          "args": [],
          "name": "ClassTail",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "name"
      }]
    },
    "ids": "sec-runtime-semantics-namedevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (ClassTail \"ClassDefinitionEvaluation\" undefined name)\n  0:let value = __x0__\n  1:[? value]\n  2:value[\"SourceText\"] = (get-syntax ClassExpression)\n  3:return value\n}"
  }, {
    "code": ["        1. For each child node _child_ of this Parse Node, do", "          1. If _child_ is an instance of _symbol_, return *true*.", "          1. If _child_ is an instance of a nonterminal, then", "            1. Let _contained_ be the result of _child_ Contains _symbol_.", "            1. If _contained_ is *true*, return *true*.", "        1. Return *false*."],
    "head": {
      "name": "Contains",
      "params": []
    },
    "ids": "sec-static-semantics-contains",
    "rawBody": "{\n  0:(0) ??? \"For each child node id:{child} of this Parse Node , do in:{} out:{}\"\n  5:return false\n}"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "Contains",
      "prod": "FunctionDeclaration",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-contains",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "Contains",
      "prod": "FunctionDeclaration",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-contains",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "Contains",
      "prod": "FunctionExpression",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": true
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-contains",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "Contains",
      "prod": "GeneratorDeclaration",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-contains",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "Contains",
      "prod": "GeneratorDeclaration",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "*"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-contains",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "Contains",
      "prod": "GeneratorExpression",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": true
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-contains",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "Contains",
      "prod": "AsyncGeneratorDeclaration",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-contains",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "Contains",
      "prod": "AsyncGeneratorDeclaration",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "*"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-contains",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "Contains",
      "prod": "AsyncGeneratorExpression",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": true
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-contains",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "Contains",
      "prod": "AsyncFunctionDeclaration",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-contains",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "Contains",
      "prod": "AsyncFunctionDeclaration",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-contains",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "Contains",
      "prod": "AsyncFunctionExpression",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": true
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-contains",
    "rawBody": "return false"
  }, {
    "code": ["        1. If _symbol_ is |ClassBody|, return *true*.", "        1. If _symbol_ is |ClassHeritage|, then", "          1. If |ClassHeritage| is present, return *true*; otherwise return *false*.", "        1. Let _inHeritage_ be |ClassHeritage| Contains _symbol_.", "        1. If _inHeritage_ is *true*, return *true*.", "        1. Return the result of ComputedPropertyContains for |ClassBody| with argument _symbol_."],
    "head": {
      "idx": 0,
      "methodName": "Contains",
      "prod": "ClassTail",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ClassHeritage",
          "optional": true
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "ClassBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 3,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-contains",
    "rawBody": "{\n  0:if (0) (is-instance-of symbol ClassBody) return true else 1:{}\n  1:if (1) (is-instance-of symbol ClassHeritage) if (! (= ClassHeritage absent)) return true else return false else 1:{}\n  3:(0) access __x0__ = (ClassHeritage \"Contains\" symbol)\n  3:let inHeritage = __x0__\n  4:if (= inHeritage true) return true else 1:{}\n  5:(1) access __x1__ = (ClassBody \"ComputedPropertyContains\" symbol)\n  5:return __x1__\n}"
  }, {
    "code": ["        1. If _symbol_ is not one of |NewTarget|, |SuperProperty|, |SuperCall|, `super` or `this`, return *false*.", "        1. If |ArrowParameters| Contains _symbol_ is *true*, return *true*.", "        1. Return |ConciseBody| Contains _symbol_."],
    "head": {
      "idx": 0,
      "methodName": "Contains",
      "prod": "ArrowFunction",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ArrowParameters",
          "optional": false
        }, {
          "term": "=>"
        }, {
          "args": [],
          "name": "ConciseBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-contains",
    "rawBody": "{\n  0:if (! (|| (|| (|| (|| (0) (is-instance-of symbol NewTarget) (1) (is-instance-of symbol SuperProperty)) (2) (is-instance-of symbol SuperCall)) (= symbol \"super\")) (= symbol \"this\"))) return false else 1:{}\n  1:(0) access __x0__ = (ArrowParameters \"Contains\" symbol)\n  1:if (= __x0__ true) return true else 1:{}\n  2:(1) access __x1__ = (ConciseBody \"Contains\" symbol)\n  2:return __x1__\n}"
  }, {
    "code": ["        1. Let _formals_ be CoveredFormalsList of |CoverParenthesizedExpressionAndArrowParameterList|.", "        1. Return _formals_ Contains _symbol_."],
    "head": {
      "idx": 1,
      "methodName": "Contains",
      "prod": "ArrowParameters",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CoverParenthesizedExpressionAndArrowParameterList",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-contains",
    "rawBody": "{\n  0:(0) access __x0__ = (CoverParenthesizedExpressionAndArrowParameterList \"CoveredFormalsList\")\n  0:let formals = __x0__\n  1:(1) access __x1__ = (formals \"Contains\" symbol)\n  1:return __x1__\n}"
  }, {
    "code": ["        1. If _symbol_ is not one of |NewTarget|, |SuperProperty|, |SuperCall|, `super`, or `this`, return *false*.", "        1. Return |AsyncConciseBody| Contains _symbol_."],
    "head": {
      "idx": 0,
      "methodName": "Contains",
      "prod": "AsyncArrowFunction",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "args": [],
          "name": "AsyncArrowBindingIdentifier",
          "optional": false
        }, {
          "term": "=>"
        }, {
          "args": [],
          "name": "AsyncConciseBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-contains",
    "rawBody": "{\n  0:if (! (|| (|| (|| (|| (0) (is-instance-of symbol NewTarget) (1) (is-instance-of symbol SuperProperty)) (2) (is-instance-of symbol SuperCall)) (= symbol \"super\")) (= symbol \"this\"))) return false else 1:{}\n  1:(0) access __x0__ = (AsyncConciseBody \"Contains\" symbol)\n  1:return __x0__\n}"
  }, {
    "code": ["        1. If _symbol_ is not one of |NewTarget|, |SuperProperty|, |SuperCall|, `super`, or `this`, return *false*.", "        1. Let _head_ be CoveredAsyncArrowHead of |CoverCallExpressionAndAsyncArrowHead|.", "        1. If _head_ Contains _symbol_ is *true*, return *true*.", "        1. Return |AsyncConciseBody| Contains _symbol_."],
    "head": {
      "idx": 1,
      "methodName": "Contains",
      "prod": "AsyncArrowFunction",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CoverCallExpressionAndAsyncArrowHead",
          "optional": false
        }, {
          "term": "=>"
        }, {
          "args": [],
          "name": "AsyncConciseBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-contains",
    "rawBody": "{\n  0:if (! (|| (|| (|| (|| (0) (is-instance-of symbol NewTarget) (1) (is-instance-of symbol SuperProperty)) (2) (is-instance-of symbol SuperCall)) (= symbol \"super\")) (= symbol \"this\"))) return false else 1:{}\n  1:(0) access __x0__ = (CoverCallExpressionAndAsyncArrowHead \"CoveredAsyncArrowHead\")\n  1:let head = __x0__\n  2:(1) access __x1__ = (head \"Contains\" symbol)\n  2:if (= __x1__ true) return true else 1:{}\n  3:(2) access __x2__ = (AsyncConciseBody \"Contains\" symbol)\n  3:return __x2__\n}"
  }, {
    "code": ["        1. If _symbol_ is |MethodDefinition|, return *true*.", "        1. Return the result of ComputedPropertyContains for |MethodDefinition| with argument _symbol_."],
    "head": {
      "idx": 3,
      "methodName": "Contains",
      "prod": "PropertyDefinition",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MethodDefinition",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-contains",
    "rawBody": "{\n  0:if (0) (is-instance-of symbol MethodDefinition) return true else 1:{}\n  1:(0) access __x0__ = (MethodDefinition \"ComputedPropertyContains\" symbol)\n  1:return __x0__\n}"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "Contains",
      "prod": "LiteralPropertyName",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-contains",
    "rawBody": "return false"
  }, {
    "code": ["        1. If |MemberExpression| Contains _symbol_ is *true*, return *true*.", "        1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "Contains",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "term": "."
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-contains",
    "rawBody": "{\n  0:(0) access __x0__ = (MemberExpression \"Contains\" symbol)\n  0:if (= __x0__ true) return true else 1:{}\n  1:return false\n}"
  }, {
    "code": ["        1. If _symbol_ is the |ReservedWord| `super`, return *true*.", "        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "Contains",
      "prod": "SuperProperty",
      "rhs": {
        "tokens": [{
          "term": "super"
        }, {
          "term": "."
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-contains",
    "rawBody": "{\n  0:(0) ??? \"If id:{symbol} is the nt:{ReservedWord} code:{super} , return value:{true} .\"\n  1:return false\n}"
  }, {
    "code": ["        1. If |CallExpression| Contains _symbol_ is *true*, return *true*.", "        1. Return *false*."],
    "head": {
      "idx": 5,
      "methodName": "Contains",
      "prod": "CallExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CallExpression",
          "optional": false
        }, {
          "term": "."
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-contains",
    "rawBody": "{\n  0:(0) access __x0__ = (CallExpression \"Contains\" symbol)\n  0:if (= __x0__ true) return true else 1:{}\n  1:return false\n}"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "Contains",
      "prod": "OptionalChain",
      "rhs": {
        "tokens": [{
          "term": "?."
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-contains",
    "rawBody": "return false"
  }, {
    "code": ["        1. If |OptionalChain| Contains _symbol_ is *true*, return *true*.", "        1. Return *false*."],
    "head": {
      "idx": 6,
      "methodName": "Contains",
      "prod": "OptionalChain",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "OptionalChain",
          "optional": false
        }, {
          "term": "."
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-contains",
    "rawBody": "{\n  0:(0) access __x0__ = (OptionalChain \"Contains\" symbol)\n  0:if (= __x0__ true) return true else 1:{}\n  1:return false\n}"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "ComputedPropertyContains",
      "prod": "PropertyName",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LiteralPropertyName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-computedpropertycontains",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return the result of |ComputedPropertyName| Contains _symbol_."],
    "head": {
      "idx": 1,
      "methodName": "ComputedPropertyContains",
      "prod": "PropertyName",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ComputedPropertyName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-computedpropertycontains",
    "rawBody": "{\n  0:(0) access __x0__ = (ComputedPropertyName \"Contains\" symbol)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the result of ComputedPropertyContains for |PropertyName| with argument _symbol_."],
    "head": {
      "idx": 0,
      "methodName": "ComputedPropertyContains",
      "prod": "MethodDefinition",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-computedpropertycontains",
    "rawBody": "{\n  0:(0) access __x0__ = (PropertyName \"ComputedPropertyContains\" symbol)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the result of ComputedPropertyContains for |PropertyName| with argument _symbol_."],
    "head": {
      "idx": 4,
      "methodName": "ComputedPropertyContains",
      "prod": "MethodDefinition",
      "rhs": {
        "tokens": [{
          "term": "get"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-computedpropertycontains",
    "rawBody": "{\n  0:(0) access __x0__ = (PropertyName \"ComputedPropertyContains\" symbol)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the result of ComputedPropertyContains for |PropertyName| with argument _symbol_."],
    "head": {
      "idx": 5,
      "methodName": "ComputedPropertyContains",
      "prod": "MethodDefinition",
      "rhs": {
        "tokens": [{
          "term": "set"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "PropertySetParameterList",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-computedpropertycontains",
    "rawBody": "{\n  0:(0) access __x0__ = (PropertyName \"ComputedPropertyContains\" symbol)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the result of ComputedPropertyContains for |PropertyName| with argument _symbol_."],
    "head": {
      "idx": 0,
      "methodName": "ComputedPropertyContains",
      "prod": "GeneratorMethod",
      "rhs": {
        "tokens": [{
          "term": "*"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-computedpropertycontains",
    "rawBody": "{\n  0:(0) access __x0__ = (PropertyName \"ComputedPropertyContains\" symbol)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the result of ComputedPropertyContains for |PropertyName| with argument _symbol_."],
    "head": {
      "idx": 0,
      "methodName": "ComputedPropertyContains",
      "prod": "AsyncGeneratorMethod",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-computedpropertycontains",
    "rawBody": "{\n  0:(0) access __x0__ = (PropertyName \"ComputedPropertyContains\" symbol)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Let _inList_ be ComputedPropertyContains of |ClassElementList| with argument _symbol_.", "        1. If _inList_ is *true*, return *true*.", "        1. Return the result of ComputedPropertyContains for |ClassElement| with argument _symbol_."],
    "head": {
      "idx": 1,
      "methodName": "ComputedPropertyContains",
      "prod": "ClassElementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ClassElementList",
          "optional": false
        }, {
          "args": [],
          "name": "ClassElement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-computedpropertycontains",
    "rawBody": "{\n  0:(0) access __x0__ = (ClassElementList \"ComputedPropertyContains\" symbol)\n  0:let inList = __x0__\n  1:if (= inList true) return true else 1:{}\n  2:(1) access __x1__ = (ClassElement \"ComputedPropertyContains\" symbol)\n  2:return __x1__\n}"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "ComputedPropertyContains",
      "prod": "ClassElement",
      "rhs": {
        "tokens": [{
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-computedpropertycontains",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return the result of ComputedPropertyContains for |PropertyName| with argument _symbol_."],
    "head": {
      "idx": 0,
      "methodName": "ComputedPropertyContains",
      "prod": "AsyncMethod",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "symbol"
      }]
    },
    "ids": "sec-static-semantics-computedpropertycontains",
    "rawBody": "{\n  0:(0) access __x0__ = (PropertyName \"ComputedPropertyContains\" symbol)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ? InstantiateOrdinaryFunctionObject of |FunctionDeclaration| with argument _scope_."],
    "head": {
      "idx": 0,
      "methodName": "InstantiateFunctionObject",
      "prod": "FunctionDeclaration",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "scope"
      }]
    },
    "ids": "sec-runtime-semantics-instantiatefunctionobject",
    "rawBody": "{\n  0:(0) access __x0__ = (FunctionDeclaration \"InstantiateOrdinaryFunctionObject\" scope)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["        1. Return ? InstantiateOrdinaryFunctionObject of |FunctionDeclaration| with argument _scope_."],
    "head": {
      "idx": 1,
      "methodName": "InstantiateFunctionObject",
      "prod": "FunctionDeclaration",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "scope"
      }]
    },
    "ids": "sec-runtime-semantics-instantiatefunctionobject",
    "rawBody": "{\n  0:(0) access __x0__ = (FunctionDeclaration \"InstantiateOrdinaryFunctionObject\" scope)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["        1. Return ? InstantiateGeneratorFunctionObject of |GeneratorDeclaration| with argument _scope_."],
    "head": {
      "idx": 0,
      "methodName": "InstantiateFunctionObject",
      "prod": "GeneratorDeclaration",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "scope"
      }]
    },
    "ids": "sec-runtime-semantics-instantiatefunctionobject",
    "rawBody": "{\n  0:(0) access __x0__ = (GeneratorDeclaration \"InstantiateGeneratorFunctionObject\" scope)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["        1. Return ? InstantiateGeneratorFunctionObject of |GeneratorDeclaration| with argument _scope_."],
    "head": {
      "idx": 1,
      "methodName": "InstantiateFunctionObject",
      "prod": "GeneratorDeclaration",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "*"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "scope"
      }]
    },
    "ids": "sec-runtime-semantics-instantiatefunctionobject",
    "rawBody": "{\n  0:(0) access __x0__ = (GeneratorDeclaration \"InstantiateGeneratorFunctionObject\" scope)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["        1. Return ? InstantiateAsyncGeneratorFunctionObject of |AsyncGeneratorDeclaration| with argument _scope_."],
    "head": {
      "idx": 0,
      "methodName": "InstantiateFunctionObject",
      "prod": "AsyncGeneratorDeclaration",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "scope"
      }]
    },
    "ids": "sec-runtime-semantics-instantiatefunctionobject",
    "rawBody": "{\n  0:(0) access __x0__ = (AsyncGeneratorDeclaration \"InstantiateAsyncGeneratorFunctionObject\" scope)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["        1. Return ? InstantiateAsyncGeneratorFunctionObject of |AsyncGeneratorDeclaration| with argument _scope_."],
    "head": {
      "idx": 1,
      "methodName": "InstantiateFunctionObject",
      "prod": "AsyncGeneratorDeclaration",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "*"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "scope"
      }]
    },
    "ids": "sec-runtime-semantics-instantiatefunctionobject",
    "rawBody": "{\n  0:(0) access __x0__ = (AsyncGeneratorDeclaration \"InstantiateAsyncGeneratorFunctionObject\" scope)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["        1. Return ? InstantiateAsyncFunctionObject of |AsyncFunctionDeclaration| with argument _scope_."],
    "head": {
      "idx": 0,
      "methodName": "InstantiateFunctionObject",
      "prod": "AsyncFunctionDeclaration",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "scope"
      }]
    },
    "ids": "sec-runtime-semantics-instantiatefunctionobject",
    "rawBody": "{\n  0:(0) access __x0__ = (AsyncFunctionDeclaration \"InstantiateAsyncFunctionObject\" scope)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["        1. Return ? InstantiateAsyncFunctionObject of |AsyncFunctionDeclaration| with argument _scope_."],
    "head": {
      "idx": 1,
      "methodName": "InstantiateFunctionObject",
      "prod": "AsyncFunctionDeclaration",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "scope"
      }]
    },
    "ids": "sec-runtime-semantics-instantiatefunctionobject",
    "rawBody": "{\n  0:(0) access __x0__ = (AsyncFunctionDeclaration \"InstantiateAsyncFunctionObject\" scope)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["        1. Let _name_ be StringValue of |Identifier|.", "        1. Return ? InitializeBoundName(_name_, _value_, _environment_)."],
    "head": {
      "idx": 0,
      "methodName": "BindingInitialization",
      "prod": "BindingIdentifier",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Identifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-runtime-semantics-bindinginitialization",
    "rawBody": "{\n  0:(0) access __x0__ = (Identifier \"StringValue\")\n  0:let name = __x0__\n  1:(1) app __x1__ = (InitializeBoundName name value environment)\n  1:return [? __x1__]\n}"
  }, {
    "code": ["        1. Return ? InitializeBoundName(*\"yield\"*, _value_, _environment_)."],
    "head": {
      "idx": 1,
      "methodName": "BindingInitialization",
      "prod": "BindingIdentifier",
      "rhs": {
        "tokens": [{
          "term": "yield"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-runtime-semantics-bindinginitialization",
    "rawBody": "{\n  0:(0) app __x0__ = (InitializeBoundName \"yield\" value environment)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["        1. Return ? InitializeBoundName(*\"await\"*, _value_, _environment_)."],
    "head": {
      "idx": 2,
      "methodName": "BindingInitialization",
      "prod": "BindingIdentifier",
      "rhs": {
        "tokens": [{
          "term": "await"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-runtime-semantics-bindinginitialization",
    "rawBody": "{\n  0:(0) app __x0__ = (InitializeBoundName \"await\" value environment)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["        1. Perform ? RequireObjectCoercible(_value_).", "        1. Return the result of performing BindingInitialization for |ObjectBindingPattern| using _value_ and _environment_ as arguments."],
    "head": {
      "idx": 0,
      "methodName": "BindingInitialization",
      "prod": "BindingPattern",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ObjectBindingPattern",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-runtime-semantics-bindinginitialization",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible value)\n  0:[? __x0__]\n  1:(1) access __x1__ = (ObjectBindingPattern \"BindingInitialization\" value environment)\n  1:return __x1__\n}"
  }, {
    "code": ["        1. Let _iteratorRecord_ be ? GetIterator(_value_).", "        1. Let _result_ be IteratorBindingInitialization of |ArrayBindingPattern| with arguments _iteratorRecord_ and _environment_.", "        1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _result_).", "        1. Return _result_."],
    "head": {
      "idx": 1,
      "methodName": "BindingInitialization",
      "prod": "BindingPattern",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ArrayBindingPattern",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-runtime-semantics-bindinginitialization",
    "rawBody": "{\n  0:(0) app __x0__ = (GetIterator value)\n  0:let iteratorRecord = [? __x0__]\n  1:(1) access __x1__ = (ArrayBindingPattern \"IteratorBindingInitialization\" iteratorRecord environment)\n  1:let result = __x1__\n  2:if (= iteratorRecord[\"Done\"] false) {\n    (2) app __x2__ = (IteratorClose iteratorRecord result)\n    return [? __x2__]\n  } else 1:{}\n  3:return result\n}"
  }, {
    "code": ["        1. Return NormalCompletion(~empty~)."],
    "head": {
      "idx": 0,
      "methodName": "BindingInitialization",
      "prod": "ObjectBindingPattern",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-runtime-semantics-bindinginitialization",
    "rawBody": "return CONST_empty"
  }, {
    "code": ["        1. Perform ? PropertyBindingInitialization for |BindingPropertyList| using _value_ and _environment_ as the arguments.", "        1. Return NormalCompletion(~empty~)."],
    "head": {
      "idx": 2,
      "methodName": "BindingInitialization",
      "prod": "ObjectBindingPattern",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "BindingPropertyList",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-runtime-semantics-bindinginitialization",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingPropertyList \"PropertyBindingInitialization\" value environment)\n  0:[? __x0__]\n  1:return CONST_empty\n}"
  }, {
    "code": ["        1. Perform ? PropertyBindingInitialization for |BindingPropertyList| using _value_ and _environment_ as the arguments.", "        1. Return NormalCompletion(~empty~)."],
    "head": {
      "idx": 3,
      "methodName": "BindingInitialization",
      "prod": "ObjectBindingPattern",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "BindingPropertyList",
          "optional": false
        }, {
          "term": ","
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-runtime-semantics-bindinginitialization",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingPropertyList \"PropertyBindingInitialization\" value environment)\n  0:[? __x0__]\n  1:return CONST_empty\n}"
  }, {
    "code": ["        1. Let _excludedNames_ be a new empty List.", "        1. Return the result of performing RestBindingInitialization of |BindingRestProperty| with _value_, _environment_, and _excludedNames_ as the arguments."],
    "head": {
      "idx": 1,
      "methodName": "BindingInitialization",
      "prod": "ObjectBindingPattern",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "BindingRestProperty",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-runtime-semantics-bindinginitialization",
    "rawBody": "{\n  0:let excludedNames = (0) (new [])\n  1:(0) access __x0__ = (BindingRestProperty \"RestBindingInitialization\" value environment excludedNames)\n  1:return __x0__\n}"
  }, {
    "code": ["        1. Let _excludedNames_ be ? PropertyBindingInitialization of |BindingPropertyList| with arguments _value_ and _environment_.", "        1. Return the result of performing RestBindingInitialization of |BindingRestProperty| with arguments _value_, _environment_, and _excludedNames_."],
    "head": {
      "idx": 3,
      "methodName": "BindingInitialization",
      "prod": "ObjectBindingPattern",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "BindingPropertyList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "BindingRestProperty",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-runtime-semantics-bindinginitialization",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingPropertyList \"PropertyBindingInitialization\" value environment)\n  0:let excludedNames = [? __x0__]\n  1:(1) access __x1__ = (BindingRestProperty \"RestBindingInitialization\" value environment excludedNames)\n  1:return __x1__\n}"
  }, {
    "code": ["          1. Assert: Type(_name_) is String.", "          1. If _environment_ is not *undefined*, then", "            1. Perform _environment_.InitializeBinding(_name_, _value_).", "            1. Return NormalCompletion(*undefined*).", "          1. Else,", "            1. Let _lhs_ be ResolveBinding(_name_).", "            1. Return ? PutValue(_lhs_, _value_)."],
    "head": {
      "name": "InitializeBoundName",
      "params": [{
        "kind": "Normal",
        "name": "name"
      }, {
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-initializeboundname",
    "rawBody": "{\n  0:assert (= (typeof name) String)\n  4:if (! (= environment undefined)) {\n    2:(0) app __x0__ = (environment[\"InitializeBinding\"] environment name value)\n    2:__x0__\n    3:return undefined\n  } else {\n    5:(1) app __x1__ = (ResolveBinding name)\n    5:let lhs = __x1__\n    6:(2) app __x2__ = (PutValue lhs value)\n    6:return [? __x2__]\n  }\n}"
  }, {
    "code": ["        1. Return NormalCompletion(~empty~)."],
    "head": {
      "idx": 0,
      "methodName": "IteratorBindingInitialization",
      "prod": "ArrayBindingPattern",
      "rhs": {
        "tokens": [{
          "term": "["
        }, {
          "term": "]"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-runtime-semantics-iteratorbindinginitialization",
    "rawBody": "return CONST_empty"
  }, {
    "code": ["        1. Return the result of performing IteratorDestructuringAssignmentEvaluation of |Elision| with _iteratorRecord_ as the argument."],
    "head": {
      "idx": 0,
      "methodName": "IteratorBindingInitialization",
      "prod": "ArrayBindingPattern",
      "rhs": {
        "tokens": [{
          "term": "["
        }, {
          "args": [],
          "name": "Elision",
          "optional": false
        }, {
          "term": "]"
        }]
      },
      "subIdx": 2,
      "withParams": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-runtime-semantics-iteratorbindinginitialization",
    "rawBody": "{\n  0:(0) access __x0__ = (Elision \"IteratorDestructuringAssignmentEvaluation\" iteratorRecord)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. If |Elision| is present, then", "          1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with _iteratorRecord_ as the argument.", "        1. Return the result of performing IteratorBindingInitialization for |BindingRestElement| with _iteratorRecord_ and _environment_ as arguments."],
    "head": {
      "idx": 0,
      "methodName": "IteratorBindingInitialization",
      "prod": "ArrayBindingPattern",
      "rhs": {
        "tokens": [{
          "term": "["
        }, {
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "args": [],
          "name": "BindingRestElement",
          "optional": false
        }, {
          "term": "]"
        }]
      },
      "subIdx": 3,
      "withParams": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-runtime-semantics-iteratorbindinginitialization",
    "rawBody": "{\n  0:if (! (= Elision absent)) {\n    1:(0) access __x0__ = (Elision \"IteratorDestructuringAssignmentEvaluation\" iteratorRecord)\n    1:[? __x0__]\n  } else 1:{}\n  2:(1) access __x1__ = (BindingRestElement \"IteratorBindingInitialization\" iteratorRecord environment)\n  2:return __x1__\n}"
  }, {
    "code": ["        1. Perform ? IteratorBindingInitialization for |BindingElementList| with _iteratorRecord_ and _environment_ as arguments.", "        1. Return the result of performing IteratorDestructuringAssignmentEvaluation of |Elision| with _iteratorRecord_ as the argument."],
    "head": {
      "idx": 2,
      "methodName": "IteratorBindingInitialization",
      "prod": "ArrayBindingPattern",
      "rhs": {
        "tokens": [{
          "term": "["
        }, {
          "args": [],
          "name": "BindingElementList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "Elision",
          "optional": false
        }, {
          "term": "]"
        }]
      },
      "subIdx": 2,
      "withParams": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-runtime-semantics-iteratorbindinginitialization",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingElementList \"IteratorBindingInitialization\" iteratorRecord environment)\n  0:[? __x0__]\n  1:(1) access __x1__ = (Elision \"IteratorDestructuringAssignmentEvaluation\" iteratorRecord)\n  1:return __x1__\n}"
  }, {
    "code": ["        1. Perform ? IteratorBindingInitialization for |BindingElementList| with _iteratorRecord_ and _environment_ as arguments.", "        1. If |Elision| is present, then", "          1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with _iteratorRecord_ as the argument.", "        1. Return the result of performing IteratorBindingInitialization for |BindingRestElement| with _iteratorRecord_ and _environment_ as arguments."],
    "head": {
      "idx": 2,
      "methodName": "IteratorBindingInitialization",
      "prod": "ArrayBindingPattern",
      "rhs": {
        "tokens": [{
          "term": "["
        }, {
          "args": [],
          "name": "BindingElementList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "args": [],
          "name": "BindingRestElement",
          "optional": false
        }, {
          "term": "]"
        }]
      },
      "subIdx": 3,
      "withParams": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-runtime-semantics-iteratorbindinginitialization",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingElementList \"IteratorBindingInitialization\" iteratorRecord environment)\n  0:[? __x0__]\n  1:if (! (= Elision absent)) {\n    2:(1) access __x1__ = (Elision \"IteratorDestructuringAssignmentEvaluation\" iteratorRecord)\n    2:[? __x1__]\n  } else 1:{}\n  3:(2) access __x2__ = (BindingRestElement \"IteratorBindingInitialization\" iteratorRecord environment)\n  3:return __x2__\n}"
  }, {
    "code": ["        1. Perform ? IteratorBindingInitialization for |BindingElementList| with _iteratorRecord_ and _environment_ as arguments.", "        1. Return the result of performing IteratorBindingInitialization for |BindingElisionElement| using _iteratorRecord_ and _environment_ as arguments."],
    "head": {
      "idx": 1,
      "methodName": "IteratorBindingInitialization",
      "prod": "BindingElementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingElementList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "BindingElisionElement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-runtime-semantics-iteratorbindinginitialization",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingElementList \"IteratorBindingInitialization\" iteratorRecord environment)\n  0:[? __x0__]\n  1:(1) access __x1__ = (BindingElisionElement \"IteratorBindingInitialization\" iteratorRecord environment)\n  1:return __x1__\n}"
  }, {
    "code": ["        1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with _iteratorRecord_ as the argument.", "        1. Return the result of performing IteratorBindingInitialization of |BindingElement| with _iteratorRecord_ and _environment_ as the arguments."],
    "head": {
      "idx": 0,
      "methodName": "IteratorBindingInitialization",
      "prod": "BindingElisionElement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Elision",
          "optional": false
        }, {
          "args": [],
          "name": "BindingElement",
          "optional": false
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-runtime-semantics-iteratorbindinginitialization",
    "rawBody": "{\n  0:(0) access __x0__ = (Elision \"IteratorDestructuringAssignmentEvaluation\" iteratorRecord)\n  0:[? __x0__]\n  1:(1) access __x1__ = (BindingElement \"IteratorBindingInitialization\" iteratorRecord environment)\n  1:return __x1__\n}"
  }, {
    "code": ["        1. Let _bindingId_ be StringValue of |BindingIdentifier|.", "        1. Let _lhs_ be ? ResolveBinding(_bindingId_, _environment_).", "        1. If _iteratorRecord_.[[Done]] is *false*, then", "          1. Let _next_ be IteratorStep(_iteratorRecord_).", "          1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.", "          1. ReturnIfAbrupt(_next_).", "          1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.", "          1. Else,", "            1. Let _v_ be IteratorValue(_next_).", "            1. If _v_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.", "            1. ReturnIfAbrupt(_v_).", "        1. If _iteratorRecord_.[[Done]] is *true*, let _v_ be *undefined*.", "        1. If |Initializer| is present and _v_ is *undefined*, then", "          1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then", "            1. Set _v_ to the result of performing NamedEvaluation for |Initializer| with argument _bindingId_.", "          1. Else,", "            1. Let _defaultValue_ be the result of evaluating |Initializer|.", "            1. Set _v_ to ? GetValue(_defaultValue_).", "        1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _v_).", "        1. Return InitializeReferencedBinding(_lhs_, _v_)."],
    "head": {
      "idx": 0,
      "methodName": "IteratorBindingInitialization",
      "prod": "SingleNameBinding",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "args": [],
          "name": "Initializer",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-runtime-semantics-iteratorbindinginitialization",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingIdentifier \"StringValue\")\n  0:let bindingId = __x0__\n  1:(1) app __x1__ = (ResolveBinding bindingId environment)\n  1:let lhs = [? __x1__]\n  2:if (= iteratorRecord[\"Done\"] false) {\n    3:(2) app __x2__ = (IteratorStep iteratorRecord)\n    3:let next = __x2__\n    4:(3) app __x3__ = (IsAbruptCompletion next)\n    4:if __x3__ iteratorRecord[\"Done\"] = true else 1:{}\n    5:[? next]\n    7:if (= next false) iteratorRecord[\"Done\"] = true else {\n      8:(4) app __x4__ = (IteratorValue next)\n      8:let v = __x4__\n      9:(5) app __x5__ = (IsAbruptCompletion v)\n      9:if __x5__ iteratorRecord[\"Done\"] = true else 1:{}\n      10:[? v]\n    }\n  } else 1:{}\n  11:if (= iteratorRecord[\"Done\"] true) let v = undefined else 1:{}\n  12:if (&& (! (= Initializer absent)) (= v undefined)) {\n    15:(6) app __x6__ = (IsAnonymousFunctionDefinition Initializer)\n    15:if (= __x6__ true) {\n      14:(7) access __x7__ = (Initializer \"NamedEvaluation\" bindingId)\n      14:v = __x7__\n    } else {\n      16:(8) access __x8__ = (Initializer \"Evaluation\")\n      16:let defaultValue = __x8__\n      17:(9) app __x9__ = (GetValue defaultValue)\n      17:v = [? __x9__]\n    }\n  } else 1:{}\n  18:if (= environment undefined) {\n    (10) app __x10__ = (PutValue lhs v)\n    return [? __x10__]\n  } else 1:{}\n  19:(11) app __x11__ = (InitializeReferencedBinding lhs v)\n  19:return __x11__\n}"
  }, {
    "code": ["        1. If _iteratorRecord_.[[Done]] is *false*, then", "          1. Let _next_ be IteratorStep(_iteratorRecord_).", "          1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.", "          1. ReturnIfAbrupt(_next_).", "          1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.", "          1. Else,", "            1. Let _v_ be IteratorValue(_next_).", "            1. If _v_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.", "            1. ReturnIfAbrupt(_v_).", "        1. If _iteratorRecord_.[[Done]] is *true*, let _v_ be *undefined*.", "        1. If |Initializer| is present and _v_ is *undefined*, then", "          1. Let _defaultValue_ be the result of evaluating |Initializer|.", "          1. Set _v_ to ? GetValue(_defaultValue_).", "        1. Return the result of performing BindingInitialization of |BindingPattern| with _v_ and _environment_ as the arguments."],
    "head": {
      "idx": 1,
      "methodName": "IteratorBindingInitialization",
      "prod": "BindingElement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingPattern",
          "optional": false
        }, {
          "args": [],
          "name": "Initializer",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-runtime-semantics-iteratorbindinginitialization",
    "rawBody": "{\n  0:if (= iteratorRecord[\"Done\"] false) {\n    1:(0) app __x0__ = (IteratorStep iteratorRecord)\n    1:let next = __x0__\n    2:(1) app __x1__ = (IsAbruptCompletion next)\n    2:if __x1__ iteratorRecord[\"Done\"] = true else 1:{}\n    3:[? next]\n    5:if (= next false) iteratorRecord[\"Done\"] = true else {\n      6:(2) app __x2__ = (IteratorValue next)\n      6:let v = __x2__\n      7:(3) app __x3__ = (IsAbruptCompletion v)\n      7:if __x3__ iteratorRecord[\"Done\"] = true else 1:{}\n      8:[? v]\n    }\n  } else 1:{}\n  9:if (= iteratorRecord[\"Done\"] true) let v = undefined else 1:{}\n  10:if (&& (! (= Initializer absent)) (= v undefined)) {\n    11:(4) access __x4__ = (Initializer \"Evaluation\")\n    11:let defaultValue = __x4__\n    12:(5) app __x5__ = (GetValue defaultValue)\n    12:v = [? __x5__]\n  } else 1:{}\n  13:(6) access __x6__ = (BindingPattern \"BindingInitialization\" v environment)\n  13:return __x6__\n}"
  }, {
    "code": ["        1. Let _lhs_ be ? ResolveBinding(StringValue of |BindingIdentifier|, _environment_).", "        1. Let _A_ be ! ArrayCreate(0).", "        1. Let _n_ be 0.", "        1. Repeat,", "          1. If _iteratorRecord_.[[Done]] is *false*, then", "            1. Let _next_ be IteratorStep(_iteratorRecord_).", "            1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.", "            1. ReturnIfAbrupt(_next_).", "            1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.", "          1. If _iteratorRecord_.[[Done]] is *true*, then", "            1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _A_).", "            1. Return InitializeReferencedBinding(_lhs_, _A_).", "          1. Let _nextValue_ be IteratorValue(_next_).", "          1. If _nextValue_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.", "          1. ReturnIfAbrupt(_nextValue_).", "          1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _nextValue_).", "          1. Set _n_ to _n_ + 1."],
    "head": {
      "idx": 0,
      "methodName": "IteratorBindingInitialization",
      "prod": "BindingRestElement",
      "rhs": {
        "tokens": [{
          "term": "..."
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-runtime-semantics-iteratorbindinginitialization",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingIdentifier \"StringValue\")\n  0:(1) app __x1__ = (ResolveBinding __x0__ environment)\n  0:let lhs = [? __x1__]\n  1:(2) app __x2__ = (ArrayCreate 0i)\n  1:let A = [! __x2__]\n  2:let n = 0i\n  3:while true {\n    4:if (= iteratorRecord[\"Done\"] false) {\n      5:(3) app __x3__ = (IteratorStep iteratorRecord)\n      5:let next = __x3__\n      6:(4) app __x4__ = (IsAbruptCompletion next)\n      6:if __x4__ iteratorRecord[\"Done\"] = true else 1:{}\n      7:[? next]\n      8:if (= next false) iteratorRecord[\"Done\"] = true else 1:{}\n    } else 1:{}\n    9:if (= iteratorRecord[\"Done\"] true) {\n      10:if (= environment undefined) {\n        (5) app __x5__ = (PutValue lhs A)\n        return [? __x5__]\n      } else 1:{}\n      11:(6) app __x6__ = (InitializeReferencedBinding lhs A)\n      11:return __x6__\n    } else 1:{}\n    12:(7) app __x7__ = (IteratorValue next)\n    12:let nextValue = __x7__\n    13:(8) app __x8__ = (IsAbruptCompletion nextValue)\n    13:if __x8__ iteratorRecord[\"Done\"] = true else 1:{}\n    14:[? nextValue]\n    15:(9) app __x9__ = (ToString n)\n    15:(10) app __x10__ = (CreateDataPropertyOrThrow A [! __x9__] nextValue)\n    15:[! __x10__]\n    16:n = (+ n 1i)\n  }\n}"
  }, {
    "code": ["        1. Let _A_ be ! ArrayCreate(0).", "        1. Let _n_ be 0.", "        1. Repeat,", "          1. If _iteratorRecord_.[[Done]] is *false*, then", "            1. Let _next_ be IteratorStep(_iteratorRecord_).", "            1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.", "            1. ReturnIfAbrupt(_next_).", "            1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.", "          1. If _iteratorRecord_.[[Done]] is *true*, then", "            1. Return the result of performing BindingInitialization of |BindingPattern| with _A_ and _environment_ as the arguments.", "          1. Let _nextValue_ be IteratorValue(_next_).", "          1. If _nextValue_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.", "          1. ReturnIfAbrupt(_nextValue_).", "          1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _nextValue_).", "          1. Set _n_ to _n_ + 1."],
    "head": {
      "idx": 1,
      "methodName": "IteratorBindingInitialization",
      "prod": "BindingRestElement",
      "rhs": {
        "tokens": [{
          "term": "..."
        }, {
          "args": [],
          "name": "BindingPattern",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-runtime-semantics-iteratorbindinginitialization",
    "rawBody": "{\n  0:(0) app __x0__ = (ArrayCreate 0i)\n  0:let A = [! __x0__]\n  1:let n = 0i\n  2:while true {\n    3:if (= iteratorRecord[\"Done\"] false) {\n      4:(1) app __x1__ = (IteratorStep iteratorRecord)\n      4:let next = __x1__\n      5:(2) app __x2__ = (IsAbruptCompletion next)\n      5:if __x2__ iteratorRecord[\"Done\"] = true else 1:{}\n      6:[? next]\n      7:if (= next false) iteratorRecord[\"Done\"] = true else 1:{}\n    } else 1:{}\n    8:if (= iteratorRecord[\"Done\"] true) {\n      9:(3) access __x3__ = (BindingPattern \"BindingInitialization\" A environment)\n      9:return __x3__\n    } else 1:{}\n    10:(4) app __x4__ = (IteratorValue next)\n    10:let nextValue = __x4__\n    11:(5) app __x5__ = (IsAbruptCompletion nextValue)\n    11:if __x5__ iteratorRecord[\"Done\"] = true else 1:{}\n    12:[? nextValue]\n    13:(6) app __x6__ = (ToString n)\n    13:(7) app __x7__ = (CreateDataPropertyOrThrow A [! __x6__] nextValue)\n    13:[! __x7__]\n    14:n = (+ n 1i)\n  }\n}"
  }, {
    "code": ["        1. Return NormalCompletion(~empty~)."],
    "head": {
      "idx": 0,
      "methodName": "IteratorBindingInitialization",
      "prod": "FormalParameters",
      "rhs": {
        "tokens": [{
          "empty": null
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-runtime-semantics-iteratorbindinginitialization",
    "rawBody": "return CONST_empty"
  }, {
    "code": ["        1. Perform ? IteratorBindingInitialization for |FormalParameterList| using _iteratorRecord_ and _environment_ as the arguments.", "        1. Return the result of performing IteratorBindingInitialization for |FunctionRestParameter| using _iteratorRecord_ and _environment_ as the arguments."],
    "head": {
      "idx": 4,
      "methodName": "IteratorBindingInitialization",
      "prod": "FormalParameters",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FormalParameterList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "FunctionRestParameter",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-runtime-semantics-iteratorbindinginitialization",
    "rawBody": "{\n  0:(0) access __x0__ = (FormalParameterList \"IteratorBindingInitialization\" iteratorRecord environment)\n  0:[? __x0__]\n  1:(1) access __x1__ = (FunctionRestParameter \"IteratorBindingInitialization\" iteratorRecord environment)\n  1:return __x1__\n}"
  }, {
    "code": ["        1. Perform ? IteratorBindingInitialization for |FormalParameterList| using _iteratorRecord_ and _environment_ as the arguments.", "        1. Return the result of performing IteratorBindingInitialization for |FormalParameter| using _iteratorRecord_ and _environment_ as the arguments."],
    "head": {
      "idx": 1,
      "methodName": "IteratorBindingInitialization",
      "prod": "FormalParameterList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FormalParameterList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "FormalParameter",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-runtime-semantics-iteratorbindinginitialization",
    "rawBody": "{\n  0:(0) access __x0__ = (FormalParameterList \"IteratorBindingInitialization\" iteratorRecord environment)\n  0:[? __x0__]\n  1:(1) access __x1__ = (FormalParameter \"IteratorBindingInitialization\" iteratorRecord environment)\n  1:return __x1__\n}"
  }, {
    "code": ["        1. Assert: _iteratorRecord_.[[Done]] is *false*.", "        1. Let _next_ be IteratorStep(_iteratorRecord_).", "        1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.", "        1. ReturnIfAbrupt(_next_).", "        1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.", "        1. Else,", "          1. Let _v_ be IteratorValue(_next_).", "          1. If _v_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.", "          1. ReturnIfAbrupt(_v_).", "        1. If _iteratorRecord_.[[Done]] is *true*, let _v_ be *undefined*.", "        1. Return the result of performing BindingInitialization for |BindingIdentifier| using _v_ and _environment_ as the arguments."],
    "head": {
      "idx": 0,
      "methodName": "IteratorBindingInitialization",
      "prod": "ArrowParameters",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-runtime-semantics-iteratorbindinginitialization",
    "rawBody": "{\n  0:assert (= iteratorRecord[\"Done\"] false)\n  1:(0) app __x0__ = (IteratorStep iteratorRecord)\n  1:let next = __x0__\n  2:(1) app __x1__ = (IsAbruptCompletion next)\n  2:if __x1__ iteratorRecord[\"Done\"] = true else 1:{}\n  3:[? next]\n  5:if (= next false) iteratorRecord[\"Done\"] = true else {\n    6:(2) app __x2__ = (IteratorValue next)\n    6:let v = __x2__\n    7:(3) app __x3__ = (IsAbruptCompletion v)\n    7:if __x3__ iteratorRecord[\"Done\"] = true else 1:{}\n    8:[? v]\n  }\n  9:if (= iteratorRecord[\"Done\"] true) let v = undefined else 1:{}\n  10:(4) access __x4__ = (BindingIdentifier \"BindingInitialization\" v environment)\n  10:return __x4__\n}"
  }, {
    "code": ["        1. Let _formals_ be CoveredFormalsList of |CoverParenthesizedExpressionAndArrowParameterList|.", "        1. Return IteratorBindingInitialization of _formals_ with arguments _iteratorRecord_ and _environment_."],
    "head": {
      "idx": 1,
      "methodName": "IteratorBindingInitialization",
      "prod": "ArrowParameters",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CoverParenthesizedExpressionAndArrowParameterList",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-runtime-semantics-iteratorbindinginitialization",
    "rawBody": "{\n  0:(0) access __x0__ = (CoverParenthesizedExpressionAndArrowParameterList \"CoveredFormalsList\")\n  0:let formals = __x0__\n  1:(1) access __x1__ = (formals \"IteratorBindingInitialization\" iteratorRecord environment)\n  1:return __x1__\n}"
  }, {
    "code": ["        1. Assert: _iteratorRecord_.[[Done]] is *false*.", "        1. Let _next_ be IteratorStep(_iteratorRecord_).", "        1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.", "        1. ReturnIfAbrupt(_next_).", "        1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.", "        1. Else,", "          1. Let _v_ be IteratorValue(_next_).", "          1. If _v_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.", "          1. ReturnIfAbrupt(_v_).", "        1. If _iteratorRecord_.[[Done]] is *true*, let _v_ be *undefined*.", "        1. Return the result of performing BindingInitialization for |BindingIdentifier| using _v_ and _environment_ as the arguments."],
    "head": {
      "idx": 0,
      "methodName": "IteratorBindingInitialization",
      "prod": "AsyncArrowBindingIdentifier",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-runtime-semantics-iteratorbindinginitialization",
    "rawBody": "{\n  0:assert (= iteratorRecord[\"Done\"] false)\n  1:(0) app __x0__ = (IteratorStep iteratorRecord)\n  1:let next = __x0__\n  2:(1) app __x1__ = (IsAbruptCompletion next)\n  2:if __x1__ iteratorRecord[\"Done\"] = true else 1:{}\n  3:[? next]\n  5:if (= next false) iteratorRecord[\"Done\"] = true else {\n    6:(2) app __x2__ = (IteratorValue next)\n    6:let v = __x2__\n    7:(3) app __x3__ = (IsAbruptCompletion v)\n    7:if __x3__ iteratorRecord[\"Done\"] = true else 1:{}\n    8:[? v]\n  }\n  9:if (= iteratorRecord[\"Done\"] true) let v = undefined else 1:{}\n  10:(4) access __x4__ = (BindingIdentifier \"BindingInitialization\" v environment)\n  10:return __x4__\n}"
  }, {
    "code": ["        1. If this |IdentifierReference| is contained in strict mode code and StringValue of |Identifier| is *\"eval\"* or *\"arguments\"*, return ~invalid~.", "        1. Return ~simple~."],
    "head": {
      "idx": 0,
      "methodName": "AssignmentTargetType",
      "prod": "IdentifierReference",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Identifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "{\n  0:let __x0__ = true\n  0:__x0__ = true\n  0:if __x0__ {\n    (0) access __x1__ = (Identifier \"StringValue\")\n    __x0__ = (|| (= __x1__ \"eval\") (= __x1__ \"arguments\"))\n  } else 1:{}\n  0:if __x0__ return CONST_invalid else 1:{}\n  1:return CONST_simple\n}"
  }, {
    "code": ["        1. Return ~simple~."],
    "head": {
      "idx": 1,
      "methodName": "AssignmentTargetType",
      "prod": "IdentifierReference",
      "rhs": {
        "tokens": [{
          "term": "yield"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_simple"
  }, {
    "code": ["        1. Return ~simple~."],
    "head": {
      "idx": 2,
      "methodName": "AssignmentTargetType",
      "prod": "IdentifierReference",
      "rhs": {
        "tokens": [{
          "term": "await"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_simple"
  }, {
    "code": ["        1. Return ~simple~."],
    "head": {
      "idx": 4,
      "methodName": "AssignmentTargetType",
      "prod": "CallExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CallExpression",
          "optional": false
        }, {
          "term": "["
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": "]"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_simple"
  }, {
    "code": ["        1. Return ~simple~."],
    "head": {
      "idx": 5,
      "methodName": "AssignmentTargetType",
      "prod": "CallExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CallExpression",
          "optional": false
        }, {
          "term": "."
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_simple"
  }, {
    "code": ["        1. Return ~simple~."],
    "head": {
      "idx": 1,
      "methodName": "AssignmentTargetType",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "term": "["
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": "]"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_simple"
  }, {
    "code": ["        1. Return ~simple~."],
    "head": {
      "idx": 2,
      "methodName": "AssignmentTargetType",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "term": "."
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_simple"
  }, {
    "code": ["        1. Return ~simple~."],
    "head": {
      "idx": 4,
      "methodName": "AssignmentTargetType",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "SuperProperty",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_simple"
  }, {
    "code": ["        1. Let _expr_ be CoveredParenthesizedExpression of |CoverParenthesizedExpressionAndArrowParameterList|.", "        1. Return AssignmentTargetType of _expr_."],
    "head": {
      "idx": 12,
      "methodName": "AssignmentTargetType",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CoverParenthesizedExpressionAndArrowParameterList",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "{\n  0:(0) access __x0__ = (CoverParenthesizedExpressionAndArrowParameterList \"CoveredParenthesizedExpression\")\n  0:let expr = __x0__\n  1:(1) access __x1__ = (expr \"AssignmentTargetType\")\n  1:return __x1__\n}"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 0,
      "methodName": "AssignmentTargetType",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "term": "this"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 2,
      "methodName": "AssignmentTargetType",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Literal",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 3,
      "methodName": "AssignmentTargetType",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ArrayLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 4,
      "methodName": "AssignmentTargetType",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ObjectLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 5,
      "methodName": "AssignmentTargetType",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FunctionExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 6,
      "methodName": "AssignmentTargetType",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ClassExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 7,
      "methodName": "AssignmentTargetType",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "GeneratorExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 8,
      "methodName": "AssignmentTargetType",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AsyncFunctionExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 9,
      "methodName": "AssignmentTargetType",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AsyncGeneratorExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 10,
      "methodName": "AssignmentTargetType",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RegularExpressionLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 11,
      "methodName": "AssignmentTargetType",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "TemplateLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 0,
      "methodName": "AssignmentTargetType",
      "prod": "CallExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CoverCallExpressionAndAsyncArrowHead",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 1,
      "methodName": "AssignmentTargetType",
      "prod": "CallExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "SuperCall",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 2,
      "methodName": "AssignmentTargetType",
      "prod": "CallExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ImportCall",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 3,
      "methodName": "AssignmentTargetType",
      "prod": "CallExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CallExpression",
          "optional": false
        }, {
          "args": [],
          "name": "Arguments",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 6,
      "methodName": "AssignmentTargetType",
      "prod": "CallExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CallExpression",
          "optional": false
        }, {
          "args": [],
          "name": "TemplateLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 1,
      "methodName": "AssignmentTargetType",
      "prod": "NewExpression",
      "rhs": {
        "tokens": [{
          "term": "new"
        }, {
          "args": [],
          "name": "NewExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 3,
      "methodName": "AssignmentTargetType",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "args": [],
          "name": "TemplateLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 6,
      "methodName": "AssignmentTargetType",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "term": "new"
        }, {
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "args": [],
          "name": "Arguments",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 0,
      "methodName": "AssignmentTargetType",
      "prod": "NewTarget",
      "rhs": {
        "tokens": [{
          "term": "new"
        }, {
          "term": "."
        }, {
          "term": "target"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 0,
      "methodName": "AssignmentTargetType",
      "prod": "ImportMeta",
      "rhs": {
        "tokens": [{
          "term": "import"
        }, {
          "term": "."
        }, {
          "term": "meta"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 2,
      "methodName": "AssignmentTargetType",
      "prod": "LeftHandSideExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "OptionalExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 1,
      "methodName": "AssignmentTargetType",
      "prod": "UpdateExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "++"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 2,
      "methodName": "AssignmentTargetType",
      "prod": "UpdateExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "--"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 3,
      "methodName": "AssignmentTargetType",
      "prod": "UpdateExpression",
      "rhs": {
        "tokens": [{
          "term": "++"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 4,
      "methodName": "AssignmentTargetType",
      "prod": "UpdateExpression",
      "rhs": {
        "tokens": [{
          "term": "--"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 1,
      "methodName": "AssignmentTargetType",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "term": "delete"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 2,
      "methodName": "AssignmentTargetType",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "term": "void"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 3,
      "methodName": "AssignmentTargetType",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "term": "typeof"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 4,
      "methodName": "AssignmentTargetType",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "term": "+"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 5,
      "methodName": "AssignmentTargetType",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "term": "-"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 6,
      "methodName": "AssignmentTargetType",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "term": "~"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 7,
      "methodName": "AssignmentTargetType",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "term": "!"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 8,
      "methodName": "AssignmentTargetType",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AwaitExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 1,
      "methodName": "AssignmentTargetType",
      "prod": "ExponentiationExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "UpdateExpression",
          "optional": false
        }, {
          "term": "**"
        }, {
          "args": [],
          "name": "ExponentiationExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 1,
      "methodName": "AssignmentTargetType",
      "prod": "MultiplicativeExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MultiplicativeExpression",
          "optional": false
        }, {
          "args": [],
          "name": "MultiplicativeOperator",
          "optional": false
        }, {
          "args": [],
          "name": "ExponentiationExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 1,
      "methodName": "AssignmentTargetType",
      "prod": "AdditiveExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AdditiveExpression",
          "optional": false
        }, {
          "term": "+"
        }, {
          "args": [],
          "name": "MultiplicativeExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 2,
      "methodName": "AssignmentTargetType",
      "prod": "AdditiveExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AdditiveExpression",
          "optional": false
        }, {
          "term": "-"
        }, {
          "args": [],
          "name": "MultiplicativeExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 1,
      "methodName": "AssignmentTargetType",
      "prod": "ShiftExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }, {
          "term": "<<"
        }, {
          "args": [],
          "name": "AdditiveExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 2,
      "methodName": "AssignmentTargetType",
      "prod": "ShiftExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }, {
          "term": ">>"
        }, {
          "args": [],
          "name": "AdditiveExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 3,
      "methodName": "AssignmentTargetType",
      "prod": "ShiftExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }, {
          "term": ">>>"
        }, {
          "args": [],
          "name": "AdditiveExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 1,
      "methodName": "AssignmentTargetType",
      "prod": "RelationalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }, {
          "term": "<"
        }, {
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 2,
      "methodName": "AssignmentTargetType",
      "prod": "RelationalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }, {
          "term": ">"
        }, {
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 3,
      "methodName": "AssignmentTargetType",
      "prod": "RelationalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }, {
          "term": "<="
        }, {
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 4,
      "methodName": "AssignmentTargetType",
      "prod": "RelationalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }, {
          "term": ">="
        }, {
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 5,
      "methodName": "AssignmentTargetType",
      "prod": "RelationalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }, {
          "term": "instanceof"
        }, {
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 6,
      "methodName": "AssignmentTargetType",
      "prod": "RelationalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 1,
      "methodName": "AssignmentTargetType",
      "prod": "EqualityExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "EqualityExpression",
          "optional": false
        }, {
          "term": "=="
        }, {
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 2,
      "methodName": "AssignmentTargetType",
      "prod": "EqualityExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "EqualityExpression",
          "optional": false
        }, {
          "term": "!="
        }, {
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 3,
      "methodName": "AssignmentTargetType",
      "prod": "EqualityExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "EqualityExpression",
          "optional": false
        }, {
          "term": "==="
        }, {
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 4,
      "methodName": "AssignmentTargetType",
      "prod": "EqualityExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "EqualityExpression",
          "optional": false
        }, {
          "term": "!=="
        }, {
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 1,
      "methodName": "AssignmentTargetType",
      "prod": "BitwiseANDExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BitwiseANDExpression",
          "optional": false
        }, {
          "term": "&"
        }, {
          "args": [],
          "name": "EqualityExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 1,
      "methodName": "AssignmentTargetType",
      "prod": "BitwiseXORExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BitwiseXORExpression",
          "optional": false
        }, {
          "term": "^"
        }, {
          "args": [],
          "name": "BitwiseANDExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 1,
      "methodName": "AssignmentTargetType",
      "prod": "BitwiseORExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BitwiseORExpression",
          "optional": false
        }, {
          "term": "|"
        }, {
          "args": [],
          "name": "BitwiseXORExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 1,
      "methodName": "AssignmentTargetType",
      "prod": "LogicalANDExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LogicalANDExpression",
          "optional": false
        }, {
          "term": "&&"
        }, {
          "args": [],
          "name": "BitwiseORExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 1,
      "methodName": "AssignmentTargetType",
      "prod": "LogicalORExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LogicalORExpression",
          "optional": false
        }, {
          "term": "||"
        }, {
          "args": [],
          "name": "LogicalANDExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 0,
      "methodName": "AssignmentTargetType",
      "prod": "CoalesceExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CoalesceExpressionHead",
          "optional": false
        }, {
          "term": "??"
        }, {
          "args": [],
          "name": "BitwiseORExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 1,
      "methodName": "AssignmentTargetType",
      "prod": "ConditionalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ShortCircuitExpression",
          "optional": false
        }, {
          "term": "?"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 1,
      "methodName": "AssignmentTargetType",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "YieldExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 2,
      "methodName": "AssignmentTargetType",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ArrowFunction",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 3,
      "methodName": "AssignmentTargetType",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AsyncArrowFunction",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 4,
      "methodName": "AssignmentTargetType",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "="
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 5,
      "methodName": "AssignmentTargetType",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "args": [],
          "name": "AssignmentOperator",
          "optional": false
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 6,
      "methodName": "AssignmentTargetType",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "&&="
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 7,
      "methodName": "AssignmentTargetType",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "||="
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 8,
      "methodName": "AssignmentTargetType",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "??="
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return ~invalid~."],
    "head": {
      "idx": 1,
      "methodName": "AssignmentTargetType",
      "prod": "Expression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-assignmenttargettype",
    "rawBody": "return CONST_invalid"
  }, {
    "code": ["        1. Return StringValue of |IdentifierReference|."],
    "head": {
      "idx": 0,
      "methodName": "PropName",
      "prod": "PropertyDefinition",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "IdentifierReference",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-propname",
    "rawBody": "{\n  0:(0) access __x0__ = (IdentifierReference \"StringValue\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ~empty~."],
    "head": {
      "idx": 4,
      "methodName": "PropName",
      "prod": "PropertyDefinition",
      "rhs": {
        "tokens": [{
          "term": "..."
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-propname",
    "rawBody": "return CONST_empty"
  }, {
    "code": ["        1. Return PropName of |PropertyName|."],
    "head": {
      "idx": 2,
      "methodName": "PropName",
      "prod": "PropertyDefinition",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-propname",
    "rawBody": "{\n  0:(0) access __x0__ = (PropertyName \"PropName\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return StringValue of |IdentifierName|."],
    "head": {
      "idx": 0,
      "methodName": "PropName",
      "prod": "LiteralPropertyName",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-propname",
    "rawBody": "{\n  0:(0) access __x0__ = (IdentifierName \"StringValue\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the SV of |StringLiteral|."],
    "head": {
      "idx": 1,
      "methodName": "PropName",
      "prod": "LiteralPropertyName",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StringLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-propname",
    "rawBody": "{\n  0:(0) access __x0__ = (StringLiteral \"SV\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Let _nbr_ be the NumericValue of |NumericLiteral|.", "        1. Return ! ToString(_nbr_)."],
    "head": {
      "idx": 2,
      "methodName": "PropName",
      "prod": "LiteralPropertyName",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "NumericLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-propname",
    "rawBody": "{\n  0:(0) access __x0__ = (NumericLiteral \"NumericValue\")\n  0:let nbr = __x0__\n  1:(1) app __x1__ = (ToString nbr)\n  1:return [! __x1__]\n}"
  }, {
    "code": ["        1. Return ~empty~."],
    "head": {
      "idx": 0,
      "methodName": "PropName",
      "prod": "ComputedPropertyName",
      "rhs": {
        "tokens": [{
          "term": "["
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": "]"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-propname",
    "rawBody": "return CONST_empty"
  }, {
    "code": ["        1. Return PropName of |PropertyName|."],
    "head": {
      "idx": 0,
      "methodName": "PropName",
      "prod": "MethodDefinition",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-propname",
    "rawBody": "{\n  0:(0) access __x0__ = (PropertyName \"PropName\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return PropName of |PropertyName|."],
    "head": {
      "idx": 4,
      "methodName": "PropName",
      "prod": "MethodDefinition",
      "rhs": {
        "tokens": [{
          "term": "get"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-propname",
    "rawBody": "{\n  0:(0) access __x0__ = (PropertyName \"PropName\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return PropName of |PropertyName|."],
    "head": {
      "idx": 5,
      "methodName": "PropName",
      "prod": "MethodDefinition",
      "rhs": {
        "tokens": [{
          "term": "set"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "PropertySetParameterList",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-propname",
    "rawBody": "{\n  0:(0) access __x0__ = (PropertyName \"PropName\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return PropName of |PropertyName|."],
    "head": {
      "idx": 0,
      "methodName": "PropName",
      "prod": "GeneratorMethod",
      "rhs": {
        "tokens": [{
          "term": "*"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-propname",
    "rawBody": "{\n  0:(0) access __x0__ = (PropertyName \"PropName\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return PropName of |PropertyName|."],
    "head": {
      "idx": 0,
      "methodName": "PropName",
      "prod": "AsyncGeneratorMethod",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-propname",
    "rawBody": "{\n  0:(0) access __x0__ = (PropertyName \"PropName\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ~empty~."],
    "head": {
      "idx": 2,
      "methodName": "PropName",
      "prod": "ClassElement",
      "rhs": {
        "tokens": [{
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-propname",
    "rawBody": "return CONST_empty"
  }, {
    "code": ["        1. Return PropName of |PropertyName|."],
    "head": {
      "idx": 0,
      "methodName": "PropName",
      "prod": "AsyncMethod",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-propname",
    "rawBody": "{\n  0:(0) access __x0__ = (PropertyName \"PropName\")\n  0:return __x0__\n}"
  }, {
    "code": ["            1. If _envRec_ has a binding for the name that is the value of _N_, return *true*.", "            1. Return *false*."],
    "head": {
      "base": "DeclarativeEnvironmentRecord",
      "methodName": "HasBinding",
      "origParams": [{
        "kind": "Normal",
        "name": "N"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-declarative-environment-records-hasbinding-n",
    "rawBody": "{\n  0:if (= envRec[\"SubMap\"][N] absent) {} else return true\n  1:return false\n}"
  }, {
    "code": ["            1. Assert: _envRec_ does not already have a binding for _N_.", "            1. Create a mutable binding in _envRec_ for _N_ and record that it is uninitialized. If _D_ is *true*, record that the newly created binding may be deleted by a subsequent DeleteBinding call.", "            1. Return NormalCompletion(~empty~)."],
    "head": {
      "base": "DeclarativeEnvironmentRecord",
      "methodName": "CreateMutableBinding",
      "origParams": [{
        "kind": "Normal",
        "name": "N"
      }, {
        "kind": "Normal",
        "name": "D"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-declarative-environment-records-createmutablebinding-n-d",
    "rawBody": "{\n  1:envRec[\"SubMap\"][N] = (0) (new MutableBinding(\"initialized\" -> false))\n  1:if (= D true) envRec[\"SubMap\"][N][\"maybeDeleted\"] = true else {}\n  2:return CONST_empty\n}"
  }, {
    "code": ["            1. Assert: _envRec_ does not already have a binding for _N_.", "            1. Create an immutable binding in _envRec_ for _N_ and record that it is uninitialized. If _S_ is *true*, record that the newly created binding is a strict binding.", "            1. Return NormalCompletion(~empty~)."],
    "head": {
      "base": "DeclarativeEnvironmentRecord",
      "methodName": "CreateImmutableBinding",
      "origParams": [{
        "kind": "Normal",
        "name": "N"
      }, {
        "kind": "Normal",
        "name": "S"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-declarative-environment-records-createimmutablebinding-n-s",
    "rawBody": "{\n  1:envRec[\"SubMap\"][N] = (0) (new ImmutableBinding(\"initialized\" -> false, \"strict\" -> S))\n  2:return CONST_empty\n}"
  }, {
    "code": ["            1. Assert: _envRec_ must have an uninitialized binding for _N_.", "            1. Set the bound value for _N_ in _envRec_ to _V_.", "            1. <emu-not-ref>Record</emu-not-ref> that the binding for _N_ in _envRec_ has been initialized.", "            1. Return NormalCompletion(~empty~)."],
    "head": {
      "base": "DeclarativeEnvironmentRecord",
      "methodName": "InitializeBinding",
      "origParams": [{
        "kind": "Normal",
        "name": "N"
      }, {
        "kind": "Normal",
        "name": "V"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-declarative-environment-records-initializebinding-n-v",
    "rawBody": "{\n  1:envRec[\"SubMap\"][N][\"BoundValue\"] = V\n  3:return CONST_empty\n}"
  }, {
    "code": ["            1. [id=\"step-setmutablebinding-missing-binding\"] If _envRec_ does not have a binding for _N_, then", "              1. If _S_ is *true*, throw a *ReferenceError* exception.", "              1. Perform _envRec_.CreateMutableBinding(_N_, *true*).", "              1. Perform _envRec_.InitializeBinding(_N_, _V_).", "              1. Return NormalCompletion(~empty~).", "            1. If the binding for _N_ in _envRec_ is a strict binding, set _S_ to *true*.", "            1. If the binding for _N_ in _envRec_ has not yet been initialized, throw a *ReferenceError* exception.", "            1. Else if the binding for _N_ in _envRec_ is a mutable binding, change its bound value to _V_.", "            1. Else,", "              1. Assert: This is an attempt to change the value of an immutable binding.", "              1. If _S_ is *true*, throw a *TypeError* exception.", "            1. Return NormalCompletion(~empty~)."],
    "head": {
      "base": "DeclarativeEnvironmentRecord",
      "methodName": "SetMutableBinding",
      "origParams": [{
        "kind": "Normal",
        "name": "N"
      }, {
        "kind": "Normal",
        "name": "V"
      }, {
        "kind": "Normal",
        "name": "S"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-declarative-environment-records-setmutablebinding-n-v-s",
    "rawBody": "{\n  0:(0) ??? \"If id:{envRec} does not have a binding for id:{N} , then in:{} out:{}\"\n  5:(1) ??? \"If the binding for id:{N} in id:{envRec} is a strict binding , set id:{S} to value:{true} .\"\n  6:(2) ??? \"If the binding for id:{N} in id:{envRec} has not yet been initialized , throw a value:{ReferenceError} exception .\"\n  7:(3) ??? \"Else if the binding for id:{N} in id:{envRec} is a mutable binding , change its bound value to id:{V} .\"\n  8:(4) ??? \"Else , in:{} out:{}\"\n  11:return CONST_empty\n}"
  }, {
    "code": ["            1. Assert: _envRec_ has a binding for _N_.", "            1. If the binding for _N_ in _envRec_ is an uninitialized binding, throw a *ReferenceError* exception.", "            1. Return the value currently bound to _N_ in _envRec_."],
    "head": {
      "base": "DeclarativeEnvironmentRecord",
      "methodName": "GetBindingValue",
      "origParams": [{
        "kind": "Normal",
        "name": "N"
      }, {
        "kind": "Normal",
        "name": "S"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-declarative-environment-records-getbindingvalue-n-s",
    "rawBody": "{\n  1:(0) ??? \"If the binding for id:{N} in id:{envRec} is an uninitialized binding , throw a value:{ReferenceError} exception .\"\n  2:return envRec[\"SubMap\"][N][\"BoundValue\"]\n}"
  }, {
    "code": ["            1. Assert: _envRec_ has a binding for the name that is the value of _N_.", "            1. If the binding for _N_ in _envRec_ cannot be deleted, return *false*.", "            1. Remove the binding for _N_ from _envRec_.", "            1. Return *true*."],
    "head": {
      "base": "DeclarativeEnvironmentRecord",
      "methodName": "DeleteBinding",
      "origParams": [{
        "kind": "Normal",
        "name": "N"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-declarative-environment-records-deletebinding-n",
    "rawBody": "{\n  1:(0) ??? \"If the binding for id:{N} in id:{envRec} cannot be deleted , return value:{false} .\"\n  2:delete envRec[N]\n  3:return true\n}"
  }, {
    "code": ["            1. Return *false*."],
    "head": {
      "base": "DeclarativeEnvironmentRecord",
      "methodName": "HasThisBinding",
      "origParams": [],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-declarative-environment-records-hasthisbinding",
    "rawBody": "return false"
  }, {
    "code": ["            1. Return *false*."],
    "head": {
      "base": "DeclarativeEnvironmentRecord",
      "methodName": "HasSuperBinding",
      "origParams": [],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-declarative-environment-records-hassuperbinding",
    "rawBody": "return false"
  }, {
    "code": ["            1. Return *undefined*."],
    "head": {
      "base": "DeclarativeEnvironmentRecord",
      "methodName": "WithBaseObject",
      "origParams": [],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-declarative-environment-records-withbaseobject",
    "rawBody": "return undefined"
  }, {
    "code": ["            1. Let _bindings_ be the binding object for _envRec_.", "            1. Let _foundBinding_ be ? HasProperty(_bindings_, _N_).", "            1. If _foundBinding_ is *false*, return *false*.", "            1. If the _withEnvironment_ flag of _envRec_ is *false*, return *true*.", "            1. Let _unscopables_ be ? Get(_bindings_, @@unscopables).", "            1. If Type(_unscopables_) is Object, then", "              1. Let _blocked_ be ! ToBoolean(? Get(_unscopables_, _N_)).", "              1. If _blocked_ is *true*, return *false*.", "            1. Return *true*."],
    "head": {
      "base": "ObjectEnvironmentRecord",
      "methodName": "HasBinding",
      "origParams": [{
        "kind": "Normal",
        "name": "N"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-object-environment-records-hasbinding-n",
    "rawBody": "{\n  0:let bindings = envRec[\"BindingObject\"]\n  1:(0) app __x0__ = (HasProperty bindings N)\n  1:let foundBinding = [? __x0__]\n  2:if (= foundBinding false) return false else 0:{}\n  3:if (= envRec[\"withEnvironment\"] false) return true else 0:{}\n  4:(1) app __x1__ = (Get bindings SYMBOL_unscopables)\n  4:let unscopables = [? __x1__]\n  5:if (= (typeof unscopables) Object) {\n    6:(2) app __x2__ = (Get unscopables N)\n    6:(3) app __x3__ = (ToBoolean [? __x2__])\n    6:let blocked = [! __x3__]\n    7:if (= blocked true) return false else 0:{}\n  } else 0:{}\n  8:return true\n}"
  }, {
    "code": ["            1. Let _bindings_ be the binding object for _envRec_.", "            1. Return ? DefinePropertyOrThrow(_bindings_, _N_, PropertyDescriptor { [[Value]]: *undefined*, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: _D_ })."],
    "head": {
      "base": "ObjectEnvironmentRecord",
      "methodName": "CreateMutableBinding",
      "origParams": [{
        "kind": "Normal",
        "name": "N"
      }, {
        "kind": "Normal",
        "name": "D"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-object-environment-records-createmutablebinding-n-d",
    "rawBody": "{\n  0:let bindings = envRec[\"BindingObject\"]\n  1:(0) app __x0__ = (DefinePropertyOrThrow bindings N (0) (new PropertyDescriptor(\"Value\" -> undefined, \"Writable\" -> true, \"Enumerable\" -> true, \"Configurable\" -> D)))\n  1:return [? __x0__]\n}"
  }, {
    "code": ["            1. Return ? _envRec_.SetMutableBinding(_N_, _V_, *false*)."],
    "head": {
      "base": "ObjectEnvironmentRecord",
      "methodName": "InitializeBinding",
      "origParams": [{
        "kind": "Normal",
        "name": "N"
      }, {
        "kind": "Normal",
        "name": "V"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-object-environment-records-initializebinding-n-v",
    "rawBody": "{\n  0:(0) app __x0__ = (envRec[\"SetMutableBinding\"] envRec N V false)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["            1. Let _bindings_ be the binding object for _envRec_.", "            1. Let _stillExists_ be ? HasProperty(_bindings_, _N_).", "            1. If _stillExists_ is *false* and _S_ is *true*, throw a *ReferenceError* exception.", "            1. Return ? Set(_bindings_, _N_, _V_, _S_)."],
    "head": {
      "base": "ObjectEnvironmentRecord",
      "methodName": "SetMutableBinding",
      "origParams": [{
        "kind": "Normal",
        "name": "N"
      }, {
        "kind": "Normal",
        "name": "V"
      }, {
        "kind": "Normal",
        "name": "S"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-object-environment-records-setmutablebinding-n-v-s",
    "rawBody": "{\n  0:let bindings = envRec[\"BindingObject\"]\n  1:(0) app __x0__ = (HasProperty bindings N)\n  1:let stillExists = [? __x0__]\n  2:if (&& (= stillExists false) (= S true)) (0) throw ReferenceError else 0:{}\n  3:(1) app __x1__ = (Set bindings N V S)\n  3:return [? __x1__]\n}"
  }, {
    "code": ["            1. Let _bindings_ be the binding object for _envRec_.", "            1. Let _value_ be ? HasProperty(_bindings_, _N_).", "            1. If _value_ is *false*, then", "              1. If _S_ is *false*, return the value *undefined*; otherwise throw a *ReferenceError* exception.", "            1. Return ? Get(_bindings_, _N_)."],
    "head": {
      "base": "ObjectEnvironmentRecord",
      "methodName": "GetBindingValue",
      "origParams": [{
        "kind": "Normal",
        "name": "N"
      }, {
        "kind": "Normal",
        "name": "S"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-object-environment-records-getbindingvalue-n-s",
    "rawBody": "{\n  0:let bindings = envRec[\"BindingObject\"]\n  1:(0) app __x0__ = (HasProperty bindings N)\n  1:let value = [? __x0__]\n  2:if (= value false) if (= S false) return undefined else (0) throw ReferenceError else 0:{}\n  4:(1) app __x1__ = (Get bindings N)\n  4:return [? __x1__]\n}"
  }, {
    "code": ["            1. Let _bindings_ be the binding object for _envRec_.", "            1. Return ? _bindings_.[[Delete]](_N_)."],
    "head": {
      "base": "ObjectEnvironmentRecord",
      "methodName": "DeleteBinding",
      "origParams": [{
        "kind": "Normal",
        "name": "N"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-object-environment-records-deletebinding-n",
    "rawBody": "{\n  0:let bindings = envRec[\"BindingObject\"]\n  1:(0) app __x0__ = (bindings[\"Delete\"] bindings N)\n  1:return [? __x0__]\n}"
  }, {
    "code": ["            1. Return *false*."],
    "head": {
      "base": "ObjectEnvironmentRecord",
      "methodName": "HasThisBinding",
      "origParams": [],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-object-environment-records-hasthisbinding",
    "rawBody": "return false"
  }, {
    "code": ["            1. Return *false*."],
    "head": {
      "base": "ObjectEnvironmentRecord",
      "methodName": "HasSuperBinding",
      "origParams": [],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-object-environment-records-hassuperbinding",
    "rawBody": "return false"
  }, {
    "code": ["            1. If the _withEnvironment_ flag of _envRec_ is *true*, return the binding object for _envRec_.", "            1. Otherwise, return *undefined*."],
    "head": {
      "base": "ObjectEnvironmentRecord",
      "methodName": "WithBaseObject",
      "origParams": [],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-object-environment-records-withbaseobject",
    "rawBody": "if (= envRec[\"withEnvironment\"] true) return envRec[\"BindingObject\"] else return undefined"
  }, {
    "code": ["            1. Assert: _envRec_.[[ThisBindingStatus]] is not ~lexical~.", "            1. If _envRec_.[[ThisBindingStatus]] is ~initialized~, throw a *ReferenceError* exception.", "            1. Set _envRec_.[[ThisValue]] to _V_.", "            1. Set _envRec_.[[ThisBindingStatus]] to ~initialized~.", "            1. Return _V_."],
    "head": {
      "base": "FunctionEnvironmentRecord",
      "methodName": "BindThisValue",
      "origParams": [{
        "kind": "Normal",
        "name": "V"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-bindthisvalue",
    "rawBody": "{\n  0:assert (! (= envRec[\"ThisBindingStatus\"] CONST_lexical))\n  1:if (= envRec[\"ThisBindingStatus\"] CONST_initialized) (0) throw ReferenceError else 0:{}\n  2:envRec[\"ThisValue\"] = V\n  3:envRec[\"ThisBindingStatus\"] = CONST_initialized\n  4:return V\n}"
  }, {
    "code": ["            1. If _envRec_.[[ThisBindingStatus]] is ~lexical~, return *false*; otherwise, return *true*."],
    "head": {
      "base": "FunctionEnvironmentRecord",
      "methodName": "HasThisBinding",
      "origParams": [],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-function-environment-records-hasthisbinding",
    "rawBody": "if (= envRec[\"ThisBindingStatus\"] CONST_lexical) return false else return true"
  }, {
    "code": ["            1. If _envRec_.[[ThisBindingStatus]] is ~lexical~, return *false*.", "            1. If _envRec_.[[FunctionObject]].[[HomeObject]] has the value *undefined*, return *false*; otherwise, return *true*."],
    "head": {
      "base": "FunctionEnvironmentRecord",
      "methodName": "HasSuperBinding",
      "origParams": [],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-function-environment-records-hassuperbinding",
    "rawBody": "{\n  0:if (= envRec[\"ThisBindingStatus\"] CONST_lexical) return false else 0:{}\n  1:if (= envRec[\"FunctionObject\"][\"HomeObject\"] undefined) return false else return true\n}"
  }, {
    "code": ["            1. Assert: _envRec_.[[ThisBindingStatus]] is not ~lexical~.", "            1. If _envRec_.[[ThisBindingStatus]] is ~uninitialized~, throw a *ReferenceError* exception.", "            1. Return _envRec_.[[ThisValue]]."],
    "head": {
      "base": "FunctionEnvironmentRecord",
      "methodName": "GetThisBinding",
      "origParams": [],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-function-environment-records-getthisbinding",
    "rawBody": "{\n  0:assert (! (= envRec[\"ThisBindingStatus\"] CONST_lexical))\n  1:if (= envRec[\"ThisBindingStatus\"] CONST_uninitialized) (0) throw ReferenceError else 0:{}\n  2:return envRec[\"ThisValue\"]\n}"
  }, {
    "code": ["            1. Let _home_ be _envRec_.[[FunctionObject]].[[HomeObject]].", "            1. If _home_ has the value *undefined*, return *undefined*.", "            1. Assert: Type(_home_) is Object.", "            1. Return ? _home_.[[GetPrototypeOf]]()."],
    "head": {
      "base": "FunctionEnvironmentRecord",
      "methodName": "GetSuperBase",
      "origParams": [],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-getsuperbase",
    "rawBody": "{\n  0:let home = envRec[\"FunctionObject\"][\"HomeObject\"]\n  1:if (= home undefined) return undefined else 0:{}\n  2:assert (= (typeof home) Object)\n  3:(0) app __x0__ = (home[\"GetPrototypeOf\"] home)\n  3:return [? __x0__]\n}"
  }, {
    "code": ["            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].", "            1. If _DclRec_.HasBinding(_N_) is *true*, return *true*.", "            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].", "            1. Return ? _ObjRec_.HasBinding(_N_)."],
    "head": {
      "base": "GlobalEnvironmentRecord",
      "methodName": "HasBinding",
      "origParams": [{
        "kind": "Normal",
        "name": "N"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-global-environment-records-hasbinding-n",
    "rawBody": "{\n  0:let DclRec = envRec[\"DeclarativeRecord\"]\n  1:(0) app __x0__ = (DclRec[\"HasBinding\"] DclRec N)\n  1:if (= __x0__ true) return true else 0:{}\n  2:let ObjRec = envRec[\"ObjectRecord\"]\n  3:(1) app __x1__ = (ObjRec[\"HasBinding\"] ObjRec N)\n  3:return [? __x1__]\n}"
  }, {
    "code": ["            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].", "            1. If _DclRec_.HasBinding(_N_) is *true*, throw a *TypeError* exception.", "            1. Return _DclRec_.CreateMutableBinding(_N_, _D_)."],
    "head": {
      "base": "GlobalEnvironmentRecord",
      "methodName": "CreateMutableBinding",
      "origParams": [{
        "kind": "Normal",
        "name": "N"
      }, {
        "kind": "Normal",
        "name": "D"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-global-environment-records-createmutablebinding-n-d",
    "rawBody": "{\n  0:let DclRec = envRec[\"DeclarativeRecord\"]\n  1:(0) app __x0__ = (DclRec[\"HasBinding\"] DclRec N)\n  1:if (= __x0__ true) (0) throw TypeError else 0:{}\n  2:(1) app __x1__ = (DclRec[\"CreateMutableBinding\"] DclRec N D)\n  2:return __x1__\n}"
  }, {
    "code": ["            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].", "            1. If _DclRec_.HasBinding(_N_) is *true*, throw a *TypeError* exception.", "            1. Return _DclRec_.CreateImmutableBinding(_N_, _S_)."],
    "head": {
      "base": "GlobalEnvironmentRecord",
      "methodName": "CreateImmutableBinding",
      "origParams": [{
        "kind": "Normal",
        "name": "N"
      }, {
        "kind": "Normal",
        "name": "S"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-global-environment-records-createimmutablebinding-n-s",
    "rawBody": "{\n  0:let DclRec = envRec[\"DeclarativeRecord\"]\n  1:(0) app __x0__ = (DclRec[\"HasBinding\"] DclRec N)\n  1:if (= __x0__ true) (0) throw TypeError else 0:{}\n  2:(1) app __x1__ = (DclRec[\"CreateImmutableBinding\"] DclRec N S)\n  2:return __x1__\n}"
  }, {
    "code": ["            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].", "            1. If _DclRec_.HasBinding(_N_) is *true*, then", "              1. Return _DclRec_.InitializeBinding(_N_, _V_).", "            1. Assert: If the binding exists, it must be in the object Environment Record.", "            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].", "            1. Return ? _ObjRec_.InitializeBinding(_N_, _V_)."],
    "head": {
      "base": "GlobalEnvironmentRecord",
      "methodName": "InitializeBinding",
      "origParams": [{
        "kind": "Normal",
        "name": "N"
      }, {
        "kind": "Normal",
        "name": "V"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-global-environment-records-initializebinding-n-v",
    "rawBody": "{\n  0:let DclRec = envRec[\"DeclarativeRecord\"]\n  1:(0) app __x0__ = (DclRec[\"HasBinding\"] DclRec N)\n  1:if (= __x0__ true) {\n    2:(1) app __x1__ = (DclRec[\"InitializeBinding\"] DclRec N V)\n    2:return __x1__\n  } else 3:{}\n  4:let ObjRec = envRec[\"ObjectRecord\"]\n  5:(2) app __x2__ = (ObjRec[\"InitializeBinding\"] ObjRec N V)\n  5:return [? __x2__]\n}"
  }, {
    "code": ["            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].", "            1. If _DclRec_.HasBinding(_N_) is *true*, then", "              1. Return _DclRec_.SetMutableBinding(_N_, _V_, _S_).", "            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].", "            1. Return ? _ObjRec_.SetMutableBinding(_N_, _V_, _S_)."],
    "head": {
      "base": "GlobalEnvironmentRecord",
      "methodName": "SetMutableBinding",
      "origParams": [{
        "kind": "Normal",
        "name": "N"
      }, {
        "kind": "Normal",
        "name": "V"
      }, {
        "kind": "Normal",
        "name": "S"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-global-environment-records-setmutablebinding-n-v-s",
    "rawBody": "{\n  0:let DclRec = envRec[\"DeclarativeRecord\"]\n  1:(0) app __x0__ = (DclRec[\"HasBinding\"] DclRec N)\n  1:if (= __x0__ true) {\n    2:(1) app __x1__ = (DclRec[\"SetMutableBinding\"] DclRec N V S)\n    2:return __x1__\n  } else 3:{}\n  3:let ObjRec = envRec[\"ObjectRecord\"]\n  4:(2) app __x2__ = (ObjRec[\"SetMutableBinding\"] ObjRec N V S)\n  4:return [? __x2__]\n}"
  }, {
    "code": ["            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].", "            1. If _DclRec_.HasBinding(_N_) is *true*, then", "              1. Return _DclRec_.GetBindingValue(_N_, _S_).", "            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].", "            1. Return ? _ObjRec_.GetBindingValue(_N_, _S_)."],
    "head": {
      "base": "GlobalEnvironmentRecord",
      "methodName": "GetBindingValue",
      "origParams": [{
        "kind": "Normal",
        "name": "N"
      }, {
        "kind": "Normal",
        "name": "S"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-global-environment-records-getbindingvalue-n-s",
    "rawBody": "{\n  0:let DclRec = envRec[\"DeclarativeRecord\"]\n  1:(0) app __x0__ = (DclRec[\"HasBinding\"] DclRec N)\n  1:if (= __x0__ true) {\n    2:(1) app __x1__ = (DclRec[\"GetBindingValue\"] DclRec N S)\n    2:return __x1__\n  } else 3:{}\n  3:let ObjRec = envRec[\"ObjectRecord\"]\n  4:(2) app __x2__ = (ObjRec[\"GetBindingValue\"] ObjRec N S)\n  4:return [? __x2__]\n}"
  }, {
    "code": ["            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].", "            1. If _DclRec_.HasBinding(_N_) is *true*, then", "              1. Return _DclRec_.DeleteBinding(_N_).", "            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].", "            1. Let _globalObject_ be the binding object for _ObjRec_.", "            1. Let _existingProp_ be ? HasOwnProperty(_globalObject_, _N_).", "            1. If _existingProp_ is *true*, then", "              1. Let _status_ be ? _ObjRec_.DeleteBinding(_N_).", "              1. If _status_ is *true*, then", "                1. Let _varNames_ be _envRec_.[[VarNames]].", "                1. If _N_ is an element of _varNames_, remove that element from the _varNames_.", "              1. Return _status_.", "            1. Return *true*."],
    "head": {
      "base": "GlobalEnvironmentRecord",
      "methodName": "DeleteBinding",
      "origParams": [{
        "kind": "Normal",
        "name": "N"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-global-environment-records-deletebinding-n",
    "rawBody": "{\n  0:let DclRec = envRec[\"DeclarativeRecord\"]\n  1:(0) app __x0__ = (DclRec[\"HasBinding\"] DclRec N)\n  1:if (= __x0__ true) {\n    2:(1) app __x1__ = (DclRec[\"DeleteBinding\"] DclRec N)\n    2:return __x1__\n  } else 3:{}\n  3:let ObjRec = envRec[\"ObjectRecord\"]\n  4:let globalObject = ObjRec[\"BindingObject\"]\n  5:(2) app __x2__ = (HasOwnProperty globalObject N)\n  5:let existingProp = [? __x2__]\n  6:if (= existingProp true) {\n    7:(3) app __x3__ = (ObjRec[\"DeleteBinding\"] ObjRec N)\n    7:let status = [? __x3__]\n    8:if (= status true) {\n      9:let varNames = envRec[\"VarNames\"]\n      10:(0) ??? \"If id:{N} is an element of id:{varNames} , remove that element from the id:{varNames} .\"\n    } else 3:{}\n    11:return status\n  } else 3:{}\n  12:return true\n}"
  }, {
    "code": ["            1. Return *true*."],
    "head": {
      "base": "GlobalEnvironmentRecord",
      "methodName": "HasThisBinding",
      "origParams": [],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-global-environment-records-hasthisbinding",
    "rawBody": "return true"
  }, {
    "code": ["            1. Return *false*."],
    "head": {
      "base": "GlobalEnvironmentRecord",
      "methodName": "HasSuperBinding",
      "origParams": [],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-global-environment-records-hassuperbinding",
    "rawBody": "return false"
  }, {
    "code": ["            1. Return *undefined*."],
    "head": {
      "base": "GlobalEnvironmentRecord",
      "methodName": "WithBaseObject",
      "origParams": [],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-global-environment-records-withbaseobject",
    "rawBody": "return undefined"
  }, {
    "code": ["            1. Return _envRec_.[[GlobalThisValue]]."],
    "head": {
      "base": "GlobalEnvironmentRecord",
      "methodName": "GetThisBinding",
      "origParams": [],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-global-environment-records-getthisbinding",
    "rawBody": "return envRec[\"GlobalThisValue\"]"
  }, {
    "code": ["            1. Let _varDeclaredNames_ be _envRec_.[[VarNames]].", "            1. If _varDeclaredNames_ contains _N_, return *true*.", "            1. Return *false*."],
    "head": {
      "base": "GlobalEnvironmentRecord",
      "methodName": "HasVarDeclaration",
      "origParams": [{
        "kind": "Normal",
        "name": "N"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-hasvardeclaration",
    "rawBody": "{\n  0:let varDeclaredNames = envRec[\"VarNames\"]\n  1:if (contains varDeclaredNames N) return true else 3:{}\n  2:return false\n}"
  }, {
    "code": ["            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].", "            1. Return _DclRec_.HasBinding(_N_)."],
    "head": {
      "base": "GlobalEnvironmentRecord",
      "methodName": "HasLexicalDeclaration",
      "origParams": [{
        "kind": "Normal",
        "name": "N"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-haslexicaldeclaration",
    "rawBody": "{\n  0:let DclRec = envRec[\"DeclarativeRecord\"]\n  1:(0) app __x0__ = (DclRec[\"HasBinding\"] DclRec N)\n  1:return __x0__\n}"
  }, {
    "code": ["            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].", "            1. Let _globalObject_ be the binding object for _ObjRec_.", "            1. Let _existingProp_ be ? _globalObject_.[[GetOwnProperty]](_N_).", "            1. If _existingProp_ is *undefined*, return *false*.", "            1. If _existingProp_.[[Configurable]] is *true*, return *false*.", "            1. Return *true*."],
    "head": {
      "base": "GlobalEnvironmentRecord",
      "methodName": "HasRestrictedGlobalProperty",
      "origParams": [{
        "kind": "Normal",
        "name": "N"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-hasrestrictedglobalproperty",
    "rawBody": "{\n  0:let ObjRec = envRec[\"ObjectRecord\"]\n  1:let globalObject = ObjRec[\"BindingObject\"]\n  2:(0) app __x0__ = (globalObject[\"GetOwnProperty\"] globalObject N)\n  2:let existingProp = [? __x0__]\n  3:if (= existingProp undefined) return false else 3:{}\n  4:if (= existingProp[\"Configurable\"] true) return false else 3:{}\n  5:return true\n}"
  }, {
    "code": ["            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].", "            1. Let _globalObject_ be the binding object for _ObjRec_.", "            1. Let _hasProperty_ be ? HasOwnProperty(_globalObject_, _N_).", "            1. If _hasProperty_ is *true*, return *true*.", "            1. Return ? IsExtensible(_globalObject_)."],
    "head": {
      "base": "GlobalEnvironmentRecord",
      "methodName": "CanDeclareGlobalVar",
      "origParams": [{
        "kind": "Normal",
        "name": "N"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-candeclareglobalvar",
    "rawBody": "{\n  0:let ObjRec = envRec[\"ObjectRecord\"]\n  1:let globalObject = ObjRec[\"BindingObject\"]\n  2:(0) app __x0__ = (HasOwnProperty globalObject N)\n  2:let hasProperty = [? __x0__]\n  3:if (= hasProperty true) return true else 3:{}\n  4:(1) app __x1__ = (IsExtensible globalObject)\n  4:return [? __x1__]\n}"
  }, {
    "code": ["            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].", "            1. Let _globalObject_ be the binding object for _ObjRec_.", "            1. Let _existingProp_ be ? _globalObject_.[[GetOwnProperty]](_N_).", "            1. If _existingProp_ is *undefined*, return ? IsExtensible(_globalObject_).", "            1. If _existingProp_.[[Configurable]] is *true*, return *true*.", "            1. If IsDataDescriptor(_existingProp_) is *true* and _existingProp_ has attribute values { [[Writable]]: *true*, [[Enumerable]]: *true* }, return *true*.", "            1. Return *false*."],
    "head": {
      "base": "GlobalEnvironmentRecord",
      "methodName": "CanDeclareGlobalFunction",
      "origParams": [{
        "kind": "Normal",
        "name": "N"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-candeclareglobalfunction",
    "rawBody": "{\n  0:let ObjRec = envRec[\"ObjectRecord\"]\n  1:let globalObject = ObjRec[\"BindingObject\"]\n  2:(0) app __x0__ = (globalObject[\"GetOwnProperty\"] globalObject N)\n  2:let existingProp = [? __x0__]\n  3:if (= existingProp undefined) {\n    (1) app __x1__ = (IsExtensible globalObject)\n    return [? __x1__]\n  } else 3:{}\n  4:if (= existingProp[\"Configurable\"] true) return true else 3:{}\n  5:(0) ??? \"If IsDataDescriptor ( id:{existingProp} ) is value:{true} and id:{existingProp} has attribute values { [ [ Writable ] ] : value:{true} , [ [ Enumerable ] ] : value:{true} } , return value:{true} .\"\n  6:return false\n}"
  }, {
    "code": ["            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].", "            1. Let _globalObject_ be the binding object for _ObjRec_.", "            1. Let _hasProperty_ be ? HasOwnProperty(_globalObject_, _N_).", "            1. Let _extensible_ be ? IsExtensible(_globalObject_).", "            1. If _hasProperty_ is *false* and _extensible_ is *true*, then", "              1. Perform ? _ObjRec_.CreateMutableBinding(_N_, _D_).", "              1. Perform ? _ObjRec_.InitializeBinding(_N_, *undefined*).", "            1. Let _varDeclaredNames_ be _envRec_.[[VarNames]].", "            1. If _varDeclaredNames_ does not contain _N_, then", "              1. Append _N_ to _varDeclaredNames_.", "            1. Return NormalCompletion(~empty~)."],
    "head": {
      "base": "GlobalEnvironmentRecord",
      "methodName": "CreateGlobalVarBinding",
      "origParams": [{
        "kind": "Normal",
        "name": "N"
      }, {
        "kind": "Normal",
        "name": "D"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-createglobalvarbinding",
    "rawBody": "{\n  0:let ObjRec = envRec[\"ObjectRecord\"]\n  1:let globalObject = ObjRec[\"BindingObject\"]\n  2:(0) app __x0__ = (HasOwnProperty globalObject N)\n  2:let hasProperty = [? __x0__]\n  3:(1) app __x1__ = (IsExtensible globalObject)\n  3:let extensible = [? __x1__]\n  4:if (&& (= hasProperty false) (= extensible true)) {\n    5:(2) app __x2__ = (ObjRec[\"CreateMutableBinding\"] ObjRec N D)\n    5:[? __x2__]\n    6:(3) app __x3__ = (ObjRec[\"InitializeBinding\"] ObjRec N undefined)\n    6:[? __x3__]\n  } else 3:{}\n  7:let varDeclaredNames = envRec[\"VarNames\"]\n  8:if (! (contains varDeclaredNames N)) append N -> varDeclaredNames else 3:{}\n  10:return CONST_empty\n}"
  }, {
    "code": ["            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].", "            1. Let _globalObject_ be the binding object for _ObjRec_.", "            1. Let _existingProp_ be ? _globalObject_.[[GetOwnProperty]](_N_).", "            1. If _existingProp_ is *undefined* or _existingProp_.[[Configurable]] is *true*, then", "              1. Let _desc_ be the PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: _D_ }.", "            1. Else,", "              1. Let _desc_ be the PropertyDescriptor { [[Value]]: _V_ }.", "            1. Perform ? DefinePropertyOrThrow(_globalObject_, _N_, _desc_).", "            1. [id=\"step-createglobalfunctionbinding-set\"] Perform ? Set(_globalObject_, _N_, _V_, *false*).", "            1. Let _varDeclaredNames_ be _envRec_.[[VarNames]].", "            1. If _varDeclaredNames_ does not contain _N_, then", "              1. Append _N_ to _varDeclaredNames_.", "            1. Return NormalCompletion(~empty~)."],
    "head": {
      "base": "GlobalEnvironmentRecord",
      "methodName": "CreateGlobalFunctionBinding",
      "origParams": [{
        "kind": "Normal",
        "name": "N"
      }, {
        "kind": "Normal",
        "name": "V"
      }, {
        "kind": "Normal",
        "name": "D"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-createglobalfunctionbinding",
    "rawBody": "{\n  0:let ObjRec = envRec[\"ObjectRecord\"]\n  1:let globalObject = ObjRec[\"BindingObject\"]\n  2:(0) app __x0__ = (globalObject[\"GetOwnProperty\"] globalObject N)\n  2:let existingProp = [? __x0__]\n  5:if (|| (= existingProp undefined) (= existingProp[\"Configurable\"] true)) let desc = (0) (new PropertyDescriptor(\"Value\" -> V, \"Writable\" -> true, \"Enumerable\" -> true, \"Configurable\" -> D)) else let desc = (1) (new PropertyDescriptor(\"Value\" -> V))\n  7:(1) app __x1__ = (DefinePropertyOrThrow globalObject N desc)\n  7:[? __x1__]\n  8:(2) app __x2__ = (Set globalObject N V false)\n  8:[? __x2__]\n  9:let varDeclaredNames = envRec[\"VarNames\"]\n  10:if (! (contains varDeclaredNames N)) append N -> varDeclaredNames else 3:{}\n  12:return CONST_empty\n}"
  }, {
    "code": ["            1. Assert: _S_ is *true*.", "            1. Assert: _envRec_ has a binding for _N_.", "            1. If the binding for _N_ is an indirect binding, then", "              1. Let _M_ and _N2_ be the indirection values provided when this binding for _N_ was created.", "              1. Let _targetEnv_ be _M_.[[Environment]].", "              1. If _targetEnv_ is *undefined*, throw a *ReferenceError* exception.", "              1. Return ? _targetEnv_.GetBindingValue(_N2_, *true*).", "            1. If the binding for _N_ in _envRec_ is an uninitialized binding, throw a *ReferenceError* exception.", "            1. Return the value currently bound to _N_ in _envRec_."],
    "head": {
      "base": "ModuleEnvironmentRecord",
      "methodName": "GetBindingValue",
      "origParams": [{
        "kind": "Normal",
        "name": "N"
      }, {
        "kind": "Normal",
        "name": "S"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-module-environment-records-getbindingvalue-n-s",
    "rawBody": "{\n  0:assert (= S true)\n  2:(0) ??? \"If the binding for id:{N} is an indirect binding , then in:{} out:{}\"\n  7:(1) ??? \"If the binding for id:{N} in id:{envRec} is an uninitialized binding , throw a value:{ReferenceError} exception .\"\n  8:return envRec[\"SubMap\"][N][\"BoundValue\"]\n}"
  }, {
    "code": ["            1. Return *true*."],
    "head": {
      "base": "ModuleEnvironmentRecord",
      "methodName": "HasThisBinding",
      "origParams": [],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-module-environment-records-hasthisbinding",
    "rawBody": "return true"
  }, {
    "code": ["            1. Return *undefined*."],
    "head": {
      "base": "ModuleEnvironmentRecord",
      "methodName": "GetThisBinding",
      "origParams": [],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-module-environment-records-getthisbinding",
    "rawBody": "return undefined"
  }, {
    "code": ["            1. Assert: _envRec_ does not already have a binding for _N_.", "            1. Assert: _M_ is a Module Record.", "            1. Assert: When _M_.[[Environment]] is instantiated it will have a direct binding for _N2_.", "            1. Create an immutable indirect binding in _envRec_ for _N_ that references _M_ and _N2_ as its target binding and record that the binding is initialized.", "            1. Return NormalCompletion(~empty~)."],
    "head": {
      "base": "ModuleEnvironmentRecord",
      "methodName": "CreateImportBinding",
      "origParams": [{
        "kind": "Normal",
        "name": "N"
      }, {
        "kind": "Normal",
        "name": "M"
      }, {
        "kind": "Normal",
        "name": "N2"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "envRec"
      }
    },
    "ids": "sec-createimportbinding",
    "rawBody": "{\n  3:(0) ??? \"Create an immutable indirect binding in id:{envRec} for id:{N} that references id:{M} and id:{N2} as its target binding and record that the binding is initialized .\"\n  4:return CONST_empty\n}"
  }, {
    "code": ["          1. If _env_ is the value *null*, then", "            1. Return the Reference Record { [[Base]]: ~unresolvable~, [[ReferencedName]]: _name_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ }.", "          1. Let _exists_ be ? _env_.HasBinding(_name_).", "          1. If _exists_ is *true*, then", "            1. Return the Reference Record { [[Base]]: _env_, [[ReferencedName]]: _name_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ }.", "          1. Else,", "            1. Let _outer_ be _env_.[[OuterEnv]].", "            1. Return ? GetIdentifierReference(_outer_, _name_, _strict_)."],
    "head": {
      "name": "GetIdentifierReference",
      "params": [{
        "kind": "Normal",
        "name": "env"
      }, {
        "kind": "Normal",
        "name": "name"
      }, {
        "kind": "Normal",
        "name": "strict"
      }]
    },
    "ids": "sec-getidentifierreference",
    "rawBody": "{\n  0:if (= env null) return (0) (new ReferenceRecord(\"Base\" -> CONST_unresolvable, \"ReferencedName\" -> name, \"Strict\" -> strict, \"ThisValue\" -> CONST_empty)) else 2:{}\n  2:(0) app __x0__ = (env[\"HasBinding\"] env name)\n  2:let exists = [? __x0__]\n  5:if (= exists true) return (1) (new ReferenceRecord(\"Base\" -> env, \"ReferencedName\" -> name, \"Strict\" -> strict, \"ThisValue\" -> CONST_empty)) else {\n    6:let outer = env[\"OuterEnv\"]\n    7:(1) app __x1__ = (GetIdentifierReference outer name strict)\n    7:return [? __x1__]\n  }\n}"
  }, {
    "code": ["          1. Let _env_ be a new declarative Environment Record containing no bindings.", "          1. Set _env_.[[OuterEnv]] to _E_.", "          1. Return _env_."],
    "head": {
      "name": "NewDeclarativeEnvironment",
      "params": [{
        "kind": "Normal",
        "name": "E"
      }]
    },
    "ids": "sec-newdeclarativeenvironment",
    "rawBody": "{\n  0:let env = (0) (new DeclarativeEnvironmentRecord())\n  1:env[\"OuterEnv\"] = E\n  2:return env\n}"
  }, {
    "code": ["          1. Let _env_ be a new object Environment Record containing _O_ as the binding object.", "          1. Set _env_.[[OuterEnv]] to _E_.", "          1. Return _env_."],
    "head": {
      "name": "NewObjectEnvironment",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "E"
      }]
    },
    "ids": "sec-newobjectenvironment",
    "rawBody": "{\n  0:let env = (0) (new ObjectEnvironmentRecord(\"BindingObject\" -> O))\n  1:env[\"OuterEnv\"] = E\n  2:return env\n}"
  }, {
    "code": ["          1. Assert: _F_ is an ECMAScript function.", "          1. Assert: Type(_newTarget_) is Undefined or Object.", "          1. Let _env_ be a new function Environment Record containing no bindings.", "          1. Set _env_.[[FunctionObject]] to _F_.", "          1. If _F_.[[ThisMode]] is ~lexical~, set _env_.[[ThisBindingStatus]] to ~lexical~.", "          1. Else, set _env_.[[ThisBindingStatus]] to ~uninitialized~.", "          1. Set _env_.[[NewTarget]] to _newTarget_.", "          1. Set _env_.[[OuterEnv]] to _F_.[[Environment]].", "          1. Return _env_."],
    "head": {
      "name": "NewFunctionEnvironment",
      "params": [{
        "kind": "Normal",
        "name": "F"
      }, {
        "kind": "Normal",
        "name": "newTarget"
      }]
    },
    "ids": "sec-newfunctionenvironment",
    "rawBody": "{\n  0:assert (0) (is-instance-of F ECMAScriptFunctionObject)\n  1:assert (|| (= (typeof newTarget) Undefined) (= (typeof newTarget) Object))\n  2:let env = (1) (new FunctionEnvironmentRecord())\n  3:env[\"FunctionObject\"] = F\n  5:if (= F[\"ThisMode\"] CONST_lexical) env[\"ThisBindingStatus\"] = CONST_lexical else env[\"ThisBindingStatus\"] = CONST_uninitialized\n  6:env[\"NewTarget\"] = newTarget\n  7:env[\"OuterEnv\"] = F[\"Environment\"]\n  8:return env\n}"
  }, {
    "code": ["          1. Let _objRec_ be a new object Environment Record containing _G_ as the binding object.", "          1. Let _dclRec_ be a new declarative Environment Record containing no bindings.", "          1. Let _env_ be a new global Environment Record.", "          1. Set _env_.[[ObjectRecord]] to _objRec_.", "          1. Set _env_.[[GlobalThisValue]] to _thisValue_.", "          1. Set _env_.[[DeclarativeRecord]] to _dclRec_.", "          1. Set _env_.[[VarNames]] to a new empty List.", "          1. Set _env_.[[OuterEnv]] to *null*.", "          1. Return _env_."],
    "head": {
      "name": "NewGlobalEnvironment",
      "params": [{
        "kind": "Normal",
        "name": "G"
      }, {
        "kind": "Normal",
        "name": "thisValue"
      }]
    },
    "ids": "sec-newglobalenvironment",
    "rawBody": "{\n  0:let objRec = (0) (new ObjectEnvironmentRecord(\"BindingObject\" -> G))\n  1:let dclRec = (1) (new DeclarativeEnvironmentRecord())\n  2:let env = (2) (new GlobalEnvironmentRecord())\n  3:env[\"ObjectRecord\"] = objRec\n  4:env[\"GlobalThisValue\"] = thisValue\n  5:env[\"DeclarativeRecord\"] = dclRec\n  6:env[\"VarNames\"] = (3) (new [])\n  7:env[\"OuterEnv\"] = null\n  8:return env\n}"
  }, {
    "code": ["          1. Let _env_ be a new module Environment Record containing no bindings.", "          1. Set _env_.[[OuterEnv]] to _E_.", "          1. Return _env_."],
    "head": {
      "name": "NewModuleEnvironment",
      "params": [{
        "kind": "Normal",
        "name": "E"
      }]
    },
    "ids": "sec-newmoduleenvironment",
    "rawBody": "{\n  0:let env = (0) (new ModuleEnvironmentRecord())\n  1:env[\"OuterEnv\"] = E\n  2:return env\n}"
  }, {
    "code": ["        1. Let _realmRec_ be a new Realm Record.", "        1. Perform CreateIntrinsics(_realmRec_).", "        1. Set _realmRec_.[[GlobalObject]] to *undefined*.", "        1. Set _realmRec_.[[GlobalEnv]] to *undefined*.", "        1. Set _realmRec_.[[TemplateMap]] to a new empty List.", "        1. Return _realmRec_."],
    "head": {
      "name": "CreateRealm",
      "params": []
    },
    "ids": "sec-createrealm",
    "rawBody": "{\n  0:let realmRec = REALM\n  1:(0) app __x0__ = (CreateIntrinsics realmRec)\n  1:__x0__\n  2:realmRec[\"GlobalObject\"] = undefined\n  3:realmRec[\"GlobalEnv\"] = undefined\n  4:realmRec[\"TemplateMap\"] = (0) (new [])\n  5:return realmRec\n}"
  }, {
    "code": ["        1. Let _intrinsics_ be a new Record.", "        1. Set _realmRec_.[[Intrinsics]] to _intrinsics_.", "        1. Set fields of _intrinsics_ with the values listed in <emu-xref href=\"#table-well-known-intrinsic-objects\"></emu-xref>. The field names are the names listed in column one of the table. The value of each field is a new object value fully and recursively populated with property values as defined by the specification of each object in clauses <emu-xref href=\"#sec-global-object\"></emu-xref> through <emu-xref href=\"#sec-reflection\"></emu-xref>. All object property values are newly created object values. All values that are built-in function objects are created by performing CreateBuiltinFunction(_steps_, _length_, _name_, _slots_, _realmRec_, _prototype_) where _steps_ is the definition of that function provided by this specification, _name_ is the initial value of the function's `name` property, _length_ is the initial value of the function's `length` property, _slots_ is a list of the names, if any, of the function's specified internal slots, and _prototype_ is the specified value of the function's [[Prototype]] internal slot. The creation of the intrinsics and their properties must be ordered to avoid any dependencies upon objects that have not yet been created.", "        1. Perform AddRestrictedFunctionProperties(_intrinsics_.[[%Function.prototype%]], _realmRec_).", "        1. Return _intrinsics_."],
    "head": {
      "name": "CreateIntrinsics",
      "params": [{
        "kind": "Normal",
        "name": "realmRec"
      }]
    },
    "ids": "sec-createintrinsics",
    "rawBody": "{\n  0:let intrinsics = (0) (new Record())\n  1:realmRec[\"Intrinsics\"] = intrinsics\n  2:realmRec[\"Intrinsics\"] = INTRINSICS\n  2:intrinsics = INTRINSICS\n  3:(0) app __x0__ = (AddRestrictedFunctionProperties intrinsics[\"INTRINSIC_Function_prototype\"] realmRec)\n  3:__x0__\n  4:return intrinsics\n}"
  }, {
    "code": ["        1. If _globalObj_ is *undefined*, then", "          1. Let _intrinsics_ be _realmRec_.[[Intrinsics]].", "          1. Set _globalObj_ to ! OrdinaryObjectCreate(_intrinsics_.[[%Object.prototype%]]).", "        1. Assert: Type(_globalObj_) is Object.", "        1. If _thisValue_ is *undefined*, set _thisValue_ to _globalObj_.", "        1. Set _realmRec_.[[GlobalObject]] to _globalObj_.", "        1. Let _newGlobalEnv_ be NewGlobalEnvironment(_globalObj_, _thisValue_).", "        1. Set _realmRec_.[[GlobalEnv]] to _newGlobalEnv_.", "        1. Return _realmRec_."],
    "head": {
      "name": "SetRealmGlobalObject",
      "params": [{
        "kind": "Normal",
        "name": "realmRec"
      }, {
        "kind": "Normal",
        "name": "globalObj"
      }, {
        "kind": "Normal",
        "name": "thisValue"
      }]
    },
    "ids": "sec-setrealmglobalobject",
    "rawBody": "{\n  0:if (= globalObj undefined) {\n    1:let intrinsics = realmRec[\"Intrinsics\"]\n    2:(0) app __x0__ = (OrdinaryObjectCreate intrinsics[\"INTRINSIC_Object_prototype\"])\n    2:globalObj = [! __x0__]\n  } else 2:{}\n  3:assert (= (typeof globalObj) Object)\n  4:if (= thisValue undefined) thisValue = globalObj else 2:{}\n  5:realmRec[\"GlobalObject\"] = globalObj\n  6:(1) app __x1__ = (NewGlobalEnvironment globalObj thisValue)\n  6:let newGlobalEnv = __x1__\n  7:realmRec[\"GlobalEnv\"] = newGlobalEnv\n  8:return realmRec\n}"
  }, {
    "code": ["        1. Let _global_ be _realmRec_.[[GlobalObject]].", "        1. For each property of the Global Object specified in clause <emu-xref href=\"#sec-global-object\"></emu-xref>, do", "          1. Let _name_ be the String value of the property name.", "          1. Let _desc_ be the fully populated data Property Descriptor for the property, containing the specified attributes for the property. For properties listed in <emu-xref href=\"#sec-function-properties-of-the-global-object\"></emu-xref>, <emu-xref href=\"#sec-constructor-properties-of-the-global-object\"></emu-xref>, or <emu-xref href=\"#sec-other-properties-of-the-global-object\"></emu-xref> the value of the [[Value]] attribute is the corresponding intrinsic object from _realmRec_.", "          1. Perform ? DefinePropertyOrThrow(_global_, _name_, _desc_).", "        1. Return _global_."],
    "head": {
      "name": "SetDefaultGlobalBindings",
      "params": [{
        "kind": "Normal",
        "name": "realmRec"
      }]
    },
    "ids": "sec-setdefaultglobalbindings",
    "rawBody": "{\n  0:let global = realmRec[\"GlobalObject\"]\n  1:let __keys__ = (0) (map-keys GLOBAL[\"SubMap\"])\n  1:let __i__ = 0i\n  1:while (< __i__ __keys__[\"length\"]) {\n    let name = __keys__[__i__]\n    let desc = GLOBAL[\"SubMap\"][name]\n    global[\"SubMap\"][name] = GLOBAL[\"SubMap\"][name]\n    __i__ = (+ __i__ 1i)\n  }\n  1:global[\"SubMap\"][\"globalThis\"][\"Value\"] = global\n  5:return global\n}"
  }, {
    "code": ["        1. If the execution context stack is empty, return *null*.", "        1. Let _ec_ be the topmost execution context on the execution context stack whose ScriptOrModule component is not *null*.", "        1. If no such execution context exists, return *null*. Otherwise, return _ec_'s ScriptOrModule."],
    "head": {
      "name": "GetActiveScriptOrModule",
      "params": []
    },
    "ids": "sec-getactivescriptormodule",
    "rawBody": "{\n  0:if (= EXECUTION_STACK[\"length\"] 0i) return null else 2:{}\n  1:let ec = EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)]\n  2:return ec[\"ScriptOrModule\"]\n}"
  }, {
    "code": ["        1. If _env_ is not present or if _env_ is *undefined*, then", "          1. Set _env_ to the running execution context's LexicalEnvironment.", "        1. Assert: _env_ is an Environment Record.", "        1. If the code matching the syntactic production that is being evaluated is contained in strict mode code, let _strict_ be *true*; else let _strict_ be *false*.", "        1. Return ? GetIdentifierReference(_env_, _name_, _strict_)."],
    "head": {
      "name": "ResolveBinding",
      "params": [{
        "kind": "Normal",
        "name": "name"
      }, {
        "kind": "Optional",
        "name": "env"
      }]
    },
    "ids": "sec-resolvebinding",
    "rawBody": "{\n  0:if (|| (= env absent) (= env undefined)) env = CONTEXT[\"LexicalEnvironment\"] else 2:{}\n  2:assert (0) (is-instance-of env EnvironmentRecord)\n  3:if true let strict = true else let strict = false\n  4:(0) app __x0__ = (GetIdentifierReference env name strict)\n  4:return [? __x0__]\n}"
  }, {
    "code": ["        1. Let _env_ be the running execution context's LexicalEnvironment.", "        1. [id=\"step-getthisenvironment-loop\"] Repeat,", "          1. Let _exists_ be _env_.HasThisBinding().", "          1. If _exists_ is *true*, return _env_.", "          1. Let _outer_ be _env_.[[OuterEnv]].", "          1. Assert: _outer_ is not *null*.", "          1. Set _env_ to _outer_."],
    "head": {
      "name": "GetThisEnvironment",
      "params": []
    },
    "ids": "sec-getthisenvironment",
    "rawBody": "{\n  0:let env = CONTEXT[\"LexicalEnvironment\"]\n  1:while true {\n    2:(0) app __x0__ = (env[\"HasThisBinding\"] env)\n    2:let exists = __x0__\n    3:if (= exists true) return env else 2:{}\n    4:let outer = env[\"OuterEnv\"]\n    5:assert (! (= outer null))\n    6:env = outer\n  }\n}"
  }, {
    "code": ["        1. Let _envRec_ be GetThisEnvironment().", "        1. Return ? _envRec_.GetThisBinding()."],
    "head": {
      "name": "ResolveThisBinding",
      "params": []
    },
    "ids": "sec-resolvethisbinding",
    "rawBody": "{\n  0:(0) app __x0__ = (GetThisEnvironment)\n  0:let envRec = __x0__\n  1:(1) app __x1__ = (envRec[\"GetThisBinding\"] envRec)\n  1:return [? __x1__]\n}"
  }, {
    "code": ["        1. Let _envRec_ be GetThisEnvironment().", "        1. Assert: _envRec_ has a [[NewTarget]] field.", "        1. Return _envRec_.[[NewTarget]]."],
    "head": {
      "name": "GetNewTarget",
      "params": []
    },
    "ids": "sec-getnewtarget",
    "rawBody": "{\n  0:(0) app __x0__ = (GetThisEnvironment)\n  0:let envRec = __x0__\n  1:assert (! (= envRec[\"NewTarget\"] absent))\n  2:return envRec[\"NewTarget\"]\n}"
  }, {
    "code": ["        1. Let _currentRealm_ be the current Realm Record.", "        1. Return _currentRealm_.[[GlobalObject]]."],
    "head": {
      "name": "GetGlobalObject",
      "params": []
    },
    "ids": "sec-getglobalobject",
    "rawBody": "{\n  0:let currentRealm = REALM\n  1:return currentRealm[\"GlobalObject\"]\n}"
  }, {
    "code": ["        1. Assert: IsCallable(_callback_) is *true*.", "        1. Return the JobCallback Record { [[Callback]]: _callback_, [[HostDefined]]: ~empty~ }."],
    "head": {
      "name": "HostMakeJobCallback",
      "params": [{
        "kind": "Normal",
        "name": "callback"
      }]
    },
    "ids": "sec-hostmakejobcallback",
    "rawBody": "{\n  0:(0) app __x0__ = (IsCallable callback)\n  0:assert (= __x0__ true)\n  1:return (0) (new JobCallbackRecord(\"Callback\" -> callback, \"HostDefined\" -> CONST_empty))\n}"
  }, {
    "code": ["        1. Assert: IsCallable(_jobCallback_.[[Callback]]) is *true*.", "        1. Return ? Call(_jobCallback_.[[Callback]], _V_, _argumentsList_)."],
    "head": {
      "name": "HostCallJobCallback",
      "params": [{
        "kind": "Normal",
        "name": "jobCallback"
      }, {
        "kind": "Normal",
        "name": "V"
      }, {
        "kind": "Normal",
        "name": "argumentsList"
      }]
    },
    "ids": "sec-hostcalljobcallback",
    "rawBody": "{\n  0:(0) app __x0__ = (IsCallable jobCallback[\"Callback\"])\n  0:assert (= __x0__ true)\n  1:(1) app __x1__ = (Call jobCallback[\"Callback\"] V argumentsList)\n  1:return [? __x1__]\n}"
  }, {
    "code": ["      1. Let _realm_ be CreateRealm().", "      1. Let _newContext_ be a new execution context.", "      1. Set the Function of _newContext_ to *null*.", "      1. Set the Realm of _newContext_ to _realm_.", "      1. Set the ScriptOrModule of _newContext_ to *null*.", "      1. Push _newContext_ onto the execution context stack; _newContext_ is now the running execution context.", "      1. If the host requires use of an exotic object to serve as _realm_'s global object, let _global_ be such an object created in a host-defined manner. Otherwise, let _global_ be *undefined*, indicating that an ordinary object should be created as the global object.", "      1. If the host requires that the `this` binding in _realm_'s global scope return an object other than the global object, let _thisValue_ be such an object created in a host-defined manner. Otherwise, let _thisValue_ be *undefined*, indicating that _realm_'s global `this` binding should be the global object.", "      1. Perform SetRealmGlobalObject(_realm_, _global_, _thisValue_).", "      1. Let _globalObj_ be ? SetDefaultGlobalBindings(_realm_).", "      1. Create any host-defined global object properties on _globalObj_.", "      1. Return NormalCompletion(~empty~)."],
    "head": {
      "name": "InitializeHostDefinedRealm",
      "params": []
    },
    "ids": "sec-initializehostdefinedrealm",
    "rawBody": "{\n  0:(0) app __x0__ = (CreateRealm)\n  0:let realm = __x0__\n  1:let newContext = (0) (new ExecutionContext())\n  2:newContext[\"Function\"] = null\n  3:newContext[\"Realm\"] = realm\n  4:newContext[\"ScriptOrModule\"] = null\n  5:append newContext -> EXECUTION_STACK\n  5:CONTEXT = EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)]\n  6:let global = undefined\n  7:let thisValue = undefined\n  8:(1) app __x1__ = (SetRealmGlobalObject realm global thisValue)\n  8:__x1__\n  9:(2) app __x2__ = (SetDefaultGlobalBindings realm)\n  9:let globalObj = [? __x2__]\n  11:return CONST_empty\n}"
  }, {
    "code": ["        1. Let _AR_ be the Agent Record of the surrounding agent.", "        1. Return _AR_.[[Signifier]]."],
    "head": {
      "name": "AgentSignifier",
      "params": []
    },
    "ids": "sec-agentsignifier",
    "rawBody": "{\n  0:let AR = AGENT\n  1:return AR[\"Signifier\"]\n}"
  }, {
    "code": ["        1. Let _AR_ be the Agent Record of the surrounding agent.", "        1. Return _AR_.[[CanBlock]]."],
    "head": {
      "name": "AgentCanSuspend",
      "params": []
    },
    "ids": "sec-agentcansuspend",
    "rawBody": "{\n  0:let AR = AGENT\n  1:return AR[\"CanBlock\"]\n}"
  }, {
    "code": ["        1. For each element _obj_ of _S_, do", "          1. For each WeakRef _ref_ such that _ref_.[[WeakRefTarget]] is _obj_, do", "            1. Set _ref_.[[WeakRefTarget]] to ~empty~.", "          1. For each FinalizationRegistry _fg_ such that _fg_.[[Cells]] contains a Record _cell_ such that _cell_.[[WeakRefTarget]] is _obj_, do", "            1. Set _cell_.[[WeakRefTarget]] to ~empty~.", "            1. Optionally, perform ! HostEnqueueFinalizationRegistryCleanupJob(_fg_).", "          1. For each WeakMap _map_ such that _map_.[[WeakMapData]] contains a Record _r_ such that _r_.[[Key]] is _obj_, do", "            1. Set _r_.[[Key]] to ~empty~.", "            1. Set _r_.[[Value]] to ~empty~.", "          1. For each WeakSet _set_ such that _set_.[[WeakSetData]] contains _obj_, do", "            1. Replace the element of _set_.[[WeakSetData]] whose value is _obj_ with an element whose value is ~empty~."],
    "head": {
      "name": "Execution",
      "params": []
    },
    "ids": "sec-weakref-execution",
    "rawBody": "{\n  0:let __x0__ = S\n  0:let __x1__ = 0i\n  0:while (< __x1__ __x0__[\"length\"]) {\n    let obj = __x0__[__x1__]\n    1:(0) ??? \"For each WeakRef id:{ref} such that id:{ref} . [ [ WeakRefTarget ] ] is id:{obj} , do in:{} out:{}\"\n    3:(1) ??? \"For each FinalizationRegistry id:{fg} such that id:{fg} . [ [ Cells ] ] contains a Record id:{cell} such that id:{cell} . [ [ WeakRefTarget ] ] is id:{obj} , do in:{} out:{}\"\n    6:(2) ??? \"For each WeakMap id:{map} such that id:{map} . [ [ WeakMapData ] ] contains a Record id:{r} such that id:{r} . [ [ Key ] ] is id:{obj} , do in:{} out:{}\"\n    9:(3) ??? \"For each WeakSet id:{set} such that id:{set} . [ [ WeakSetData ] ] contains id:{obj} , do in:{} out:{}\"\n    __x1__ = (+ __x1__ 1i)\n  }\n}"
  }, {
    "code": ["      1. Let _agentRecord_ be the surrounding agent's Agent Record.", "      1. Set _agentRecord_.[[KeptAlive]] to a new empty List."],
    "head": {
      "name": "ClearKeptObjects",
      "params": []
    },
    "ids": "sec-clear-kept-objects",
    "rawBody": "{\n  0:let agentRecord = AGENT\n  1:agentRecord[\"KeptAlive\"] = (0) (new [])\n}"
  }, {
    "code": ["      1. Let _agentRecord_ be the surrounding agent's Agent Record.", "      1. Append _object_ to _agentRecord_.[[KeptAlive]]."],
    "head": {
      "name": "AddToKeptObjects",
      "params": [{
        "kind": "Normal",
        "name": "object"
      }]
    },
    "ids": "sec-addtokeptobjects",
    "rawBody": "{\n  0:let agentRecord = AGENT\n  1:append object -> agentRecord[\"KeptAlive\"]\n}"
  }, {
    "code": ["      1. Assert: _finalizationRegistry_ has [[Cells]] and [[CleanupCallback]] internal slots.", "      1. Let _callback_ be _finalizationRegistry_.[[CleanupCallback]].", "      1. While _finalizationRegistry_.[[Cells]] contains a Record _cell_ such that _cell_.[[WeakRefTarget]] is ~empty~, an implementation may perform the following steps:", "        1. Choose any such _cell_.", "        1. Remove _cell_ from _finalizationRegistry_.[[Cells]].", "        1. Perform ? Call(_callback_, *undefined*, « _cell_.[[HeldValue]] »).", "      1. Return NormalCompletion(*undefined*)."],
    "head": {
      "name": "CleanupFinalizationRegistry",
      "params": [{
        "kind": "Normal",
        "name": "finalizationRegistry"
      }]
    },
    "ids": "sec-cleanup-finalization-registry",
    "rawBody": "{\n  1:let callback = finalizationRegistry[\"CleanupCallback\"]\n  2:(0) ??? \"While id:{finalizationRegistry} . [ [ Cells ] ] contains a Record id:{cell} such that id:{cell} . [ [ WeakRefTarget ] ] is const:{empty} , an implementation may perform the following steps : in:{} out:{}\"\n  6:return undefined\n}"
  }, {
    "code": ["        1. Return ! OrdinaryGetPrototypeOf(_O_)."],
    "head": {
      "base": "OrdinaryObject",
      "methodName": "GetPrototypeOf",
      "origParams": [],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-ordinary-object-internal-methods-and-internal-slots-getprototypeof",
    "rawBody": "{\n  0:(0) app __x0__ = (OrdinaryGetPrototypeOf O)\n  0:return [! __x0__]\n}"
  }, {
    "code": ["          1. Return _O_.[[Prototype]]."],
    "head": {
      "name": "OrdinaryGetPrototypeOf",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }]
    },
    "ids": "sec-ordinarygetprototypeof",
    "rawBody": "return O[\"Prototype\"]"
  }, {
    "code": ["        1. Return ! OrdinarySetPrototypeOf(_O_, _V_)."],
    "head": {
      "base": "OrdinaryObject",
      "methodName": "SetPrototypeOf",
      "origParams": [{
        "kind": "Normal",
        "name": "V"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-ordinary-object-internal-methods-and-internal-slots-setprototypeof-v",
    "rawBody": "{\n  0:(0) app __x0__ = (OrdinarySetPrototypeOf O V)\n  0:return [! __x0__]\n}"
  }, {
    "code": ["          1. Assert: Either Type(_V_) is Object or Type(_V_) is Null.", "          1. Let _current_ be _O_.[[Prototype]].", "          1. If SameValue(_V_, _current_) is *true*, return *true*.", "          1. Let _extensible_ be _O_.[[Extensible]].", "          1. If _extensible_ is *false*, return *false*.", "          1. Let _p_ be _V_.", "          1. Let _done_ be *false*.", "          1. [id=\"step-ordinarysetprototypeof-loop\"] Repeat, while _done_ is *false*,", "            1. If _p_ is *null*, set _done_ to *true*.", "            1. Else if SameValue(_p_, _O_) is *true*, return *false*.", "            1. Else,", "              1. If _p_.[[GetPrototypeOf]] is not the ordinary object internal method defined in <emu-xref href=\"#sec-ordinary-object-internal-methods-and-internal-slots-getprototypeof\"></emu-xref>, set _done_ to *true*.", "              1. Else, set _p_ to _p_.[[Prototype]].", "          1. Set _O_.[[Prototype]] to _V_.", "          1. Return *true*."],
    "head": {
      "name": "OrdinarySetPrototypeOf",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "V"
      }]
    },
    "ids": "sec-ordinarysetprototypeof",
    "rawBody": "{\n  1:let current = O[\"Prototype\"]\n  2:(0) app __x0__ = (SameValue V current)\n  2:if (= __x0__ true) return true else 0:{}\n  3:let extensible = O[\"Extensible\"]\n  4:if (= extensible false) return false else 0:{}\n  5:let p = V\n  6:let done = false\n  7:while (= done false) if (= p null) done = true else {\n    (1) app __x1__ = (SameValue p O)\n    if (= __x1__ true) return false else if (! (= p[\"GetPrototypeOf\"] ALGORITHM[\"OrdinaryObject.GetPrototypeOf\"])) done = true else p = p[\"Prototype\"]\n  }\n  13:O[\"Prototype\"] = V\n  14:return true\n}"
  }, {
    "code": ["        1. Return ! OrdinaryIsExtensible(_O_)."],
    "head": {
      "base": "OrdinaryObject",
      "methodName": "IsExtensible",
      "origParams": [],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-ordinary-object-internal-methods-and-internal-slots-isextensible",
    "rawBody": "{\n  0:(0) app __x0__ = (OrdinaryIsExtensible O)\n  0:return [! __x0__]\n}"
  }, {
    "code": ["          1. Return _O_.[[Extensible]]."],
    "head": {
      "name": "OrdinaryIsExtensible",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }]
    },
    "ids": "sec-ordinaryisextensible",
    "rawBody": "return O[\"Extensible\"]"
  }, {
    "code": ["        1. Return ! OrdinaryPreventExtensions(_O_)."],
    "head": {
      "base": "OrdinaryObject",
      "methodName": "PreventExtensions",
      "origParams": [],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-ordinary-object-internal-methods-and-internal-slots-preventextensions",
    "rawBody": "{\n  0:(0) app __x0__ = (OrdinaryPreventExtensions O)\n  0:return [! __x0__]\n}"
  }, {
    "code": ["          1. Set _O_.[[Extensible]] to *false*.", "          1. Return *true*."],
    "head": {
      "name": "OrdinaryPreventExtensions",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }]
    },
    "ids": "sec-ordinarypreventextensions",
    "rawBody": "{\n  0:O[\"Extensible\"] = false\n  1:return true\n}"
  }, {
    "code": ["        1. Return ! OrdinaryGetOwnProperty(_O_, _P_)."],
    "head": {
      "base": "OrdinaryObject",
      "methodName": "GetOwnProperty",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-ordinary-object-internal-methods-and-internal-slots-getownproperty-p",
    "rawBody": "{\n  0:(0) app __x0__ = (OrdinaryGetOwnProperty O P)\n  0:return [! __x0__]\n}"
  }, {
    "code": ["          1. Assert: IsPropertyKey(_P_) is *true*.", "          1. If _O_ does not have an own property with key _P_, return *undefined*.", "          1. Let _D_ be a newly created Property Descriptor with no fields.", "          1. Let _X_ be _O_'s own property whose key is _P_.", "          1. If _X_ is a data property, then", "            1. Set _D_.[[Value]] to the value of _X_'s [[Value]] attribute.", "            1. Set _D_.[[Writable]] to the value of _X_'s [[Writable]] attribute.", "          1. Else,", "            1. Assert: _X_ is an accessor property.", "            1. Set _D_.[[Get]] to the value of _X_'s [[Get]] attribute.", "            1. Set _D_.[[Set]] to the value of _X_'s [[Set]] attribute.", "          1. Set _D_.[[Enumerable]] to the value of _X_'s [[Enumerable]] attribute.", "          1. Set _D_.[[Configurable]] to the value of _X_'s [[Configurable]] attribute.", "          1. Return _D_."],
    "head": {
      "name": "OrdinaryGetOwnProperty",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "P"
      }]
    },
    "ids": "sec-ordinarygetownproperty",
    "rawBody": "{\n  0:(0) app __x0__ = (IsPropertyKey P)\n  0:assert (= __x0__ true)\n  1:if (= O[\"SubMap\"][P] absent) return undefined else 0:{}\n  2:let D = (0) (new PropertyDescriptor())\n  3:let X = O[\"SubMap\"][P]\n  7:(1) app __x1__ = (IsDataDescriptor X)\n  7:if __x1__ {\n    5:D[\"Value\"] = X[\"Value\"]\n    6:D[\"Writable\"] = X[\"Writable\"]\n  } else {\n    8:(2) app __x2__ = (IsAccessorDescriptor X)\n    8:assert __x2__\n    9:D[\"Get\"] = X[\"Get\"]\n    10:D[\"Set\"] = X[\"Set\"]\n  }\n  11:D[\"Enumerable\"] = X[\"Enumerable\"]\n  12:D[\"Configurable\"] = X[\"Configurable\"]\n  13:return D\n}"
  }, {
    "code": ["        1. Return ? OrdinaryDefineOwnProperty(_O_, _P_, _Desc_)."],
    "head": {
      "base": "OrdinaryObject",
      "methodName": "DefineOwnProperty",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Normal",
        "name": "Desc"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-ordinary-object-internal-methods-and-internal-slots-defineownproperty-p-desc",
    "rawBody": "{\n  0:(0) app __x0__ = (OrdinaryDefineOwnProperty O P Desc)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Let _current_ be ? _O_.[[GetOwnProperty]](_P_).", "          1. Let _extensible_ be ? IsExtensible(_O_).", "          1. Return ValidateAndApplyPropertyDescriptor(_O_, _P_, _extensible_, _Desc_, _current_)."],
    "head": {
      "name": "OrdinaryDefineOwnProperty",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Normal",
        "name": "Desc"
      }]
    },
    "ids": "sec-ordinarydefineownproperty",
    "rawBody": "{\n  0:(0) app __x0__ = (O[\"GetOwnProperty\"] O P)\n  0:let current = [? __x0__]\n  1:(1) app __x1__ = (IsExtensible O)\n  1:let extensible = [? __x1__]\n  2:(2) app __x2__ = (ValidateAndApplyPropertyDescriptor O P extensible Desc current)\n  2:return __x2__\n}"
  }, {
    "code": ["          1. Return ValidateAndApplyPropertyDescriptor(*undefined*, *undefined*, _Extensible_, _Desc_, _Current_)."],
    "head": {
      "name": "IsCompatiblePropertyDescriptor",
      "params": [{
        "kind": "Normal",
        "name": "Extensible"
      }, {
        "kind": "Normal",
        "name": "Desc"
      }, {
        "kind": "Normal",
        "name": "Current"
      }]
    },
    "ids": "sec-iscompatiblepropertydescriptor",
    "rawBody": "{\n  0:(0) app __x0__ = (ValidateAndApplyPropertyDescriptor undefined undefined Extensible Desc Current)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Assert: If _O_ is not *undefined*, then IsPropertyKey(_P_) is *true*.", "          1. If _current_ is *undefined*, then", "            1. If _extensible_ is *false*, return *false*.", "            1. Assert: _extensible_ is *true*.", "            1. If IsGenericDescriptor(_Desc_) is *true* or IsDataDescriptor(_Desc_) is *true*, then", "              1. If _O_ is not *undefined*, create an own data property named _P_ of object _O_ whose [[Value]], [[Writable]], [[Enumerable]], and [[Configurable]] attribute values are described by _Desc_. If the value of an attribute field of _Desc_ is absent, the attribute of the newly created property is set to its <emu-xref href=\"#table-default-attribute-values\">default value</emu-xref>.", "            1. Else,", "              1. Assert: ! IsAccessorDescriptor(_Desc_) is *true*.", "              1. If _O_ is not *undefined*, create an own accessor property named _P_ of object _O_ whose [[Get]], [[Set]], [[Enumerable]], and [[Configurable]] attribute values are described by _Desc_. If the value of an attribute field of _Desc_ is absent, the attribute of the newly created property is set to its <emu-xref href=\"#table-default-attribute-values\">default value</emu-xref>.", "            1. Return *true*.", "          1. If every field in _Desc_ is absent, return *true*.", "          1. If _current_.[[Configurable]] is *false*, then", "            1. If _Desc_.[[Configurable]] is present and its value is *true*, return *false*.", "            1. If _Desc_.[[Enumerable]] is present and ! SameValue(_Desc_.[[Enumerable]], _current_.[[Enumerable]]) is *false*, return *false*.", "          1. If ! IsGenericDescriptor(_Desc_) is *true*, then", "            1. NOTE: No further validation is required.", "          1. Else if ! SameValue(! IsDataDescriptor(_current_), ! IsDataDescriptor(_Desc_)) is *false*, then", "            1. If _current_.[[Configurable]] is *false*, return *false*.", "            1. If IsDataDescriptor(_current_) is *true*, then", "              1. If _O_ is not *undefined*, convert the property named _P_ of object _O_ from a data property to an accessor property. Preserve the existing values of the converted property's [[Configurable]] and [[Enumerable]] attributes and set the rest of the property's attributes to their <emu-xref href=\"#table-default-attribute-values\">default values</emu-xref>.", "            1. Else,", "              1. If _O_ is not *undefined*, convert the property named _P_ of object _O_ from an accessor property to a data property. Preserve the existing values of the converted property's [[Configurable]] and [[Enumerable]] attributes and set the rest of the property's attributes to their <emu-xref href=\"#table-default-attribute-values\">default values</emu-xref>.", "          1. Else if IsDataDescriptor(_current_) and IsDataDescriptor(_Desc_) are both *true*, then", "            1. If _current_.[[Configurable]] is *false* and _current_.[[Writable]] is *false*, then", "              1. If _Desc_.[[Writable]] is present and _Desc_.[[Writable]] is *true*, return *false*.", "              1. If _Desc_.[[Value]] is present and SameValue(_Desc_.[[Value]], _current_.[[Value]]) is *false*, return *false*.", "              1. Return *true*.", "          1. Else,", "            1. Assert: ! IsAccessorDescriptor(_current_) and ! IsAccessorDescriptor(_Desc_) are both *true*.", "            1. If _current_.[[Configurable]] is *false*, then", "              1. If _Desc_.[[Set]] is present and SameValue(_Desc_.[[Set]], _current_.[[Set]]) is *false*, return *false*.", "              1. If _Desc_.[[Get]] is present and SameValue(_Desc_.[[Get]], _current_.[[Get]]) is *false*, return *false*.", "              1. Return *true*.", "          1. If _O_ is not *undefined*, then", "            1. For each field of _Desc_ that is present, set the corresponding attribute of the property named _P_ of object _O_ to the value of the field.", "          1. Return *true*."],
    "head": {
      "name": "ValidateAndApplyPropertyDescriptor",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Normal",
        "name": "extensible"
      }, {
        "kind": "Normal",
        "name": "Desc"
      }, {
        "kind": "Normal",
        "name": "current"
      }]
    },
    "ids": "sec-validateandapplypropertydescriptor",
    "rawBody": "{\n  1:if (= current undefined) {\n    2:if (= extensible false) return false else 15:{}\n    3:assert (= extensible true)\n    6:let __x0__ = true\n    6:(0) app __x1__ = (IsGenericDescriptor Desc)\n    6:__x0__ = (= __x1__ true)\n    6:if __x0__ 15:{} else {\n      (1) app __x2__ = (IsDataDescriptor Desc)\n      __x0__ = (= __x2__ true)\n    }\n    6:if __x0__ if (! (= O undefined)) {\n      let dp = (0) (new DataProperty())\n      if (! (= absent Desc[\"Value\"])) dp[\"Value\"] = Desc[\"Value\"] else dp[\"Value\"] = undefined\n      if (! (= absent Desc[\"Writable\"])) dp[\"Writable\"] = Desc[\"Writable\"] else dp[\"Writable\"] = false\n      if (! (= absent Desc[\"Enumerable\"])) dp[\"Enumerable\"] = Desc[\"Enumerable\"] else dp[\"Enumerable\"] = false\n      if (! (= absent Desc[\"Configurable\"])) dp[\"Configurable\"] = Desc[\"Configurable\"] else dp[\"Configurable\"] = false\n      O[\"SubMap\"][P] = dp\n    } else {} else {\n      7:(2) app __x3__ = (IsAccessorDescriptor Desc)\n      7:assert (= [! __x3__] true)\n      8:if (= O undefined) {} else {}\n    }\n    9:return true\n  } else 15:{}\n  10:if (&& (= absent Desc[\"Value\"]) (&& (= absent Desc[\"Writable\"]) (&& (= absent Desc[\"Get\"]) (&& (= absent Desc[\"Set\"]) (&& (= absent Desc[\"Enumerable\"]) (= absent Desc[\"Configurable\"])))))) return true else {}\n  11:if (= current[\"Configurable\"] false) {\n    12:if (= Desc[\"Configurable\"] true) return false else 15:{}\n    13:let __x4__ = true\n    13:__x4__ = (! (= Desc[\"Enumerable\"] absent))\n    13:if __x4__ {\n      (3) app __x5__ = (SameValue Desc[\"Enumerable\"] current[\"Enumerable\"])\n      __x4__ = (= [! __x5__] false)\n    } else 15:{}\n    13:if __x4__ return false else 15:{}\n  } else 15:{}\n  27:(4) app __x6__ = (IsGenericDescriptor Desc)\n  27:if (= [! __x6__] true) {} else {\n    (5) app __x7__ = (IsDataDescriptor current)\n    (6) app __x8__ = (IsDataDescriptor Desc)\n    (7) app __x9__ = (SameValue [! __x7__] [! __x8__])\n    if (= [! __x9__] false) {\n      17:if (= current[\"Configurable\"] false) return false else 15:{}\n      20:(8) app __x10__ = (IsDataDescriptor current)\n      20:if (= __x10__ true) if (= O undefined) {} else {} else if (= O undefined) {} else {}\n    } else {\n      (9) app __x11__ = (IsDataDescriptor current)\n      (10) app __x12__ = (IsDataDescriptor Desc)\n      if (&& (= __x11__ true) (= __x12__ true)) if (&& (= current[\"Configurable\"] false) (= current[\"Writable\"] false)) {\n        24:if (&& (! (= Desc[\"Writable\"] absent)) (= Desc[\"Writable\"] true)) return false else 15:{}\n        25:let __x13__ = true\n        25:__x13__ = (! (= Desc[\"Value\"] absent))\n        25:if __x13__ {\n          (11) app __x14__ = (SameValue Desc[\"Value\"] current[\"Value\"])\n          __x13__ = (= __x14__ false)\n        } else 15:{}\n        25:if __x13__ return false else 15:{}\n        26:return true\n      } else 15:{} else {\n        28:(12) app __x15__ = (IsAccessorDescriptor current)\n        28:(13) app __x16__ = (IsAccessorDescriptor Desc)\n        28:assert (&& (= [! __x15__] true) (= [! __x16__] true))\n        29:if (= current[\"Configurable\"] false) {\n          30:let __x17__ = true\n          30:__x17__ = (! (= Desc[\"Set\"] absent))\n          30:if __x17__ {\n            (14) app __x18__ = (SameValue Desc[\"Set\"] current[\"Set\"])\n            __x17__ = (= __x18__ false)\n          } else 15:{}\n          30:if __x17__ return false else 15:{}\n          31:let __x19__ = true\n          31:__x19__ = (! (= Desc[\"Get\"] absent))\n          31:if __x19__ {\n            (15) app __x20__ = (SameValue Desc[\"Get\"] current[\"Get\"])\n            __x19__ = (= __x20__ false)\n          } else 15:{}\n          31:if __x19__ return false else 15:{}\n          32:return true\n        } else 15:{}\n      }\n    }\n  }\n  33:if (! (= O undefined)) {\n    34:let __keys__ = (1) (map-keys Desc)\n    34:let __i__ = 0i\n    34:while (< __i__ __keys__[\"length\"]) {\n      let __key__ = __keys__[__i__]\n      O[\"SubMap\"][P][__key__] = Desc[__key__]\n      __i__ = (+ __i__ 1i)\n    }\n  } else 15:{}\n  35:return true\n}"
  }, {
    "code": ["        1. Return ? OrdinaryHasProperty(_O_, _P_)."],
    "head": {
      "base": "OrdinaryObject",
      "methodName": "HasProperty",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-ordinary-object-internal-methods-and-internal-slots-hasproperty-p",
    "rawBody": "{\n  0:(0) app __x0__ = (OrdinaryHasProperty O P)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Assert: IsPropertyKey(_P_) is *true*.", "          1. Let _hasOwn_ be ? _O_.[[GetOwnProperty]](_P_).", "          1. If _hasOwn_ is not *undefined*, return *true*.", "          1. Let _parent_ be ? _O_.[[GetPrototypeOf]]().", "          1. If _parent_ is not *null*, then", "            1. Return ? _parent_.[[HasProperty]](_P_).", "          1. Return *false*."],
    "head": {
      "name": "OrdinaryHasProperty",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "P"
      }]
    },
    "ids": "sec-ordinaryhasproperty",
    "rawBody": "{\n  0:(0) app __x0__ = (IsPropertyKey P)\n  0:assert (= __x0__ true)\n  1:(1) app __x1__ = (O[\"GetOwnProperty\"] O P)\n  1:let hasOwn = [? __x1__]\n  2:if (! (= hasOwn undefined)) return true else 15:{}\n  3:(2) app __x2__ = (O[\"GetPrototypeOf\"] O)\n  3:let parent = [? __x2__]\n  4:if (! (= parent null)) {\n    5:(3) app __x3__ = (parent[\"HasProperty\"] parent P)\n    5:return [? __x3__]\n  } else 15:{}\n  6:return false\n}"
  }, {
    "code": ["        1. Return ? OrdinaryGet(_O_, _P_, _Receiver_)."],
    "head": {
      "base": "OrdinaryObject",
      "methodName": "Get",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Normal",
        "name": "Receiver"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver",
    "rawBody": "{\n  0:(0) app __x0__ = (OrdinaryGet O P Receiver)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Assert: IsPropertyKey(_P_) is *true*.", "          1. Let _desc_ be ? _O_.[[GetOwnProperty]](_P_).", "          1. If _desc_ is *undefined*, then", "            1. Let _parent_ be ? _O_.[[GetPrototypeOf]]().", "            1. If _parent_ is *null*, return *undefined*.", "            1. Return ? _parent_.[[Get]](_P_, _Receiver_).", "          1. If IsDataDescriptor(_desc_) is *true*, return _desc_.[[Value]].", "          1. Assert: IsAccessorDescriptor(_desc_) is *true*.", "          1. Let _getter_ be _desc_.[[Get]].", "          1. If _getter_ is *undefined*, return *undefined*.", "          1. Return ? Call(_getter_, _Receiver_)."],
    "head": {
      "name": "OrdinaryGet",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Normal",
        "name": "Receiver"
      }]
    },
    "ids": "sec-ordinaryget",
    "rawBody": "{\n  0:(0) app __x0__ = (IsPropertyKey P)\n  0:assert (= __x0__ true)\n  1:(1) app __x1__ = (O[\"GetOwnProperty\"] O P)\n  1:let desc = [? __x1__]\n  2:if (= desc undefined) {\n    3:(2) app __x2__ = (O[\"GetPrototypeOf\"] O)\n    3:let parent = [? __x2__]\n    4:if (= parent null) return undefined else 15:{}\n    5:(3) app __x3__ = (parent[\"Get\"] parent P Receiver)\n    5:return [? __x3__]\n  } else 15:{}\n  6:(4) app __x4__ = (IsDataDescriptor desc)\n  6:if (= __x4__ true) return desc[\"Value\"] else 15:{}\n  7:(5) app __x5__ = (IsAccessorDescriptor desc)\n  7:assert (= __x5__ true)\n  8:let getter = desc[\"Get\"]\n  9:if (= getter undefined) return undefined else 15:{}\n  10:(6) app __x6__ = (Call getter Receiver)\n  10:return [? __x6__]\n}"
  }, {
    "code": ["        1. Return ? OrdinarySet(_O_, _P_, _V_, _Receiver_)."],
    "head": {
      "base": "OrdinaryObject",
      "methodName": "Set",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Normal",
        "name": "V"
      }, {
        "kind": "Normal",
        "name": "Receiver"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-ordinary-object-internal-methods-and-internal-slots-set-p-v-receiver",
    "rawBody": "{\n  0:(0) app __x0__ = (OrdinarySet O P V Receiver)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Assert: IsPropertyKey(_P_) is *true*.", "          1. Let _ownDesc_ be ? _O_.[[GetOwnProperty]](_P_).", "          1. Return OrdinarySetWithOwnDescriptor(_O_, _P_, _V_, _Receiver_, _ownDesc_)."],
    "head": {
      "name": "OrdinarySet",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Normal",
        "name": "V"
      }, {
        "kind": "Normal",
        "name": "Receiver"
      }]
    },
    "ids": "sec-ordinaryset",
    "rawBody": "{\n  0:(0) app __x0__ = (IsPropertyKey P)\n  0:assert (= __x0__ true)\n  1:(1) app __x1__ = (O[\"GetOwnProperty\"] O P)\n  1:let ownDesc = [? __x1__]\n  2:(2) app __x2__ = (OrdinarySetWithOwnDescriptor O P V Receiver ownDesc)\n  2:return __x2__\n}"
  }, {
    "code": ["          1. Assert: IsPropertyKey(_P_) is *true*.", "          1. If _ownDesc_ is *undefined*, then", "            1. Let _parent_ be ? _O_.[[GetPrototypeOf]]().", "            1. If _parent_ is not *null*, then", "              1. Return ? _parent_.[[Set]](_P_, _V_, _Receiver_).", "            1. Else,", "              1. Set _ownDesc_ to the PropertyDescriptor { [[Value]]: *undefined*, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true* }.", "          1. If IsDataDescriptor(_ownDesc_) is *true*, then", "            1. If _ownDesc_.[[Writable]] is *false*, return *false*.", "            1. If Type(_Receiver_) is not Object, return *false*.", "            1. Let _existingDescriptor_ be ? _Receiver_.[[GetOwnProperty]](_P_).", "            1. If _existingDescriptor_ is not *undefined*, then", "              1. If IsAccessorDescriptor(_existingDescriptor_) is *true*, return *false*.", "              1. If _existingDescriptor_.[[Writable]] is *false*, return *false*.", "              1. Let _valueDesc_ be the PropertyDescriptor { [[Value]]: _V_ }.", "              1. Return ? _Receiver_.[[DefineOwnProperty]](_P_, _valueDesc_).", "            1. Else,", "              1. Assert: _Receiver_ does not currently have a property _P_.", "              1. Return ? CreateDataProperty(_Receiver_, _P_, _V_).", "          1. Assert: IsAccessorDescriptor(_ownDesc_) is *true*.", "          1. Let _setter_ be _ownDesc_.[[Set]].", "          1. If _setter_ is *undefined*, return *false*.", "          1. Perform ? Call(_setter_, _Receiver_, « _V_ »).", "          1. Return *true*."],
    "head": {
      "name": "OrdinarySetWithOwnDescriptor",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Normal",
        "name": "V"
      }, {
        "kind": "Normal",
        "name": "Receiver"
      }, {
        "kind": "Normal",
        "name": "ownDesc"
      }]
    },
    "ids": "sec-ordinarysetwithowndescriptor",
    "rawBody": "{\n  0:(0) app __x0__ = (IsPropertyKey P)\n  0:assert (= __x0__ true)\n  1:if (= ownDesc undefined) {\n    2:(1) app __x1__ = (O[\"GetPrototypeOf\"] O)\n    2:let parent = [? __x1__]\n    5:if (! (= parent null)) {\n      4:(2) app __x2__ = (parent[\"Set\"] parent P V Receiver)\n      4:return [? __x2__]\n    } else ownDesc = (0) (new PropertyDescriptor(\"Value\" -> undefined, \"Writable\" -> true, \"Enumerable\" -> true, \"Configurable\" -> true))\n  } else 17:{}\n  7:(3) app __x3__ = (IsDataDescriptor ownDesc)\n  7:if (= __x3__ true) {\n    8:if (= ownDesc[\"Writable\"] false) return false else 17:{}\n    9:if (! (= (typeof Receiver) Object)) return false else 17:{}\n    10:(4) app __x4__ = (Receiver[\"GetOwnProperty\"] Receiver P)\n    10:let existingDescriptor = [? __x4__]\n    16:if (! (= existingDescriptor undefined)) {\n      12:(5) app __x5__ = (IsAccessorDescriptor existingDescriptor)\n      12:if (= __x5__ true) return false else 17:{}\n      13:if (= existingDescriptor[\"Writable\"] false) return false else 17:{}\n      14:let valueDesc = (1) (new PropertyDescriptor(\"Value\" -> V))\n      15:(6) app __x6__ = (Receiver[\"DefineOwnProperty\"] Receiver P valueDesc)\n      15:return [? __x6__]\n    } else {\n      18:(7) app __x7__ = (CreateDataProperty Receiver P V)\n      18:return [? __x7__]\n    }\n  } else 17:{}\n  19:(8) app __x8__ = (IsAccessorDescriptor ownDesc)\n  19:assert (= __x8__ true)\n  20:let setter = ownDesc[\"Set\"]\n  21:if (= setter undefined) return false else 17:{}\n  22:(9) app __x9__ = (Call setter Receiver (2) (new [V]))\n  22:[? __x9__]\n  23:return true\n}"
  }, {
    "code": ["        1. Return ? OrdinaryDelete(_O_, _P_)."],
    "head": {
      "base": "OrdinaryObject",
      "methodName": "Delete",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-ordinary-object-internal-methods-and-internal-slots-delete-p",
    "rawBody": "{\n  0:(0) app __x0__ = (OrdinaryDelete O P)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Assert: IsPropertyKey(_P_) is *true*.", "          1. Let _desc_ be ? _O_.[[GetOwnProperty]](_P_).", "          1. If _desc_ is *undefined*, return *true*.", "          1. If _desc_.[[Configurable]] is *true*, then", "            1. Remove the own property with name _P_ from _O_.", "            1. Return *true*.", "          1. Return *false*."],
    "head": {
      "name": "OrdinaryDelete",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "P"
      }]
    },
    "ids": "sec-ordinarydelete",
    "rawBody": "{\n  0:(0) app __x0__ = (IsPropertyKey P)\n  0:assert (= __x0__ true)\n  1:(1) app __x1__ = (O[\"GetOwnProperty\"] O P)\n  1:let desc = [? __x1__]\n  2:if (= desc undefined) return true else 17:{}\n  3:if (= desc[\"Configurable\"] true) {\n    4:delete O[P]\n    5:return true\n  } else 17:{}\n  6:return false\n}"
  }, {
    "code": ["        1. Return ! OrdinaryOwnPropertyKeys(_O_)."],
    "head": {
      "base": "OrdinaryObject",
      "methodName": "OwnPropertyKeys",
      "origParams": [],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys",
    "rawBody": "{\n  0:(0) app __x0__ = (OrdinaryOwnPropertyKeys O)\n  0:return [! __x0__]\n}"
  }, {
    "code": ["          1. Let _keys_ be a new empty List.", "          1. For each own property key _P_ of _O_ such that _P_ is an array index, in ascending numeric index order, do", "            1. Add _P_ as the last element of _keys_.", "          1. For each own property key _P_ of _O_ such that Type(_P_) is String and _P_ is not an array index, in ascending chronological order of property creation, do", "            1. Add _P_ as the last element of _keys_.", "          1. For each own property key _P_ of _O_ such that Type(_P_) is Symbol, in ascending chronological order of property creation, do", "            1. Add _P_ as the last element of _keys_.", "          1. Return _keys_."],
    "head": {
      "name": "OrdinaryOwnPropertyKeys",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }]
    },
    "ids": "sec-ordinaryownpropertykeys",
    "rawBody": "{\n  0:let keys = (0) (new [])\n  1:(1) ??? \"For each own property key id:{P} of id:{O} such that id:{P} is an array index , in ascending numeric index order , do in:{} out:{}\"\n  3:(2) ??? \"For each own property key id:{P} of id:{O} such that Type ( id:{P} ) is String and id:{P} is not an array index , in ascending chronological order of property creation , do in:{} out:{}\"\n  5:(3) ??? \"For each own property key id:{P} of id:{O} such that Type ( id:{P} ) is Symbol , in ascending chronological order of property creation , do in:{} out:{}\"\n  7:return keys\n}"
  }, {
    "code": ["        1. Let _internalSlotsList_ be « [[Prototype]], [[Extensible]] ».", "        1. If _additionalInternalSlotsList_ is present, append each of its elements to _internalSlotsList_.", "        1. Let _O_ be ! MakeBasicObject(_internalSlotsList_).", "        1. Set _O_.[[Prototype]] to _proto_.", "        1. Return _O_."],
    "head": {
      "name": "OrdinaryObjectCreate",
      "params": [{
        "kind": "Normal",
        "name": "proto"
      }, {
        "kind": "Optional",
        "name": "additionalInternalSlotsList"
      }]
    },
    "ids": "sec-ordinaryobjectcreate",
    "rawBody": "{\n  0:let internalSlotsList = (0) (new [\"Prototype\", \"Extensible\"])\n  1:if (! (= additionalInternalSlotsList absent)) {\n    let __x0__ = additionalInternalSlotsList\n    let __x1__ = 0i\n    while (< __x1__ __x0__[\"length\"]) {\n      let __x2__ = __x0__[__x1__]\n      append __x2__ -> internalSlotsList\n      __x1__ = (+ __x1__ 1i)\n    }\n  } else 17:{}\n  2:(0) app __x3__ = (MakeBasicObject internalSlotsList)\n  2:let O = [! __x3__]\n  3:O[\"Prototype\"] = proto\n  4:return O\n}"
  }, {
    "code": ["        1. Assert: _intrinsicDefaultProto_ is a String value that is this specification's name of an intrinsic object. The corresponding object must be an intrinsic that is intended to be used as the [[Prototype]] value of an object.", "        1. Let _proto_ be ? GetPrototypeFromConstructor(_constructor_, _intrinsicDefaultProto_).", "        1. Return ! OrdinaryObjectCreate(_proto_, _internalSlotsList_)."],
    "head": {
      "name": "OrdinaryCreateFromConstructor",
      "params": [{
        "kind": "Normal",
        "name": "constructor"
      }, {
        "kind": "Normal",
        "name": "intrinsicDefaultProto"
      }, {
        "kind": "Optional",
        "name": "internalSlotsList"
      }]
    },
    "ids": "sec-ordinarycreatefromconstructor",
    "rawBody": "{\n  1:(0) app __x0__ = (GetPrototypeFromConstructor constructor intrinsicDefaultProto)\n  1:let proto = [? __x0__]\n  2:(1) app __x1__ = (OrdinaryObjectCreate proto internalSlotsList)\n  2:return [! __x1__]\n}"
  }, {
    "code": ["        1. Assert: _intrinsicDefaultProto_ is a String value that is this specification's name of an intrinsic object. The corresponding object must be an intrinsic that is intended to be used as the [[Prototype]] value of an object.", "        1. Assert: IsCallable(_constructor_) is *true*.", "        1. Let _proto_ be ? Get(_constructor_, *\"prototype\"*).", "        1. If Type(_proto_) is not Object, then", "          1. Let _realm_ be ? GetFunctionRealm(_constructor_).", "          1. Set _proto_ to _realm_'s intrinsic object named _intrinsicDefaultProto_.", "        1. Return _proto_."],
    "head": {
      "name": "GetPrototypeFromConstructor",
      "params": [{
        "kind": "Normal",
        "name": "constructor"
      }, {
        "kind": "Normal",
        "name": "intrinsicDefaultProto"
      }]
    },
    "ids": "sec-getprototypefromconstructor",
    "rawBody": "{\n  1:(0) app __x0__ = (IsCallable constructor)\n  1:assert (= __x0__ true)\n  2:(1) app __x1__ = (Get constructor \"prototype\")\n  2:let proto = [? __x1__]\n  3:if (! (= (typeof proto) Object)) {\n    4:(2) app __x2__ = (GetFunctionRealm constructor)\n    4:let realm = [? __x2__]\n    5:proto = INTRINSICS[intrinsicDefaultProto]\n  } else 0:{}\n  6:return proto\n}"
  }, {
    "code": ["        1. If Type(_O_) is not Object, throw a *TypeError* exception.", "        1. If _O_ does not have an _internalSlot_ internal slot, throw a *TypeError* exception."],
    "head": {
      "name": "RequireInternalSlot",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "internalSlot"
      }]
    },
    "ids": "sec-requireinternalslot",
    "rawBody": "{\n  0:if (! (= (typeof O) Object)) (0) throw TypeError else 0:{}\n  1:if (= O[internalSlot] absent) (1) throw TypeError else 0:{}\n}"
  }, {
    "code": ["        1. Assert: _F_ is an ECMAScript function object.", "        1. Let _callerContext_ be the running execution context.", "        1. Let _calleeContext_ be PrepareForOrdinaryCall(_F_, *undefined*).", "        1. Assert: _calleeContext_ is now the running execution context.", "        1. If _F_.[[IsClassConstructor]] is *true*, then", "          1. Let _error_ be a newly created *TypeError* object.", "          1. NOTE: _error_ is created in _calleeContext_ with _F_'s associated Realm Record.", "          1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.", "          1. Return ThrowCompletion(_error_).", "        1. Perform OrdinaryCallBindThis(_F_, _calleeContext_, _thisArgument_).", "        1. Let _result_ be OrdinaryCallEvaluateBody(_F_, _argumentsList_).", "        1. [id=\"step-call-pop-context-stack\"] Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.", "        1. If _result_.[[Type]] is ~return~, return NormalCompletion(_result_.[[Value]]).", "        1. ReturnIfAbrupt(_result_).", "        1. Return NormalCompletion(*undefined*)."],
    "head": {
      "base": "ECMAScriptFunctionObject",
      "methodName": "Call",
      "origParams": [{
        "kind": "Normal",
        "name": "thisArgument"
      }, {
        "kind": "Normal",
        "name": "argumentsList"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "F"
      }
    },
    "ids": "sec-ecmascript-function-objects-call-thisargument-argumentslist",
    "rawBody": "{\n  0:assert (0) (is-instance-of F ECMAScriptFunctionObject)\n  1:let callerContext = CONTEXT\n  2:(0) app __x0__ = (PrepareForOrdinaryCall F undefined)\n  2:let calleeContext = __x0__\n  4:if (= F[\"IsClassConstructor\"] true) {\n    5:let error = (1) (new OrdinaryObject())\n    7:if (= EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)] calleeContext) {\n      let __x1__ = (- EXECUTION_STACK[\"length\"] 1i)\n      (pop EXECUTION_STACK __x1__)\n    } else {}\n    7:CONTEXT = EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)]\n    8:(1) app __x2__ = (ThrowCompletion error)\n    8:return __x2__\n  } else 6:{}\n  9:(2) app __x3__ = (OrdinaryCallBindThis F calleeContext thisArgument)\n  9:__x3__\n  10:(3) app __x4__ = (OrdinaryCallEvaluateBody F argumentsList)\n  10:let result = __x4__\n  11:if (= EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)] calleeContext) {\n    let __x5__ = (- EXECUTION_STACK[\"length\"] 1i)\n    (pop EXECUTION_STACK __x5__)\n  } else {}\n  11:CONTEXT = EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)]\n  12:if (= result[\"Type\"] CONST_return) return result[\"Value\"] else 6:{}\n  13:[? result]\n  14:return undefined\n}"
  }, {
    "code": ["          1. Assert: Type(_newTarget_) is Undefined or Object.", "          1. Let _callerContext_ be the running execution context.", "          1. Let _calleeContext_ be a new ECMAScript code execution context.", "          1. Set the Function of _calleeContext_ to _F_.", "          1. Let _calleeRealm_ be _F_.[[Realm]].", "          1. Set the Realm of _calleeContext_ to _calleeRealm_.", "          1. Set the ScriptOrModule of _calleeContext_ to _F_.[[ScriptOrModule]].", "          1. Let _localEnv_ be NewFunctionEnvironment(_F_, _newTarget_).", "          1. Set the LexicalEnvironment of _calleeContext_ to _localEnv_.", "          1. Set the VariableEnvironment of _calleeContext_ to _localEnv_.", "          1. If _callerContext_ is not already suspended, suspend _callerContext_.", "          1. Push _calleeContext_ onto the execution context stack; _calleeContext_ is now the running execution context.", "          1. NOTE: Any exception objects produced after this point are associated with _calleeRealm_.", "          1. Return _calleeContext_."],
    "head": {
      "name": "PrepareForOrdinaryCall",
      "params": [{
        "kind": "Normal",
        "name": "F"
      }, {
        "kind": "Normal",
        "name": "newTarget"
      }]
    },
    "ids": "sec-prepareforordinarycall",
    "rawBody": "{\n  0:assert (|| (= (typeof newTarget) Undefined) (= (typeof newTarget) Object))\n  1:let callerContext = CONTEXT\n  2:let calleeContext = (0) (new ExecutionContext())\n  3:calleeContext[\"Function\"] = F\n  4:let calleeRealm = F[\"Realm\"]\n  5:calleeContext[\"Realm\"] = calleeRealm\n  6:calleeContext[\"ScriptOrModule\"] = F[\"ScriptOrModule\"]\n  7:(0) app __x0__ = (NewFunctionEnvironment F newTarget)\n  7:let localEnv = __x0__\n  8:calleeContext[\"LexicalEnvironment\"] = localEnv\n  9:calleeContext[\"VariableEnvironment\"] = localEnv\n  10:if (= callerContext null) CONTEXT = null else 12:{}\n  11:append calleeContext -> EXECUTION_STACK\n  11:CONTEXT = EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)]\n  13:return calleeContext\n}"
  }, {
    "code": ["          1. Let _thisMode_ be _F_.[[ThisMode]].", "          1. If _thisMode_ is ~lexical~, return NormalCompletion(*undefined*).", "          1. Let _calleeRealm_ be _F_.[[Realm]].", "          1. Let _localEnv_ be the LexicalEnvironment of _calleeContext_.", "          1. If _thisMode_ is ~strict~, let _thisValue_ be _thisArgument_.", "          1. Else,", "            1. If _thisArgument_ is *undefined* or *null*, then", "              1. Let _globalEnv_ be _calleeRealm_.[[GlobalEnv]].", "              1. Assert: _globalEnv_ is a global Environment Record.", "              1. Let _thisValue_ be _globalEnv_.[[GlobalThisValue]].", "            1. Else,", "              1. Let _thisValue_ be ! ToObject(_thisArgument_).", "              1. NOTE: ToObject produces wrapper objects using _calleeRealm_.", "          1. Assert: _localEnv_ is a function Environment Record.", "          1. Assert: The next step never returns an abrupt completion because _localEnv_.[[ThisBindingStatus]] is not ~initialized~.", "          1. Return _localEnv_.BindThisValue(_thisValue_)."],
    "head": {
      "name": "OrdinaryCallBindThis",
      "params": [{
        "kind": "Normal",
        "name": "F"
      }, {
        "kind": "Normal",
        "name": "calleeContext"
      }, {
        "kind": "Normal",
        "name": "thisArgument"
      }]
    },
    "ids": "sec-ordinarycallbindthis",
    "rawBody": "{\n  0:let thisMode = F[\"ThisMode\"]\n  1:if (= thisMode CONST_lexical) return undefined else 14:{}\n  2:let calleeRealm = F[\"Realm\"]\n  3:(0) access __x0__ = (calleeContext \"LexicalEnvironment\")\n  3:let localEnv = __x0__\n  5:if (= thisMode CONST_strict) let thisValue = thisArgument else if (|| (= thisArgument undefined) (= thisArgument null)) {\n    7:let globalEnv = calleeRealm[\"GlobalEnv\"]\n    8:assert (0) (is-instance-of globalEnv GlobalEnvironmentRecord)\n    9:let thisValue = globalEnv[\"GlobalThisValue\"]\n  } else {\n    11:(1) app __x1__ = (ToObject thisArgument)\n    11:let thisValue = [! __x1__]\n  }\n  13:assert (1) (is-instance-of localEnv FunctionEnvironmentRecord)\n  15:(2) app __x2__ = (localEnv[\"BindThisValue\"] localEnv thisValue)\n  15:return __x2__\n}"
  }, {
    "code": ["          1. Return ? EvaluateFunctionBody of |FunctionBody| with arguments _functionObject_ and _argumentsList_."],
    "head": {
      "idx": 0,
      "methodName": "EvaluateBody",
      "prod": "FunctionBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FunctionStatementList",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "functionObject"
      }, {
        "kind": "Normal",
        "name": "argumentsList"
      }]
    },
    "ids": "sec-runtime-semantics-evaluatebody",
    "rawBody": "{\n  0:(0) access __x0__ = (FunctionBody \"EvaluateFunctionBody\" functionObject argumentsList)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Return ? EvaluateConciseBody of |ConciseBody| with arguments _functionObject_ and _argumentsList_."],
    "head": {
      "idx": 0,
      "methodName": "EvaluateBody",
      "prod": "ConciseBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExpressionBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "functionObject"
      }, {
        "kind": "Normal",
        "name": "argumentsList"
      }]
    },
    "ids": "sec-runtime-semantics-evaluatebody",
    "rawBody": "{\n  0:(0) access __x0__ = (ConciseBody \"EvaluateConciseBody\" functionObject argumentsList)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Return ? EvaluateGeneratorBody of |GeneratorBody| with arguments _functionObject_ and _argumentsList_."],
    "head": {
      "idx": 0,
      "methodName": "EvaluateBody",
      "prod": "GeneratorBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "functionObject"
      }, {
        "kind": "Normal",
        "name": "argumentsList"
      }]
    },
    "ids": "sec-runtime-semantics-evaluatebody",
    "rawBody": "{\n  0:(0) access __x0__ = (GeneratorBody \"EvaluateGeneratorBody\" functionObject argumentsList)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Return ? EvaluateAsyncGeneratorBody of |AsyncGeneratorBody| with arguments _functionObject_ and _argumentsList_."],
    "head": {
      "idx": 0,
      "methodName": "EvaluateBody",
      "prod": "AsyncGeneratorBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "functionObject"
      }, {
        "kind": "Normal",
        "name": "argumentsList"
      }]
    },
    "ids": "sec-runtime-semantics-evaluatebody",
    "rawBody": "{\n  0:(0) access __x0__ = (AsyncGeneratorBody \"EvaluateAsyncGeneratorBody\" functionObject argumentsList)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Return ? EvaluateAsyncFunctionBody of |AsyncFunctionBody| with arguments _functionObject_ and _argumentsList_."],
    "head": {
      "idx": 0,
      "methodName": "EvaluateBody",
      "prod": "AsyncFunctionBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "functionObject"
      }, {
        "kind": "Normal",
        "name": "argumentsList"
      }]
    },
    "ids": "sec-runtime-semantics-evaluatebody",
    "rawBody": "{\n  0:(0) access __x0__ = (AsyncFunctionBody \"EvaluateAsyncFunctionBody\" functionObject argumentsList)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Return ? EvaluateAsyncConciseBody of |AsyncConciseBody| with arguments _functionObject_ and _argumentsList_."],
    "head": {
      "idx": 0,
      "methodName": "EvaluateBody",
      "prod": "AsyncConciseBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExpressionBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "functionObject"
      }, {
        "kind": "Normal",
        "name": "argumentsList"
      }]
    },
    "ids": "sec-runtime-semantics-evaluatebody",
    "rawBody": "{\n  0:(0) access __x0__ = (AsyncConciseBody \"EvaluateAsyncConciseBody\" functionObject argumentsList)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Return the result of EvaluateBody of the parsed code that is _F_.[[ECMAScriptCode]] passing _F_ and _argumentsList_ as the arguments."],
    "head": {
      "name": "OrdinaryCallEvaluateBody",
      "params": [{
        "kind": "Normal",
        "name": "F"
      }, {
        "kind": "Normal",
        "name": "argumentsList"
      }]
    },
    "ids": "sec-ordinarycallevaluatebody",
    "rawBody": "{\n  0:(0) access __x0__ = (F[\"ECMAScriptCode\"] \"EvaluateBody\" F argumentsList)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Assert: _F_ is an ECMAScript function object.", "        1. Assert: Type(_newTarget_) is Object.", "        1. Let _callerContext_ be the running execution context.", "        1. Let _kind_ be _F_.[[ConstructorKind]].", "        1. If _kind_ is ~base~, then", "          1. Let _thisArgument_ be ? OrdinaryCreateFromConstructor(_newTarget_, *\"%Object.prototype%\"*).", "        1. Let _calleeContext_ be PrepareForOrdinaryCall(_F_, _newTarget_).", "        1. Assert: _calleeContext_ is now the running execution context.", "        1. If _kind_ is ~base~, perform OrdinaryCallBindThis(_F_, _calleeContext_, _thisArgument_).", "        1. Let _constructorEnv_ be the LexicalEnvironment of _calleeContext_.", "        1. Let _result_ be OrdinaryCallEvaluateBody(_F_, _argumentsList_).", "        1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.", "        1. If _result_.[[Type]] is ~return~, then", "          1. If Type(_result_.[[Value]]) is Object, return NormalCompletion(_result_.[[Value]]).", "          1. If _kind_ is ~base~, return NormalCompletion(_thisArgument_).", "          1. If _result_.[[Value]] is not *undefined*, throw a *TypeError* exception.", "        1. Else, ReturnIfAbrupt(_result_).", "        1. Return ? _constructorEnv_.GetThisBinding()."],
    "head": {
      "base": "ECMAScriptFunctionObject",
      "methodName": "Construct",
      "origParams": [{
        "kind": "Normal",
        "name": "argumentsList"
      }, {
        "kind": "Normal",
        "name": "newTarget"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "F"
      }
    },
    "ids": "sec-ecmascript-function-objects-construct-argumentslist-newtarget",
    "rawBody": "{\n  0:assert (0) (is-instance-of F ECMAScriptFunctionObject)\n  1:assert (= (typeof newTarget) Object)\n  2:let callerContext = CONTEXT\n  3:let kind = F[\"ConstructorKind\"]\n  4:if (= kind CONST_base) {\n    5:(0) app __x0__ = (OrdinaryCreateFromConstructor newTarget \"%Object.prototype%\")\n    5:let thisArgument = [? __x0__]\n  } else 7:{}\n  6:(1) app __x1__ = (PrepareForOrdinaryCall F newTarget)\n  6:let calleeContext = __x1__\n  8:if (= kind CONST_base) {\n    (2) app __x2__ = (OrdinaryCallBindThis F calleeContext thisArgument)\n    __x2__\n  } else 7:{}\n  9:(3) access __x3__ = (calleeContext \"LexicalEnvironment\")\n  9:let constructorEnv = __x3__\n  10:(4) app __x4__ = (OrdinaryCallEvaluateBody F argumentsList)\n  10:let result = __x4__\n  11:if (= EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)] calleeContext) {\n    let __x5__ = (- EXECUTION_STACK[\"length\"] 1i)\n    (pop EXECUTION_STACK __x5__)\n  } else {}\n  11:CONTEXT = EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)]\n  16:if (= result[\"Type\"] CONST_return) {\n    13:if (= (typeof result[\"Value\"]) Object) return result[\"Value\"] else 7:{}\n    14:if (= kind CONST_base) return thisArgument else 7:{}\n    15:if (! (= result[\"Value\"] undefined)) (1) throw TypeError else 7:{}\n  } else [? result]\n  17:(5) app __x6__ = (constructorEnv[\"GetThisBinding\"] constructorEnv)\n  17:return [? __x6__]\n}"
  }, {
    "code": ["        1. Assert: Type(_functionPrototype_) is Object.", "        1. Let _internalSlotsList_ be the internal slots listed in <emu-xref href=\"#table-internal-slots-of-ecmascript-function-objects\"></emu-xref>.", "        1. Let _F_ be ! OrdinaryObjectCreate(_functionPrototype_, _internalSlotsList_).", "        1. Set _F_.[[Call]] to the definition specified in <emu-xref href=\"#sec-ecmascript-function-objects-call-thisargument-argumentslist\"></emu-xref>.", "        1. Set _F_.[[SourceText]] to _sourceText_.", "        1. Set _F_.[[FormalParameters]] to _ParameterList_.", "        1. Set _F_.[[ECMAScriptCode]] to _Body_.", "        1. If the source text matching _Body_ is strict mode code, let _Strict_ be *true*; else let _Strict_ be *false*.", "        1. Set _F_.[[Strict]] to _Strict_.", "        1. If _thisMode_ is ~lexical-this~, set _F_.[[ThisMode]] to ~lexical~.", "        1. Else if _Strict_ is *true*, set _F_.[[ThisMode]] to ~strict~.", "        1. Else, set _F_.[[ThisMode]] to ~global~.", "        1. Set _F_.[[IsClassConstructor]] to *false*.", "        1. Set _F_.[[Environment]] to _Scope_.", "        1. Set _F_.[[ScriptOrModule]] to GetActiveScriptOrModule().", "        1. Set _F_.[[Realm]] to the current Realm Record.", "        1. Set _F_.[[HomeObject]] to *undefined*.", "        1. Let _len_ be the ExpectedArgumentCount of _ParameterList_.", "        1. Perform ! SetFunctionLength(_F_, _len_).", "        1. Return _F_."],
    "head": {
      "name": "OrdinaryFunctionCreate",
      "params": [{
        "kind": "Normal",
        "name": "functionPrototype"
      }, {
        "kind": "Normal",
        "name": "sourceText"
      }, {
        "kind": "Normal",
        "name": "ParameterList"
      }, {
        "kind": "Normal",
        "name": "Body"
      }, {
        "kind": "Normal",
        "name": "thisMode"
      }, {
        "kind": "Normal",
        "name": "Scope"
      }]
    },
    "ids": "sec-ordinaryfunctioncreate",
    "rawBody": "{\n  0:assert (= (typeof functionPrototype) Object)\n  1:let internalSlotsList = (0) (new [\"Environment\", \"FormalParameters\", \"ECMAScriptCode\", \"ConstructorKind\", \"Realm\", \"ScriptOrModule\", \"ThisMode\", \"Strict\", \"HomeObject\", \"SourceText\", \"IsClassConstructor\"])\n  2:(0) app __x0__ = (OrdinaryObjectCreate functionPrototype internalSlotsList)\n  2:let F = [! __x0__]\n  3:F[\"Call\"] = ALGORITHM[\"ECMAScriptFunctionObject.Call\"]\n  4:F[\"SourceText\"] = sourceText\n  5:F[\"FormalParameters\"] = ParameterList\n  6:F[\"ECMAScriptCode\"] = Body\n  7:if true let Strict = true else let Strict = false\n  8:F[\"Strict\"] = Strict\n  11:if (= thisMode CONST_lexicalDASHthis) F[\"ThisMode\"] = CONST_lexical else if (= Strict true) F[\"ThisMode\"] = CONST_strict else F[\"ThisMode\"] = CONST_global\n  12:F[\"IsClassConstructor\"] = false\n  13:F[\"Environment\"] = Scope\n  14:(1) app __x1__ = (GetActiveScriptOrModule)\n  14:F[\"ScriptOrModule\"] = __x1__\n  15:F[\"Realm\"] = REALM\n  16:F[\"HomeObject\"] = undefined\n  17:(2) access __x2__ = (ParameterList \"ExpectedArgumentCount\")\n  17:let len = __x2__\n  18:(3) app __x3__ = (SetFunctionLength F len)\n  18:[! __x3__]\n  19:return F\n}"
  }, {
    "code": ["        1. Assert: _realm_.[[Intrinsics]].[[%ThrowTypeError%]] exists and has been initialized.", "        1. Let _thrower_ be _realm_.[[Intrinsics]].[[%ThrowTypeError%]].", "        1. Perform ! DefinePropertyOrThrow(_F_, *\"caller\"*, PropertyDescriptor { [[Get]]: _thrower_, [[Set]]: _thrower_, [[Enumerable]]: *false*, [[Configurable]]: *true* }).", "        1. Return ! DefinePropertyOrThrow(_F_, *\"arguments\"*, PropertyDescriptor { [[Get]]: _thrower_, [[Set]]: _thrower_, [[Enumerable]]: *false*, [[Configurable]]: *true* })."],
    "head": {
      "name": "AddRestrictedFunctionProperties",
      "params": [{
        "kind": "Normal",
        "name": "F"
      }, {
        "kind": "Normal",
        "name": "realm"
      }]
    },
    "ids": "sec-addrestrictedfunctionproperties",
    "rawBody": "{\n  1:let thrower = realm[\"Intrinsics\"][\"INTRINSIC_ThrowTypeError\"]\n  2:(0) app __x0__ = (DefinePropertyOrThrow F \"caller\" (0) (new PropertyDescriptor(\"Get\" -> thrower, \"Set\" -> thrower, \"Enumerable\" -> false, \"Configurable\" -> true)))\n  2:[! __x0__]\n  3:(1) app __x1__ = (DefinePropertyOrThrow F \"arguments\" (1) (new PropertyDescriptor(\"Get\" -> thrower, \"Set\" -> thrower, \"Enumerable\" -> false, \"Configurable\" -> true)))\n  3:return [! __x1__]\n}"
  }, {
    "code": ["          1. Throw a *TypeError* exception."],
    "head": {
      "name": "%ThrowTypeError%",
      "params": []
    },
    "ids": "sec-%throwtypeerror%",
    "rawBody": "(0) throw TypeError"
  }, {
    "code": ["        1. Assert: _F_ is an ECMAScript function object or a built-in function object.", "        1. If _F_ is an ECMAScript function object, then", "          1. Assert: IsConstructor(_F_) is *false*.", "          1. Assert: _F_ is an extensible object that does not have a *\"prototype\"* own property.", "          1. Set _F_.[[Construct]] to the definition specified in <emu-xref href=\"#sec-ecmascript-function-objects-construct-argumentslist-newtarget\"></emu-xref>.", "        1. Set _F_.[[ConstructorKind]] to ~base~.", "        1. If _writablePrototype_ is not present, set _writablePrototype_ to *true*.", "        1. If _prototype_ is not present, then", "          1. Set _prototype_ to ! OrdinaryObjectCreate(%Object.prototype%).", "          1. Perform ! DefinePropertyOrThrow(_prototype_, *\"constructor\"*, PropertyDescriptor { [[Value]]: _F_, [[Writable]]: _writablePrototype_, [[Enumerable]]: *false*, [[Configurable]]: *true* }).", "        1. Perform ! DefinePropertyOrThrow(_F_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: _writablePrototype_, [[Enumerable]]: *false*, [[Configurable]]: *false* }).", "        1. Return NormalCompletion(*undefined*)."],
    "head": {
      "name": "MakeConstructor",
      "params": [{
        "kind": "Normal",
        "name": "F"
      }, {
        "kind": "Optional",
        "name": "writablePrototype"
      }, {
        "kind": "Optional",
        "name": "prototype"
      }]
    },
    "ids": "sec-makeconstructor",
    "rawBody": "{\n  1:if (0) (is-instance-of F ECMAScriptFunctionObject) {\n    2:(0) app __x0__ = (IsConstructor F)\n    2:assert (= __x0__ false)\n    4:F[\"Construct\"] = ALGORITHM[\"ECMAScriptFunctionObject.Construct\"]\n  } else 3:{}\n  5:F[\"ConstructorKind\"] = CONST_base\n  6:if (= writablePrototype absent) writablePrototype = true else 3:{}\n  7:if (= prototype absent) {\n    8:(1) app __x1__ = (OrdinaryObjectCreate INTRINSIC_Object_prototype)\n    8:prototype = [! __x1__]\n    9:(2) app __x2__ = (DefinePropertyOrThrow prototype \"constructor\" (1) (new PropertyDescriptor(\"Value\" -> F, \"Writable\" -> writablePrototype, \"Enumerable\" -> false, \"Configurable\" -> true)))\n    9:[! __x2__]\n  } else 3:{}\n  10:(3) app __x3__ = (DefinePropertyOrThrow F \"prototype\" (2) (new PropertyDescriptor(\"Value\" -> prototype, \"Writable\" -> writablePrototype, \"Enumerable\" -> false, \"Configurable\" -> false)))\n  10:[! __x3__]\n  11:return undefined\n}"
  }, {
    "code": ["        1. Assert: _F_ is an ECMAScript function object.", "        1. Assert: _F_.[[IsClassConstructor]] is *false*.", "        1. Set _F_.[[IsClassConstructor]] to *true*.", "        1. Return NormalCompletion(*undefined*)."],
    "head": {
      "name": "MakeClassConstructor",
      "params": [{
        "kind": "Normal",
        "name": "F"
      }]
    },
    "ids": "sec-makeclassconstructor",
    "rawBody": "{\n  0:assert (0) (is-instance-of F ECMAScriptFunctionObject)\n  1:assert (= F[\"IsClassConstructor\"] false)\n  2:F[\"IsClassConstructor\"] = true\n  3:return undefined\n}"
  }, {
    "code": ["        1. Assert: _F_ is an ECMAScript function object.", "        1. Assert: Type(_homeObject_) is Object.", "        1. Set _F_.[[HomeObject]] to _homeObject_.", "        1. Return NormalCompletion(*undefined*)."],
    "head": {
      "name": "MakeMethod",
      "params": [{
        "kind": "Normal",
        "name": "F"
      }, {
        "kind": "Normal",
        "name": "homeObject"
      }]
    },
    "ids": "sec-makemethod",
    "rawBody": "{\n  0:assert (0) (is-instance-of F ECMAScriptFunctionObject)\n  1:assert (= (typeof homeObject) Object)\n  2:F[\"HomeObject\"] = homeObject\n  3:return undefined\n}"
  }, {
    "code": ["        1. Assert: _F_ is an extensible object that does not have a *\"name\"* own property.", "        1. Assert: Type(_name_) is either Symbol or String.", "        1. Assert: If _prefix_ is present, then Type(_prefix_) is String.", "        1. If Type(_name_) is Symbol, then", "          1. Let _description_ be _name_'s [[Description]] value.", "          1. If _description_ is *undefined*, set _name_ to the empty String.", "          1. Else, set _name_ to the string-concatenation of *\"[\"*, _description_, and *\"]\"*.", "        1. If _F_ has an [[InitialName]] internal slot, then", "          1. Set _F_.[[InitialName]] to _name_.", "        1. If _prefix_ is present, then", "          1. Set _name_ to the string-concatenation of _prefix_, the code unit 0x0020 (SPACE), and _name_.", "          1. If _F_ has an [[InitialName]] internal slot, then", "            1. Optionally, set _F_.[[InitialName]] to _name_.", "        1. Return ! DefinePropertyOrThrow(_F_, *\"name\"*, PropertyDescriptor { [[Value]]: _name_, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* })."],
    "head": {
      "name": "SetFunctionName",
      "params": [{
        "kind": "Normal",
        "name": "F"
      }, {
        "kind": "Normal",
        "name": "name"
      }, {
        "kind": "Optional",
        "name": "prefix"
      }]
    },
    "ids": "sec-setfunctionname",
    "rawBody": "{\n  1:assert (|| (= (typeof name) Symbol) (= (typeof name) String))\n  3:if (= (typeof name) Symbol) {\n    4:let description = name[\"Description\"]\n    6:if (= description undefined) name = \"\" else name = (+ (+ \"[\" description) \"]\")\n  } else 2:{}\n  7:if (! (= F[\"InitialName\"] absent)) F[\"InitialName\"] = name else 2:{}\n  9:if (! (= prefix absent)) {\n    10:name = (+ (+ prefix \" \") name)\n    11:if (! (= F[\"InitialName\"] absent)) if AnyBool F[\"InitialName\"] = name else 2:{} else 2:{}\n  } else 2:{}\n  13:(0) app __x0__ = (DefinePropertyOrThrow F \"name\" (0) (new PropertyDescriptor(\"Value\" -> name, \"Writable\" -> false, \"Enumerable\" -> false, \"Configurable\" -> true)))\n  13:return [! __x0__]\n}"
  }, {
    "code": ["        1. Assert: _F_ is an extensible object that does not have a *\"length\"* own property.", "        1. Return ! DefinePropertyOrThrow(_F_, *\"length\"*, PropertyDescriptor { [[Value]]: 𝔽(_length_), [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* })."],
    "head": {
      "name": "SetFunctionLength",
      "params": [{
        "kind": "Normal",
        "name": "F"
      }, {
        "kind": "Normal",
        "name": "length"
      }]
    },
    "ids": "sec-setfunctionlength",
    "rawBody": "{\n  1:(0) app __x0__ = (DefinePropertyOrThrow F \"length\" (0) (new PropertyDescriptor(\"Value\" -> length, \"Writable\" -> false, \"Enumerable\" -> false, \"Configurable\" -> true)))\n  1:return [! __x0__]\n}"
  }, {
    "code": ["        1. Let _calleeContext_ be the running execution context.", "        1. Let _code_ be _func_.[[ECMAScriptCode]].", "        1. Let _strict_ be _func_.[[Strict]].", "        1. Let _formals_ be _func_.[[FormalParameters]].", "        1. Let _parameterNames_ be the BoundNames of _formals_.", "        1. If _parameterNames_ has any duplicate entries, let _hasDuplicates_ be *true*. Otherwise, let _hasDuplicates_ be *false*.", "        1. Let _simpleParameterList_ be IsSimpleParameterList of _formals_.", "        1. Let _hasParameterExpressions_ be ContainsExpression of _formals_.", "        1. Let _varNames_ be the VarDeclaredNames of _code_.", "        1. Let _varDeclarations_ be the VarScopedDeclarations of _code_.", "        1. Let _lexicalNames_ be the LexicallyDeclaredNames of _code_.", "        1. Let _functionNames_ be a new empty List.", "        1. Let _functionsToInitialize_ be a new empty List.", "        1. For each element _d_ of _varDeclarations_, in reverse List order, do", "          1. If _d_ is neither a |VariableDeclaration| nor a |ForBinding| nor a |BindingIdentifier|, then", "            1. Assert: _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|.", "            1. Let _fn_ be the sole element of the BoundNames of _d_.", "            1. If _fn_ is not an element of _functionNames_, then", "              1. Insert _fn_ as the first element of _functionNames_.", "              1. NOTE: If there are multiple function declarations for the same name, the last declaration is used.", "              1. Insert _d_ as the first element of _functionsToInitialize_.", "        1. Let _argumentsObjectNeeded_ be *true*.", "        1. If _func_.[[ThisMode]] is ~lexical~, then", "          1. NOTE: Arrow functions never have an arguments objects.", "          1. Set _argumentsObjectNeeded_ to *false*.", "        1. Else if *\"arguments\"* is an element of _parameterNames_, then", "          1. Set _argumentsObjectNeeded_ to *false*.", "        1. Else if _hasParameterExpressions_ is *false*, then", "          1. If *\"arguments\"* is an element of _functionNames_ or if *\"arguments\"* is an element of _lexicalNames_, then", "            1. Set _argumentsObjectNeeded_ to *false*.", "        1. If _strict_ is *true* or if _hasParameterExpressions_ is *false*, then", "          1. NOTE: Only a single Environment Record is needed for the parameters and top-level vars.", "          1. Let _env_ be the LexicalEnvironment of _calleeContext_.", "        1. Else,", "          1. NOTE: A separate Environment Record is needed to ensure that bindings created by direct eval calls in the formal parameter list are outside the environment where parameters are declared.", "          1. Let _calleeEnv_ be the LexicalEnvironment of _calleeContext_.", "          1. Let _env_ be NewDeclarativeEnvironment(_calleeEnv_).", "          1. Assert: The VariableEnvironment of _calleeContext_ is _calleeEnv_.", "          1. Set the LexicalEnvironment of _calleeContext_ to _env_.", "        1. For each String _paramName_ of _parameterNames_, do", "          1. Let _alreadyDeclared_ be _env_.HasBinding(_paramName_).", "          1. NOTE: Early errors ensure that duplicate parameter names can only occur in non-strict functions that do not have parameter default values or rest parameters.", "          1. If _alreadyDeclared_ is *false*, then", "            1. Perform ! _env_.CreateMutableBinding(_paramName_, *false*).", "            1. If _hasDuplicates_ is *true*, then", "              1. Perform ! _env_.InitializeBinding(_paramName_, *undefined*).", "        1. If _argumentsObjectNeeded_ is *true*, then", "          1. If _strict_ is *true* or if _simpleParameterList_ is *false*, then", "            1. Let _ao_ be CreateUnmappedArgumentsObject(_argumentsList_).", "          1. Else,", "            1. NOTE: A mapped argument object is only provided for non-strict functions that don't have a rest parameter, any parameter default value initializers, or any destructured parameters.", "            1. Let _ao_ be CreateMappedArgumentsObject(_func_, _formals_, _argumentsList_, _env_).", "          1. If _strict_ is *true*, then", "            1. Perform ! _env_.CreateImmutableBinding(*\"arguments\"*, *false*).", "          1. Else,", "            1. Perform ! _env_.CreateMutableBinding(*\"arguments\"*, *false*).", "          1. Call _env_.InitializeBinding(*\"arguments\"*, _ao_).", "          1. Let _parameterBindings_ be a List whose elements are the elements of _parameterNames_, followed by *\"arguments\"*.", "        1. Else,", "          1. Let _parameterBindings_ be _parameterNames_.", "        1. Let _iteratorRecord_ be CreateListIteratorRecord(_argumentsList_).", "        1. If _hasDuplicates_ is *true*, then", "          1. Perform ? IteratorBindingInitialization for _formals_ with _iteratorRecord_ and *undefined* as arguments.", "        1. Else,", "          1. Perform ? IteratorBindingInitialization for _formals_ with _iteratorRecord_ and _env_ as arguments.", "        1. If _hasParameterExpressions_ is *false*, then", "          1. NOTE: Only a single Environment Record is needed for the parameters and top-level vars.", "          1. Let _instantiatedVarNames_ be a copy of the List _parameterBindings_.", "          1. For each element _n_ of _varNames_, do", "            1. If _n_ is not an element of _instantiatedVarNames_, then", "              1. Append _n_ to _instantiatedVarNames_.", "              1. Perform ! _env_.CreateMutableBinding(_n_, *false*).", "              1. Call _env_.InitializeBinding(_n_, *undefined*).", "          1. Let _varEnv_ be _env_.", "        1. Else,", "          1. NOTE: A separate Environment Record is needed to ensure that closures created by expressions in the formal parameter list do not have visibility of declarations in the function body.", "          1. Let _varEnv_ be NewDeclarativeEnvironment(_env_).", "          1. Set the VariableEnvironment of _calleeContext_ to _varEnv_.", "          1. Let _instantiatedVarNames_ be a new empty List.", "          1. For each element _n_ of _varNames_, do", "            1. If _n_ is not an element of _instantiatedVarNames_, then", "              1. Append _n_ to _instantiatedVarNames_.", "              1. Perform ! _varEnv_.CreateMutableBinding(_n_, *false*).", "              1. If _n_ is not an element of _parameterBindings_ or if _n_ is an element of _functionNames_, let _initialValue_ be *undefined*.", "              1. Else,", "                1. Let _initialValue_ be ! _env_.GetBindingValue(_n_, *false*).", "              1. Call _varEnv_.InitializeBinding(_n_, _initialValue_).", "              1. NOTE: A var with the same name as a formal parameter initially has the same value as the corresponding initialized parameter.", "        1. [id=\"step-functiondeclarationinstantiation-web-compat-insertion-point\"] NOTE: Annex <emu-xref href=\"#sec-web-compat-functiondeclarationinstantiation\"></emu-xref> adds additional steps at this point.", "        1. If _strict_ is *false*, then", "          1. Let _lexEnv_ be NewDeclarativeEnvironment(_varEnv_).", "          1. NOTE: Non-strict functions use a separate Environment Record for top-level lexical declarations so that a direct eval can determine whether any var scoped declarations introduced by the eval code conflict with pre-existing top-level lexically scoped declarations. This is not needed for strict functions because a strict direct eval always places all declarations into a new Environment Record.", "        1. Else, let _lexEnv_ be _varEnv_.", "        1. Set the LexicalEnvironment of _calleeContext_ to _lexEnv_.", "        1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _code_.", "        1. For each element _d_ of _lexDeclarations_, do", "          1. NOTE: A lexically declared name cannot be the same as a function/generator declaration, formal parameter, or a var name. Lexically declared names are only instantiated here but not initialized.", "          1. For each element _dn_ of the BoundNames of _d_, do", "            1. If IsConstantDeclaration of _d_ is *true*, then", "              1. Perform ! _lexEnv_.CreateImmutableBinding(_dn_, *true*).", "            1. Else,", "              1. Perform ! _lexEnv_.CreateMutableBinding(_dn_, *false*).", "        1. For each Parse Node _f_ of _functionsToInitialize_, do", "          1. Let _fn_ be the sole element of the BoundNames of _f_.", "          1. Let _fo_ be InstantiateFunctionObject of _f_ with argument _lexEnv_.", "          1. Perform ! _varEnv_.SetMutableBinding(_fn_, _fo_, *false*).", "        1. Return NormalCompletion(~empty~)."],
    "head": {
      "name": "FunctionDeclarationInstantiation",
      "params": [{
        "kind": "Normal",
        "name": "func"
      }, {
        "kind": "Normal",
        "name": "argumentsList"
      }]
    },
    "ids": "sec-functiondeclarationinstantiation",
    "rawBody": "{\n  0:let calleeContext = CONTEXT\n  1:let code = func[\"ECMAScriptCode\"]\n  2:let strict = func[\"Strict\"]\n  3:let formals = func[\"FormalParameters\"]\n  4:(0) access __x0__ = (formals \"BoundNames\")\n  4:let parameterNames = __x0__\n  5:(1) app __x1__ = (IsDuplicate parameterNames)\n  5:if __x1__ let hasDuplicates = true else let hasDuplicates = false\n  6:(2) access __x2__ = (formals \"IsSimpleParameterList\")\n  6:let simpleParameterList = __x2__\n  7:(3) access __x3__ = (formals \"ContainsExpression\")\n  7:let hasParameterExpressions = __x3__\n  8:(4) access __x4__ = (code \"VarDeclaredNames\")\n  8:let varNames = __x4__\n  9:(5) access __x5__ = (code \"VarScopedDeclarations\")\n  9:let varDeclarations = __x5__\n  10:(6) access __x6__ = (code \"LexicallyDeclaredNames\")\n  10:let lexicalNames = __x6__\n  11:let functionNames = (0) (new [])\n  12:let functionsToInitialize = (1) (new [])\n  13:let __x7__ = varDeclarations\n  13:let __x8__ = __x7__[\"length\"]\n  13:while (< 0i __x8__) {\n    __x8__ = (- __x8__ 1i)\n    let d = __x7__[__x8__]\n    14:if (! (|| (|| (2) (is-instance-of d VariableDeclaration) (3) (is-instance-of d ForBinding)) (4) (is-instance-of d BindingIdentifier))) {\n      15:assert (|| (|| (|| (5) (is-instance-of d FunctionDeclaration) (6) (is-instance-of d GeneratorDeclaration)) (7) (is-instance-of d AsyncFunctionDeclaration)) (8) (is-instance-of d AsyncGeneratorDeclaration))\n      16:(7) access __x9__ = (d \"BoundNames\")\n      16:let fn = __x9__[0i]\n      17:if (! (contains functionNames fn)) {\n        18:prepend fn -> functionNames\n        20:prepend d -> functionsToInitialize\n      } else 96:{}\n    } else 96:{}\n  }\n  21:let argumentsObjectNeeded = true\n  27:if (= func[\"ThisMode\"] CONST_lexical) argumentsObjectNeeded = false else if (contains parameterNames \"arguments\") argumentsObjectNeeded = false else if (= hasParameterExpressions false) if (|| (contains functionNames \"arguments\") (contains lexicalNames \"arguments\")) argumentsObjectNeeded = false else 96:{} else 96:{}\n  33:if (|| (= strict true) (= hasParameterExpressions false)) {\n    32:(8) access __x10__ = (calleeContext \"LexicalEnvironment\")\n    32:let env = __x10__\n  } else {\n    35:(9) access __x11__ = (calleeContext \"LexicalEnvironment\")\n    35:let calleeEnv = __x11__\n    36:(10) app __x12__ = (NewDeclarativeEnvironment calleeEnv)\n    36:let env = __x12__\n    37:(11) access __x13__ = (calleeContext \"VariableEnvironment\")\n    37:assert (= __x13__ calleeEnv)\n    38:calleeContext[\"LexicalEnvironment\"] = env\n  }\n  39:let __x14__ = parameterNames\n  39:let __x15__ = 0i\n  39:while (< __x15__ __x14__[\"length\"]) {\n    let paramName = __x14__[__x15__]\n    40:(12) app __x16__ = (env[\"HasBinding\"] env paramName)\n    40:let alreadyDeclared = __x16__\n    42:if (= alreadyDeclared false) {\n      43:(13) app __x17__ = (env[\"CreateMutableBinding\"] env paramName false)\n      43:[! __x17__]\n      44:if (= hasDuplicates true) {\n        45:(14) app __x18__ = (env[\"InitializeBinding\"] env paramName undefined)\n        45:[! __x18__]\n      } else 96:{}\n    } else 96:{}\n    __x15__ = (+ __x15__ 1i)\n  }\n  58:if (= argumentsObjectNeeded true) {\n    49:if (|| (= strict true) (= simpleParameterList false)) {\n      48:(15) app __x19__ = (CreateUnmappedArgumentsObject argumentsList)\n      48:let ao = __x19__\n    } else {\n      51:(16) app __x20__ = (CreateMappedArgumentsObject func formals argumentsList env)\n      51:let ao = __x20__\n    }\n    54:if (= strict true) {\n      53:(17) app __x21__ = (env[\"CreateImmutableBinding\"] env \"arguments\" false)\n      53:[! __x21__]\n    } else {\n      55:(18) app __x22__ = (env[\"CreateMutableBinding\"] env \"arguments\" false)\n      55:[! __x22__]\n    }\n    56:(19) app __x23__ = (env[\"InitializeBinding\"] env \"arguments\" ao)\n    56:__x23__\n    57:let __x24__ = (9) (copy-obj parameterNames)\n    57:append \"arguments\" -> __x24__\n    57:let parameterBindings = __x24__\n  } else let parameterBindings = parameterNames\n  60:(20) app __x25__ = (CreateListIteratorRecord argumentsList)\n  60:let iteratorRecord = __x25__\n  63:if (= hasDuplicates true) {\n    62:(21) access __x26__ = (formals \"IteratorBindingInitialization\" iteratorRecord undefined)\n    62:[? __x26__]\n  } else {\n    64:(22) access __x27__ = (formals \"IteratorBindingInitialization\" iteratorRecord env)\n    64:[? __x27__]\n  }\n  74:if (= hasParameterExpressions false) {\n    67:let instantiatedVarNames = (10) (copy-obj parameterBindings)\n    68:let __x28__ = varNames\n    68:let __x29__ = 0i\n    68:while (< __x29__ __x28__[\"length\"]) {\n      let n = __x28__[__x29__]\n      69:if (! (contains instantiatedVarNames n)) {\n        70:append n -> instantiatedVarNames\n        71:(23) app __x30__ = (env[\"CreateMutableBinding\"] env n false)\n        71:[! __x30__]\n        72:(24) app __x31__ = (env[\"InitializeBinding\"] env n undefined)\n        72:__x31__\n      } else 96:{}\n      __x29__ = (+ __x29__ 1i)\n    }\n    73:let varEnv = env\n  } else {\n    76:(25) app __x32__ = (NewDeclarativeEnvironment env)\n    76:let varEnv = __x32__\n    77:calleeContext[\"VariableEnvironment\"] = varEnv\n    78:let instantiatedVarNames = (11) (new [])\n    79:let __x33__ = varNames\n    79:let __x34__ = 0i\n    79:while (< __x34__ __x33__[\"length\"]) {\n      let n = __x33__[__x34__]\n      80:if (! (contains instantiatedVarNames n)) {\n        81:append n -> instantiatedVarNames\n        82:(26) app __x35__ = (varEnv[\"CreateMutableBinding\"] varEnv n false)\n        82:[! __x35__]\n        84:if (|| (! (contains parameterBindings n)) (contains functionNames n)) let initialValue = undefined else {\n          85:(27) app __x36__ = (env[\"GetBindingValue\"] env n false)\n          85:let initialValue = [! __x36__]\n        }\n        86:(28) app __x37__ = (varEnv[\"InitializeBinding\"] varEnv n initialValue)\n        86:__x37__\n      } else 96:{}\n      __x34__ = (+ __x34__ 1i)\n    }\n  }\n  92:if (= strict false) {\n    90:(29) app __x38__ = (NewDeclarativeEnvironment varEnv)\n    90:let lexEnv = __x38__\n  } else let lexEnv = varEnv\n  93:calleeContext[\"LexicalEnvironment\"] = lexEnv\n  94:(30) access __x39__ = (code \"LexicallyScopedDeclarations\")\n  94:let lexDeclarations = __x39__\n  95:let __x40__ = lexDeclarations\n  95:let __x41__ = 0i\n  95:while (< __x41__ __x40__[\"length\"]) {\n    let d = __x40__[__x41__]\n    97:(31) access __x42__ = (d \"BoundNames\")\n    97:let __x43__ = __x42__\n    97:let __x44__ = 0i\n    97:while (< __x44__ __x43__[\"length\"]) {\n      let dn = __x43__[__x44__]\n      100:(32) access __x45__ = (d \"IsConstantDeclaration\")\n      100:if (= __x45__ true) {\n        99:(33) app __x46__ = (lexEnv[\"CreateImmutableBinding\"] lexEnv dn true)\n        99:[! __x46__]\n      } else {\n        101:(34) app __x47__ = (lexEnv[\"CreateMutableBinding\"] lexEnv dn false)\n        101:[! __x47__]\n      }\n      __x44__ = (+ __x44__ 1i)\n    }\n    __x41__ = (+ __x41__ 1i)\n  }\n  102:let __x48__ = functionsToInitialize\n  102:let __x49__ = 0i\n  102:while (< __x49__ __x48__[\"length\"]) {\n    let f = __x48__[__x49__]\n    103:(35) access __x50__ = (f \"BoundNames\")\n    103:let fn = __x50__[0i]\n    104:(36) access __x51__ = (f \"InstantiateFunctionObject\" lexEnv)\n    104:let fo = __x51__\n    105:(37) app __x52__ = (varEnv[\"SetMutableBinding\"] varEnv fn fo false)\n    105:[! __x52__]\n    __x49__ = (+ __x49__ 1i)\n  }\n  106:return CONST_empty\n}"
  }, {
    "code": ["        1. Let _callerContext_ be the running execution context.", "        1. If _callerContext_ is not already suspended, suspend _callerContext_.", "        1. Let _calleeContext_ be a new execution context.", "        1. Set the Function of _calleeContext_ to _F_.", "        1. Let _calleeRealm_ be _F_.[[Realm]].", "        1. Set the Realm of _calleeContext_ to _calleeRealm_.", "        1. Set the ScriptOrModule of _calleeContext_ to *null*.", "        1. Perform any necessary implementation-defined initialization of _calleeContext_.", "        1. Push _calleeContext_ onto the execution context stack; _calleeContext_ is now the running execution context.", "        1. [id=\"step-call-builtin-function-result\"] Let _result_ be the Completion Record that is the result of evaluating _F_ in a manner that conforms to the specification of _F_. _thisArgument_ is the *this* value, _argumentsList_ provides the named parameters, and the NewTarget value is *undefined*.", "        1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.", "        1. Return _result_."],
    "head": {
      "base": "BuiltinFunctionObject",
      "methodName": "Call",
      "origParams": [{
        "kind": "Normal",
        "name": "thisArgument"
      }, {
        "kind": "Normal",
        "name": "argumentsList"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "F"
      }
    },
    "ids": "sec-built-in-function-objects-call-thisargument-argumentslist",
    "rawBody": "{\n  0:let callerContext = CONTEXT\n  1:if (= callerContext null) CONTEXT = null else 7:{}\n  2:let calleeContext = (0) (new ExecutionContext())\n  3:calleeContext[\"Function\"] = F\n  4:let calleeRealm = F[\"Realm\"]\n  5:calleeContext[\"Realm\"] = calleeRealm\n  6:calleeContext[\"ScriptOrModule\"] = null\n  8:append calleeContext -> EXECUTION_STACK\n  8:CONTEXT = EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)]\n  9:(0) app result = (F[\"Code\"] thisArgument argumentsList undefined)\n  10:if (= EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)] calleeContext) {\n    let __x0__ = (- EXECUTION_STACK[\"length\"] 1i)\n    (pop EXECUTION_STACK __x0__)\n  } else {}\n  10:CONTEXT = EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)]\n  11:return result\n}"
  }, {
    "code": ["        1. Let _result_ be the Completion Record that is the result of evaluating _F_ in a manner that conforms to the specification of _F_. The *this* value is uninitialized, _argumentsList_ provides the named parameters, and _newTarget_ provides the NewTarget value."],
    "head": {
      "base": "BuiltinFunctionObject",
      "methodName": "Construct",
      "origParams": [{
        "kind": "Normal",
        "name": "argumentsList"
      }, {
        "kind": "Normal",
        "name": "newTarget"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "F"
      }
    },
    "ids": "sec-built-in-function-objects-construct-argumentslist-newtarget",
    "rawBody": "(0) ??? \"Let id:{result} be the Completion Record that is the result of evaluating id:{F} in a manner that conforms to the specification of id:{F} . The value:{this} value is uninitialized , id:{argumentsList} provides the named parameters , and id:{newTarget} provides the NewTarget value .\""
  }, {
    "code": ["        1. Assert: _steps_ is either a set of algorithm steps or other definition of a function's behaviour provided in this specification.", "        1. If _realm_ is not present or _realm_ is ~empty~, set _realm_ to the current Realm Record.", "        1. Assert: _realm_ is a Realm Record.", "        1. If _prototype_ is not present, set _prototype_ to _realm_.[[Intrinsics]].[[%Function.prototype%]].", "        1. Let _func_ be a new built-in function object that when called performs the action described by _steps_. The new function object has internal slots whose names are the elements of _internalSlotsList_, and an [[InitialName]] internal slot.", "        1. Set _func_.[[Realm]] to _realm_.", "        1. Set _func_.[[Prototype]] to _prototype_.", "        1. Set _func_.[[Extensible]] to *true*.", "        1. Set _func_.[[InitialName]] to *null*.", "        1. Perform ! SetFunctionLength(_func_, _length_).", "        1. If _prefix_ is not present, then", "          1. Perform ! SetFunctionName(_func_, _name_).", "        1. Else,", "          1. Perform ! SetFunctionName(_func_, _name_, _prefix_).", "        1. Return _func_."],
    "head": {
      "name": "CreateBuiltinFunction",
      "params": [{
        "kind": "Normal",
        "name": "steps"
      }, {
        "kind": "Normal",
        "name": "length"
      }, {
        "kind": "Normal",
        "name": "name"
      }, {
        "kind": "Normal",
        "name": "internalSlotsList"
      }, {
        "kind": "Optional",
        "name": "realm"
      }, {
        "kind": "Optional",
        "name": "prototype"
      }, {
        "kind": "Optional",
        "name": "prefix"
      }]
    },
    "ids": "sec-createbuiltinfunction",
    "rawBody": "{\n  1:if (|| (= realm absent) (= realm CONST_empty)) realm = REALM else 0:{}\n  2:assert (0) (is-instance-of realm RealmRecord)\n  3:if (= prototype absent) prototype = realm[\"Intrinsics\"][\"INTRINSIC_Function_prototype\"] else 0:{}\n  4:(1) ??? \"Let id:{func} be a new built - in function object that when called performs the action described by id:{steps} . The new function object has internal slots whose names are the elements of id:{internalSlotsList} , and an [ [ InitialName ] ] internal slot .\"\n  5:func[\"Realm\"] = realm\n  6:func[\"Prototype\"] = prototype\n  7:func[\"Extensible\"] = true\n  8:func[\"InitialName\"] = null\n  9:(0) app __x0__ = (SetFunctionLength func length)\n  9:[! __x0__]\n  12:if (= prefix absent) {\n    11:(1) app __x1__ = (SetFunctionName func name)\n    11:[! __x1__]\n  } else {\n    13:(2) app __x2__ = (SetFunctionName func name prefix)\n    13:[! __x2__]\n  }\n  14:return func\n}"
  }, {
    "code": ["          1. Let _target_ be _F_.[[BoundTargetFunction]].", "          1. Let _boundThis_ be _F_.[[BoundThis]].", "          1. Let _boundArgs_ be _F_.[[BoundArguments]].", "          1. Let _args_ be a List whose elements are the elements of _boundArgs_, followed by the elements of _argumentsList_.", "          1. Return ? Call(_target_, _boundThis_, _args_)."],
    "head": {
      "base": "BoundFunctionExoticObject",
      "methodName": "Call",
      "origParams": [{
        "kind": "Normal",
        "name": "thisArgument"
      }, {
        "kind": "Normal",
        "name": "argumentsList"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "F"
      }
    },
    "ids": "sec-bound-function-exotic-objects-call-thisargument-argumentslist",
    "rawBody": "{\n  0:let target = F[\"BoundTargetFunction\"]\n  1:let boundThis = F[\"BoundThis\"]\n  2:let boundArgs = F[\"BoundArguments\"]\n  3:let __x0__ = (0) (copy-obj boundArgs)\n  3:append argumentsList -> __x0__\n  3:let args = __x0__\n  4:(0) app __x1__ = (Call target boundThis args)\n  4:return [? __x1__]\n}"
  }, {
    "code": ["          1. Let _target_ be _F_.[[BoundTargetFunction]].", "          1. Assert: IsConstructor(_target_) is *true*.", "          1. Let _boundArgs_ be _F_.[[BoundArguments]].", "          1. Let _args_ be a List whose elements are the elements of _boundArgs_, followed by the elements of _argumentsList_.", "          1. If SameValue(_F_, _newTarget_) is *true*, set _newTarget_ to _target_.", "          1. Return ? Construct(_target_, _args_, _newTarget_)."],
    "head": {
      "base": "BoundFunctionExoticObject",
      "methodName": "Construct",
      "origParams": [{
        "kind": "Normal",
        "name": "argumentsList"
      }, {
        "kind": "Normal",
        "name": "newTarget"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "F"
      }
    },
    "ids": "sec-bound-function-exotic-objects-construct-argumentslist-newtarget",
    "rawBody": "{\n  0:let target = F[\"BoundTargetFunction\"]\n  1:(0) app __x0__ = (IsConstructor target)\n  1:assert (= __x0__ true)\n  2:let boundArgs = F[\"BoundArguments\"]\n  3:let __x1__ = (0) (copy-obj boundArgs)\n  3:append argumentsList -> __x1__\n  3:let args = __x1__\n  4:(1) app __x2__ = (SameValue F newTarget)\n  4:if (= __x2__ true) newTarget = target else 0:{}\n  5:(2) app __x3__ = (Construct target args newTarget)\n  5:return [? __x3__]\n}"
  }, {
    "code": ["          1. Assert: Type(_targetFunction_) is Object.", "          1. Let _proto_ be ? _targetFunction_.[[GetPrototypeOf]]().", "          1. Let _internalSlotsList_ be the internal slots listed in <emu-xref href=\"#table-internal-slots-of-bound-function-exotic-objects\"></emu-xref>, plus [[Prototype]] and [[Extensible]].", "          1. Let _obj_ be ! MakeBasicObject(_internalSlotsList_).", "          1. Set _obj_.[[Prototype]] to _proto_.", "          1. Set _obj_.[[Call]] as described in <emu-xref href=\"#sec-bound-function-exotic-objects-call-thisargument-argumentslist\"></emu-xref>.", "          1. If IsConstructor(_targetFunction_) is *true*, then", "            1. Set _obj_.[[Construct]] as described in <emu-xref href=\"#sec-bound-function-exotic-objects-construct-argumentslist-newtarget\"></emu-xref>.", "          1. Set _obj_.[[BoundTargetFunction]] to _targetFunction_.", "          1. Set _obj_.[[BoundThis]] to _boundThis_.", "          1. Set _obj_.[[BoundArguments]] to _boundArgs_.", "          1. Return _obj_."],
    "head": {
      "name": "BoundFunctionCreate",
      "params": [{
        "kind": "Normal",
        "name": "targetFunction"
      }, {
        "kind": "Normal",
        "name": "boundThis"
      }, {
        "kind": "Normal",
        "name": "boundArgs"
      }]
    },
    "ids": "sec-boundfunctioncreate",
    "rawBody": "{\n  0:assert (= (typeof targetFunction) Object)\n  1:(0) app __x0__ = (targetFunction[\"GetPrototypeOf\"] targetFunction)\n  1:let proto = [? __x0__]\n  2:let internalSlotsList = (0) (new [\"BoundTargetFunction\", \"BoundThis\", \"BoundArguments\", \"Prototype\", \"Extensible\"])\n  3:(1) app __x1__ = (MakeBasicObject internalSlotsList)\n  3:let obj = [! __x1__]\n  4:obj[\"Prototype\"] = proto\n  5:obj[\"Call\"] = ALGORITHM[\"BoundFunctionExoticObject.Call\"]\n  6:(2) app __x2__ = (IsConstructor targetFunction)\n  6:if (= __x2__ true) obj[\"Construct\"] = ALGORITHM[\"BoundFunctionExoticObject.Construct\"] else 0:{}\n  8:obj[\"BoundTargetFunction\"] = targetFunction\n  9:obj[\"BoundThis\"] = boundThis\n  10:obj[\"BoundArguments\"] = boundArgs\n  11:return obj\n}"
  }, {
    "code": ["          1. Assert: IsPropertyKey(_P_) is *true*.", "          1. If _P_ is *\"length\"*, then", "            1. Return ? ArraySetLength(_A_, _Desc_).", "          1. Else if _P_ is an array index, then", "            1. Let _oldLenDesc_ be OrdinaryGetOwnProperty(_A_, *\"length\"*).", "            1. Assert: ! IsDataDescriptor(_oldLenDesc_) is *true*.", "            1. Assert: _oldLenDesc_.[[Configurable]] is *false*.", "            1. Let _oldLen_ be _oldLenDesc_.[[Value]].", "            1. Assert: _oldLen_ is a non-negative integral Number.", "            1. Let _index_ be ! ToUint32(_P_).", "            1. If _index_ ≥ _oldLen_ and _oldLenDesc_.[[Writable]] is *false*, return *false*.", "            1. Let _succeeded_ be ! OrdinaryDefineOwnProperty(_A_, _P_, _Desc_).", "            1. If _succeeded_ is *false*, return *false*.", "            1. If _index_ ≥ _oldLen_, then", "              1. Set _oldLenDesc_.[[Value]] to _index_ + *1*<sub>𝔽</sub>.", "              1. Let _succeeded_ be OrdinaryDefineOwnProperty(_A_, *\"length\"*, _oldLenDesc_).", "              1. Assert: _succeeded_ is *true*.", "            1. Return *true*.", "          1. Return OrdinaryDefineOwnProperty(_A_, _P_, _Desc_)."],
    "head": {
      "base": "ArrayExoticObject",
      "methodName": "DefineOwnProperty",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Normal",
        "name": "Desc"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "A"
      }
    },
    "ids": "sec-array-exotic-objects-defineownproperty-p-desc",
    "rawBody": "{\n  0:(0) app __x0__ = (IsPropertyKey P)\n  0:assert (= __x0__ true)\n  3:if (= P \"length\") {\n    2:(1) app __x1__ = (ArraySetLength A Desc)\n    2:return [? __x1__]\n  } else {\n    (2) app __x2__ = (IsArrayIndex P)\n    if __x2__ {\n      4:(3) app __x3__ = (OrdinaryGetOwnProperty A \"length\")\n      4:let oldLenDesc = __x3__\n      5:(4) app __x4__ = (IsDataDescriptor oldLenDesc)\n      5:assert (= [! __x4__] true)\n      6:assert (= oldLenDesc[\"Configurable\"] false)\n      7:let oldLen = oldLenDesc[\"Value\"]\n      9:(5) app __x5__ = (ToUint32 P)\n      9:let index = [! __x5__]\n      10:if (&& (! (< index oldLen)) (= oldLenDesc[\"Writable\"] false)) return false else 8:{}\n      11:(6) app __x6__ = (OrdinaryDefineOwnProperty A P Desc)\n      11:let succeeded = [! __x6__]\n      12:if (= succeeded false) return false else 8:{}\n      13:if (! (< index oldLen)) {\n        14:oldLenDesc[\"Value\"] = (+ index 1i)\n        15:(7) app __x7__ = (OrdinaryDefineOwnProperty A \"length\" oldLenDesc)\n        15:let succeeded = __x7__\n        16:assert (= succeeded true)\n      } else 8:{}\n      17:return true\n    } else 8:{}\n  }\n  18:(8) app __x8__ = (OrdinaryDefineOwnProperty A P Desc)\n  18:return __x8__\n}"
  }, {
    "code": ["          1. If _length_ > 2<sup>32</sup> - 1, throw a *RangeError* exception.", "          1. If _proto_ is not present, set _proto_ to %Array.prototype%.", "          1. Let _A_ be ! MakeBasicObject(« [[Prototype]], [[Extensible]] »).", "          1. Set _A_.[[Prototype]] to _proto_.", "          1. Set _A_.[[DefineOwnProperty]] as specified in <emu-xref href=\"#sec-array-exotic-objects-defineownproperty-p-desc\"></emu-xref>.", "          1. Perform ! OrdinaryDefineOwnProperty(_A_, *\"length\"*, PropertyDescriptor { [[Value]]: 𝔽(_length_), [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).", "          1. Return _A_."],
    "head": {
      "name": "ArrayCreate",
      "params": [{
        "kind": "Normal",
        "name": "length"
      }, {
        "kind": "Optional",
        "name": "proto"
      }]
    },
    "ids": "sec-arraycreate",
    "rawBody": "{\n  0:if (< (- (** 2.0 32i) 1i) length) (0) throw RangeError else 8:{}\n  1:if (= proto absent) proto = INTRINSIC_Array_prototype else 8:{}\n  2:(0) app __x0__ = (MakeBasicObject (1) (new [\"Prototype\", \"Extensible\"]))\n  2:let A = [! __x0__]\n  3:A[\"Prototype\"] = proto\n  4:A[\"DefineOwnProperty\"] = ALGORITHM[\"ArrayExoticObject.DefineOwnProperty\"]\n  5:(1) app __x1__ = (OrdinaryDefineOwnProperty A \"length\" (2) (new PropertyDescriptor(\"Value\" -> length, \"Writable\" -> true, \"Enumerable\" -> false, \"Configurable\" -> false)))\n  5:[! __x1__]\n  6:return A\n}"
  }, {
    "code": ["          1. Let _isArray_ be ? IsArray(_originalArray_).", "          1. If _isArray_ is *false*, return ? ArrayCreate(_length_).", "          1. Let _C_ be ? Get(_originalArray_, *\"constructor\"*).", "          1. If IsConstructor(_C_) is *true*, then", "            1. Let _thisRealm_ be the current Realm Record.", "            1. Let _realmC_ be ? GetFunctionRealm(_C_).", "            1. If _thisRealm_ and _realmC_ are not the same Realm Record, then", "              1. If SameValue(_C_, _realmC_.[[Intrinsics]].[[%Array%]]) is *true*, set _C_ to *undefined*.", "          1. If Type(_C_) is Object, then", "            1. Set _C_ to ? Get(_C_, @@species).", "            1. If _C_ is *null*, set _C_ to *undefined*.", "          1. If _C_ is *undefined*, return ? ArrayCreate(_length_).", "          1. If IsConstructor(_C_) is *false*, throw a *TypeError* exception.", "          1. Return ? Construct(_C_, « 𝔽(_length_) »)."],
    "head": {
      "name": "ArraySpeciesCreate",
      "params": [{
        "kind": "Normal",
        "name": "originalArray"
      }, {
        "kind": "Normal",
        "name": "length"
      }]
    },
    "ids": "sec-arrayspeciescreate",
    "rawBody": "{\n  0:(0) app __x0__ = (IsArray originalArray)\n  0:let isArray = [? __x0__]\n  1:if (= isArray false) {\n    (1) app __x1__ = (ArrayCreate length)\n    return [? __x1__]\n  } else 8:{}\n  2:(2) app __x2__ = (Get originalArray \"constructor\")\n  2:let C = [? __x2__]\n  3:(3) app __x3__ = (IsConstructor C)\n  3:if (= __x3__ true) {\n    4:let thisRealm = REALM\n    5:(4) app __x4__ = (GetFunctionRealm C)\n    5:let realmC = [? __x4__]\n    6:if (! (= thisRealm realmC)) {\n      7:(5) app __x5__ = (SameValue C realmC[\"Intrinsics\"][\"INTRINSIC_Array\"])\n      7:if (= __x5__ true) C = undefined else 8:{}\n    } else 8:{}\n  } else 8:{}\n  8:if (= (typeof C) Object) {\n    9:(6) app __x6__ = (Get C SYMBOL_species)\n    9:C = [? __x6__]\n    10:if (= C null) C = undefined else 8:{}\n  } else 8:{}\n  11:if (= C undefined) {\n    (7) app __x7__ = (ArrayCreate length)\n    return [? __x7__]\n  } else 8:{}\n  12:(8) app __x8__ = (IsConstructor C)\n  12:if (= __x8__ false) (0) throw TypeError else 8:{}\n  13:(9) app __x9__ = (Construct C (1) (new [length]))\n  13:return [? __x9__]\n}"
  }, {
    "code": ["          1. If _Desc_.[[Value]] is absent, then", "            1. Return OrdinaryDefineOwnProperty(_A_, *\"length\"*, _Desc_).", "          1. Let _newLenDesc_ be a copy of _Desc_.", "          1. [id=\"step-arraysetlength-newlen\"] Let _newLen_ be ? ToUint32(_Desc_.[[Value]]).", "          1. [id=\"step-arraysetlength-numberlen\"] Let _numberLen_ be ? ToNumber(_Desc_.[[Value]]).", "          1. If _newLen_ is not the same value as _numberLen_, throw a *RangeError* exception.", "          1. Set _newLenDesc_.[[Value]] to _newLen_.", "          1. Let _oldLenDesc_ be OrdinaryGetOwnProperty(_A_, *\"length\"*).", "          1. Assert: ! IsDataDescriptor(_oldLenDesc_) is *true*.", "          1. Assert: _oldLenDesc_.[[Configurable]] is *false*.", "          1. Let _oldLen_ be _oldLenDesc_.[[Value]].", "          1. If _newLen_ ≥ _oldLen_, then", "            1. Return OrdinaryDefineOwnProperty(_A_, *\"length\"*, _newLenDesc_).", "          1. If _oldLenDesc_.[[Writable]] is *false*, return *false*.", "          1. If _newLenDesc_.[[Writable]] is absent or has the value *true*, let _newWritable_ be *true*.", "          1. Else,", "            1. NOTE: Setting the [[Writable]] attribute to *false* is deferred in case any elements cannot be deleted.", "            1. Let _newWritable_ be *false*.", "            1. Set _newLenDesc_.[[Writable]] to *true*.", "          1. Let _succeeded_ be ! OrdinaryDefineOwnProperty(_A_, *\"length\"*, _newLenDesc_).", "          1. If _succeeded_ is *false*, return *false*.", "          1. For each own property key _P_ of _A_ that is an array index, whose numeric value is greater than or equal to _newLen_, in descending numeric index order, do", "            1. Let _deleteSucceeded_ be ! _A_.[[Delete]](_P_).", "            1. If _deleteSucceeded_ is *false*, then", "              1. Set _newLenDesc_.[[Value]] to ! ToUint32(_P_) + *1*<sub>𝔽</sub>.", "              1. If _newWritable_ is *false*, set _newLenDesc_.[[Writable]] to *false*.", "              1. Perform ! OrdinaryDefineOwnProperty(_A_, *\"length\"*, _newLenDesc_).", "              1. Return *false*.", "          1. If _newWritable_ is *false*, then", "            1. Let _succeeded_ be ! OrdinaryDefineOwnProperty(_A_, *\"length\"*, PropertyDescriptor { [[Writable]]: *false* }).", "            1. Assert: _succeeded_ is *true*.", "          1. Return *true*."],
    "head": {
      "name": "ArraySetLength",
      "params": [{
        "kind": "Normal",
        "name": "A"
      }, {
        "kind": "Normal",
        "name": "Desc"
      }]
    },
    "ids": "sec-arraysetlength",
    "rawBody": "{\n  0:if (= Desc[\"Value\"] absent) {\n    1:(0) app __x0__ = (OrdinaryDefineOwnProperty A \"length\" Desc)\n    1:return __x0__\n  } else 16:{}\n  2:let newLenDesc = (0) (copy-obj Desc)\n  3:(1) app __x1__ = (ToUint32 Desc[\"Value\"])\n  3:let newLen = [? __x1__]\n  4:(2) app __x2__ = (ToNumber Desc[\"Value\"])\n  4:let numberLen = [? __x2__]\n  5:if (! (= newLen numberLen)) (1) throw RangeError else 16:{}\n  6:newLenDesc[\"Value\"] = newLen\n  7:(3) app __x3__ = (OrdinaryGetOwnProperty A \"length\")\n  7:let oldLenDesc = __x3__\n  8:(4) app __x4__ = (IsDataDescriptor oldLenDesc)\n  8:assert (= [! __x4__] true)\n  9:assert (= oldLenDesc[\"Configurable\"] false)\n  10:let oldLen = oldLenDesc[\"Value\"]\n  11:if (! (< newLen oldLen)) {\n    12:(5) app __x5__ = (OrdinaryDefineOwnProperty A \"length\" newLenDesc)\n    12:return __x5__\n  } else 16:{}\n  13:if (= oldLenDesc[\"Writable\"] false) return false else 16:{}\n  15:if (|| (= newLenDesc[\"Writable\"] absent) (= newLenDesc[\"Writable\"] true)) let newWritable = true else {\n    17:let newWritable = false\n    18:newLenDesc[\"Writable\"] = true\n  }\n  19:(6) app __x6__ = (OrdinaryDefineOwnProperty A \"length\" newLenDesc)\n  19:let succeeded = [! __x6__]\n  20:if (= succeeded false) return false else 16:{}\n  28:if (= newWritable false) {\n    29:(7) app __x7__ = (OrdinaryDefineOwnProperty A \"length\" (2) (new PropertyDescriptor(\"Writable\" -> false)))\n    29:let succeeded = [! __x7__]\n    30:assert (= succeeded true)\n  } else 16:{}\n  31:return true\n}"
  }, {
    "code": ["          1. Assert: IsPropertyKey(_P_) is *true*.", "          1. Let _desc_ be OrdinaryGetOwnProperty(_S_, _P_).", "          1. If _desc_ is not *undefined*, return _desc_.", "          1. Return ! StringGetOwnProperty(_S_, _P_)."],
    "head": {
      "base": "StringExoticObject",
      "methodName": "GetOwnProperty",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "S"
      }
    },
    "ids": "sec-string-exotic-objects-getownproperty-p",
    "rawBody": "{\n  0:(0) app __x0__ = (IsPropertyKey P)\n  0:assert (= __x0__ true)\n  1:(1) app __x1__ = (OrdinaryGetOwnProperty S P)\n  1:let desc = __x1__\n  2:if (! (= desc undefined)) return desc else 16:{}\n  3:(2) app __x2__ = (StringGetOwnProperty S P)\n  3:return [! __x2__]\n}"
  }, {
    "code": ["          1. Assert: IsPropertyKey(_P_) is *true*.", "          1. Let _stringDesc_ be ! StringGetOwnProperty(_S_, _P_).", "          1. If _stringDesc_ is not *undefined*, then", "            1. Let _extensible_ be _S_.[[Extensible]].", "            1. Return ! IsCompatiblePropertyDescriptor(_extensible_, _Desc_, _stringDesc_).", "          1. Return ! OrdinaryDefineOwnProperty(_S_, _P_, _Desc_)."],
    "head": {
      "base": "StringExoticObject",
      "methodName": "DefineOwnProperty",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Normal",
        "name": "Desc"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "S"
      }
    },
    "ids": "sec-string-exotic-objects-defineownproperty-p-desc",
    "rawBody": "{\n  0:(0) app __x0__ = (IsPropertyKey P)\n  0:assert (= __x0__ true)\n  1:(1) app __x1__ = (StringGetOwnProperty S P)\n  1:let stringDesc = [! __x1__]\n  2:if (! (= stringDesc undefined)) {\n    3:let extensible = S[\"Extensible\"]\n    4:(2) app __x2__ = (IsCompatiblePropertyDescriptor extensible Desc stringDesc)\n    4:return [! __x2__]\n  } else 16:{}\n  5:(3) app __x3__ = (OrdinaryDefineOwnProperty S P Desc)\n  5:return [! __x3__]\n}"
  }, {
    "code": ["          1. Let _keys_ be a new empty List.", "          1. Let _str_ be _O_.[[StringData]].", "          1. Assert: Type(_str_) is String.", "          1. Let _len_ be the length of _str_.", "          1. For each integer _i_ starting with 0 such that _i_ < _len_, in ascending order, do", "            1. Add ! ToString(𝔽(_i_)) as the last element of _keys_.", "          1. For each own property key _P_ of _O_ such that _P_ is an array index and ! ToIntegerOrInfinity(_P_) ≥ _len_, in ascending numeric index order, do", "            1. Add _P_ as the last element of _keys_.", "          1. For each own property key _P_ of _O_ such that Type(_P_) is String and _P_ is not an array index, in ascending chronological order of property creation, do", "            1. Add _P_ as the last element of _keys_.", "          1. For each own property key _P_ of _O_ such that Type(_P_) is Symbol, in ascending chronological order of property creation, do", "            1. Add _P_ as the last element of _keys_.", "          1. Return _keys_."],
    "head": {
      "base": "StringExoticObject",
      "methodName": "OwnPropertyKeys",
      "origParams": [],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-string-exotic-objects-ownpropertykeys",
    "rawBody": "{\n  0:let keys = (0) (new [])\n  1:let str = O[\"StringData\"]\n  2:assert (= (typeof str) String)\n  3:let len = str[\"length\"]\n  4:let i = (+ 0i 0i)\n  4:let __x0__ = (+ len 0i)\n  4:while (< i __x0__) {\n    (0) app __x1__ = (ToString i)\n    append [! __x1__] -> keys\n  }\n  6:(1) ??? \"For each own property key id:{P} of id:{O} such that id:{P} is an array index and ! ToIntegerOrInfinity ( id:{P} ) ≥ id:{len} , in ascending numeric index order , do in:{} out:{}\"\n  8:(2) ??? \"For each own property key id:{P} of id:{O} such that Type ( id:{P} ) is String and id:{P} is not an array index , in ascending chronological order of property creation , do in:{} out:{}\"\n  10:(3) ??? \"For each own property key id:{P} of id:{O} such that Type ( id:{P} ) is Symbol , in ascending chronological order of property creation , do in:{} out:{}\"\n  12:return keys\n}"
  }, {
    "code": ["          1. Let _S_ be ! MakeBasicObject(« [[Prototype]], [[Extensible]], [[StringData]] »).", "          1. Set _S_.[[Prototype]] to _prototype_.", "          1. Set _S_.[[StringData]] to _value_.", "          1. Set _S_.[[GetOwnProperty]] as specified in <emu-xref href=\"#sec-string-exotic-objects-getownproperty-p\"></emu-xref>.", "          1. Set _S_.[[DefineOwnProperty]] as specified in <emu-xref href=\"#sec-string-exotic-objects-defineownproperty-p-desc\"></emu-xref>.", "          1. Set _S_.[[OwnPropertyKeys]] as specified in <emu-xref href=\"#sec-string-exotic-objects-ownpropertykeys\"></emu-xref>.", "          1. Let _length_ be the number of code unit elements in _value_.", "          1. Perform ! DefinePropertyOrThrow(_S_, *\"length\"*, PropertyDescriptor { [[Value]]: 𝔽(_length_), [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).", "          1. Return _S_."],
    "head": {
      "name": "StringCreate",
      "params": [{
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "prototype"
      }]
    },
    "ids": "sec-stringcreate",
    "rawBody": "{\n  0:(0) app __x0__ = (MakeBasicObject (0) (new [\"Prototype\", \"Extensible\", \"StringData\"]))\n  0:let S = [! __x0__]\n  1:S[\"Prototype\"] = prototype\n  2:S[\"StringData\"] = value\n  3:S[\"GetOwnProperty\"] = ALGORITHM[\"StringExoticObject.GetOwnProperty\"]\n  4:S[\"DefineOwnProperty\"] = ALGORITHM[\"StringExoticObject.DefineOwnProperty\"]\n  5:S[\"OwnPropertyKeys\"] = ALGORITHM[\"StringExoticObject.OwnPropertyKeys\"]\n  6:let length = value[\"length\"]\n  7:(1) app __x1__ = (DefinePropertyOrThrow S \"length\" (1) (new PropertyDescriptor(\"Value\" -> length, \"Writable\" -> false, \"Enumerable\" -> false, \"Configurable\" -> false)))\n  7:[! __x1__]\n  8:return S\n}"
  }, {
    "code": ["          1. Assert: _S_ is an Object that has a [[StringData]] internal slot.", "          1. Assert: IsPropertyKey(_P_) is *true*.", "          1. If Type(_P_) is not String, return *undefined*.", "          1. Let _index_ be ! CanonicalNumericIndexString(_P_).", "          1. If _index_ is *undefined*, return *undefined*.", "          1. If IsIntegralNumber(_index_) is *false*, return *undefined*.", "          1. If _index_ is *-0*<sub>𝔽</sub>, return *undefined*.", "          1. Let _str_ be _S_.[[StringData]].", "          1. Assert: Type(_str_) is String.", "          1. Let _len_ be the length of _str_.", "          1. If ℝ(_index_) < 0 or _len_ ≤ ℝ(_index_), return *undefined*.", "          1. Let _resultStr_ be the String value of length 1, containing one code unit from _str_, specifically the code unit at index ℝ(_index_).", "          1. Return the PropertyDescriptor { [[Value]]: _resultStr_, [[Writable]]: *false*, [[Enumerable]]: *true*, [[Configurable]]: *false* }."],
    "head": {
      "name": "StringGetOwnProperty",
      "params": [{
        "kind": "Normal",
        "name": "S"
      }, {
        "kind": "Normal",
        "name": "P"
      }]
    },
    "ids": "sec-stringgetownproperty",
    "rawBody": "{\n  1:(0) app __x0__ = (IsPropertyKey P)\n  1:assert (= __x0__ true)\n  2:if (! (= (typeof P) String)) return undefined else 0:{}\n  3:(1) app __x1__ = (CanonicalNumericIndexString P)\n  3:let index = [! __x1__]\n  4:if (= index undefined) return undefined else 0:{}\n  5:(2) app __x2__ = (IsIntegralNumber index)\n  5:if (= __x2__ false) return undefined else 0:{}\n  6:if (= index -0.0) return undefined else 0:{}\n  7:let str = S[\"StringData\"]\n  8:assert (= (typeof str) String)\n  9:let len = str[\"length\"]\n  10:if (|| (< index 0i) (! (< index len))) return undefined else 0:{}\n  11:(0) ??? \"Let id:{resultStr} be the String value of length 1 , containing one code unit from id:{str} , specifically the code unit at index ℝ ( id:{index} ) .\"\n  12:return (1) (new PropertyDescriptor(\"Value\" -> resultStr, \"Writable\" -> false, \"Enumerable\" -> true, \"Configurable\" -> false))\n}"
  }, {
    "code": ["          1. Let _desc_ be OrdinaryGetOwnProperty(_args_, _P_).", "          1. If _desc_ is *undefined*, return _desc_.", "          1. Let _map_ be _args_.[[ParameterMap]].", "          1. Let _isMapped_ be ! HasOwnProperty(_map_, _P_).", "          1. If _isMapped_ is *true*, then", "            1. Set _desc_.[[Value]] to Get(_map_, _P_).", "          1. Return _desc_."],
    "head": {
      "base": "ArgumentsExoticObject",
      "methodName": "GetOwnProperty",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "args"
      }
    },
    "ids": "sec-arguments-exotic-objects-getownproperty-p",
    "rawBody": "{\n  0:(0) app __x0__ = (OrdinaryGetOwnProperty args P)\n  0:let desc = __x0__\n  1:if (= desc undefined) return desc else 0:{}\n  2:let map = args[\"ParameterMap\"]\n  3:(1) app __x1__ = (HasOwnProperty map P)\n  3:let isMapped = [! __x1__]\n  4:if (= isMapped true) {\n    5:(2) app __x2__ = (Get map P)\n    5:desc[\"Value\"] = __x2__\n  } else 0:{}\n  6:return desc\n}"
  }, {
    "code": ["          1. Let _map_ be _args_.[[ParameterMap]].", "          1. Let _isMapped_ be HasOwnProperty(_map_, _P_).", "          1. Let _newArgDesc_ be _Desc_.", "          1. If _isMapped_ is *true* and IsDataDescriptor(_Desc_) is *true*, then", "            1. If _Desc_.[[Value]] is not present and _Desc_.[[Writable]] is present and its value is *false*, then", "              1. Set _newArgDesc_ to a copy of _Desc_.", "              1. Set _newArgDesc_.[[Value]] to Get(_map_, _P_).", "          1. Let _allowed_ be ? OrdinaryDefineOwnProperty(_args_, _P_, _newArgDesc_).", "          1. If _allowed_ is *false*, return *false*.", "          1. If _isMapped_ is *true*, then", "            1. If IsAccessorDescriptor(_Desc_) is *true*, then", "              1. Call _map_.[[Delete]](_P_).", "            1. Else,", "              1. If _Desc_.[[Value]] is present, then", "                1. Let _setStatus_ be Set(_map_, _P_, _Desc_.[[Value]], *false*).", "                1. Assert: _setStatus_ is *true* because formal parameters mapped by argument objects are always writable.", "              1. If _Desc_.[[Writable]] is present and its value is *false*, then", "                1. Call _map_.[[Delete]](_P_).", "          1. Return *true*."],
    "head": {
      "base": "ArgumentsExoticObject",
      "methodName": "DefineOwnProperty",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Normal",
        "name": "Desc"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "args"
      }
    },
    "ids": "sec-arguments-exotic-objects-defineownproperty-p-desc",
    "rawBody": "{\n  0:let map = args[\"ParameterMap\"]\n  1:(0) app __x0__ = (HasOwnProperty map P)\n  1:let isMapped = __x0__\n  2:let newArgDesc = Desc\n  3:let __x1__ = true\n  3:__x1__ = (= isMapped true)\n  3:if __x1__ {\n    (1) app __x2__ = (IsDataDescriptor Desc)\n    __x1__ = (= __x2__ true)\n  } else 15:{}\n  3:if __x1__ if (&& (= Desc[\"Value\"] absent) (= Desc[\"Writable\"] false)) {\n    5:newArgDesc = (0) (copy-obj Desc)\n    6:(2) app __x3__ = (Get map P)\n    6:newArgDesc[\"Value\"] = __x3__\n  } else 15:{} else 15:{}\n  7:(3) app __x4__ = (OrdinaryDefineOwnProperty args P newArgDesc)\n  7:let allowed = [? __x4__]\n  8:if (= allowed false) return false else 15:{}\n  9:if (= isMapped true) {\n    12:(4) app __x5__ = (IsAccessorDescriptor Desc)\n    12:if (= __x5__ true) {\n      11:(5) app __x6__ = (map[\"Delete\"] map P)\n      11:__x6__\n    } else {\n      13:if (! (= Desc[\"Value\"] absent)) {\n        14:(6) app __x7__ = (Set map P Desc[\"Value\"] false)\n        14:let setStatus = __x7__\n      } else 15:{}\n      16:if (= Desc[\"Writable\"] false) {\n        17:(7) app __x8__ = (map[\"Delete\"] map P)\n        17:__x8__\n      } else 15:{}\n    }\n  } else 15:{}\n  18:return true\n}"
  }, {
    "code": ["          1. Let _map_ be _args_.[[ParameterMap]].", "          1. Let _isMapped_ be ! HasOwnProperty(_map_, _P_).", "          1. If _isMapped_ is *false*, then", "            1. Return ? OrdinaryGet(_args_, _P_, _Receiver_).", "          1. Else,", "            1. Assert: _map_ contains a formal parameter mapping for _P_.", "            1. Return Get(_map_, _P_)."],
    "head": {
      "base": "ArgumentsExoticObject",
      "methodName": "Get",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Normal",
        "name": "Receiver"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "args"
      }
    },
    "ids": "sec-arguments-exotic-objects-get-p-receiver",
    "rawBody": "{\n  0:let map = args[\"ParameterMap\"]\n  1:(0) app __x0__ = (HasOwnProperty map P)\n  1:let isMapped = [! __x0__]\n  4:if (= isMapped false) {\n    3:(1) app __x1__ = (OrdinaryGet args P Receiver)\n    3:return [? __x1__]\n  } else {\n    6:(2) app __x2__ = (Get map P)\n    6:return __x2__\n  }\n}"
  }, {
    "code": ["          1. If SameValue(_args_, _Receiver_) is *false*, then", "            1. Let _isMapped_ be *false*.", "          1. Else,", "            1. Let _map_ be _args_.[[ParameterMap]].", "            1. Let _isMapped_ be ! HasOwnProperty(_map_, _P_).", "          1. If _isMapped_ is *true*, then", "            1. Let _setStatus_ be Set(_map_, _P_, _V_, *false*).", "            1. Assert: _setStatus_ is *true* because formal parameters mapped by argument objects are always writable.", "          1. Return ? OrdinarySet(_args_, _P_, _V_, _Receiver_)."],
    "head": {
      "base": "ArgumentsExoticObject",
      "methodName": "Set",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Normal",
        "name": "V"
      }, {
        "kind": "Normal",
        "name": "Receiver"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "args"
      }
    },
    "ids": "sec-arguments-exotic-objects-set-p-v-receiver",
    "rawBody": "{\n  2:(0) app __x0__ = (SameValue args Receiver)\n  2:if (= __x0__ false) let isMapped = false else {\n    3:let map = args[\"ParameterMap\"]\n    4:(1) app __x1__ = (HasOwnProperty map P)\n    4:let isMapped = [! __x1__]\n  }\n  5:if (= isMapped true) {\n    6:(2) app __x2__ = (Set map P V false)\n    6:let setStatus = __x2__\n  } else 7:{}\n  8:(3) app __x3__ = (OrdinarySet args P V Receiver)\n  8:return [? __x3__]\n}"
  }, {
    "code": ["          1. Let _map_ be _args_.[[ParameterMap]].", "          1. Let _isMapped_ be ! HasOwnProperty(_map_, _P_).", "          1. Let _result_ be ? OrdinaryDelete(_args_, _P_).", "          1. If _result_ is *true* and _isMapped_ is *true*, then", "            1. Call _map_.[[Delete]](_P_).", "          1. Return _result_."],
    "head": {
      "base": "ArgumentsExoticObject",
      "methodName": "Delete",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "args"
      }
    },
    "ids": "sec-arguments-exotic-objects-delete-p",
    "rawBody": "{\n  0:let map = args[\"ParameterMap\"]\n  1:(0) app __x0__ = (HasOwnProperty map P)\n  1:let isMapped = [! __x0__]\n  2:(1) app __x1__ = (OrdinaryDelete args P)\n  2:let result = [? __x1__]\n  3:if (&& (= result true) (= isMapped true)) {\n    4:(2) app __x2__ = (map[\"Delete\"] map P)\n    4:__x2__\n  } else 7:{}\n  5:return result\n}"
  }, {
    "code": ["          1. Let _len_ be the number of elements in _argumentsList_.", "          1. Let _obj_ be ! OrdinaryObjectCreate(%Object.prototype%, « [[ParameterMap]] »).", "          1. Set _obj_.[[ParameterMap]] to *undefined*.", "          1. Perform DefinePropertyOrThrow(_obj_, *\"length\"*, PropertyDescriptor { [[Value]]: 𝔽(_len_), [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).", "          1. Let _index_ be 0.", "          1. Repeat, while _index_ < _len_,", "            1. Let _val_ be _argumentsList_[_index_].", "            1. Perform ! CreateDataPropertyOrThrow(_obj_, ! ToString(𝔽(_index_)), _val_).", "            1. Set _index_ to _index_ + 1.", "          1. Perform ! DefinePropertyOrThrow(_obj_, @@iterator, PropertyDescriptor { [[Value]]: %Array.prototype.values%, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).", "          1. Perform ! DefinePropertyOrThrow(_obj_, *\"callee\"*, PropertyDescriptor { [[Get]]: %ThrowTypeError%, [[Set]]: %ThrowTypeError%, [[Enumerable]]: *false*, [[Configurable]]: *false* }).", "          1. Return _obj_."],
    "head": {
      "name": "CreateUnmappedArgumentsObject",
      "params": [{
        "kind": "Normal",
        "name": "argumentsList"
      }]
    },
    "ids": "sec-createunmappedargumentsobject",
    "rawBody": "{\n  0:let len = argumentsList[\"length\"]\n  1:(0) app __x0__ = (OrdinaryObjectCreate INTRINSIC_Object_prototype (0) (new [\"ParameterMap\"]))\n  1:let obj = [! __x0__]\n  2:obj[\"ParameterMap\"] = undefined\n  3:(1) app __x1__ = (DefinePropertyOrThrow obj \"length\" (1) (new PropertyDescriptor(\"Value\" -> len, \"Writable\" -> true, \"Enumerable\" -> false, \"Configurable\" -> true)))\n  3:__x1__\n  4:let index = 0i\n  5:while (< index len) {\n    6:let val = argumentsList[index]\n    7:(2) app __x2__ = (ToString index)\n    7:(3) app __x3__ = (CreateDataPropertyOrThrow obj [! __x2__] val)\n    7:[! __x3__]\n    8:index = (+ index 1i)\n  }\n  9:(4) app __x4__ = (DefinePropertyOrThrow obj SYMBOL_iterator (2) (new PropertyDescriptor(\"Value\" -> INTRINSIC_Array_prototype_values, \"Writable\" -> true, \"Enumerable\" -> false, \"Configurable\" -> true)))\n  9:[! __x4__]\n  10:(5) app __x5__ = (DefinePropertyOrThrow obj \"callee\" (3) (new PropertyDescriptor(\"Get\" -> INTRINSIC_ThrowTypeError, \"Set\" -> INTRINSIC_ThrowTypeError, \"Enumerable\" -> false, \"Configurable\" -> false)))\n  10:[! __x5__]\n  11:return obj\n}"
  }, {
    "code": ["          1. Assert: _formals_ does not contain a rest parameter, any binding patterns, or any initializers. It may contain duplicate identifiers.", "          1. Let _len_ be the number of elements in _argumentsList_.", "          1. Let _obj_ be ! MakeBasicObject(« [[Prototype]], [[Extensible]], [[ParameterMap]] »).", "          1. Set _obj_.[[GetOwnProperty]] as specified in <emu-xref href=\"#sec-arguments-exotic-objects-getownproperty-p\"></emu-xref>.", "          1. Set _obj_.[[DefineOwnProperty]] as specified in <emu-xref href=\"#sec-arguments-exotic-objects-defineownproperty-p-desc\"></emu-xref>.", "          1. Set _obj_.[[Get]] as specified in <emu-xref href=\"#sec-arguments-exotic-objects-get-p-receiver\"></emu-xref>.", "          1. Set _obj_.[[Set]] as specified in <emu-xref href=\"#sec-arguments-exotic-objects-set-p-v-receiver\"></emu-xref>.", "          1. Set _obj_.[[Delete]] as specified in <emu-xref href=\"#sec-arguments-exotic-objects-delete-p\"></emu-xref>.", "          1. Set _obj_.[[Prototype]] to %Object.prototype%.", "          1. Let _map_ be ! OrdinaryObjectCreate(*null*).", "          1. Set _obj_.[[ParameterMap]] to _map_.", "          1. Let _parameterNames_ be the BoundNames of _formals_.", "          1. Let _numberOfParameters_ be the number of elements in _parameterNames_.", "          1. Let _index_ be 0.", "          1. Repeat, while _index_ < _len_,", "            1. Let _val_ be _argumentsList_[_index_].", "            1. Perform ! CreateDataPropertyOrThrow(_obj_, ! ToString(𝔽(_index_)), _val_).", "            1. Set _index_ to _index_ + 1.", "          1. Perform ! DefinePropertyOrThrow(_obj_, *\"length\"*, PropertyDescriptor { [[Value]]: 𝔽(_len_), [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).", "          1. Let _mappedNames_ be a new empty List.", "          1. Let _index_ be _numberOfParameters_ - 1.", "          1. Repeat, while _index_ ≥ 0,", "            1. Let _name_ be _parameterNames_[_index_].", "            1. If _name_ is not an element of _mappedNames_, then", "              1. Add _name_ as an element of the list _mappedNames_.", "              1. If _index_ < _len_, then", "                1. Let _g_ be MakeArgGetter(_name_, _env_).", "                1. Let _p_ be MakeArgSetter(_name_, _env_).", "                1. Perform _map_.[[DefineOwnProperty]](! ToString(𝔽(_index_)), PropertyDescriptor { [[Set]]: _p_, [[Get]]: _g_, [[Enumerable]]: *false*, [[Configurable]]: *true* }).", "            1. Set _index_ to _index_ - 1.", "          1. Perform ! DefinePropertyOrThrow(_obj_, @@iterator, PropertyDescriptor { [[Value]]: %Array.prototype.values%, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).", "          1. Perform ! DefinePropertyOrThrow(_obj_, *\"callee\"*, PropertyDescriptor { [[Value]]: _func_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).", "          1. Return _obj_."],
    "head": {
      "name": "CreateMappedArgumentsObject",
      "params": [{
        "kind": "Normal",
        "name": "func"
      }, {
        "kind": "Normal",
        "name": "formals"
      }, {
        "kind": "Normal",
        "name": "argumentsList"
      }, {
        "kind": "Normal",
        "name": "env"
      }]
    },
    "ids": "sec-createmappedargumentsobject",
    "rawBody": "{\n  1:let len = argumentsList[\"length\"]\n  2:(0) app __x0__ = (MakeBasicObject (0) (new [\"Prototype\", \"Extensible\", \"ParameterMap\"]))\n  2:let obj = [! __x0__]\n  3:obj[\"GetOwnProperty\"] = ALGORITHM[\"ArgumentsExoticObject.GetOwnProperty\"]\n  4:obj[\"DefineOwnProperty\"] = ALGORITHM[\"ArgumentsExoticObject.DefineOwnProperty\"]\n  5:obj[\"Get\"] = ALGORITHM[\"ArgumentsExoticObject.Get\"]\n  6:obj[\"Set\"] = ALGORITHM[\"ArgumentsExoticObject.Set\"]\n  7:obj[\"Delete\"] = ALGORITHM[\"ArgumentsExoticObject.Delete\"]\n  8:obj[\"Prototype\"] = INTRINSIC_Object_prototype\n  9:(1) app __x1__ = (OrdinaryObjectCreate null)\n  9:let map = [! __x1__]\n  10:obj[\"ParameterMap\"] = map\n  11:(2) access __x2__ = (formals \"BoundNames\")\n  11:let parameterNames = __x2__\n  12:let numberOfParameters = parameterNames[\"length\"]\n  13:let index = 0i\n  14:while (< index len) {\n    15:let val = argumentsList[index]\n    16:(3) app __x3__ = (ToString index)\n    16:(4) app __x4__ = (CreateDataPropertyOrThrow obj [! __x3__] val)\n    16:[! __x4__]\n    17:index = (+ index 1i)\n  }\n  18:(5) app __x5__ = (DefinePropertyOrThrow obj \"length\" (1) (new PropertyDescriptor(\"Value\" -> len, \"Writable\" -> true, \"Enumerable\" -> false, \"Configurable\" -> true)))\n  18:[! __x5__]\n  19:let mappedNames = (2) (new [])\n  20:let index = (- numberOfParameters 1i)\n  21:while (! (< index 0i)) {\n    22:let name = parameterNames[index]\n    23:if (! (contains mappedNames name)) {\n      24:append name -> mappedNames\n      25:if (< index len) {\n        26:(6) app __x6__ = (MakeArgGetter name env)\n        26:let g = __x6__\n        27:(7) app __x7__ = (MakeArgSetter name env)\n        27:let p = __x7__\n        28:(8) app __x8__ = (ToString index)\n        28:(9) app __x9__ = (map[\"DefineOwnProperty\"] map [! __x8__] (3) (new PropertyDescriptor(\"Set\" -> p, \"Get\" -> g, \"Enumerable\" -> false, \"Configurable\" -> true)))\n        28:__x9__\n      } else 0:{}\n    } else 0:{}\n    29:index = (- index 1i)\n  }\n  30:(10) app __x10__ = (DefinePropertyOrThrow obj SYMBOL_iterator (4) (new PropertyDescriptor(\"Value\" -> INTRINSIC_Array_prototype_values, \"Writable\" -> true, \"Enumerable\" -> false, \"Configurable\" -> true)))\n  30:[! __x10__]\n  31:(11) app __x11__ = (DefinePropertyOrThrow obj \"callee\" (5) (new PropertyDescriptor(\"Value\" -> func, \"Writable\" -> true, \"Enumerable\" -> false, \"Configurable\" -> true)))\n  31:[! __x11__]\n  32:return obj\n}"
  }, {
    "code": ["            1. Let _steps_ be the steps of an ArgGetter function as specified below.", "            1. Let _length_ be the number of non-optional parameters of an ArgGetter function as specified below.", "            1. Let _getter_ be ! CreateBuiltinFunction(_steps_, _length_, *\"\"*, « [[Name]], [[Env]] »).", "            1. Set _getter_.[[Name]] to _name_.", "            1. Set _getter_.[[Env]] to _env_.", "            1. Return _getter_."],
    "head": {
      "name": "MakeArgGetter",
      "params": [{
        "kind": "Normal",
        "name": "name"
      }, {
        "kind": "Normal",
        "name": "env"
      }]
    },
    "ids": "sec-makearggetter",
    "rawBody": "{\n  0:(0) ??? \"Let id:{steps} be the steps of an ArgGetter function as specified below .\"\n  1:(1) ??? \"Let id:{length} be the number of non - optional parameters of an ArgGetter function as specified below .\"\n  2:(0) app __x0__ = (CreateBuiltinFunction steps length \"\" (2) (new [\"Name\", \"Env\"]))\n  2:let getter = [! __x0__]\n  3:getter[\"Name\"] = name\n  4:getter[\"Env\"] = env\n  5:return getter\n}"
  }, {
    "code": ["            1. Let _f_ be the active function object.", "            1. Let _name_ be _f_.[[Name]].", "            1. Let _env_ be _f_.[[Env]].", "            1. Return _env_.GetBindingValue(_name_, *false*)."],
    "head": {
      "name": "MakeArgGetter",
      "params": [{
        "kind": "Normal",
        "name": "name"
      }, {
        "kind": "Normal",
        "name": "env"
      }]
    },
    "ids": "sec-makearggetter",
    "rawBody": "{\n  0:let f = CONTEXT[\"Function\"]\n  1:let name = f[\"Name\"]\n  2:let env = f[\"Env\"]\n  3:(0) app __x0__ = (env[\"GetBindingValue\"] env name false)\n  3:return __x0__\n}"
  }, {
    "code": ["            1. Let _steps_ be the steps of an ArgSetter function as specified below.", "            1. Let _length_ be the number of non-optional parameters of an ArgSetter function as specified below.", "            1. Let _setter_ be ! CreateBuiltinFunction(_steps_, _length_, *\"\"*, « [[Name]], [[Env]] »).", "            1. Set _setter_.[[Name]] to _name_.", "            1. Set _setter_.[[Env]] to _env_.", "            1. Return _setter_."],
    "head": {
      "name": "MakeArgSetter",
      "params": [{
        "kind": "Normal",
        "name": "name"
      }, {
        "kind": "Normal",
        "name": "env"
      }]
    },
    "ids": "sec-makeargsetter",
    "rawBody": "{\n  0:(0) ??? \"Let id:{steps} be the steps of an ArgSetter function as specified below .\"\n  1:(1) ??? \"Let id:{length} be the number of non - optional parameters of an ArgSetter function as specified below .\"\n  2:(0) app __x0__ = (CreateBuiltinFunction steps length \"\" (2) (new [\"Name\", \"Env\"]))\n  2:let setter = [! __x0__]\n  3:setter[\"Name\"] = name\n  4:setter[\"Env\"] = env\n  5:return setter\n}"
  }, {
    "code": ["            1. Let _f_ be the active function object.", "            1. Let _name_ be _f_.[[Name]].", "            1. Let _env_ be _f_.[[Env]].", "            1. Return _env_.SetMutableBinding(_name_, _value_, *false*)."],
    "head": {
      "name": "MakeArgSetter",
      "params": [{
        "kind": "Normal",
        "name": "name"
      }, {
        "kind": "Normal",
        "name": "env"
      }]
    },
    "ids": "sec-makeargsetter",
    "rawBody": "{\n  0:let f = CONTEXT[\"Function\"]\n  1:let name = f[\"Name\"]\n  2:let env = f[\"Env\"]\n  3:(0) app __x0__ = (env[\"SetMutableBinding\"] env name value false)\n  3:return __x0__\n}"
  }, {
    "code": ["          1. Assert: IsPropertyKey(_P_) is *true*.", "          1. Assert: _O_ is an Integer-Indexed exotic object.", "          1. If Type(_P_) is String, then", "            1. Let _numericIndex_ be ! CanonicalNumericIndexString(_P_).", "            1. If _numericIndex_ is not *undefined*, then", "              1. Let _value_ be ! IntegerIndexedElementGet(_O_, _numericIndex_).", "              1. If _value_ is *undefined*, return *undefined*.", "              1. Return the PropertyDescriptor { [[Value]]: _value_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true* }.", "          1. Return OrdinaryGetOwnProperty(_O_, _P_)."],
    "head": {
      "base": "IntegerIndexedExoticObject",
      "methodName": "GetOwnProperty",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-integer-indexed-exotic-objects-getownproperty-p",
    "rawBody": "{\n  0:(0) app __x0__ = (IsPropertyKey P)\n  0:assert (= __x0__ true)\n  2:if (= (typeof P) String) {\n    3:(1) app __x1__ = (CanonicalNumericIndexString P)\n    3:let numericIndex = [! __x1__]\n    4:if (! (= numericIndex undefined)) {\n      5:(2) app __x2__ = (IntegerIndexedElementGet O numericIndex)\n      5:let value = [! __x2__]\n      6:if (= value undefined) return undefined else 1:{}\n      7:return (0) (new PropertyDescriptor(\"Value\" -> value, \"Writable\" -> true, \"Enumerable\" -> true, \"Configurable\" -> true))\n    } else 1:{}\n  } else 1:{}\n  8:(3) app __x3__ = (OrdinaryGetOwnProperty O P)\n  8:return __x3__\n}"
  }, {
    "code": ["          1. Assert: IsPropertyKey(_P_) is *true*.", "          1. Assert: _O_ is an Integer-Indexed exotic object.", "          1. If Type(_P_) is String, then", "            1. Let _numericIndex_ be ! CanonicalNumericIndexString(_P_).", "            1. If _numericIndex_ is not *undefined*, return ! IsValidIntegerIndex(_O_, _numericIndex_).", "          1. Return ? OrdinaryHasProperty(_O_, _P_)."],
    "head": {
      "base": "IntegerIndexedExoticObject",
      "methodName": "HasProperty",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-integer-indexed-exotic-objects-hasproperty-p",
    "rawBody": "{\n  0:(0) app __x0__ = (IsPropertyKey P)\n  0:assert (= __x0__ true)\n  2:if (= (typeof P) String) {\n    3:(1) app __x1__ = (CanonicalNumericIndexString P)\n    3:let numericIndex = [! __x1__]\n    4:if (! (= numericIndex undefined)) {\n      (2) app __x2__ = (IsValidIntegerIndex O numericIndex)\n      return [! __x2__]\n    } else 1:{}\n  } else 1:{}\n  5:(3) app __x3__ = (OrdinaryHasProperty O P)\n  5:return [? __x3__]\n}"
  }, {
    "code": ["          1. Assert: IsPropertyKey(_P_) is *true*.", "          1. Assert: _O_ is an Integer-Indexed exotic object.", "          1. If Type(_P_) is String, then", "            1. Let _numericIndex_ be ! CanonicalNumericIndexString(_P_).", "            1. If _numericIndex_ is not *undefined*, then", "              1. If ! IsValidIntegerIndex(_O_, _numericIndex_) is *false*, return *false*.", "              1. If _Desc_ has a [[Configurable]] field and if _Desc_.[[Configurable]] is *false*, return *false*.", "              1. If _Desc_ has an [[Enumerable]] field and if _Desc_.[[Enumerable]] is *false*, return *false*.", "              1. If ! IsAccessorDescriptor(_Desc_) is *true*, return *false*.", "              1. If _Desc_ has a [[Writable]] field and if _Desc_.[[Writable]] is *false*, return *false*.", "              1. If _Desc_ has a [[Value]] field, perform ? IntegerIndexedElementSet(_O_, _numericIndex_, _Desc_.[[Value]]).", "              1. Return *true*.", "          1. Return ! OrdinaryDefineOwnProperty(_O_, _P_, _Desc_)."],
    "head": {
      "base": "IntegerIndexedExoticObject",
      "methodName": "DefineOwnProperty",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Normal",
        "name": "Desc"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-integer-indexed-exotic-objects-defineownproperty-p-desc",
    "rawBody": "{\n  0:(0) app __x0__ = (IsPropertyKey P)\n  0:assert (= __x0__ true)\n  2:if (= (typeof P) String) {\n    3:(1) app __x1__ = (CanonicalNumericIndexString P)\n    3:let numericIndex = [! __x1__]\n    4:if (! (= numericIndex undefined)) {\n      5:(2) app __x2__ = (IsValidIntegerIndex O numericIndex)\n      5:if (= [! __x2__] false) return false else 1:{}\n      6:if (&& (! (= Desc[\"Configurable\"] absent)) (= Desc[\"Configurable\"] false)) return false else 1:{}\n      7:if (&& (! (= Desc[\"Enumerable\"] absent)) (= Desc[\"Enumerable\"] false)) return false else 1:{}\n      8:(3) app __x3__ = (IsAccessorDescriptor Desc)\n      8:if (= [! __x3__] true) return false else 1:{}\n      9:if (&& (! (= Desc[\"Writable\"] absent)) (= Desc[\"Writable\"] false)) return false else 1:{}\n      10:if (! (= Desc[\"Value\"] absent)) {\n        (4) app __x4__ = (IntegerIndexedElementSet O numericIndex Desc[\"Value\"])\n        [? __x4__]\n      } else 1:{}\n      11:return true\n    } else 1:{}\n  } else 1:{}\n  12:(5) app __x5__ = (OrdinaryDefineOwnProperty O P Desc)\n  12:return [! __x5__]\n}"
  }, {
    "code": ["          1. Assert: IsPropertyKey(_P_) is *true*.", "          1. If Type(_P_) is String, then", "            1. Let _numericIndex_ be ! CanonicalNumericIndexString(_P_).", "            1. If _numericIndex_ is not *undefined*, then", "              1. Return ! IntegerIndexedElementGet(_O_, _numericIndex_).", "          1. Return ? OrdinaryGet(_O_, _P_, _Receiver_)."],
    "head": {
      "base": "IntegerIndexedExoticObject",
      "methodName": "Get",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Normal",
        "name": "Receiver"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-integer-indexed-exotic-objects-get-p-receiver",
    "rawBody": "{\n  0:(0) app __x0__ = (IsPropertyKey P)\n  0:assert (= __x0__ true)\n  1:if (= (typeof P) String) {\n    2:(1) app __x1__ = (CanonicalNumericIndexString P)\n    2:let numericIndex = [! __x1__]\n    3:if (! (= numericIndex undefined)) {\n      4:(2) app __x2__ = (IntegerIndexedElementGet O numericIndex)\n      4:return [! __x2__]\n    } else 1:{}\n  } else 1:{}\n  5:(3) app __x3__ = (OrdinaryGet O P Receiver)\n  5:return [? __x3__]\n}"
  }, {
    "code": ["          1. Assert: IsPropertyKey(_P_) is *true*.", "          1. If Type(_P_) is String, then", "            1. Let _numericIndex_ be ! CanonicalNumericIndexString(_P_).", "            1. If _numericIndex_ is not *undefined*, then", "              1. Perform ? IntegerIndexedElementSet(_O_, _numericIndex_, _V_).", "              1. Return *true*.", "          1. Return ? OrdinarySet(_O_, _P_, _V_, _Receiver_)."],
    "head": {
      "base": "IntegerIndexedExoticObject",
      "methodName": "Set",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Normal",
        "name": "V"
      }, {
        "kind": "Normal",
        "name": "Receiver"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-integer-indexed-exotic-objects-set-p-v-receiver",
    "rawBody": "{\n  0:(0) app __x0__ = (IsPropertyKey P)\n  0:assert (= __x0__ true)\n  1:if (= (typeof P) String) {\n    2:(1) app __x1__ = (CanonicalNumericIndexString P)\n    2:let numericIndex = [! __x1__]\n    3:if (! (= numericIndex undefined)) {\n      4:(2) app __x2__ = (IntegerIndexedElementSet O numericIndex V)\n      4:[? __x2__]\n      5:return true\n    } else 1:{}\n  } else 1:{}\n  6:(3) app __x3__ = (OrdinarySet O P V Receiver)\n  6:return [? __x3__]\n}"
  }, {
    "code": ["          1. Assert: IsPropertyKey(_P_) is *true*.", "          1. Assert: _O_ is an Integer-Indexed exotic object.", "          1. If Type(_P_) is String, then", "            1. Let _numericIndex_ be ! CanonicalNumericIndexString(_P_).", "            1. If _numericIndex_ is not *undefined*, then", "              1. If ! IsValidIntegerIndex(_O_, _numericIndex_) is *false*, return *true*; else return *false*.", "          1. Return ? OrdinaryDelete(_O_, _P_)."],
    "head": {
      "base": "IntegerIndexedExoticObject",
      "methodName": "Delete",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-integer-indexed-exotic-objects-delete-p",
    "rawBody": "{\n  0:(0) app __x0__ = (IsPropertyKey P)\n  0:assert (= __x0__ true)\n  2:if (= (typeof P) String) {\n    3:(1) app __x1__ = (CanonicalNumericIndexString P)\n    3:let numericIndex = [! __x1__]\n    4:if (! (= numericIndex undefined)) {\n      5:(2) app __x2__ = (IsValidIntegerIndex O numericIndex)\n      5:if (= [! __x2__] false) return true else return false\n    } else 1:{}\n  } else 1:{}\n  6:(3) app __x3__ = (OrdinaryDelete O P)\n  6:return [? __x3__]\n}"
  }, {
    "code": ["          1. Let _keys_ be a new empty List.", "          1. Assert: _O_ is an Integer-Indexed exotic object.", "          1. If IsDetachedBuffer(_O_.[[ViewedArrayBuffer]]) is *false*, then", "            1. For each integer _i_ starting with 0 such that _i_ < _O_.[[ArrayLength]], in ascending order, do", "              1. Add ! ToString(𝔽(_i_)) as the last element of _keys_.", "          1. For each own property key _P_ of _O_ such that Type(_P_) is String and _P_ is not an integer index, in ascending chronological order of property creation, do", "            1. Add _P_ as the last element of _keys_.", "          1. For each own property key _P_ of _O_ such that Type(_P_) is Symbol, in ascending chronological order of property creation, do", "            1. Add _P_ as the last element of _keys_.", "          1. Return _keys_."],
    "head": {
      "base": "IntegerIndexedExoticObject",
      "methodName": "OwnPropertyKeys",
      "origParams": [],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-integer-indexed-exotic-objects-ownpropertykeys",
    "rawBody": "{\n  0:let keys = (0) (new [])\n  2:(0) app __x0__ = (IsDetachedBuffer O[\"ViewedArrayBuffer\"])\n  2:if (= __x0__ false) {\n    3:let i = (+ 0i 0i)\n    3:let __x1__ = (+ O[\"ArrayLength\"] 0i)\n    3:while (< i __x1__) {\n      (1) app __x2__ = (ToString i)\n      append [! __x2__] -> keys\n    }\n  } else 1:{}\n  5:(1) ??? \"For each own property key id:{P} of id:{O} such that Type ( id:{P} ) is String and id:{P} is not an integer index , in ascending chronological order of property creation , do in:{} out:{}\"\n  7:(2) ??? \"For each own property key id:{P} of id:{O} such that Type ( id:{P} ) is Symbol , in ascending chronological order of property creation , do in:{} out:{}\"\n  9:return keys\n}"
  }, {
    "code": ["          1. Let _internalSlotsList_ be « [[Prototype]], [[Extensible]], [[ViewedArrayBuffer]], [[TypedArrayName]], [[ContentType]], [[ByteLength]], [[ByteOffset]], [[ArrayLength]] ».", "          1. Let _A_ be ! MakeBasicObject(_internalSlotsList_).", "          1. Set _A_.[[GetOwnProperty]] as specified in <emu-xref href=\"#sec-integer-indexed-exotic-objects-getownproperty-p\"></emu-xref>.", "          1. Set _A_.[[HasProperty]] as specified in <emu-xref href=\"#sec-integer-indexed-exotic-objects-hasproperty-p\"></emu-xref>.", "          1. Set _A_.[[DefineOwnProperty]] as specified in <emu-xref href=\"#sec-integer-indexed-exotic-objects-defineownproperty-p-desc\"></emu-xref>.", "          1. Set _A_.[[Get]] as specified in <emu-xref href=\"#sec-integer-indexed-exotic-objects-get-p-receiver\"></emu-xref>.", "          1. Set _A_.[[Set]] as specified in <emu-xref href=\"#sec-integer-indexed-exotic-objects-set-p-v-receiver\"></emu-xref>.", "          1. Set _A_.[[Delete]] as specified in <emu-xref href=\"#sec-integer-indexed-exotic-objects-delete-p\"></emu-xref>.", "          1. Set _A_.[[OwnPropertyKeys]] as specified in <emu-xref href=\"#sec-integer-indexed-exotic-objects-ownpropertykeys\"></emu-xref>.", "          1. Set _A_.[[Prototype]] to _prototype_.", "          1. Return _A_."],
    "head": {
      "name": "IntegerIndexedObjectCreate",
      "params": [{
        "kind": "Normal",
        "name": "prototype"
      }]
    },
    "ids": "sec-integerindexedobjectcreate",
    "rawBody": "{\n  0:let internalSlotsList = (0) (new [\"Prototype\", \"Extensible\", \"ViewedArrayBuffer\", \"TypedArrayName\", \"ContentType\", \"ByteLength\", \"ByteOffset\", \"ArrayLength\"])\n  1:(0) app __x0__ = (MakeBasicObject internalSlotsList)\n  1:let A = [! __x0__]\n  2:A[\"GetOwnProperty\"] = ALGORITHM[\"IntegerIndexedExoticObject.GetOwnProperty\"]\n  3:A[\"HasProperty\"] = ALGORITHM[\"IntegerIndexedExoticObject.HasProperty\"]\n  4:A[\"DefineOwnProperty\"] = ALGORITHM[\"IntegerIndexedExoticObject.DefineOwnProperty\"]\n  5:A[\"Get\"] = ALGORITHM[\"IntegerIndexedExoticObject.Get\"]\n  6:A[\"Set\"] = ALGORITHM[\"IntegerIndexedExoticObject.Set\"]\n  7:A[\"Delete\"] = ALGORITHM[\"IntegerIndexedExoticObject.Delete\"]\n  8:A[\"OwnPropertyKeys\"] = ALGORITHM[\"IntegerIndexedExoticObject.OwnPropertyKeys\"]\n  9:A[\"Prototype\"] = prototype\n  10:return A\n}"
  }, {
    "code": ["          1. Assert: _O_ is an Integer-Indexed exotic object.", "          1. If IsDetachedBuffer(_O_.[[ViewedArrayBuffer]]) is *true*, return *false*.", "          1. If ! IsIntegralNumber(_index_) is *false*, return *false*.", "          1. If _index_ is *-0*<sub>𝔽</sub>, return *false*.", "          1. If ℝ(_index_) < 0 or ℝ(_index_) ≥ _O_.[[ArrayLength]], return *false*.", "          1. Return *true*."],
    "head": {
      "name": "IsValidIntegerIndex",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "index"
      }]
    },
    "ids": "sec-isvalidintegerindex",
    "rawBody": "{\n  1:(0) app __x0__ = (IsDetachedBuffer O[\"ViewedArrayBuffer\"])\n  1:if (= __x0__ true) return false else 0:{}\n  2:(1) app __x1__ = (IsIntegralNumber index)\n  2:if (= [! __x1__] false) return false else 0:{}\n  3:if (= index -0.0) return false else 0:{}\n  4:if (|| (< index 0i) (! (< index O[\"ArrayLength\"]))) return false else 0:{}\n  5:return true\n}"
  }, {
    "code": ["          1. Assert: _O_ is an Integer-Indexed exotic object.", "          1. If ! IsValidIntegerIndex(_O_, _index_) is *false*, return *undefined*.", "          1. Let _offset_ be _O_.[[ByteOffset]].", "          1. Let _arrayTypeName_ be the String value of _O_.[[TypedArrayName]].", "          1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _arrayTypeName_.", "          1. Let _indexedPosition_ be (ℝ(_index_) × _elementSize_) + _offset_.", "          1. Let _elementType_ be the Element Type value in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _arrayTypeName_.", "          1. Return GetValueFromBuffer(_O_.[[ViewedArrayBuffer]], _indexedPosition_, _elementType_, *true*, ~Unordered~)."],
    "head": {
      "name": "IntegerIndexedElementGet",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "index"
      }]
    },
    "ids": "sec-integerindexedelementget",
    "rawBody": "{\n  1:(0) app __x0__ = (IsValidIntegerIndex O index)\n  1:if (= [! __x0__] false) return undefined else 0:{}\n  2:let offset = O[\"ByteOffset\"]\n  3:let arrayTypeName = O[\"TypedArrayName\"]\n  4:(0) ??? \"Let id:{elementSize} be the Element Size value specified in link:{table-the-typedarray-constructors} for id:{arrayTypeName} .\"\n  5:let indexedPosition = (+ (* index elementSize) offset)\n  6:let elementType = CONST_Int8\n  7:(1) app __x1__ = (GetValueFromBuffer O[\"ViewedArrayBuffer\"] indexedPosition elementType true CONST_Unordered)\n  7:return __x1__\n}"
  }, {
    "code": ["          1. Assert: _O_ is an Integer-Indexed exotic object.", "          1. If _O_.[[ContentType]] is ~BigInt~, let _numValue_ be ? ToBigInt(_value_).", "          1. Otherwise, let _numValue_ be ? ToNumber(_value_).", "          1. If ! IsValidIntegerIndex(_O_, _index_) is *true*, then", "            1. Let _offset_ be _O_.[[ByteOffset]].", "            1. Let _arrayTypeName_ be the String value of _O_.[[TypedArrayName]].", "            1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _arrayTypeName_.", "            1. Let _indexedPosition_ be (ℝ(_index_) × _elementSize_) + _offset_.", "            1. Let _elementType_ be the Element Type value in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _arrayTypeName_.", "            1. Perform SetValueInBuffer(_O_.[[ViewedArrayBuffer]], _indexedPosition_, _elementType_, _numValue_, *true*, ~Unordered~).", "          1. Return NormalCompletion(*undefined*)."],
    "head": {
      "name": "IntegerIndexedElementSet",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "index"
      }, {
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "sec-integerindexedelementset",
    "rawBody": "{\n  2:if (= O[\"ContentType\"] CONST_BigInt) {\n    (0) app __x0__ = (ToBigInt value)\n    let numValue = [? __x0__]\n  } else {\n    (1) app __x1__ = (ToNumber value)\n    let numValue = [? __x1__]\n  }\n  3:(2) app __x2__ = (IsValidIntegerIndex O index)\n  3:if (= [! __x2__] true) {\n    4:let offset = O[\"ByteOffset\"]\n    5:let arrayTypeName = O[\"TypedArrayName\"]\n    6:(0) ??? \"Let id:{elementSize} be the Element Size value specified in link:{table-the-typedarray-constructors} for id:{arrayTypeName} .\"\n    7:let indexedPosition = (+ (* index elementSize) offset)\n    8:let elementType = CONST_Int8\n    9:(3) app __x3__ = (SetValueInBuffer O[\"ViewedArrayBuffer\"] indexedPosition elementType numValue true CONST_Unordered)\n    9:__x3__\n  } else 0:{}\n  10:return undefined\n}"
  }, {
    "code": ["          1. Return ? SetImmutablePrototype(_O_, _V_)."],
    "head": {
      "base": "ModuleNamespaceExoticObject",
      "methodName": "SetPrototypeOf",
      "origParams": [{
        "kind": "Normal",
        "name": "V"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-module-namespace-exotic-objects-setprototypeof-v",
    "rawBody": "{\n  0:(0) app __x0__ = (SetImmutablePrototype O V)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "base": "ModuleNamespaceExoticObject",
      "methodName": "IsExtensible",
      "origParams": [],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-module-namespace-exotic-objects-isextensible",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *true*."],
    "head": {
      "base": "ModuleNamespaceExoticObject",
      "methodName": "PreventExtensions",
      "origParams": [],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-module-namespace-exotic-objects-preventextensions",
    "rawBody": "return true"
  }, {
    "code": ["          1. If Type(_P_) is Symbol, return OrdinaryGetOwnProperty(_O_, _P_).", "          1. Let _exports_ be _O_.[[Exports]].", "          1. If _P_ is not an element of _exports_, return *undefined*.", "          1. Let _value_ be ? _O_.[[Get]](_P_, _O_).", "          1. Return PropertyDescriptor { [[Value]]: _value_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *false* }."],
    "head": {
      "base": "ModuleNamespaceExoticObject",
      "methodName": "GetOwnProperty",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-module-namespace-exotic-objects-getownproperty-p",
    "rawBody": "{\n  0:if (= (typeof P) Symbol) {\n    (0) app __x0__ = (OrdinaryGetOwnProperty O P)\n    return __x0__\n  } else 0:{}\n  1:let exports = O[\"Exports\"]\n  2:if (! (contains exports P)) return undefined else 0:{}\n  3:(1) app __x1__ = (O[\"Get\"] O P O)\n  3:let value = [? __x1__]\n  4:return (0) (new PropertyDescriptor(\"Value\" -> value, \"Writable\" -> true, \"Enumerable\" -> true, \"Configurable\" -> false))\n}"
  }, {
    "code": ["          1. If Type(_P_) is Symbol, return OrdinaryDefineOwnProperty(_O_, _P_, _Desc_).", "          1. Let _current_ be ? _O_.[[GetOwnProperty]](_P_).", "          1. If _current_ is *undefined*, return *false*.", "          1. If _Desc_.[[Configurable]] is present and has value *true*, return *false*.", "          1. If _Desc_.[[Enumerable]] is present and has value *false*, return *false*.", "          1. If ! IsAccessorDescriptor(_Desc_) is *true*, return *false*.", "          1. If _Desc_.[[Writable]] is present and has value *false*, return *false*.", "          1. If _Desc_.[[Value]] is present, return SameValue(_Desc_.[[Value]], _current_.[[Value]]).", "          1. Return *true*."],
    "head": {
      "base": "ModuleNamespaceExoticObject",
      "methodName": "DefineOwnProperty",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Normal",
        "name": "Desc"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-module-namespace-exotic-objects-defineownproperty-p-desc",
    "rawBody": "{\n  0:if (= (typeof P) Symbol) {\n    (0) app __x0__ = (OrdinaryDefineOwnProperty O P Desc)\n    return __x0__\n  } else 0:{}\n  1:(1) app __x1__ = (O[\"GetOwnProperty\"] O P)\n  1:let current = [? __x1__]\n  2:if (= current undefined) return false else 0:{}\n  3:if (= Desc[\"Configurable\"] true) return false else 0:{}\n  4:if (= Desc[\"Enumerable\"] false) return false else 0:{}\n  5:(2) app __x2__ = (IsAccessorDescriptor Desc)\n  5:if (= [! __x2__] true) return false else 0:{}\n  6:if (= Desc[\"Writable\"] false) return false else 0:{}\n  7:if (! (= Desc[\"Value\"] absent)) {\n    (3) app __x3__ = (SameValue Desc[\"Value\"] current[\"Value\"])\n    return __x3__\n  } else 0:{}\n  8:return true\n}"
  }, {
    "code": ["          1. If Type(_P_) is Symbol, return OrdinaryHasProperty(_O_, _P_).", "          1. Let _exports_ be _O_.[[Exports]].", "          1. If _P_ is an element of _exports_, return *true*.", "          1. Return *false*."],
    "head": {
      "base": "ModuleNamespaceExoticObject",
      "methodName": "HasProperty",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-module-namespace-exotic-objects-hasproperty-p",
    "rawBody": "{\n  0:if (= (typeof P) Symbol) {\n    (0) app __x0__ = (OrdinaryHasProperty O P)\n    return __x0__\n  } else 0:{}\n  1:let exports = O[\"Exports\"]\n  2:if (contains exports P) return true else 0:{}\n  3:return false\n}"
  }, {
    "code": ["          1. Assert: IsPropertyKey(_P_) is *true*.", "          1. If Type(_P_) is Symbol, then", "            1. Return ? OrdinaryGet(_O_, _P_, _Receiver_).", "          1. Let _exports_ be _O_.[[Exports]].", "          1. If _P_ is not an element of _exports_, return *undefined*.", "          1. Let _m_ be _O_.[[Module]].", "          1. Let _binding_ be ! _m_.ResolveExport(_P_).", "          1. Assert: _binding_ is a ResolvedBinding Record.", "          1. Let _targetModule_ be _binding_.[[Module]].", "          1. Assert: _targetModule_ is not *undefined*.", "          1. If _binding_.[[BindingName]] is *\"\\*namespace\\*\"*, then", "            1. Return ? GetModuleNamespace(_targetModule_).", "          1. Let _targetEnv_ be _targetModule_.[[Environment]].", "          1. If _targetEnv_ is *undefined*, throw a *ReferenceError* exception.", "          1. Return ? _targetEnv_.GetBindingValue(_binding_.[[BindingName]], *true*)."],
    "head": {
      "base": "ModuleNamespaceExoticObject",
      "methodName": "Get",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Normal",
        "name": "Receiver"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-module-namespace-exotic-objects-get-p-receiver",
    "rawBody": "{\n  0:(0) app __x0__ = (IsPropertyKey P)\n  0:assert (= __x0__ true)\n  1:if (= (typeof P) Symbol) {\n    2:(1) app __x1__ = (OrdinaryGet O P Receiver)\n    2:return [? __x1__]\n  } else 0:{}\n  3:let exports = O[\"Exports\"]\n  4:if (! (contains exports P)) return undefined else 0:{}\n  5:let m = O[\"Module\"]\n  6:(2) app __x2__ = (m[\"ResolveExport\"] m P)\n  6:let binding = [! __x2__]\n  7:assert (0) (is-instance-of binding ResolvedBindingRecord)\n  8:let targetModule = binding[\"Module\"]\n  9:assert (! (= targetModule undefined))\n  10:if (= binding[\"BindingName\"] \"*namespace*\") {\n    11:(3) app __x3__ = (GetModuleNamespace targetModule)\n    11:return [? __x3__]\n  } else 0:{}\n  12:let targetEnv = targetModule[\"Environment\"]\n  13:if (= targetEnv undefined) (1) throw ReferenceError else 0:{}\n  14:(4) app __x4__ = (targetEnv[\"GetBindingValue\"] targetEnv binding[\"BindingName\"] true)\n  14:return [? __x4__]\n}"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "base": "ModuleNamespaceExoticObject",
      "methodName": "Set",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Normal",
        "name": "V"
      }, {
        "kind": "Normal",
        "name": "Receiver"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-module-namespace-exotic-objects-set-p-v-receiver",
    "rawBody": "return false"
  }, {
    "code": ["          1. Assert: IsPropertyKey(_P_) is *true*.", "          1. If Type(_P_) is Symbol, then", "            1. Return ? OrdinaryDelete(_O_, _P_).", "          1. Let _exports_ be _O_.[[Exports]].", "          1. If _P_ is an element of _exports_, return *false*.", "          1. Return *true*."],
    "head": {
      "base": "ModuleNamespaceExoticObject",
      "methodName": "Delete",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-module-namespace-exotic-objects-delete-p",
    "rawBody": "{\n  0:(0) app __x0__ = (IsPropertyKey P)\n  0:assert (= __x0__ true)\n  1:if (= (typeof P) Symbol) {\n    2:(1) app __x1__ = (OrdinaryDelete O P)\n    2:return [? __x1__]\n  } else 0:{}\n  3:let exports = O[\"Exports\"]\n  4:if (contains exports P) return false else 0:{}\n  5:return true\n}"
  }, {
    "code": ["          1. Let _exports_ be a copy of _O_.[[Exports]].", "          1. Let _symbolKeys_ be ! OrdinaryOwnPropertyKeys(_O_).", "          1. Append all the entries of _symbolKeys_ to the end of _exports_.", "          1. Return _exports_."],
    "head": {
      "base": "ModuleNamespaceExoticObject",
      "methodName": "OwnPropertyKeys",
      "origParams": [],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-module-namespace-exotic-objects-ownpropertykeys",
    "rawBody": "{\n  0:let exports = (0) (copy-obj O[\"Exports\"])\n  1:(0) app __x0__ = (OrdinaryOwnPropertyKeys O)\n  1:let symbolKeys = [! __x0__]\n  2:let __x1__ = symbolKeys\n  2:let __x2__ = 0i\n  2:while (< __x2__ __x1__[\"length\"]) {\n    let __x3__ = __x1__[__x2__]\n    append __x3__ -> exports\n    __x2__ = (+ __x2__ 1i)\n  }\n  3:return exports\n}"
  }, {
    "code": ["          1. Assert: _module_ is a Module Record.", "          1. Assert: _module_.[[Namespace]] is *undefined*.", "          1. Assert: _exports_ is a List of String values.", "          1. Let _internalSlotsList_ be the internal slots listed in <emu-xref href=\"#table-internal-slots-of-module-namespace-exotic-objects\"></emu-xref>.", "          1. Let _M_ be ! MakeBasicObject(_internalSlotsList_).", "          1. Set _M_'s essential internal methods to the definitions specified in <emu-xref href=\"#sec-module-namespace-exotic-objects\"></emu-xref>.", "          1. Set _M_.[[Prototype]] to *null*.", "          1. Set _M_.[[Module]] to _module_.", "          1. Let _sortedExports_ be a List whose elements are the elements of _exports_ ordered as if an Array of the same values had been sorted using %Array.prototype.sort% using *undefined* as _comparefn_.", "          1. Set _M_.[[Exports]] to _sortedExports_.", "          1. Create own properties of _M_ corresponding to the definitions in <emu-xref href=\"#sec-module-namespace-objects\"></emu-xref>.", "          1. Set _module_.[[Namespace]] to _M_.", "          1. Return _M_."],
    "head": {
      "name": "ModuleNamespaceCreate",
      "params": [{
        "kind": "Normal",
        "name": "module"
      }, {
        "kind": "Normal",
        "name": "exports"
      }]
    },
    "ids": "sec-modulenamespacecreate",
    "rawBody": "{\n  1:assert (= module[\"Namespace\"] undefined)\n  3:let internalSlotsList = (0) (new [\"Module\", \"Exports\", \"Prototype\"])\n  4:(0) app __x0__ = (MakeBasicObject internalSlotsList)\n  4:let M = [! __x0__]\n  6:M[\"Prototype\"] = null\n  7:M[\"Module\"] = module\n  8:let sortedExports = (1) (copy-obj exports)\n  9:M[\"Exports\"] = sortedExports\n  10:M[\"SubMap\"] = (2) (new SubMap())\n  11:module[\"Namespace\"] = M\n  12:return M\n}"
  }, {
    "code": ["          1. Return ? SetImmutablePrototype(_O_, _V_)."],
    "head": {
      "base": "ImmutablePrototypeExoticObject",
      "methodName": "SetPrototypeOf",
      "origParams": [{
        "kind": "Normal",
        "name": "V"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-immutable-prototype-exotic-objects-setprototypeof-v",
    "rawBody": "{\n  0:(0) app __x0__ = (SetImmutablePrototype O V)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Assert: Either Type(_V_) is Object or Type(_V_) is Null.", "          1. Let _current_ be ? _O_.[[GetPrototypeOf]]().", "          1. If SameValue(_V_, _current_) is *true*, return *true*.", "          1. Return *false*."],
    "head": {
      "name": "SetImmutablePrototype",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "V"
      }]
    },
    "ids": "sec-set-immutable-prototype",
    "rawBody": "{\n  1:(0) app __x0__ = (O[\"GetPrototypeOf\"] O)\n  1:let current = [? __x0__]\n  2:(1) app __x1__ = (SameValue V current)\n  2:if (= __x1__ true) return true else 0:{}\n  3:return false\n}"
  }, {
    "code": ["        1. Let _handler_ be _O_.[[ProxyHandler]].", "        1. If _handler_ is *null*, throw a *TypeError* exception.", "        1. Assert: Type(_handler_) is Object.", "        1. Let _target_ be _O_.[[ProxyTarget]].", "        1. Let _trap_ be ? GetMethod(_handler_, *\"getPrototypeOf\"*).", "        1. If _trap_ is *undefined*, then", "          1. Return ? _target_.[[GetPrototypeOf]]().", "        1. Let _handlerProto_ be ? Call(_trap_, _handler_, « _target_ »).", "        1. If Type(_handlerProto_) is neither Object nor Null, throw a *TypeError* exception.", "        1. Let _extensibleTarget_ be ? IsExtensible(_target_).", "        1. If _extensibleTarget_ is *true*, return _handlerProto_.", "        1. Let _targetProto_ be ? _target_.[[GetPrototypeOf]]().", "        1. If SameValue(_handlerProto_, _targetProto_) is *false*, throw a *TypeError* exception.", "        1. Return _handlerProto_."],
    "head": {
      "base": "ProxyObject",
      "methodName": "GetPrototypeOf",
      "origParams": [],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-proxy-object-internal-methods-and-internal-slots-getprototypeof",
    "rawBody": "{\n  0:let handler = O[\"ProxyHandler\"]\n  1:if (= handler null) (0) throw TypeError else 0:{}\n  2:assert (= (typeof handler) Object)\n  3:let target = O[\"ProxyTarget\"]\n  4:(0) app __x0__ = (GetMethod handler \"getPrototypeOf\")\n  4:let trap = [? __x0__]\n  5:if (= trap undefined) {\n    6:(1) app __x1__ = (target[\"GetPrototypeOf\"] target)\n    6:return [? __x1__]\n  } else 0:{}\n  7:(2) app __x2__ = (Call trap handler (1) (new [target]))\n  7:let handlerProto = [? __x2__]\n  8:if (! (|| (= (typeof handlerProto) Object) (= (typeof handlerProto) Null))) (2) throw TypeError else 0:{}\n  9:(3) app __x3__ = (IsExtensible target)\n  9:let extensibleTarget = [? __x3__]\n  10:if (= extensibleTarget true) return handlerProto else 0:{}\n  11:(4) app __x4__ = (target[\"GetPrototypeOf\"] target)\n  11:let targetProto = [? __x4__]\n  12:(5) app __x5__ = (SameValue handlerProto targetProto)\n  12:if (= __x5__ false) (3) throw TypeError else 0:{}\n  13:return handlerProto\n}"
  }, {
    "code": ["        1. Assert: Either Type(_V_) is Object or Type(_V_) is Null.", "        1. Let _handler_ be _O_.[[ProxyHandler]].", "        1. If _handler_ is *null*, throw a *TypeError* exception.", "        1. Assert: Type(_handler_) is Object.", "        1. Let _target_ be _O_.[[ProxyTarget]].", "        1. Let _trap_ be ? GetMethod(_handler_, *\"setPrototypeOf\"*).", "        1. If _trap_ is *undefined*, then", "          1. Return ? _target_.[[SetPrototypeOf]](_V_).", "        1. Let _booleanTrapResult_ be ! ToBoolean(? Call(_trap_, _handler_, « _target_, _V_ »)).", "        1. If _booleanTrapResult_ is *false*, return *false*.", "        1. Let _extensibleTarget_ be ? IsExtensible(_target_).", "        1. If _extensibleTarget_ is *true*, return *true*.", "        1. Let _targetProto_ be ? _target_.[[GetPrototypeOf]]().", "        1. If SameValue(_V_, _targetProto_) is *false*, throw a *TypeError* exception.", "        1. Return *true*."],
    "head": {
      "base": "ProxyObject",
      "methodName": "SetPrototypeOf",
      "origParams": [{
        "kind": "Normal",
        "name": "V"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-proxy-object-internal-methods-and-internal-slots-setprototypeof-v",
    "rawBody": "{\n  1:let handler = O[\"ProxyHandler\"]\n  2:if (= handler null) (0) throw TypeError else 0:{}\n  3:assert (= (typeof handler) Object)\n  4:let target = O[\"ProxyTarget\"]\n  5:(0) app __x0__ = (GetMethod handler \"setPrototypeOf\")\n  5:let trap = [? __x0__]\n  6:if (= trap undefined) {\n    7:(1) app __x1__ = (target[\"SetPrototypeOf\"] target V)\n    7:return [? __x1__]\n  } else 0:{}\n  8:(2) app __x2__ = (Call trap handler (1) (new [target, V]))\n  8:(3) app __x3__ = (ToBoolean [? __x2__])\n  8:let booleanTrapResult = [! __x3__]\n  9:if (= booleanTrapResult false) return false else 0:{}\n  10:(4) app __x4__ = (IsExtensible target)\n  10:let extensibleTarget = [? __x4__]\n  11:if (= extensibleTarget true) return true else 0:{}\n  12:(5) app __x5__ = (target[\"GetPrototypeOf\"] target)\n  12:let targetProto = [? __x5__]\n  13:(6) app __x6__ = (SameValue V targetProto)\n  13:if (= __x6__ false) (2) throw TypeError else 0:{}\n  14:return true\n}"
  }, {
    "code": ["        1. Let _handler_ be _O_.[[ProxyHandler]].", "        1. If _handler_ is *null*, throw a *TypeError* exception.", "        1. Assert: Type(_handler_) is Object.", "        1. Let _target_ be _O_.[[ProxyTarget]].", "        1. Let _trap_ be ? GetMethod(_handler_, *\"isExtensible\"*).", "        1. If _trap_ is *undefined*, then", "          1. Return ? IsExtensible(_target_).", "        1. Let _booleanTrapResult_ be ! ToBoolean(? Call(_trap_, _handler_, « _target_ »)).", "        1. Let _targetResult_ be ? IsExtensible(_target_).", "        1. If SameValue(_booleanTrapResult_, _targetResult_) is *false*, throw a *TypeError* exception.", "        1. Return _booleanTrapResult_."],
    "head": {
      "base": "ProxyObject",
      "methodName": "IsExtensible",
      "origParams": [],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-proxy-object-internal-methods-and-internal-slots-isextensible",
    "rawBody": "{\n  0:let handler = O[\"ProxyHandler\"]\n  1:if (= handler null) (0) throw TypeError else 0:{}\n  2:assert (= (typeof handler) Object)\n  3:let target = O[\"ProxyTarget\"]\n  4:(0) app __x0__ = (GetMethod handler \"isExtensible\")\n  4:let trap = [? __x0__]\n  5:if (= trap undefined) {\n    6:(1) app __x1__ = (IsExtensible target)\n    6:return [? __x1__]\n  } else 0:{}\n  7:(2) app __x2__ = (Call trap handler (1) (new [target]))\n  7:(3) app __x3__ = (ToBoolean [? __x2__])\n  7:let booleanTrapResult = [! __x3__]\n  8:(4) app __x4__ = (IsExtensible target)\n  8:let targetResult = [? __x4__]\n  9:(5) app __x5__ = (SameValue booleanTrapResult targetResult)\n  9:if (= __x5__ false) (2) throw TypeError else 0:{}\n  10:return booleanTrapResult\n}"
  }, {
    "code": ["        1. Let _handler_ be _O_.[[ProxyHandler]].", "        1. If _handler_ is *null*, throw a *TypeError* exception.", "        1. Assert: Type(_handler_) is Object.", "        1. Let _target_ be _O_.[[ProxyTarget]].", "        1. Let _trap_ be ? GetMethod(_handler_, *\"preventExtensions\"*).", "        1. If _trap_ is *undefined*, then", "          1. Return ? _target_.[[PreventExtensions]]().", "        1. Let _booleanTrapResult_ be ! ToBoolean(? Call(_trap_, _handler_, « _target_ »)).", "        1. If _booleanTrapResult_ is *true*, then", "          1. Let _extensibleTarget_ be ? IsExtensible(_target_).", "          1. If _extensibleTarget_ is *true*, throw a *TypeError* exception.", "        1. Return _booleanTrapResult_."],
    "head": {
      "base": "ProxyObject",
      "methodName": "PreventExtensions",
      "origParams": [],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-proxy-object-internal-methods-and-internal-slots-preventextensions",
    "rawBody": "{\n  0:let handler = O[\"ProxyHandler\"]\n  1:if (= handler null) (0) throw TypeError else 0:{}\n  2:assert (= (typeof handler) Object)\n  3:let target = O[\"ProxyTarget\"]\n  4:(0) app __x0__ = (GetMethod handler \"preventExtensions\")\n  4:let trap = [? __x0__]\n  5:if (= trap undefined) {\n    6:(1) app __x1__ = (target[\"PreventExtensions\"] target)\n    6:return [? __x1__]\n  } else 0:{}\n  7:(2) app __x2__ = (Call trap handler (1) (new [target]))\n  7:(3) app __x3__ = (ToBoolean [? __x2__])\n  7:let booleanTrapResult = [! __x3__]\n  8:if (= booleanTrapResult true) {\n    9:(4) app __x4__ = (IsExtensible target)\n    9:let extensibleTarget = [? __x4__]\n    10:if (= extensibleTarget true) (2) throw TypeError else 0:{}\n  } else 0:{}\n  11:return booleanTrapResult\n}"
  }, {
    "code": ["        1. Assert: IsPropertyKey(_P_) is *true*.", "        1. Let _handler_ be _O_.[[ProxyHandler]].", "        1. If _handler_ is *null*, throw a *TypeError* exception.", "        1. Assert: Type(_handler_) is Object.", "        1. Let _target_ be _O_.[[ProxyTarget]].", "        1. Let _trap_ be ? GetMethod(_handler_, *\"getOwnPropertyDescriptor\"*).", "        1. If _trap_ is *undefined*, then", "          1. Return ? _target_.[[GetOwnProperty]](_P_).", "        1. Let _trapResultObj_ be ? Call(_trap_, _handler_, « _target_, _P_ »).", "        1. If Type(_trapResultObj_) is neither Object nor Undefined, throw a *TypeError* exception.", "        1. Let _targetDesc_ be ? _target_.[[GetOwnProperty]](_P_).", "        1. If _trapResultObj_ is *undefined*, then", "          1. If _targetDesc_ is *undefined*, return *undefined*.", "          1. If _targetDesc_.[[Configurable]] is *false*, throw a *TypeError* exception.", "          1. Let _extensibleTarget_ be ? IsExtensible(_target_).", "          1. If _extensibleTarget_ is *false*, throw a *TypeError* exception.", "          1. Return *undefined*.", "        1. Let _extensibleTarget_ be ? IsExtensible(_target_).", "        1. Let _resultDesc_ be ? ToPropertyDescriptor(_trapResultObj_).", "        1. Call CompletePropertyDescriptor(_resultDesc_).", "        1. Let _valid_ be IsCompatiblePropertyDescriptor(_extensibleTarget_, _resultDesc_, _targetDesc_).", "        1. If _valid_ is *false*, throw a *TypeError* exception.", "        1. If _resultDesc_.[[Configurable]] is *false*, then", "          1. If _targetDesc_ is *undefined* or _targetDesc_.[[Configurable]] is *true*, then", "            1. Throw a *TypeError* exception.", "          1. If _resultDesc_ has a [[Writable]] field and _resultDesc_.[[Writable]] is *false*, then", "            1. If _targetDesc_.[[Writable]] is *true*, throw a *TypeError* exception.", "        1. Return _resultDesc_."],
    "head": {
      "base": "ProxyObject",
      "methodName": "GetOwnProperty",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-proxy-object-internal-methods-and-internal-slots-getownproperty-p",
    "rawBody": "{\n  0:(0) app __x0__ = (IsPropertyKey P)\n  0:assert (= __x0__ true)\n  1:let handler = O[\"ProxyHandler\"]\n  2:if (= handler null) (0) throw TypeError else 0:{}\n  3:assert (= (typeof handler) Object)\n  4:let target = O[\"ProxyTarget\"]\n  5:(1) app __x1__ = (GetMethod handler \"getOwnPropertyDescriptor\")\n  5:let trap = [? __x1__]\n  6:if (= trap undefined) {\n    7:(2) app __x2__ = (target[\"GetOwnProperty\"] target P)\n    7:return [? __x2__]\n  } else 0:{}\n  8:(3) app __x3__ = (Call trap handler (1) (new [target, P]))\n  8:let trapResultObj = [? __x3__]\n  9:if (! (|| (= (typeof trapResultObj) Object) (= (typeof trapResultObj) Undefined))) (2) throw TypeError else 0:{}\n  10:(4) app __x4__ = (target[\"GetOwnProperty\"] target P)\n  10:let targetDesc = [? __x4__]\n  11:if (= trapResultObj undefined) {\n    12:if (= targetDesc undefined) return undefined else 0:{}\n    13:if (= targetDesc[\"Configurable\"] false) (3) throw TypeError else 0:{}\n    14:(5) app __x5__ = (IsExtensible target)\n    14:let extensibleTarget = [? __x5__]\n    15:if (= extensibleTarget false) (4) throw TypeError else 0:{}\n    16:return undefined\n  } else 0:{}\n  17:(6) app __x6__ = (IsExtensible target)\n  17:let extensibleTarget = [? __x6__]\n  18:(7) app __x7__ = (ToPropertyDescriptor trapResultObj)\n  18:let resultDesc = [? __x7__]\n  19:(8) app __x8__ = (CompletePropertyDescriptor resultDesc)\n  19:__x8__\n  20:(9) app __x9__ = (IsCompatiblePropertyDescriptor extensibleTarget resultDesc targetDesc)\n  20:let valid = __x9__\n  21:if (= valid false) (5) throw TypeError else 0:{}\n  22:if (= resultDesc[\"Configurable\"] false) {\n    23:if (|| (= targetDesc undefined) (= targetDesc[\"Configurable\"] true)) (6) throw TypeError else 0:{}\n    25:if (&& (! (= resultDesc[\"Writable\"] absent)) (= resultDesc[\"Writable\"] false)) if (= targetDesc[\"Writable\"] true) (7) throw TypeError else 0:{} else 0:{}\n  } else 0:{}\n  27:return resultDesc\n}"
  }, {
    "code": ["        1. Assert: IsPropertyKey(_P_) is *true*.", "        1. Let _handler_ be _O_.[[ProxyHandler]].", "        1. If _handler_ is *null*, throw a *TypeError* exception.", "        1. Assert: Type(_handler_) is Object.", "        1. Let _target_ be _O_.[[ProxyTarget]].", "        1. Let _trap_ be ? GetMethod(_handler_, *\"defineProperty\"*).", "        1. If _trap_ is *undefined*, then", "          1. Return ? _target_.[[DefineOwnProperty]](_P_, _Desc_).", "        1. Let _descObj_ be FromPropertyDescriptor(_Desc_).", "        1. Let _booleanTrapResult_ be ! ToBoolean(? Call(_trap_, _handler_, « _target_, _P_, _descObj_ »)).", "        1. If _booleanTrapResult_ is *false*, return *false*.", "        1. Let _targetDesc_ be ? _target_.[[GetOwnProperty]](_P_).", "        1. Let _extensibleTarget_ be ? IsExtensible(_target_).", "        1. If _Desc_ has a [[Configurable]] field and if _Desc_.[[Configurable]] is *false*, then", "          1. Let _settingConfigFalse_ be *true*.", "        1. Else, let _settingConfigFalse_ be *false*.", "        1. If _targetDesc_ is *undefined*, then", "          1. If _extensibleTarget_ is *false*, throw a *TypeError* exception.", "          1. If _settingConfigFalse_ is *true*, throw a *TypeError* exception.", "        1. Else,", "          1. If IsCompatiblePropertyDescriptor(_extensibleTarget_, _Desc_, _targetDesc_) is *false*, throw a *TypeError* exception.", "          1. If _settingConfigFalse_ is *true* and _targetDesc_.[[Configurable]] is *true*, throw a *TypeError* exception.", "          1. If IsDataDescriptor(_targetDesc_) is *true*, _targetDesc_.[[Configurable]] is *false*, and _targetDesc_.[[Writable]] is *true*, then", "            1. If _Desc_ has a [[Writable]] field and _Desc_.[[Writable]] is *false*, throw a *TypeError* exception.", "        1. Return *true*."],
    "head": {
      "base": "ProxyObject",
      "methodName": "DefineOwnProperty",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Normal",
        "name": "Desc"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-proxy-object-internal-methods-and-internal-slots-defineownproperty-p-desc",
    "rawBody": "{\n  0:(0) app __x0__ = (IsPropertyKey P)\n  0:assert (= __x0__ true)\n  1:let handler = O[\"ProxyHandler\"]\n  2:if (= handler null) (0) throw TypeError else 0:{}\n  3:assert (= (typeof handler) Object)\n  4:let target = O[\"ProxyTarget\"]\n  5:(1) app __x1__ = (GetMethod handler \"defineProperty\")\n  5:let trap = [? __x1__]\n  6:if (= trap undefined) {\n    7:(2) app __x2__ = (target[\"DefineOwnProperty\"] target P Desc)\n    7:return [? __x2__]\n  } else 0:{}\n  8:(3) app __x3__ = (FromPropertyDescriptor Desc)\n  8:let descObj = __x3__\n  9:(4) app __x4__ = (Call trap handler (1) (new [target, P, descObj]))\n  9:(5) app __x5__ = (ToBoolean [? __x4__])\n  9:let booleanTrapResult = [! __x5__]\n  10:if (= booleanTrapResult false) return false else 0:{}\n  11:(6) app __x6__ = (target[\"GetOwnProperty\"] target P)\n  11:let targetDesc = [? __x6__]\n  12:(7) app __x7__ = (IsExtensible target)\n  12:let extensibleTarget = [? __x7__]\n  15:if (&& (! (= Desc[\"Configurable\"] absent)) (= Desc[\"Configurable\"] false)) let settingConfigFalse = true else let settingConfigFalse = false\n  19:if (= targetDesc undefined) {\n    17:if (= extensibleTarget false) (2) throw TypeError else 0:{}\n    18:if (= settingConfigFalse true) (3) throw TypeError else 0:{}\n  } else {\n    20:(8) app __x8__ = (IsCompatiblePropertyDescriptor extensibleTarget Desc targetDesc)\n    20:if (= __x8__ false) (4) throw TypeError else 0:{}\n    21:if (&& (= settingConfigFalse true) (= targetDesc[\"Configurable\"] true)) (5) throw TypeError else 0:{}\n    22:(9) app __x9__ = (IsDataDescriptor targetDesc)\n    22:if (&& (&& (= __x9__ true) (= targetDesc[\"Configurable\"] false)) (= targetDesc[\"Writable\"] true)) if (&& (! (= Desc[\"Writable\"] absent)) (= Desc[\"Writable\"] false)) (6) throw TypeError else 0:{} else 0:{}\n  }\n  24:return true\n}"
  }, {
    "code": ["        1. Assert: IsPropertyKey(_P_) is *true*.", "        1. Let _handler_ be _O_.[[ProxyHandler]].", "        1. If _handler_ is *null*, throw a *TypeError* exception.", "        1. Assert: Type(_handler_) is Object.", "        1. Let _target_ be _O_.[[ProxyTarget]].", "        1. Let _trap_ be ? GetMethod(_handler_, *\"has\"*).", "        1. If _trap_ is *undefined*, then", "          1. Return ? _target_.[[HasProperty]](_P_).", "        1. Let _booleanTrapResult_ be ! ToBoolean(? Call(_trap_, _handler_, « _target_, _P_ »)).", "        1. If _booleanTrapResult_ is *false*, then", "          1. Let _targetDesc_ be ? _target_.[[GetOwnProperty]](_P_).", "          1. If _targetDesc_ is not *undefined*, then", "            1. If _targetDesc_.[[Configurable]] is *false*, throw a *TypeError* exception.", "            1. Let _extensibleTarget_ be ? IsExtensible(_target_).", "            1. If _extensibleTarget_ is *false*, throw a *TypeError* exception.", "        1. Return _booleanTrapResult_."],
    "head": {
      "base": "ProxyObject",
      "methodName": "HasProperty",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-proxy-object-internal-methods-and-internal-slots-hasproperty-p",
    "rawBody": "{\n  0:(0) app __x0__ = (IsPropertyKey P)\n  0:assert (= __x0__ true)\n  1:let handler = O[\"ProxyHandler\"]\n  2:if (= handler null) (0) throw TypeError else 0:{}\n  3:assert (= (typeof handler) Object)\n  4:let target = O[\"ProxyTarget\"]\n  5:(1) app __x1__ = (GetMethod handler \"has\")\n  5:let trap = [? __x1__]\n  6:if (= trap undefined) {\n    7:(2) app __x2__ = (target[\"HasProperty\"] target P)\n    7:return [? __x2__]\n  } else 0:{}\n  8:(3) app __x3__ = (Call trap handler (1) (new [target, P]))\n  8:(4) app __x4__ = (ToBoolean [? __x3__])\n  8:let booleanTrapResult = [! __x4__]\n  9:if (= booleanTrapResult false) {\n    10:(5) app __x5__ = (target[\"GetOwnProperty\"] target P)\n    10:let targetDesc = [? __x5__]\n    11:if (! (= targetDesc undefined)) {\n      12:if (= targetDesc[\"Configurable\"] false) (2) throw TypeError else 0:{}\n      13:(6) app __x6__ = (IsExtensible target)\n      13:let extensibleTarget = [? __x6__]\n      14:if (= extensibleTarget false) (3) throw TypeError else 0:{}\n    } else 0:{}\n  } else 0:{}\n  15:return booleanTrapResult\n}"
  }, {
    "code": ["        1. Assert: IsPropertyKey(_P_) is *true*.", "        1. Let _handler_ be _O_.[[ProxyHandler]].", "        1. If _handler_ is *null*, throw a *TypeError* exception.", "        1. Assert: Type(_handler_) is Object.", "        1. Let _target_ be _O_.[[ProxyTarget]].", "        1. Let _trap_ be ? GetMethod(_handler_, *\"get\"*).", "        1. If _trap_ is *undefined*, then", "          1. Return ? _target_.[[Get]](_P_, _Receiver_).", "        1. Let _trapResult_ be ? Call(_trap_, _handler_, « _target_, _P_, _Receiver_ »).", "        1. Let _targetDesc_ be ? _target_.[[GetOwnProperty]](_P_).", "        1. If _targetDesc_ is not *undefined* and _targetDesc_.[[Configurable]] is *false*, then", "          1. If IsDataDescriptor(_targetDesc_) is *true* and _targetDesc_.[[Writable]] is *false*, then", "            1. If SameValue(_trapResult_, _targetDesc_.[[Value]]) is *false*, throw a *TypeError* exception.", "          1. If IsAccessorDescriptor(_targetDesc_) is *true* and _targetDesc_.[[Get]] is *undefined*, then", "            1. If _trapResult_ is not *undefined*, throw a *TypeError* exception.", "        1. Return _trapResult_."],
    "head": {
      "base": "ProxyObject",
      "methodName": "Get",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Normal",
        "name": "Receiver"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-proxy-object-internal-methods-and-internal-slots-get-p-receiver",
    "rawBody": "{\n  0:(0) app __x0__ = (IsPropertyKey P)\n  0:assert (= __x0__ true)\n  1:let handler = O[\"ProxyHandler\"]\n  2:if (= handler null) (0) throw TypeError else 0:{}\n  3:assert (= (typeof handler) Object)\n  4:let target = O[\"ProxyTarget\"]\n  5:(1) app __x1__ = (GetMethod handler \"get\")\n  5:let trap = [? __x1__]\n  6:if (= trap undefined) {\n    7:(2) app __x2__ = (target[\"Get\"] target P Receiver)\n    7:return [? __x2__]\n  } else 0:{}\n  8:(3) app __x3__ = (Call trap handler (1) (new [target, P, Receiver]))\n  8:let trapResult = [? __x3__]\n  9:(4) app __x4__ = (target[\"GetOwnProperty\"] target P)\n  9:let targetDesc = [? __x4__]\n  10:if (&& (! (= targetDesc undefined)) (= targetDesc[\"Configurable\"] false)) {\n    11:(5) app __x5__ = (IsDataDescriptor targetDesc)\n    11:if (&& (= __x5__ true) (= targetDesc[\"Writable\"] false)) {\n      12:(6) app __x6__ = (SameValue trapResult targetDesc[\"Value\"])\n      12:if (= __x6__ false) (2) throw TypeError else 0:{}\n    } else 0:{}\n    13:(7) app __x7__ = (IsAccessorDescriptor targetDesc)\n    13:if (&& (= __x7__ true) (= targetDesc[\"Get\"] undefined)) if (! (= trapResult undefined)) (3) throw TypeError else 0:{} else 0:{}\n  } else 0:{}\n  15:return trapResult\n}"
  }, {
    "code": ["        1. Assert: IsPropertyKey(_P_) is *true*.", "        1. Let _handler_ be _O_.[[ProxyHandler]].", "        1. If _handler_ is *null*, throw a *TypeError* exception.", "        1. Assert: Type(_handler_) is Object.", "        1. Let _target_ be _O_.[[ProxyTarget]].", "        1. Let _trap_ be ? GetMethod(_handler_, *\"set\"*).", "        1. If _trap_ is *undefined*, then", "          1. Return ? _target_.[[Set]](_P_, _V_, _Receiver_).", "        1. Let _booleanTrapResult_ be ! ToBoolean(? Call(_trap_, _handler_, « _target_, _P_, _V_, _Receiver_ »)).", "        1. If _booleanTrapResult_ is *false*, return *false*.", "        1. Let _targetDesc_ be ? _target_.[[GetOwnProperty]](_P_).", "        1. If _targetDesc_ is not *undefined* and _targetDesc_.[[Configurable]] is *false*, then", "          1. If IsDataDescriptor(_targetDesc_) is *true* and _targetDesc_.[[Writable]] is *false*, then", "            1. If SameValue(_V_, _targetDesc_.[[Value]]) is *false*, throw a *TypeError* exception.", "          1. If IsAccessorDescriptor(_targetDesc_) is *true*, then", "            1. If _targetDesc_.[[Set]] is *undefined*, throw a *TypeError* exception.", "        1. Return *true*."],
    "head": {
      "base": "ProxyObject",
      "methodName": "Set",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Normal",
        "name": "V"
      }, {
        "kind": "Normal",
        "name": "Receiver"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-proxy-object-internal-methods-and-internal-slots-set-p-v-receiver",
    "rawBody": "{\n  0:(0) app __x0__ = (IsPropertyKey P)\n  0:assert (= __x0__ true)\n  1:let handler = O[\"ProxyHandler\"]\n  2:if (= handler null) (0) throw TypeError else 0:{}\n  3:assert (= (typeof handler) Object)\n  4:let target = O[\"ProxyTarget\"]\n  5:(1) app __x1__ = (GetMethod handler \"set\")\n  5:let trap = [? __x1__]\n  6:if (= trap undefined) {\n    7:(2) app __x2__ = (target[\"Set\"] target P V Receiver)\n    7:return [? __x2__]\n  } else 0:{}\n  8:(3) app __x3__ = (Call trap handler (1) (new [target, P, V, Receiver]))\n  8:(4) app __x4__ = (ToBoolean [? __x3__])\n  8:let booleanTrapResult = [! __x4__]\n  9:if (= booleanTrapResult false) return false else 0:{}\n  10:(5) app __x5__ = (target[\"GetOwnProperty\"] target P)\n  10:let targetDesc = [? __x5__]\n  11:if (&& (! (= targetDesc undefined)) (= targetDesc[\"Configurable\"] false)) {\n    12:(6) app __x6__ = (IsDataDescriptor targetDesc)\n    12:if (&& (= __x6__ true) (= targetDesc[\"Writable\"] false)) {\n      13:(7) app __x7__ = (SameValue V targetDesc[\"Value\"])\n      13:if (= __x7__ false) (2) throw TypeError else 0:{}\n    } else 0:{}\n    14:(8) app __x8__ = (IsAccessorDescriptor targetDesc)\n    14:if (= __x8__ true) if (= targetDesc[\"Set\"] undefined) (3) throw TypeError else 0:{} else 0:{}\n  } else 0:{}\n  16:return true\n}"
  }, {
    "code": ["        1. Assert: IsPropertyKey(_P_) is *true*.", "        1. Let _handler_ be _O_.[[ProxyHandler]].", "        1. If _handler_ is *null*, throw a *TypeError* exception.", "        1. Assert: Type(_handler_) is Object.", "        1. Let _target_ be _O_.[[ProxyTarget]].", "        1. Let _trap_ be ? GetMethod(_handler_, *\"deleteProperty\"*).", "        1. If _trap_ is *undefined*, then", "          1. Return ? _target_.[[Delete]](_P_).", "        1. Let _booleanTrapResult_ be ! ToBoolean(? Call(_trap_, _handler_, « _target_, _P_ »)).", "        1. If _booleanTrapResult_ is *false*, return *false*.", "        1. Let _targetDesc_ be ? _target_.[[GetOwnProperty]](_P_).", "        1. If _targetDesc_ is *undefined*, return *true*.", "        1. If _targetDesc_.[[Configurable]] is *false*, throw a *TypeError* exception.", "        1. Let _extensibleTarget_ be ? IsExtensible(_target_).", "        1. If _extensibleTarget_ is *false*, throw a *TypeError* exception.", "        1. Return *true*."],
    "head": {
      "base": "ProxyObject",
      "methodName": "Delete",
      "origParams": [{
        "kind": "Normal",
        "name": "P"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-proxy-object-internal-methods-and-internal-slots-delete-p",
    "rawBody": "{\n  0:(0) app __x0__ = (IsPropertyKey P)\n  0:assert (= __x0__ true)\n  1:let handler = O[\"ProxyHandler\"]\n  2:if (= handler null) (0) throw TypeError else 0:{}\n  3:assert (= (typeof handler) Object)\n  4:let target = O[\"ProxyTarget\"]\n  5:(1) app __x1__ = (GetMethod handler \"deleteProperty\")\n  5:let trap = [? __x1__]\n  6:if (= trap undefined) {\n    7:(2) app __x2__ = (target[\"Delete\"] target P)\n    7:return [? __x2__]\n  } else 0:{}\n  8:(3) app __x3__ = (Call trap handler (1) (new [target, P]))\n  8:(4) app __x4__ = (ToBoolean [? __x3__])\n  8:let booleanTrapResult = [! __x4__]\n  9:if (= booleanTrapResult false) return false else 0:{}\n  10:(5) app __x5__ = (target[\"GetOwnProperty\"] target P)\n  10:let targetDesc = [? __x5__]\n  11:if (= targetDesc undefined) return true else 0:{}\n  12:if (= targetDesc[\"Configurable\"] false) (2) throw TypeError else 0:{}\n  13:(6) app __x6__ = (IsExtensible target)\n  13:let extensibleTarget = [? __x6__]\n  14:if (= extensibleTarget false) (3) throw TypeError else 0:{}\n  15:return true\n}"
  }, {
    "code": ["        1. Let _handler_ be _O_.[[ProxyHandler]].", "        1. If _handler_ is *null*, throw a *TypeError* exception.", "        1. Assert: Type(_handler_) is Object.", "        1. Let _target_ be _O_.[[ProxyTarget]].", "        1. Let _trap_ be ? GetMethod(_handler_, *\"ownKeys\"*).", "        1. If _trap_ is *undefined*, then", "          1. Return ? _target_.[[OwnPropertyKeys]]().", "        1. Let _trapResultArray_ be ? Call(_trap_, _handler_, « _target_ »).", "        1. Let _trapResult_ be ? CreateListFromArrayLike(_trapResultArray_, « String, Symbol »).", "        1. If _trapResult_ contains any duplicate entries, throw a *TypeError* exception.", "        1. Let _extensibleTarget_ be ? IsExtensible(_target_).", "        1. Let _targetKeys_ be ? _target_.[[OwnPropertyKeys]]().", "        1. Assert: _targetKeys_ is a List whose elements are only String and Symbol values.", "        1. Assert: _targetKeys_ contains no duplicate entries.", "        1. Let _targetConfigurableKeys_ be a new empty List.", "        1. Let _targetNonconfigurableKeys_ be a new empty List.", "        1. For each element _key_ of _targetKeys_, do", "          1. Let _desc_ be ? _target_.[[GetOwnProperty]](_key_).", "          1. If _desc_ is not *undefined* and _desc_.[[Configurable]] is *false*, then", "            1. Append _key_ as an element of _targetNonconfigurableKeys_.", "          1. Else,", "            1. Append _key_ as an element of _targetConfigurableKeys_.", "        1. If _extensibleTarget_ is *true* and _targetNonconfigurableKeys_ is empty, then", "          1. Return _trapResult_.", "        1. Let _uncheckedResultKeys_ be a List whose elements are the elements of _trapResult_.", "        1. For each element _key_ of _targetNonconfigurableKeys_, do", "          1. If _key_ is not an element of _uncheckedResultKeys_, throw a *TypeError* exception.", "          1. Remove _key_ from _uncheckedResultKeys_.", "        1. If _extensibleTarget_ is *true*, return _trapResult_.", "        1. For each element _key_ of _targetConfigurableKeys_, do", "          1. If _key_ is not an element of _uncheckedResultKeys_, throw a *TypeError* exception.", "          1. Remove _key_ from _uncheckedResultKeys_.", "        1. If _uncheckedResultKeys_ is not empty, throw a *TypeError* exception.", "        1. Return _trapResult_."],
    "head": {
      "base": "ProxyObject",
      "methodName": "OwnPropertyKeys",
      "origParams": [],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-proxy-object-internal-methods-and-internal-slots-ownpropertykeys",
    "rawBody": "{\n  0:let handler = O[\"ProxyHandler\"]\n  1:if (= handler null) (0) throw TypeError else 13:{}\n  2:assert (= (typeof handler) Object)\n  3:let target = O[\"ProxyTarget\"]\n  4:(0) app __x0__ = (GetMethod handler \"ownKeys\")\n  4:let trap = [? __x0__]\n  5:if (= trap undefined) {\n    6:(1) app __x1__ = (target[\"OwnPropertyKeys\"] target)\n    6:return [? __x1__]\n  } else 13:{}\n  7:(2) app __x2__ = (Call trap handler (1) (new [target]))\n  7:let trapResultArray = [? __x2__]\n  8:(3) app __x3__ = (CreateListFromArrayLike trapResultArray (2) (new [String, Symbol]))\n  8:let trapResult = [? __x3__]\n  9:(4) app __x4__ = (IsDuplicate trapResult)\n  9:if __x4__ (3) throw TypeError else 13:{}\n  10:(5) app __x5__ = (IsExtensible target)\n  10:let extensibleTarget = [? __x5__]\n  11:(6) app __x6__ = (target[\"OwnPropertyKeys\"] target)\n  11:let targetKeys = [? __x6__]\n  14:let targetConfigurableKeys = (4) (new [])\n  15:let targetNonconfigurableKeys = (5) (new [])\n  16:let __x7__ = targetKeys\n  16:let __x8__ = 0i\n  16:while (< __x8__ __x7__[\"length\"]) {\n    let key = __x7__[__x8__]\n    17:(7) app __x9__ = (target[\"GetOwnProperty\"] target key)\n    17:let desc = [? __x9__]\n    20:if (&& (! (= desc undefined)) (= desc[\"Configurable\"] false)) append key -> targetNonconfigurableKeys else append key -> targetConfigurableKeys\n    __x8__ = (+ __x8__ 1i)\n  }\n  22:if (&& (= extensibleTarget true) (= targetNonconfigurableKeys[\"length\"] 0i)) return trapResult else 13:{}\n  24:let uncheckedResultKeys = (6) (copy-obj trapResult)\n  25:let __x10__ = targetNonconfigurableKeys\n  25:let __x11__ = 0i\n  25:while (< __x11__ __x10__[\"length\"]) {\n    let key = __x10__[__x11__]\n    26:if (! (contains uncheckedResultKeys key)) (7) throw TypeError else 13:{}\n    27:let __x12__ = 0i\n    27:while (< __x12__ uncheckedResultKeys[\"length\"]) if (= uncheckedResultKeys[__x12__] key) (pop uncheckedResultKeys __x12__) else __x12__ = (+ __x12__ 1i)\n    __x11__ = (+ __x11__ 1i)\n  }\n  28:if (= extensibleTarget true) return trapResult else 13:{}\n  29:let __x13__ = targetConfigurableKeys\n  29:let __x14__ = 0i\n  29:while (< __x14__ __x13__[\"length\"]) {\n    let key = __x13__[__x14__]\n    30:if (! (contains uncheckedResultKeys key)) (8) throw TypeError else 13:{}\n    31:let __x15__ = 0i\n    31:while (< __x15__ uncheckedResultKeys[\"length\"]) if (= uncheckedResultKeys[__x15__] key) (pop uncheckedResultKeys __x15__) else __x15__ = (+ __x15__ 1i)\n    __x14__ = (+ __x14__ 1i)\n  }\n  32:if (< 0i uncheckedResultKeys[\"length\"]) (9) throw TypeError else 13:{}\n  33:return trapResult\n}"
  }, {
    "code": ["        1. Let _handler_ be _O_.[[ProxyHandler]].", "        1. If _handler_ is *null*, throw a *TypeError* exception.", "        1. Assert: Type(_handler_) is Object.", "        1. Let _target_ be _O_.[[ProxyTarget]].", "        1. Let _trap_ be ? GetMethod(_handler_, *\"apply\"*).", "        1. If _trap_ is *undefined*, then", "          1. Return ? Call(_target_, _thisArgument_, _argumentsList_).", "        1. Let _argArray_ be ! CreateArrayFromList(_argumentsList_).", "        1. Return ? Call(_trap_, _handler_, « _target_, _thisArgument_, _argArray_ »)."],
    "head": {
      "base": "ProxyObject",
      "methodName": "Call",
      "origParams": [{
        "kind": "Normal",
        "name": "thisArgument"
      }, {
        "kind": "Normal",
        "name": "argumentsList"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-proxy-object-internal-methods-and-internal-slots-call-thisargument-argumentslist",
    "rawBody": "{\n  0:let handler = O[\"ProxyHandler\"]\n  1:if (= handler null) (0) throw TypeError else 13:{}\n  2:assert (= (typeof handler) Object)\n  3:let target = O[\"ProxyTarget\"]\n  4:(0) app __x0__ = (GetMethod handler \"apply\")\n  4:let trap = [? __x0__]\n  5:if (= trap undefined) {\n    6:(1) app __x1__ = (Call target thisArgument argumentsList)\n    6:return [? __x1__]\n  } else 13:{}\n  7:(2) app __x2__ = (CreateArrayFromList argumentsList)\n  7:let argArray = [! __x2__]\n  8:(3) app __x3__ = (Call trap handler (1) (new [target, thisArgument, argArray]))\n  8:return [? __x3__]\n}"
  }, {
    "code": ["        1. Let _handler_ be _O_.[[ProxyHandler]].", "        1. If _handler_ is *null*, throw a *TypeError* exception.", "        1. Assert: Type(_handler_) is Object.", "        1. Let _target_ be _O_.[[ProxyTarget]].", "        1. Assert: IsConstructor(_target_) is *true*.", "        1. Let _trap_ be ? GetMethod(_handler_, *\"construct\"*).", "        1. If _trap_ is *undefined*, then", "          1. Return ? Construct(_target_, _argumentsList_, _newTarget_).", "        1. Let _argArray_ be ! CreateArrayFromList(_argumentsList_).", "        1. Let _newObj_ be ? Call(_trap_, _handler_, « _target_, _argArray_, _newTarget_ »).", "        1. If Type(_newObj_) is not Object, throw a *TypeError* exception.", "        1. Return _newObj_."],
    "head": {
      "base": "ProxyObject",
      "methodName": "Construct",
      "origParams": [{
        "kind": "Normal",
        "name": "argumentsList"
      }, {
        "kind": "Normal",
        "name": "newTarget"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "O"
      }
    },
    "ids": "sec-proxy-object-internal-methods-and-internal-slots-construct-argumentslist-newtarget",
    "rawBody": "{\n  0:let handler = O[\"ProxyHandler\"]\n  1:if (= handler null) (0) throw TypeError else 13:{}\n  2:assert (= (typeof handler) Object)\n  3:let target = O[\"ProxyTarget\"]\n  4:(0) app __x0__ = (IsConstructor target)\n  4:assert (= __x0__ true)\n  5:(1) app __x1__ = (GetMethod handler \"construct\")\n  5:let trap = [? __x1__]\n  6:if (= trap undefined) {\n    7:(2) app __x2__ = (Construct target argumentsList newTarget)\n    7:return [? __x2__]\n  } else 13:{}\n  8:(3) app __x3__ = (CreateArrayFromList argumentsList)\n  8:let argArray = [! __x3__]\n  9:(4) app __x4__ = (Call trap handler (1) (new [target, argArray, newTarget]))\n  9:let newObj = [? __x4__]\n  10:if (! (= (typeof newObj) Object)) (2) throw TypeError else 13:{}\n  11:return newObj\n}"
  }, {
    "code": ["        1. If Type(_target_) is not Object, throw a *TypeError* exception.", "        1. If Type(_handler_) is not Object, throw a *TypeError* exception.", "        1. Let _P_ be ! MakeBasicObject(« [[ProxyHandler]], [[ProxyTarget]] »).", "        1. Set _P_'s essential internal methods, except for [[Call]] and [[Construct]], to the definitions specified in <emu-xref href=\"#sec-proxy-object-internal-methods-and-internal-slots\"></emu-xref>.", "        1. If IsCallable(_target_) is *true*, then", "          1. Set _P_.[[Call]] as specified in <emu-xref href=\"#sec-proxy-object-internal-methods-and-internal-slots-call-thisargument-argumentslist\"></emu-xref>.", "          1. If IsConstructor(_target_) is *true*, then", "            1. Set _P_.[[Construct]] as specified in <emu-xref href=\"#sec-proxy-object-internal-methods-and-internal-slots-construct-argumentslist-newtarget\"></emu-xref>.", "        1. Set _P_.[[ProxyTarget]] to _target_.", "        1. Set _P_.[[ProxyHandler]] to _handler_.", "        1. Return _P_."],
    "head": {
      "name": "ProxyCreate",
      "params": [{
        "kind": "Normal",
        "name": "target"
      }, {
        "kind": "Normal",
        "name": "handler"
      }]
    },
    "ids": "sec-proxycreate",
    "rawBody": "{\n  0:if (! (= (typeof target) Object)) (0) throw TypeError else 3:{}\n  1:if (! (= (typeof handler) Object)) (1) throw TypeError else 3:{}\n  2:(0) app __x0__ = (MakeBasicObject (2) (new [\"ProxyHandler\", \"ProxyTarget\"]))\n  2:let P = [! __x0__]\n  4:(1) app __x1__ = (IsCallable target)\n  4:if (= __x1__ true) {\n    5:P[\"Call\"] = ALGORITHM[\"ProxyObject.Call\"]\n    6:(2) app __x2__ = (IsConstructor target)\n    6:if (= __x2__ true) P[\"Construct\"] = ALGORITHM[\"ProxyObject.Construct\"] else 3:{}\n  } else 3:{}\n  8:P[\"ProxyTarget\"] = target\n  9:P[\"ProxyHandler\"] = handler\n  10:return P\n}"
  }, {
    "code": ["        1. Assert: 0 ≤ _cp_ ≤ 0x10FFFF.", "        1. If _cp_ ≤ 0xFFFF, return the String value consisting of the code unit whose value is _cp_.", "        1. Let _cu1_ be the code unit whose value is floor((_cp_ - 0x10000) / 0x400) + 0xD800.", "        1. Let _cu2_ be the code unit whose value is ((_cp_ - 0x10000) modulo 0x400) + 0xDC00.", "        1. Return the string-concatenation of _cu1_ and _cu2_."],
    "head": {
      "name": "UTF16EncodeCodePoint",
      "params": [{
        "kind": "Normal",
        "name": "cp"
      }]
    },
    "ids": "sec-utf16encodecodepoint",
    "rawBody": "{\n  0:assert (&& (! (< cp 0i)) (! (< 1114111i cp)))\n  1:if (! (< 65535i cp)) return cp else 3:{}\n  2:(0) app __x0__ = (floor (/ (- cp 65536i) 1024i))\n  2:let cu1 = (+ __x0__ 55296i)\n  3:let cu2 = (+ (%% (- cp 65536i) 1024i) 56320i)\n  4:return (+ cu1 cu2)\n}"
  }, {
    "code": ["        1. Let _result_ be the empty String.", "        1. For each code point _cp_ of _text_, do", "          1. Set _result_ to the string-concatenation of _result_ and ! UTF16EncodeCodePoint(_cp_).", "        1. Return _result_."],
    "head": {
      "name": "CodePointsToString",
      "params": [{
        "kind": "Normal",
        "name": "text"
      }]
    },
    "ids": "sec-codepointstostring",
    "rawBody": "{\n  0:let result = \"\"\n  1:let __x0__ = text\n  1:let __x1__ = 0i\n  1:while (< __x1__ __x0__[\"length\"]) {\n    let cp = __x0__[__x1__]\n    2:(0) app __x2__ = (UTF16EncodeCodePoint cp)\n    2:result = (+ result [! __x2__])\n    __x1__ = (+ __x1__ 1i)\n  }\n  3:return result\n}"
  }, {
    "code": ["        1. Assert: _lead_ is a <emu-xref href=\"#leading-surrogate\"></emu-xref> and _trail_ is a <emu-xref href=\"#trailing-surrogate\"></emu-xref>.", "        1. Let _cp_ be (_lead_ - 0xD800) × 0x400 + (_trail_ - 0xDC00) + 0x10000.", "        1. Return the code point _cp_."],
    "head": {
      "name": "UTF16SurrogatePairToCodePoint",
      "params": [{
        "kind": "Normal",
        "name": "lead"
      }, {
        "kind": "Normal",
        "name": "trail"
      }]
    },
    "ids": "sec-utf16decodesurrogatepair",
    "rawBody": "{\n  1:let cp = (+ (+ (* (- lead 55296i) 1024i) (- trail 56320i)) 65536i)\n  2:return cp\n}"
  }, {
    "code": ["        1. Let _size_ be the length of _string_.", "        1. Assert: _position_ ≥ 0 and _position_ < _size_.", "        1. Let _first_ be the code unit at index _position_ within _string_.", "        1. Let _cp_ be the code point whose numeric value is that of _first_.", "        1. If _first_ is not a <emu-xref href=\"#leading-surrogate\"></emu-xref> or <emu-xref href=\"#trailing-surrogate\"></emu-xref>, then", "          1. Return the Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: *false* }.", "        1. If _first_ is a <emu-xref href=\"#trailing-surrogate\"></emu-xref> or _position_ + 1 = _size_, then", "          1. Return the Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: *true* }.", "        1. Let _second_ be the code unit at index _position_ + 1 within _string_.", "        1. If _second_ is not a <emu-xref href=\"#trailing-surrogate\"></emu-xref>, then", "          1. Return the Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: *true* }.", "        1. Set _cp_ to ! UTF16SurrogatePairToCodePoint(_first_, _second_).", "        1. Return the Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 2, [[IsUnpairedSurrogate]]: *false* }."],
    "head": {
      "name": "CodePointAt",
      "params": [{
        "kind": "Normal",
        "name": "string"
      }, {
        "kind": "Normal",
        "name": "position"
      }]
    },
    "ids": "sec-codepointat",
    "rawBody": "{\n  0:let size = string[\"length\"]\n  1:assert (&& (! (< position 0i)) (< position size))\n  2:let first = string[position]\n  3:(0) ??? \"Let id:{cp} be the code point whose numeric value is that of id:{first} .\"\n  4:(1) ??? \"If id:{first} is not a link:{leading-surrogate} or link:{trailing-surrogate} , then in:{} out:{}\"\n  6:(2) ??? \"If id:{first} is a link:{trailing-surrogate} or id:{position} + 1 = id:{size} , then in:{} out:{}\"\n  8:let second = string[(+ position 1i)]\n  9:(3) ??? \"If id:{second} is not a link:{trailing-surrogate} , then in:{} out:{}\"\n  11:(0) app __x0__ = (UTF16SurrogatePairToCodePoint first second)\n  11:cp = [! __x0__]\n  12:return (4) (new Record(\"CodePoint\" -> cp, \"CodeUnitCount\" -> 2i, \"IsUnpairedSurrogate\" -> false))\n}"
  }, {
    "code": ["        1. Let _codePoints_ be a new empty List.", "        1. Let _size_ be the length of _string_.", "        1. Let _position_ be 0.", "        1. Repeat, while _position_ < _size_,", "          1. Let _cp_ be ! CodePointAt(_string_, _position_).", "          1. Append _cp_.[[CodePoint]] to _codePoints_.", "          1. Set _position_ to _position_ + _cp_.[[CodeUnitCount]].", "        1. Return _codePoints_."],
    "head": {
      "name": "StringToCodePoints",
      "params": [{
        "kind": "Normal",
        "name": "string"
      }]
    },
    "ids": "sec-stringtocodepoints",
    "rawBody": "{\n  0:let codePoints = (0) (new [])\n  1:let size = string[\"length\"]\n  2:let position = 0i\n  3:while (< position size) {\n    4:(0) app __x0__ = (CodePointAt string position)\n    4:let cp = [! __x0__]\n    5:append cp[\"CodePoint\"] -> codePoints\n    6:position = (+ position cp[\"CodeUnitCount\"])\n  }\n  7:return codePoints\n}"
  }, {
    "code": ["        1. Attempt to parse _sourceText_ using _goalSymbol_ as the goal symbol, and analyse the parse result for any early error conditions. Parsing and early error detection may be interleaved in an implementation-defined manner.", "        1. If the parse succeeded and no early errors were found, return the Parse Node (an instance of _goalSymbol_) at the root of the parse tree resulting from the parse.", "        1. Otherwise, return a List of one or more *SyntaxError* objects representing the parsing errors and/or early errors. If more than one parsing error or early error is present, the number and ordering of error objects in the list is implementation-defined, but at least one must be present."],
    "head": {
      "name": "ParseText",
      "params": [{
        "kind": "Normal",
        "name": "sourceText"
      }, {
        "kind": "Normal",
        "name": "goalSymbol"
      }]
    },
    "ids": "sec-parsetext",
    "rawBody": "{\n  0:(0) ??? \"Attempt to parse id:{sourceText} using id:{goalSymbol} as the goal symbol , and analyse the parse result for any early error conditions . Parsing and early error detection may be interleaved in an implementation - defined manner .\"\n  1:(1) ??? \"If the parse succeeded and no early errors were found , return the Parse Node ( an instance of id:{goalSymbol} ) at the root of the parse tree resulting from the parse .\"\n  2:(2) ??? \"Otherwise , return a List of one or more value:{SyntaxError} objects representing the parsing errors and / or early errors . If more than one parsing error or early error is present , the number and ordering of error objects in the list is implementation - defined , but at least one must be present .\"\n}"
  }, {
    "code": ["          1. Return the Number value that results from rounding the MV of |DecimalLiteral| as described below."],
    "head": {
      "idx": 0,
      "methodName": "NumericValue",
      "prod": "NumericLiteral",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "DecimalLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-numericvalue",
    "rawBody": "(0) ??? \"Return the Number value that results from rounding the MV of nt:{DecimalLiteral} as described below .\""
  }, {
    "code": ["          1. Return the Number value that results from rounding the MV of |NonDecimalIntegerLiteral| as described below."],
    "head": {
      "idx": 2,
      "methodName": "NumericValue",
      "prod": "NumericLiteral",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "NonDecimalIntegerLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-numericvalue",
    "rawBody": "(0) ??? \"Return the Number value that results from rounding the MV of nt:{NonDecimalIntegerLiteral} as described below .\""
  }, {
    "code": ["          1. Return the BigInt value that represents the MV of |NonDecimalIntegerLiteral|."],
    "head": {
      "idx": 3,
      "methodName": "NumericValue",
      "prod": "NumericLiteral",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "NonDecimalIntegerLiteral",
          "optional": false
        }, {
          "args": [],
          "name": "BigIntLiteralSuffix",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-numericvalue",
    "rawBody": "{\n  0:(0) access __x0__ = (NonDecimalIntegerLiteral \"MV\")\n  0:return (convert __x0__ num2bigint )\n}"
  }, {
    "code": ["          1. Return *0*<sub>ℤ</sub>."],
    "head": {
      "idx": 0,
      "methodName": "NumericValue",
      "prod": "DecimalBigIntegerLiteral",
      "rhs": {
        "tokens": [{
          "term": "0"
        }, {
          "args": [],
          "name": "BigIntLiteralSuffix",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-numericvalue",
    "rawBody": "return 0i"
  }, {
    "code": ["          1. Return the BigInt value that represents the MV of |NonZeroDigit|."],
    "head": {
      "idx": 1,
      "methodName": "NumericValue",
      "prod": "DecimalBigIntegerLiteral",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "NonZeroDigit",
          "optional": false
        }, {
          "args": [],
          "name": "BigIntLiteralSuffix",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-numericvalue",
    "rawBody": "{\n  0:(0) access __x0__ = (NonZeroDigit \"MV\")\n  0:return (convert __x0__ num2bigint )\n}"
  }, {
    "code": ["          1. Let _n_ be the number of code points in |DecimalDigits|, excluding all occurrences of |NumericLiteralSeparator|.", "          1. Let _mv_ be (the MV of |NonZeroDigit| × 10) plus the MV of |DecimalDigits|.", "          1. Return ℤ(_mv_)."],
    "head": {
      "idx": 1,
      "methodName": "NumericValue",
      "prod": "DecimalBigIntegerLiteral",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "NonZeroDigit",
          "optional": false
        }, {
          "args": [],
          "name": "DecimalDigits",
          "optional": false
        }, {
          "args": [],
          "name": "BigIntLiteralSuffix",
          "optional": false
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-numericvalue",
    "rawBody": "{\n  0:(0) ??? \"Let id:{n} be the number of code points in nt:{DecimalDigits} , excluding all occurrences of nt:{NumericLiteralSeparator} .\"\n  1:(0) access __nzd__ = (NonZeroDigit \"MV\")\n  1:(1) access __dds__ = (DecimalDigits \"MV\")\n  1:let mv = (+ (* __nzd__ 10.0) __dds__)\n  2:return (convert mv num2bigint )\n}"
  }, {
    "code": ["          1. Let _n_ be the number of code points in |DecimalDigits|, excluding all occurrences of |NumericLiteralSeparator|.", "          1. Let _mv_ be (the MV of |NonZeroDigit| × 10) plus the MV of |DecimalDigits|.", "          1. Return ℤ(_mv_)."],
    "head": {
      "idx": 2,
      "methodName": "NumericValue",
      "prod": "DecimalBigIntegerLiteral",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "NonZeroDigit",
          "optional": false
        }, {
          "args": [],
          "name": "NumericLiteralSeparator",
          "optional": false
        }, {
          "args": [],
          "name": "DecimalDigits",
          "optional": false
        }, {
          "args": [],
          "name": "BigIntLiteralSuffix",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-numericvalue",
    "rawBody": "{\n  0:(0) ??? \"Let id:{n} be the number of code points in nt:{DecimalDigits} , excluding all occurrences of nt:{NumericLiteralSeparator} .\"\n  1:(0) access __nzd__ = (NonZeroDigit \"MV\")\n  1:(1) access __dds__ = (DecimalDigits \"MV\")\n  1:let mv = (+ (* __nzd__ 10.0) __dds__)\n  2:return (convert mv num2bigint )\n}"
  }, {
    "code": ["          1. Return the source text that was recognized as |RegularExpressionBody|."],
    "head": {
      "idx": 0,
      "methodName": "BodyText",
      "prod": "RegularExpressionLiteral",
      "rhs": {
        "tokens": [{
          "term": "/"
        }, {
          "args": [],
          "name": "RegularExpressionBody",
          "optional": false
        }, {
          "term": "/"
        }, {
          "args": [],
          "name": "RegularExpressionFlags",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-bodytext",
    "rawBody": "(0) ??? \"Return the source text that was recognized as nt:{RegularExpressionBody} .\""
  }, {
    "code": ["          1. Return the source text that was recognized as |RegularExpressionFlags|."],
    "head": {
      "idx": 0,
      "methodName": "FlagText",
      "prod": "RegularExpressionLiteral",
      "rhs": {
        "tokens": [{
          "term": "/"
        }, {
          "args": [],
          "name": "RegularExpressionBody",
          "optional": false
        }, {
          "term": "/"
        }, {
          "args": [],
          "name": "RegularExpressionFlags",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-flagtext",
    "rawBody": "(0) ??? \"Return the source text that was recognized as nt:{RegularExpressionFlags} .\""
  }, {
    "code": ["        1. Let _idText_ be the source text matched by |IdentifierName|.", "        1. Let _idTextUnescaped_ be the result of replacing any occurrences of `\\\\` |UnicodeEscapeSequence| in _idText_ with the code point represented by the |UnicodeEscapeSequence|.", "        1. Return ! CodePointsToString(_idTextUnescaped_)."],
    "head": {
      "idx": 0,
      "methodName": "StringValue",
      "prod": "IdentifierName",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "IdentifierStart",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-stringvalue",
    "rawBody": "{\n  0:let idText = (get-syntax IdentifierName)\n  1:(0) ??? \"Let id:{idTextUnescaped} be the result of replacing any occurrences of code:{\\\\\\\\} nt:{UnicodeEscapeSequence} in id:{idText} with the code point represented by the nt:{UnicodeEscapeSequence} .\"\n  2:(0) app __x0__ = (CodePointsToString idTextUnescaped)\n  2:return [! __x0__]\n}"
  }, {
    "code": ["        1. Let _idText_ be the source text matched by |IdentifierName|.", "        1. Let _idTextUnescaped_ be the result of replacing any occurrences of `\\\\` |UnicodeEscapeSequence| in _idText_ with the code point represented by the |UnicodeEscapeSequence|.", "        1. Return ! CodePointsToString(_idTextUnescaped_)."],
    "head": {
      "idx": 1,
      "methodName": "StringValue",
      "prod": "IdentifierName",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }, {
          "args": [],
          "name": "IdentifierPart",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-stringvalue",
    "rawBody": "{\n  0:let idText = (get-syntax IdentifierName)\n  1:(0) ??? \"Let id:{idTextUnescaped} be the result of replacing any occurrences of code:{\\\\\\\\} nt:{UnicodeEscapeSequence} in id:{idText} with the code point represented by the nt:{UnicodeEscapeSequence} .\"\n  2:(0) app __x0__ = (CodePointsToString idTextUnescaped)\n  2:return [! __x0__]\n}"
  }, {
    "code": ["        1. Return *\"yield\"*."],
    "head": {
      "idx": 1,
      "methodName": "StringValue",
      "prod": "IdentifierReference",
      "rhs": {
        "tokens": [{
          "term": "yield"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-stringvalue",
    "rawBody": "return \"yield\""
  }, {
    "code": ["        1. Return *\"yield\"*."],
    "head": {
      "idx": 1,
      "methodName": "StringValue",
      "prod": "BindingIdentifier",
      "rhs": {
        "tokens": [{
          "term": "yield"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-stringvalue",
    "rawBody": "return \"yield\""
  }, {
    "code": ["        1. Return *\"yield\"*."],
    "head": {
      "idx": 1,
      "methodName": "StringValue",
      "prod": "LabelIdentifier",
      "rhs": {
        "tokens": [{
          "term": "yield"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-stringvalue",
    "rawBody": "return \"yield\""
  }, {
    "code": ["        1. Return *\"await\"*."],
    "head": {
      "idx": 2,
      "methodName": "StringValue",
      "prod": "IdentifierReference",
      "rhs": {
        "tokens": [{
          "term": "await"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-stringvalue",
    "rawBody": "return \"await\""
  }, {
    "code": ["        1. Return *\"await\"*."],
    "head": {
      "idx": 2,
      "methodName": "StringValue",
      "prod": "BindingIdentifier",
      "rhs": {
        "tokens": [{
          "term": "await"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-stringvalue",
    "rawBody": "return \"await\""
  }, {
    "code": ["        1. Return *\"await\"*."],
    "head": {
      "idx": 2,
      "methodName": "StringValue",
      "prod": "LabelIdentifier",
      "rhs": {
        "tokens": [{
          "term": "await"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-stringvalue",
    "rawBody": "return \"await\""
  }, {
    "code": ["        1. Return the StringValue of |IdentifierName|."],
    "head": {
      "idx": 0,
      "methodName": "StringValue",
      "prod": "Identifier",
      "rhs": {
        "tokens": [{
          "base": {
            "args": [],
            "name": "IdentifierName",
            "optional": false
          },
          "cases": [{
            "args": [],
            "name": "ReservedWord",
            "optional": false
          }]
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-stringvalue",
    "rawBody": "{\n  0:(0) access __x0__ = (IdentifierName \"StringValue\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ? ResolveBinding(StringValue of |Identifier|)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "IdentifierReference",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Identifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-identifiers-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Identifier \"StringValue\")\n  0:(1) app __x1__ = (ResolveBinding __x0__)\n  0:return [? __x1__]\n}"
  }, {
    "code": ["        1. Return ? ResolveBinding(*\"yield\"*)."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "IdentifierReference",
      "rhs": {
        "tokens": [{
          "term": "yield"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-identifiers-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (ResolveBinding \"yield\")\n  0:return [? __x0__]\n}"
  }, {
    "code": ["        1. Return ? ResolveBinding(*\"await\"*)."],
    "head": {
      "idx": 2,
      "methodName": "Evaluation",
      "prod": "IdentifierReference",
      "rhs": {
        "tokens": [{
          "term": "await"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-identifiers-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (ResolveBinding \"await\")\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Return the |ParenthesizedExpression| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|."],
    "head": {
      "idx": 0,
      "methodName": "CoveredParenthesizedExpression",
      "prod": "CoverParenthesizedExpressionAndArrowParameterList",
      "rhs": {
        "tokens": [{
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-coveredparenthesizedexpression",
    "rawBody": "return (parse-syntax CoverParenthesizedExpressionAndArrowParameterList \"ParenthesizedExpression\" (0) (new []))"
  }, {
    "code": ["          1. Return ? ResolveThisBinding()."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "term": "this"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-this-keyword-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (ResolveThisBinding)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Return *null*."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "Literal",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "NullLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-literals-runtime-semantics-evaluation",
    "rawBody": "return null"
  }, {
    "code": ["          1. If |BooleanLiteral| is the token `false`, return *false*.", "          1. If |BooleanLiteral| is the token `true`, return *true*."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "Literal",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BooleanLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-literals-runtime-semantics-evaluation",
    "rawBody": "{\n  0:if (= (get-syntax BooleanLiteral) \"false\") return false else 0:{}\n  1:if (= (get-syntax BooleanLiteral) \"true\") return true else 0:{}\n}"
  }, {
    "code": ["          1. Return the NumericValue of |NumericLiteral| as defined in <emu-xref href=\"#sec-literals-numeric-literals\"></emu-xref>."],
    "head": {
      "idx": 2,
      "methodName": "Evaluation",
      "prod": "Literal",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "NumericLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-literals-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (NumericLiteral \"NumericValue\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return the SV of |StringLiteral| as defined in <emu-xref href=\"#sec-static-semantics-sv\"></emu-xref>."],
    "head": {
      "idx": 3,
      "methodName": "Evaluation",
      "prod": "Literal",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StringLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-literals-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (StringLiteral \"SV\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Let _len_ be _nextIndex_ + 1.", "          1. Perform ? Set(_array_, *\"length\"*, 𝔽(_len_), *true*).", "          1. NOTE: The above Set throws if _len_ exceeds 2<sup>32</sup>-1.", "          1. Return _len_."],
    "head": {
      "idx": 0,
      "methodName": "ArrayAccumulation",
      "prod": "Elision",
      "rhs": {
        "tokens": [{
          "term": ","
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "array"
      }, {
        "kind": "Normal",
        "name": "nextIndex"
      }]
    },
    "ids": "sec-runtime-semantics-arrayaccumulation",
    "rawBody": "{\n  0:let len = (+ nextIndex 1i)\n  1:(0) app __x0__ = (Set array \"length\" len true)\n  1:[? __x0__]\n  3:return len\n}"
  }, {
    "code": ["          1. Return the result of performing ArrayAccumulation for |Elision| with arguments _array_ and _nextIndex_ + 1."],
    "head": {
      "idx": 1,
      "methodName": "ArrayAccumulation",
      "prod": "Elision",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Elision",
          "optional": false
        }, {
          "term": ","
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "array"
      }, {
        "kind": "Normal",
        "name": "nextIndex"
      }]
    },
    "ids": "sec-runtime-semantics-arrayaccumulation",
    "rawBody": "{\n  0:(0) access __x0__ = (Elision \"ArrayAccumulation\" array (+ nextIndex 1i))\n  0:return __x0__\n}"
  }, {
    "code": ["          1. If |Elision| is present, then", "            1. Set _nextIndex_ to the result of performing ArrayAccumulation for |Elision| with arguments _array_ and _nextIndex_.", "            1. ReturnIfAbrupt(_nextIndex_).", "          1. Let _initResult_ be the result of evaluating |AssignmentExpression|.", "          1. Let _initValue_ be ? GetValue(_initResult_).", "          1. Let _created_ be ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _initValue_).", "          1. Return _nextIndex_ + 1."],
    "head": {
      "idx": 0,
      "methodName": "ArrayAccumulation",
      "prod": "ElementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Normal",
        "name": "array"
      }, {
        "kind": "Normal",
        "name": "nextIndex"
      }]
    },
    "ids": "sec-runtime-semantics-arrayaccumulation",
    "rawBody": "{\n  0:if (! (= Elision absent)) {\n    1:(0) access __x0__ = (Elision \"ArrayAccumulation\" array nextIndex)\n    1:nextIndex = __x0__\n    2:[? nextIndex]\n  } else 2:{}\n  3:(1) access __x1__ = (AssignmentExpression \"Evaluation\")\n  3:let initResult = __x1__\n  4:(2) app __x2__ = (GetValue initResult)\n  4:let initValue = [? __x2__]\n  5:(3) app __x3__ = (ToString nextIndex)\n  5:(4) app __x4__ = (CreateDataPropertyOrThrow array [! __x3__] initValue)\n  5:let created = [! __x4__]\n  6:return (+ nextIndex 1i)\n}"
  }, {
    "code": ["          1. If |Elision| is present, then", "            1. Set _nextIndex_ to the result of performing ArrayAccumulation for |Elision| with arguments _array_ and _nextIndex_.", "            1. ReturnIfAbrupt(_nextIndex_).", "          1. Return the result of performing ArrayAccumulation for |SpreadElement| with arguments _array_ and _nextIndex_."],
    "head": {
      "idx": 1,
      "methodName": "ArrayAccumulation",
      "prod": "ElementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "args": [],
          "name": "SpreadElement",
          "optional": false
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Normal",
        "name": "array"
      }, {
        "kind": "Normal",
        "name": "nextIndex"
      }]
    },
    "ids": "sec-runtime-semantics-arrayaccumulation",
    "rawBody": "{\n  0:if (! (= Elision absent)) {\n    1:(0) access __x0__ = (Elision \"ArrayAccumulation\" array nextIndex)\n    1:nextIndex = __x0__\n    2:[? nextIndex]\n  } else 2:{}\n  3:(1) access __x1__ = (SpreadElement \"ArrayAccumulation\" array nextIndex)\n  3:return __x1__\n}"
  }, {
    "code": ["          1. Set _nextIndex_ to the result of performing ArrayAccumulation for |ElementList| with arguments _array_ and _nextIndex_.", "          1. ReturnIfAbrupt(_nextIndex_).", "          1. If |Elision| is present, then", "            1. Set _nextIndex_ to the result of performing ArrayAccumulation for |Elision| with arguments _array_ and _nextIndex_.", "            1. ReturnIfAbrupt(_nextIndex_).", "          1. Let _initResult_ be the result of evaluating |AssignmentExpression|.", "          1. Let _initValue_ be ? GetValue(_initResult_).", "          1. Let _created_ be ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _initValue_).", "          1. Return _nextIndex_ + 1."],
    "head": {
      "idx": 2,
      "methodName": "ArrayAccumulation",
      "prod": "ElementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ElementList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Normal",
        "name": "array"
      }, {
        "kind": "Normal",
        "name": "nextIndex"
      }]
    },
    "ids": "sec-runtime-semantics-arrayaccumulation",
    "rawBody": "{\n  0:(0) access __x0__ = (ElementList \"ArrayAccumulation\" array nextIndex)\n  0:nextIndex = __x0__\n  1:[? nextIndex]\n  2:if (! (= Elision absent)) {\n    3:(1) access __x1__ = (Elision \"ArrayAccumulation\" array nextIndex)\n    3:nextIndex = __x1__\n    4:[? nextIndex]\n  } else 2:{}\n  5:(2) access __x2__ = (AssignmentExpression \"Evaluation\")\n  5:let initResult = __x2__\n  6:(3) app __x3__ = (GetValue initResult)\n  6:let initValue = [? __x3__]\n  7:(4) app __x4__ = (ToString nextIndex)\n  7:(5) app __x5__ = (CreateDataPropertyOrThrow array [! __x4__] initValue)\n  7:let created = [! __x5__]\n  8:return (+ nextIndex 1i)\n}"
  }, {
    "code": ["          1. Set _nextIndex_ to the result of performing ArrayAccumulation for |ElementList| with arguments _array_ and _nextIndex_.", "          1. ReturnIfAbrupt(_nextIndex_).", "          1. If |Elision| is present, then", "            1. Set _nextIndex_ to the result of performing ArrayAccumulation for |Elision| with arguments _array_ and _nextIndex_.", "            1. ReturnIfAbrupt(_nextIndex_).", "          1. Return the result of performing ArrayAccumulation for |SpreadElement| with arguments _array_ and _nextIndex_."],
    "head": {
      "idx": 3,
      "methodName": "ArrayAccumulation",
      "prod": "ElementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ElementList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "args": [],
          "name": "SpreadElement",
          "optional": false
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Normal",
        "name": "array"
      }, {
        "kind": "Normal",
        "name": "nextIndex"
      }]
    },
    "ids": "sec-runtime-semantics-arrayaccumulation",
    "rawBody": "{\n  0:(0) access __x0__ = (ElementList \"ArrayAccumulation\" array nextIndex)\n  0:nextIndex = __x0__\n  1:[? nextIndex]\n  2:if (! (= Elision absent)) {\n    3:(1) access __x1__ = (Elision \"ArrayAccumulation\" array nextIndex)\n    3:nextIndex = __x1__\n    4:[? nextIndex]\n  } else 2:{}\n  5:(2) access __x2__ = (SpreadElement \"ArrayAccumulation\" array nextIndex)\n  5:return __x2__\n}"
  }, {
    "code": ["          1. Let _spreadRef_ be the result of evaluating |AssignmentExpression|.", "          1. Let _spreadObj_ be ? GetValue(_spreadRef_).", "          1. Let _iteratorRecord_ be ? GetIterator(_spreadObj_).", "          1. Repeat,", "            1. Let _next_ be ? IteratorStep(_iteratorRecord_).", "            1. If _next_ is *false*, return _nextIndex_.", "            1. Let _nextValue_ be ? IteratorValue(_next_).", "            1. Perform ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _nextValue_).", "            1. Set _nextIndex_ to _nextIndex_ + 1."],
    "head": {
      "idx": 0,
      "methodName": "ArrayAccumulation",
      "prod": "SpreadElement",
      "rhs": {
        "tokens": [{
          "term": "..."
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "array"
      }, {
        "kind": "Normal",
        "name": "nextIndex"
      }]
    },
    "ids": "sec-runtime-semantics-arrayaccumulation",
    "rawBody": "{\n  0:(0) access __x0__ = (AssignmentExpression \"Evaluation\")\n  0:let spreadRef = __x0__\n  1:(1) app __x1__ = (GetValue spreadRef)\n  1:let spreadObj = [? __x1__]\n  2:(2) app __x2__ = (GetIterator spreadObj)\n  2:let iteratorRecord = [? __x2__]\n  3:while true {\n    4:(3) app __x3__ = (IteratorStep iteratorRecord)\n    4:let next = [? __x3__]\n    5:if (= next false) return nextIndex else 2:{}\n    6:(4) app __x4__ = (IteratorValue next)\n    6:let nextValue = [? __x4__]\n    7:(5) app __x5__ = (ToString nextIndex)\n    7:(6) app __x6__ = (CreateDataPropertyOrThrow array [! __x5__] nextValue)\n    7:[! __x6__]\n    8:nextIndex = (+ nextIndex 1i)\n  }\n}"
  }, {
    "code": ["          1. Let _array_ be ! ArrayCreate(0).", "          1. If |Elision| is present, then", "            1. Let _len_ be the result of performing ArrayAccumulation for |Elision| with arguments _array_ and 0.", "            1. ReturnIfAbrupt(_len_).", "          1. Return _array_."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "ArrayLiteral",
      "rhs": {
        "tokens": [{
          "term": "["
        }, {
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "term": "]"
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-array-initializer-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (ArrayCreate 0i)\n  0:let array = [! __x0__]\n  1:if (! (= Elision absent)) {\n    2:(1) access __x1__ = (Elision \"ArrayAccumulation\" array 0i)\n    2:let len = __x1__\n    3:[? len]\n  } else 2:{}\n  4:return array\n}"
  }, {
    "code": ["          1. Let _array_ be ! ArrayCreate(0).", "          1. Let _len_ be the result of performing ArrayAccumulation for |ElementList| with arguments _array_ and 0.", "          1. ReturnIfAbrupt(_len_).", "          1. Return _array_."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "ArrayLiteral",
      "rhs": {
        "tokens": [{
          "term": "["
        }, {
          "args": [],
          "name": "ElementList",
          "optional": false
        }, {
          "term": "]"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-array-initializer-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (ArrayCreate 0i)\n  0:let array = [! __x0__]\n  1:(1) access __x1__ = (ElementList \"ArrayAccumulation\" array 0i)\n  1:let len = __x1__\n  2:[? len]\n  3:return array\n}"
  }, {
    "code": ["          1. Let _array_ be ! ArrayCreate(0).", "          1. Let _nextIndex_ be the result of performing ArrayAccumulation for |ElementList| with arguments _array_ and 0.", "          1. ReturnIfAbrupt(_nextIndex_).", "          1. If |Elision| is present, then", "            1. Let _len_ be the result of performing ArrayAccumulation for |Elision| with arguments _array_ and _nextIndex_.", "            1. ReturnIfAbrupt(_len_).", "          1. Return _array_."],
    "head": {
      "idx": 2,
      "methodName": "Evaluation",
      "prod": "ArrayLiteral",
      "rhs": {
        "tokens": [{
          "term": "["
        }, {
          "args": [],
          "name": "ElementList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "term": "]"
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-array-initializer-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (ArrayCreate 0i)\n  0:let array = [! __x0__]\n  1:(1) access __x1__ = (ElementList \"ArrayAccumulation\" array 0i)\n  1:let nextIndex = __x1__\n  2:[? nextIndex]\n  3:if (! (= Elision absent)) {\n    4:(2) access __x2__ = (Elision \"ArrayAccumulation\" array nextIndex)\n    4:let len = __x2__\n    5:[? len]\n  } else 2:{}\n  6:return array\n}"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "IsComputedPropertyKey",
      "prod": "PropertyName",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LiteralPropertyName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-iscomputedpropertykey",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *true*."],
    "head": {
      "idx": 1,
      "methodName": "IsComputedPropertyKey",
      "prod": "PropertyName",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ComputedPropertyName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-iscomputedpropertykey",
    "rawBody": "return true"
  }, {
    "code": ["          1. If PropName of |PropertyDefinition| is ~empty~, return a new empty List.", "          1. Return a List whose sole element is PropName of |PropertyDefinition|."],
    "head": {
      "idx": 0,
      "methodName": "PropertyNameList",
      "prod": "PropertyDefinitionList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "PropertyDefinition",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-propertynamelist",
    "rawBody": "{\n  0:(0) access __x0__ = (PropertyDefinition \"PropName\")\n  0:if (= __x0__ CONST_empty) return (0) (new []) else 2:{}\n  1:(1) access __x1__ = (PropertyDefinition \"PropName\")\n  1:return (1) (new [__x1__])\n}"
  }, {
    "code": ["          1. Let _list_ be PropertyNameList of |PropertyDefinitionList|.", "          1. If PropName of |PropertyDefinition| is ~empty~, return _list_.", "          1. Append PropName of |PropertyDefinition| to the end of _list_.", "          1. Return _list_."],
    "head": {
      "idx": 1,
      "methodName": "PropertyNameList",
      "prod": "PropertyDefinitionList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "PropertyDefinitionList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "PropertyDefinition",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-propertynamelist",
    "rawBody": "{\n  0:(0) access __x0__ = (PropertyDefinitionList \"PropertyNameList\")\n  0:let list = __x0__\n  1:(1) access __x1__ = (PropertyDefinition \"PropName\")\n  1:if (= __x1__ CONST_empty) return list else 2:{}\n  2:(2) access __x2__ = (PropertyDefinition \"PropName\")\n  2:append __x2__ -> list\n  3:return list\n}"
  }, {
    "code": ["          1. Return ! OrdinaryObjectCreate(%Object.prototype%)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "ObjectLiteral",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-object-initializer-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (OrdinaryObjectCreate INTRINSIC_Object_prototype)\n  0:return [! __x0__]\n}"
  }, {
    "code": ["          1. Let _obj_ be ! OrdinaryObjectCreate(%Object.prototype%).", "          1. Perform ? PropertyDefinitionEvaluation of |PropertyDefinitionList| with arguments _obj_ and *true*.", "          1. Return _obj_."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "ObjectLiteral",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "PropertyDefinitionList",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-object-initializer-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (OrdinaryObjectCreate INTRINSIC_Object_prototype)\n  0:let obj = [! __x0__]\n  1:(1) access __x1__ = (PropertyDefinitionList \"PropertyDefinitionEvaluation\" obj true)\n  1:[? __x1__]\n  2:return obj\n}"
  }, {
    "code": ["          1. Let _obj_ be ! OrdinaryObjectCreate(%Object.prototype%).", "          1. Perform ? PropertyDefinitionEvaluation of |PropertyDefinitionList| with arguments _obj_ and *true*.", "          1. Return _obj_."],
    "head": {
      "idx": 2,
      "methodName": "Evaluation",
      "prod": "ObjectLiteral",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "PropertyDefinitionList",
          "optional": false
        }, {
          "term": ","
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-object-initializer-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (OrdinaryObjectCreate INTRINSIC_Object_prototype)\n  0:let obj = [! __x0__]\n  1:(1) access __x1__ = (PropertyDefinitionList \"PropertyDefinitionEvaluation\" obj true)\n  1:[? __x1__]\n  2:return obj\n}"
  }, {
    "code": ["          1. Return StringValue of |IdentifierName|."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "LiteralPropertyName",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-object-initializer-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (IdentifierName \"StringValue\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return the SV of |StringLiteral|."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "LiteralPropertyName",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StringLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-object-initializer-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (StringLiteral \"SV\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Let _nbr_ be the NumericValue of |NumericLiteral|.", "          1. Return ! ToString(_nbr_)."],
    "head": {
      "idx": 2,
      "methodName": "Evaluation",
      "prod": "LiteralPropertyName",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "NumericLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-object-initializer-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (NumericLiteral \"NumericValue\")\n  0:let nbr = __x0__\n  1:(1) app __x1__ = (ToString nbr)\n  1:return [! __x1__]\n}"
  }, {
    "code": ["          1. Let _exprValue_ be the result of evaluating |AssignmentExpression|.", "          1. Let _propName_ be ? GetValue(_exprValue_).", "          1. Return ? ToPropertyKey(_propName_)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "ComputedPropertyName",
      "rhs": {
        "tokens": [{
          "term": "["
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": "]"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-object-initializer-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (AssignmentExpression \"Evaluation\")\n  0:let exprValue = __x0__\n  1:(1) app __x1__ = (GetValue exprValue)\n  1:let propName = [? __x1__]\n  2:(2) app __x2__ = (ToPropertyKey propName)\n  2:return [? __x2__]\n}"
  }, {
    "code": ["          1. Perform ? PropertyDefinitionEvaluation of |PropertyDefinitionList| with arguments _object_ and _enumerable_.", "          1. Return the result of performing PropertyDefinitionEvaluation of |PropertyDefinition| with arguments _object_ and _enumerable_."],
    "head": {
      "idx": 1,
      "methodName": "PropertyDefinitionEvaluation",
      "prod": "PropertyDefinitionList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "PropertyDefinitionList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "PropertyDefinition",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "object"
      }, {
        "kind": "Normal",
        "name": "enumerable"
      }]
    },
    "ids": "sec-runtime-semantics-propertydefinitionevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (PropertyDefinitionList \"PropertyDefinitionEvaluation\" object enumerable)\n  0:[? __x0__]\n  1:(1) access __x1__ = (PropertyDefinition \"PropertyDefinitionEvaluation\" object enumerable)\n  1:return __x1__\n}"
  }, {
    "code": ["          1. Let _exprValue_ be the result of evaluating |AssignmentExpression|.", "          1. Let _fromValue_ be ? GetValue(_exprValue_).", "          1. Let _excludedNames_ be a new empty List.", "          1. Return ? CopyDataProperties(_object_, _fromValue_, _excludedNames_)."],
    "head": {
      "idx": 4,
      "methodName": "PropertyDefinitionEvaluation",
      "prod": "PropertyDefinition",
      "rhs": {
        "tokens": [{
          "term": "..."
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "object"
      }, {
        "kind": "Normal",
        "name": "enumerable"
      }]
    },
    "ids": "sec-runtime-semantics-propertydefinitionevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (AssignmentExpression \"Evaluation\")\n  0:let exprValue = __x0__\n  1:(1) app __x1__ = (GetValue exprValue)\n  1:let fromValue = [? __x1__]\n  2:let excludedNames = (0) (new [])\n  3:(2) app __x2__ = (CopyDataProperties object fromValue excludedNames)\n  3:return [? __x2__]\n}"
  }, {
    "code": ["          1. Let _propName_ be StringValue of |IdentifierReference|.", "          1. Let _exprValue_ be the result of evaluating |IdentifierReference|.", "          1. Let _propValue_ be ? GetValue(_exprValue_).", "          1. Assert: _enumerable_ is *true*.", "          1. Assert: _object_ is an ordinary, extensible object with no non-configurable properties.", "          1. Return ! CreateDataPropertyOrThrow(_object_, _propName_, _propValue_)."],
    "head": {
      "idx": 0,
      "methodName": "PropertyDefinitionEvaluation",
      "prod": "PropertyDefinition",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "IdentifierReference",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "object"
      }, {
        "kind": "Normal",
        "name": "enumerable"
      }]
    },
    "ids": "sec-runtime-semantics-propertydefinitionevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (IdentifierReference \"StringValue\")\n  0:let propName = __x0__\n  1:(1) access __x1__ = (IdentifierReference \"Evaluation\")\n  1:let exprValue = __x1__\n  2:(2) app __x2__ = (GetValue exprValue)\n  2:let propValue = [? __x2__]\n  3:assert (= enumerable true)\n  5:(3) app __x3__ = (CreateDataPropertyOrThrow object propName propValue)\n  5:return [! __x3__]\n}"
  }, {
    "code": ["          1. Let _propKey_ be the result of evaluating |PropertyName|.", "          1. ReturnIfAbrupt(_propKey_).", "          1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true*, then", "            1. Let _propValue_ be ? NamedEvaluation of |AssignmentExpression| with argument _propKey_.", "          1. Else,", "            1. Let _exprValueRef_ be the result of evaluating |AssignmentExpression|.", "            1. Let _propValue_ be ? GetValue(_exprValueRef_).", "          1. Assert: _enumerable_ is *true*.", "          1. Assert: _object_ is an ordinary, extensible object with no non-configurable properties.", "          1. Return ! CreateDataPropertyOrThrow(_object_, _propKey_, _propValue_)."],
    "head": {
      "idx": 2,
      "methodName": "PropertyDefinitionEvaluation",
      "prod": "PropertyDefinition",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "object"
      }, {
        "kind": "Normal",
        "name": "enumerable"
      }]
    },
    "ids": "sec-runtime-semantics-propertydefinitionevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (PropertyName \"Evaluation\")\n  0:let propKey = __x0__\n  1:[? propKey]\n  4:(1) app __x1__ = (IsAnonymousFunctionDefinition AssignmentExpression)\n  4:if (= __x1__ true) {\n    3:(2) access __x2__ = (AssignmentExpression \"NamedEvaluation\" propKey)\n    3:let propValue = [? __x2__]\n  } else {\n    5:(3) access __x3__ = (AssignmentExpression \"Evaluation\")\n    5:let exprValueRef = __x3__\n    6:(4) app __x4__ = (GetValue exprValueRef)\n    6:let propValue = [? __x4__]\n  }\n  7:assert (= enumerable true)\n  9:(5) app __x5__ = (CreateDataPropertyOrThrow object propKey propValue)\n  9:return [! __x5__]\n}"
  }, {
    "code": ["          1. Return ? MethodDefinitionEvaluation of |MethodDefinition| with arguments _object_ and _enumerable_."],
    "head": {
      "idx": 0,
      "methodName": "PropertyDefinitionEvaluation",
      "prod": "MethodDefinition",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "object"
      }, {
        "kind": "Normal",
        "name": "enumerable"
      }]
    },
    "ids": "sec-runtime-semantics-propertydefinitionevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (MethodDefinition \"MethodDefinitionEvaluation\" object enumerable)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Return ? MethodDefinitionEvaluation of |MethodDefinition| with arguments _object_ and _enumerable_."],
    "head": {
      "idx": 4,
      "methodName": "PropertyDefinitionEvaluation",
      "prod": "MethodDefinition",
      "rhs": {
        "tokens": [{
          "term": "get"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "object"
      }, {
        "kind": "Normal",
        "name": "enumerable"
      }]
    },
    "ids": "sec-runtime-semantics-propertydefinitionevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (MethodDefinition \"MethodDefinitionEvaluation\" object enumerable)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Return ? MethodDefinitionEvaluation of |MethodDefinition| with arguments _object_ and _enumerable_."],
    "head": {
      "idx": 5,
      "methodName": "PropertyDefinitionEvaluation",
      "prod": "MethodDefinition",
      "rhs": {
        "tokens": [{
          "term": "set"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "PropertySetParameterList",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "object"
      }, {
        "kind": "Normal",
        "name": "enumerable"
      }]
    },
    "ids": "sec-runtime-semantics-propertydefinitionevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (MethodDefinition \"MethodDefinitionEvaluation\" object enumerable)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Return ? MethodDefinitionEvaluation of |GeneratorMethod| with arguments _object_ and _enumerable_."],
    "head": {
      "idx": 0,
      "methodName": "PropertyDefinitionEvaluation",
      "prod": "GeneratorMethod",
      "rhs": {
        "tokens": [{
          "term": "*"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "object"
      }, {
        "kind": "Normal",
        "name": "enumerable"
      }]
    },
    "ids": "sec-runtime-semantics-propertydefinitionevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (GeneratorMethod \"MethodDefinitionEvaluation\" object enumerable)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Return ? MethodDefinitionEvaluation of |AsyncGeneratorMethod| with arguments _object_ and _enumerable_."],
    "head": {
      "idx": 0,
      "methodName": "PropertyDefinitionEvaluation",
      "prod": "AsyncGeneratorMethod",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "object"
      }, {
        "kind": "Normal",
        "name": "enumerable"
      }]
    },
    "ids": "sec-runtime-semantics-propertydefinitionevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (AsyncGeneratorMethod \"MethodDefinitionEvaluation\" object enumerable)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Return ? MethodDefinitionEvaluation of |AsyncMethod| with arguments _object_ and _enumerable_."],
    "head": {
      "idx": 0,
      "methodName": "PropertyDefinitionEvaluation",
      "prod": "AsyncMethod",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "object"
      }, {
        "kind": "Normal",
        "name": "enumerable"
      }]
    },
    "ids": "sec-runtime-semantics-propertydefinitionevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (AsyncMethod \"MethodDefinitionEvaluation\" object enumerable)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Assert: _literal_ is a |RegularExpressionLiteral|.", "          1. If FlagText of _literal_ contains any code points other than `g`, `i`, `m`, `s`, `u`, or `y`, or if it contains the same code point more than once, return *false*.", "          1. Let _patternText_ be BodyText of _literal_.", "          1. If FlagText of _literal_ contains `u`, let _u_ be *true*; else let _u_ be *false*.", "          1. If _u_ is *false*, then", "            1. Let _stringValue_ be CodePointsToString(_patternText_).", "            1. Set _patternText_ to the sequence of code points resulting from interpreting each of the 16-bit elements of _stringValue_ as a Unicode BMP code point. UTF-16 decoding is not applied to the elements.", "          1. Let _parseResult_ be ParsePattern(_patternText_, _u_).", "          1. If _parseResult_ is a Parse Node, return *true*; else return *false*."],
    "head": {
      "name": "IsValidRegularExpressionLiteral",
      "params": [{
        "kind": "Normal",
        "name": "literal"
      }]
    },
    "ids": "sec-isvalidregularexpressionliteral",
    "rawBody": "{\n  0:assert (0) (is-instance-of literal RegularExpressionLiteral)\n  1:(1) ??? \"If FlagText of id:{literal} contains any code points other than code:{g} , code:{i} , code:{m} , code:{s} , code:{u} , or code:{y} , or if it contains the same code point more than once , return value:{false} .\"\n  2:(0) access __x0__ = (literal \"BodyText\")\n  2:let patternText = __x0__\n  3:(1) access __x1__ = (literal \"FlagText\")\n  3:if (contains __x1__ (2) ??? \"u\") let u = true else let u = false\n  4:if (= u false) {\n    5:(2) app __x2__ = (CodePointsToString patternText)\n    5:let stringValue = __x2__\n    6:(3) ??? \"Set id:{patternText} to the sequence of code points resulting from interpreting each of the 16 - bit elements of id:{stringValue} as a Unicode BMP code point . UTF - 16 decoding is not applied to the elements .\"\n  } else 8:{}\n  7:(3) app __x3__ = (ParsePattern patternText u)\n  7:let parseResult = __x3__\n  8:(4) ??? \"If id:{parseResult} is a Parse Node , return value:{true} ; else return value:{false} .\"\n}"
  }, {
    "code": ["          1. Let _pattern_ be ! CodePointsToString(BodyText of |RegularExpressionLiteral|).", "          1. Let _flags_ be ! CodePointsToString(FlagText of |RegularExpressionLiteral|).", "          1. Return RegExpCreate(_pattern_, _flags_)."],
    "head": {
      "idx": 10,
      "methodName": "Evaluation",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RegularExpressionLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-regular-expression-literals-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (RegularExpressionLiteral \"BodyText\")\n  0:(1) app __x1__ = (CodePointsToString __x0__)\n  0:let pattern = [! __x1__]\n  1:(2) access __x2__ = (RegularExpressionLiteral \"FlagText\")\n  1:(3) app __x3__ = (CodePointsToString __x2__)\n  1:let flags = [! __x3__]\n  2:(4) app __x4__ = (RegExpCreate pattern flags)\n  2:return __x4__\n}"
  }, {
    "code": ["          1. If _raw_ is *false*, then", "            1. Let _string_ be the TV of |NoSubstitutionTemplate|.", "          1. Else,", "            1. Let _string_ be the TRV of |NoSubstitutionTemplate|.", "          1. Return a List whose sole element is _string_."],
    "head": {
      "idx": 0,
      "methodName": "TemplateStrings",
      "prod": "TemplateLiteral",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "NoSubstitutionTemplate",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "raw"
      }]
    },
    "ids": "sec-static-semantics-templatestrings",
    "rawBody": "{\n  2:if (= raw false) {\n    1:(0) access __x0__ = (NoSubstitutionTemplate \"TV\")\n    1:let string = __x0__\n  } else {\n    3:(1) access __x1__ = (NoSubstitutionTemplate \"TRV\")\n    3:let string = __x1__\n  }\n  4:return (0) (new [string])\n}"
  }, {
    "code": ["          1. If _raw_ is *false*, then", "            1. Let _head_ be the TV of |TemplateHead|.", "          1. Else,", "            1. Let _head_ be the TRV of |TemplateHead|.", "          1. Let _tail_ be TemplateStrings of |TemplateSpans| with argument _raw_.", "          1. Return a List whose elements are _head_ followed by the elements of _tail_."],
    "head": {
      "idx": 0,
      "methodName": "TemplateStrings",
      "prod": "SubstitutionTemplate",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "TemplateHead",
          "optional": false
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "args": [],
          "name": "TemplateSpans",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "raw"
      }]
    },
    "ids": "sec-static-semantics-templatestrings",
    "rawBody": "{\n  2:if (= raw false) {\n    1:(0) access __x0__ = (TemplateHead \"TV\")\n    1:let head = __x0__\n  } else {\n    3:(1) access __x1__ = (TemplateHead \"TRV\")\n    3:let head = __x1__\n  }\n  4:(2) access __x2__ = (TemplateSpans \"TemplateStrings\" raw)\n  4:let tail = __x2__\n  5:let list = (0) (copy-obj tail)\n  5:prepend head -> list\n  5:return list\n}"
  }, {
    "code": ["          1. If _raw_ is *false*, then", "            1. Let _tail_ be the TV of |TemplateTail|.", "          1. Else,", "            1. Let _tail_ be the TRV of |TemplateTail|.", "          1. Return a List whose sole element is _tail_."],
    "head": {
      "idx": 0,
      "methodName": "TemplateStrings",
      "prod": "TemplateSpans",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "TemplateTail",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "raw"
      }]
    },
    "ids": "sec-static-semantics-templatestrings",
    "rawBody": "{\n  2:if (= raw false) {\n    1:(0) access __x0__ = (TemplateTail \"TV\")\n    1:let tail = __x0__\n  } else {\n    3:(1) access __x1__ = (TemplateTail \"TRV\")\n    3:let tail = __x1__\n  }\n  4:return (0) (new [tail])\n}"
  }, {
    "code": ["          1. Let _middle_ be TemplateStrings of |TemplateMiddleList| with argument _raw_.", "          1. If _raw_ is *false*, then", "            1. Let _tail_ be the TV of |TemplateTail|.", "          1. Else,", "            1. Let _tail_ be the TRV of |TemplateTail|.", "          1. Return a List whose elements are the elements of _middle_ followed by _tail_."],
    "head": {
      "idx": 1,
      "methodName": "TemplateStrings",
      "prod": "TemplateSpans",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "TemplateMiddleList",
          "optional": false
        }, {
          "args": [],
          "name": "TemplateTail",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "raw"
      }]
    },
    "ids": "sec-static-semantics-templatestrings",
    "rawBody": "{\n  0:(0) access __x0__ = (TemplateMiddleList \"TemplateStrings\" raw)\n  0:let middle = __x0__\n  3:if (= raw false) {\n    2:(1) access __x1__ = (TemplateTail \"TV\")\n    2:let tail = __x1__\n  } else {\n    4:(2) access __x2__ = (TemplateTail \"TRV\")\n    4:let tail = __x2__\n  }\n  5:let __x3__ = (0) (copy-obj middle)\n  5:append tail -> __x3__\n  5:return __x3__\n}"
  }, {
    "code": ["          1. If _raw_ is *false*, then", "            1. Let _string_ be the TV of |TemplateMiddle|.", "          1. Else,", "            1. Let _string_ be the TRV of |TemplateMiddle|.", "          1. Return a List whose sole element is _string_."],
    "head": {
      "idx": 0,
      "methodName": "TemplateStrings",
      "prod": "TemplateMiddleList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "TemplateMiddle",
          "optional": false
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "raw"
      }]
    },
    "ids": "sec-static-semantics-templatestrings",
    "rawBody": "{\n  2:if (= raw false) {\n    1:(0) access __x0__ = (TemplateMiddle \"TV\")\n    1:let string = __x0__\n  } else {\n    3:(1) access __x1__ = (TemplateMiddle \"TRV\")\n    3:let string = __x1__\n  }\n  4:return (0) (new [string])\n}"
  }, {
    "code": ["          1. Let _front_ be TemplateStrings of |TemplateMiddleList| with argument _raw_.", "          1. If _raw_ is *false*, then", "            1. Let _last_ be the TV of |TemplateMiddle|.", "          1. Else,", "            1. Let _last_ be the TRV of |TemplateMiddle|.", "          1. Append _last_ as the last element of the List _front_.", "          1. Return _front_."],
    "head": {
      "idx": 1,
      "methodName": "TemplateStrings",
      "prod": "TemplateMiddleList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "TemplateMiddleList",
          "optional": false
        }, {
          "args": [],
          "name": "TemplateMiddle",
          "optional": false
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "raw"
      }]
    },
    "ids": "sec-static-semantics-templatestrings",
    "rawBody": "{\n  0:(0) access __x0__ = (TemplateMiddleList \"TemplateStrings\" raw)\n  0:let front = __x0__\n  3:if (= raw false) {\n    2:(1) access __x1__ = (TemplateMiddle \"TV\")\n    2:let last = __x1__\n  } else {\n    4:(2) access __x2__ = (TemplateMiddle \"TRV\")\n    4:let last = __x2__\n  }\n  5:append last -> front\n  6:return front\n}"
  }, {
    "code": ["          1. Let _realm_ be the current Realm Record.", "          1. Let _templateRegistry_ be _realm_.[[TemplateMap]].", "          1. For each element _e_ of _templateRegistry_, do", "            1. If _e_.[[Site]] is the same Parse Node as _templateLiteral_, then", "              1. Return _e_.[[Array]].", "          1. Let _rawStrings_ be TemplateStrings of _templateLiteral_ with argument *true*.", "          1. Let _cookedStrings_ be TemplateStrings of _templateLiteral_ with argument *false*.", "          1. Let _count_ be the number of elements in the List _cookedStrings_.", "          1. Assert: _count_ ≤ 2<sup>32</sup> - 1.", "          1. Let _template_ be ! ArrayCreate(_count_).", "          1. Let _rawObj_ be ! ArrayCreate(_count_).", "          1. Let _index_ be 0.", "          1. Repeat, while _index_ < _count_,", "            1. Let _prop_ be ! ToString(𝔽(_index_)).", "            1. Let _cookedValue_ be _cookedStrings_[_index_].", "            1. Perform ! DefinePropertyOrThrow(_template_, _prop_, PropertyDescriptor { [[Value]]: _cookedValue_, [[Writable]]: *false*, [[Enumerable]]: *true*, [[Configurable]]: *false* }).", "            1. Let _rawValue_ be the String value _rawStrings_[_index_].", "            1. Perform ! DefinePropertyOrThrow(_rawObj_, _prop_, PropertyDescriptor { [[Value]]: _rawValue_, [[Writable]]: *false*, [[Enumerable]]: *true*, [[Configurable]]: *false* }).", "            1. Set _index_ to _index_ + 1.", "          1. Perform ! SetIntegrityLevel(_rawObj_, ~frozen~).", "          1. Perform ! DefinePropertyOrThrow(_template_, *\"raw\"*, PropertyDescriptor { [[Value]]: _rawObj_, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).", "          1. Perform ! SetIntegrityLevel(_template_, ~frozen~).", "          1. Append the Record { [[Site]]: _templateLiteral_, [[Array]]: _template_ } to _templateRegistry_.", "          1. Return _template_."],
    "head": {
      "name": "GetTemplateObject",
      "params": [{
        "kind": "Normal",
        "name": "templateLiteral"
      }]
    },
    "ids": "sec-gettemplateobject",
    "rawBody": "{\n  0:let realm = REALM\n  1:let templateRegistry = realm[\"TemplateMap\"]\n  2:let __x0__ = templateRegistry\n  2:let __x1__ = 0i\n  2:while (< __x1__ __x0__[\"length\"]) {\n    let e = __x0__[__x1__]\n    3:(0) ??? \"If id:{e} . [ [ Site ] ] is the same Parse Node as id:{templateLiteral} , then in:{} out:{}\"\n    __x1__ = (+ __x1__ 1i)\n  }\n  5:(0) access __x2__ = (templateLiteral \"TemplateStrings\" true)\n  5:let rawStrings = __x2__\n  6:(1) access __x3__ = (templateLiteral \"TemplateStrings\" false)\n  6:let cookedStrings = __x3__\n  7:let count = cookedStrings[\"length\"]\n  8:assert (! (< (- (** 2.0 32i) 1i) count))\n  9:(2) app __x4__ = (ArrayCreate count)\n  9:let template = [! __x4__]\n  10:(3) app __x5__ = (ArrayCreate count)\n  10:let rawObj = [! __x5__]\n  11:let index = 0i\n  12:while (< index count) {\n    13:(4) app __x6__ = (ToString index)\n    13:let prop = [! __x6__]\n    14:let cookedValue = cookedStrings[index]\n    15:(5) app __x7__ = (DefinePropertyOrThrow template prop (1) (new PropertyDescriptor(\"Value\" -> cookedValue, \"Writable\" -> false, \"Enumerable\" -> true, \"Configurable\" -> false)))\n    15:[! __x7__]\n    16:let rawValue = rawStrings[index]\n    17:(6) app __x8__ = (DefinePropertyOrThrow rawObj prop (2) (new PropertyDescriptor(\"Value\" -> rawValue, \"Writable\" -> false, \"Enumerable\" -> true, \"Configurable\" -> false)))\n    17:[! __x8__]\n    18:index = (+ index 1i)\n  }\n  19:(7) app __x9__ = (SetIntegrityLevel rawObj CONST_frozen)\n  19:[! __x9__]\n  20:(8) app __x10__ = (DefinePropertyOrThrow template \"raw\" (3) (new PropertyDescriptor(\"Value\" -> rawObj, \"Writable\" -> false, \"Enumerable\" -> false, \"Configurable\" -> false)))\n  20:[! __x10__]\n  21:(9) app __x11__ = (SetIntegrityLevel template CONST_frozen)\n  21:[! __x11__]\n  22:append (4) (new Record(\"Site\" -> templateLiteral, \"Array\" -> template)) -> templateRegistry\n  23:return template\n}"
  }, {
    "code": ["          1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "SubstitutionEvaluation",
      "prod": "TemplateSpans",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "TemplateTail",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-runtime-semantics-substitutionevaluation",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["          1. Return the result of SubstitutionEvaluation of |TemplateMiddleList|."],
    "head": {
      "idx": 1,
      "methodName": "SubstitutionEvaluation",
      "prod": "TemplateSpans",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "TemplateMiddleList",
          "optional": false
        }, {
          "args": [],
          "name": "TemplateTail",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-runtime-semantics-substitutionevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (TemplateMiddleList \"SubstitutionEvaluation\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Let _subRef_ be the result of evaluating |Expression|.", "          1. Let _sub_ be ? GetValue(_subRef_).", "          1. Return a List whose sole element is _sub_."],
    "head": {
      "idx": 0,
      "methodName": "SubstitutionEvaluation",
      "prod": "TemplateMiddleList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "TemplateMiddle",
          "optional": false
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-runtime-semantics-substitutionevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Expression \"Evaluation\")\n  0:let subRef = __x0__\n  1:(1) app __x1__ = (GetValue subRef)\n  1:let sub = [? __x1__]\n  2:return (0) (new [sub])\n}"
  }, {
    "code": ["          1. Let _preceding_ be ? SubstitutionEvaluation of |TemplateMiddleList|.", "          1. Let _nextRef_ be the result of evaluating |Expression|.", "          1. Let _next_ be ? GetValue(_nextRef_).", "          1. Append _next_ as the last element of the List _preceding_.", "          1. Return _preceding_."],
    "head": {
      "idx": 1,
      "methodName": "SubstitutionEvaluation",
      "prod": "TemplateMiddleList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "TemplateMiddleList",
          "optional": false
        }, {
          "args": [],
          "name": "TemplateMiddle",
          "optional": false
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-runtime-semantics-substitutionevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (TemplateMiddleList \"SubstitutionEvaluation\")\n  0:let preceding = [? __x0__]\n  1:(1) access __x1__ = (Expression \"Evaluation\")\n  1:let nextRef = __x1__\n  2:(2) app __x2__ = (GetValue nextRef)\n  2:let next = [? __x2__]\n  3:append next -> preceding\n  4:return preceding\n}"
  }, {
    "code": ["          1. Return the TV of |NoSubstitutionTemplate| as defined in <emu-xref href=\"#sec-template-literal-lexical-components\"></emu-xref>."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "TemplateLiteral",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "NoSubstitutionTemplate",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-template-literals-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (NoSubstitutionTemplate \"TV\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Let _head_ be the TV of |TemplateHead| as defined in <emu-xref href=\"#sec-template-literal-lexical-components\"></emu-xref>.", "          1. Let _subRef_ be the result of evaluating |Expression|.", "          1. Let _sub_ be ? GetValue(_subRef_).", "          1. Let _middle_ be ? ToString(_sub_).", "          1. Let _tail_ be the result of evaluating |TemplateSpans|.", "          1. ReturnIfAbrupt(_tail_).", "          1. Return the string-concatenation of _head_, _middle_, and _tail_."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "SubstitutionTemplate",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "TemplateHead",
          "optional": false
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "args": [],
          "name": "TemplateSpans",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-template-literals-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (TemplateHead \"TV\")\n  0:let head = __x0__\n  1:(1) access __x1__ = (Expression \"Evaluation\")\n  1:let subRef = __x1__\n  2:(2) app __x2__ = (GetValue subRef)\n  2:let sub = [? __x2__]\n  3:(3) app __x3__ = (ToString sub)\n  3:let middle = [? __x3__]\n  4:(4) access __x4__ = (TemplateSpans \"Evaluation\")\n  4:let tail = __x4__\n  5:[? tail]\n  6:return (+ (+ head middle) tail)\n}"
  }, {
    "code": ["          1. Return the TV of |TemplateTail| as defined in <emu-xref href=\"#sec-template-literal-lexical-components\"></emu-xref>."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "TemplateSpans",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "TemplateTail",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-template-literals-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (TemplateTail \"TV\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Let _head_ be the result of evaluating |TemplateMiddleList|.", "          1. ReturnIfAbrupt(_head_).", "          1. Let _tail_ be the TV of |TemplateTail| as defined in <emu-xref href=\"#sec-template-literal-lexical-components\"></emu-xref>.", "          1. Return the string-concatenation of _head_ and _tail_."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "TemplateSpans",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "TemplateMiddleList",
          "optional": false
        }, {
          "args": [],
          "name": "TemplateTail",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-template-literals-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (TemplateMiddleList \"Evaluation\")\n  0:let head = __x0__\n  1:[? head]\n  2:(1) access __x1__ = (TemplateTail \"TV\")\n  2:let tail = __x1__\n  3:return (+ head tail)\n}"
  }, {
    "code": ["          1. Let _head_ be the TV of |TemplateMiddle| as defined in <emu-xref href=\"#sec-template-literal-lexical-components\"></emu-xref>.", "          1. Let _subRef_ be the result of evaluating |Expression|.", "          1. Let _sub_ be ? GetValue(_subRef_).", "          1. Let _middle_ be ? ToString(_sub_).", "          1. Return the string-concatenation of _head_ and _middle_."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "TemplateMiddleList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "TemplateMiddle",
          "optional": false
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-template-literals-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (TemplateMiddle \"TV\")\n  0:let head = __x0__\n  1:(1) access __x1__ = (Expression \"Evaluation\")\n  1:let subRef = __x1__\n  2:(2) app __x2__ = (GetValue subRef)\n  2:let sub = [? __x2__]\n  3:(3) app __x3__ = (ToString sub)\n  3:let middle = [? __x3__]\n  4:return (+ head middle)\n}"
  }, {
    "code": ["          1. Let _rest_ be the result of evaluating |TemplateMiddleList|.", "          1. ReturnIfAbrupt(_rest_).", "          1. Let _middle_ be the TV of |TemplateMiddle| as defined in <emu-xref href=\"#sec-template-literal-lexical-components\"></emu-xref>.", "          1. Let _subRef_ be the result of evaluating |Expression|.", "          1. Let _sub_ be ? GetValue(_subRef_).", "          1. Let _last_ be ? ToString(_sub_).", "          1. Return the string-concatenation of _rest_, _middle_, and _last_."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "TemplateMiddleList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "TemplateMiddleList",
          "optional": false
        }, {
          "args": [],
          "name": "TemplateMiddle",
          "optional": false
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-template-literals-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (TemplateMiddleList \"Evaluation\")\n  0:let rest = __x0__\n  1:[? rest]\n  2:(1) access __x1__ = (TemplateMiddle \"TV\")\n  2:let middle = __x1__\n  3:(2) access __x2__ = (Expression \"Evaluation\")\n  3:let subRef = __x2__\n  4:(3) app __x3__ = (GetValue subRef)\n  4:let sub = [? __x3__]\n  5:(4) app __x4__ = (ToString sub)\n  5:let last = [? __x4__]\n  6:return (+ (+ rest middle) last)\n}"
  }, {
    "code": ["          1. Let _expr_ be CoveredParenthesizedExpression of |CoverParenthesizedExpressionAndArrowParameterList|.", "          1. Return the result of evaluating _expr_."],
    "head": {
      "idx": 12,
      "methodName": "Evaluation",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CoverParenthesizedExpressionAndArrowParameterList",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-grouping-operator-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (CoverParenthesizedExpressionAndArrowParameterList \"CoveredParenthesizedExpression\")\n  0:let expr = __x0__\n  1:(1) access __x1__ = (expr \"Evaluation\")\n  1:return __x1__\n}"
  }, {
    "code": ["          1. Return the result of evaluating |Expression|. This may be of type Reference."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "ParenthesizedExpression",
      "rhs": {
        "tokens": [{
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-grouping-operator-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Expression \"Evaluation\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return the |CallMemberExpression| that is covered by |CoverCallExpressionAndAsyncArrowHead|."],
    "head": {
      "idx": 0,
      "methodName": "CoveredCallExpression",
      "prod": "CoverCallExpressionAndAsyncArrowHead",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "args": [],
          "name": "Arguments",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-left-hand-side-expressions-static-semantics-coveredcallexpression",
    "rawBody": "return (parse-syntax CoverCallExpressionAndAsyncArrowHead \"CallMemberExpression\" (0) (new []))"
  }, {
    "code": ["          1. Let _baseReference_ be the result of evaluating |MemberExpression|.", "          1. Let _baseValue_ be ? GetValue(_baseReference_).", "          1. If the code matched by this |MemberExpression| is strict mode code, let _strict_ be *true*; else let _strict_ be *false*.", "          1. Return ? EvaluatePropertyAccessWithExpressionKey(_baseValue_, |Expression|, _strict_)."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "term": "["
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": "]"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-property-accessors-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (MemberExpression \"Evaluation\")\n  0:let baseReference = __x0__\n  1:(1) app __x1__ = (GetValue baseReference)\n  1:let baseValue = [? __x1__]\n  2:if true let strict = true else let strict = false\n  3:(2) app __x2__ = (EvaluatePropertyAccessWithExpressionKey baseValue Expression strict)\n  3:return [? __x2__]\n}"
  }, {
    "code": ["          1. Let _baseReference_ be the result of evaluating |MemberExpression|.", "          1. Let _baseValue_ be ? GetValue(_baseReference_).", "          1. If the code matched by this |MemberExpression| is strict mode code, let _strict_ be *true*; else let _strict_ be *false*.", "          1. Return ? EvaluatePropertyAccessWithIdentifierKey(_baseValue_, |IdentifierName|, _strict_)."],
    "head": {
      "idx": 2,
      "methodName": "Evaluation",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "term": "."
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-property-accessors-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (MemberExpression \"Evaluation\")\n  0:let baseReference = __x0__\n  1:(1) app __x1__ = (GetValue baseReference)\n  1:let baseValue = [? __x1__]\n  2:if true let strict = true else let strict = false\n  3:(2) app __x2__ = (EvaluatePropertyAccessWithIdentifierKey baseValue IdentifierName strict)\n  3:return [? __x2__]\n}"
  }, {
    "code": ["          1. Let _baseReference_ be the result of evaluating |CallExpression|.", "          1. Let _baseValue_ be ? GetValue(_baseReference_).", "          1. If the code matched by this |CallExpression| is strict mode code, let _strict_ be *true*; else let _strict_ be *false*.", "          1. Return ? EvaluatePropertyAccessWithExpressionKey(_baseValue_, |Expression|, _strict_)."],
    "head": {
      "idx": 4,
      "methodName": "Evaluation",
      "prod": "CallExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CallExpression",
          "optional": false
        }, {
          "term": "["
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": "]"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-property-accessors-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (CallExpression \"Evaluation\")\n  0:let baseReference = __x0__\n  1:(1) app __x1__ = (GetValue baseReference)\n  1:let baseValue = [? __x1__]\n  2:if true let strict = true else let strict = false\n  3:(2) app __x2__ = (EvaluatePropertyAccessWithExpressionKey baseValue Expression strict)\n  3:return [? __x2__]\n}"
  }, {
    "code": ["          1. Let _baseReference_ be the result of evaluating |CallExpression|.", "          1. Let _baseValue_ be ? GetValue(_baseReference_).", "          1. If the code matched by this |CallExpression| is strict mode code, let _strict_ be *true*; else let _strict_ be *false*.", "          1. Return ? EvaluatePropertyAccessWithIdentifierKey(_baseValue_, |IdentifierName|, _strict_)."],
    "head": {
      "idx": 5,
      "methodName": "Evaluation",
      "prod": "CallExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CallExpression",
          "optional": false
        }, {
          "term": "."
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-property-accessors-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (CallExpression \"Evaluation\")\n  0:let baseReference = __x0__\n  1:(1) app __x1__ = (GetValue baseReference)\n  1:let baseValue = [? __x1__]\n  2:if true let strict = true else let strict = false\n  3:(2) app __x2__ = (EvaluatePropertyAccessWithIdentifierKey baseValue IdentifierName strict)\n  3:return [? __x2__]\n}"
  }, {
    "code": ["        1. Let _propertyNameReference_ be the result of evaluating _expression_.", "        1. Let _propertyNameValue_ be ? GetValue(_propertyNameReference_).", "        1. Let _bv_ be ? RequireObjectCoercible(_baseValue_).", "        1. Let _propertyKey_ be ? ToPropertyKey(_propertyNameValue_).", "        1. Return the Reference Record { [[Base]]: _bv_, [[ReferencedName]]: _propertyKey_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ }."],
    "head": {
      "name": "EvaluatePropertyAccessWithExpressionKey",
      "params": [{
        "kind": "Normal",
        "name": "baseValue"
      }, {
        "kind": "Normal",
        "name": "expression"
      }, {
        "kind": "Normal",
        "name": "strict"
      }]
    },
    "ids": "sec-evaluate-property-access-with-expression-key",
    "rawBody": "{\n  0:(0) access __x0__ = (expression \"Evaluation\")\n  0:let propertyNameReference = __x0__\n  1:(1) app __x1__ = (GetValue propertyNameReference)\n  1:let propertyNameValue = [? __x1__]\n  2:(2) app __x2__ = (RequireObjectCoercible baseValue)\n  2:let bv = [? __x2__]\n  3:(3) app __x3__ = (ToPropertyKey propertyNameValue)\n  3:let propertyKey = [? __x3__]\n  4:return (0) (new ReferenceRecord(\"Base\" -> bv, \"ReferencedName\" -> propertyKey, \"Strict\" -> strict, \"ThisValue\" -> CONST_empty))\n}"
  }, {
    "code": ["        1. Assert: _identifierName_ is an |IdentifierName|.", "        1. Let _bv_ be ? RequireObjectCoercible(_baseValue_).", "        1. Let _propertyNameString_ be StringValue of _identifierName_.", "        1. Return the Reference Record { [[Base]]: _bv_, [[ReferencedName]]: _propertyNameString_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ }."],
    "head": {
      "name": "EvaluatePropertyAccessWithIdentifierKey",
      "params": [{
        "kind": "Normal",
        "name": "baseValue"
      }, {
        "kind": "Normal",
        "name": "identifierName"
      }, {
        "kind": "Normal",
        "name": "strict"
      }]
    },
    "ids": "sec-evaluate-property-access-with-identifier-key",
    "rawBody": "{\n  0:assert (0) (is-instance-of identifierName IdentifierName)\n  1:(0) app __x0__ = (RequireObjectCoercible baseValue)\n  1:let bv = [? __x0__]\n  2:(1) access __x1__ = (identifierName \"StringValue\")\n  2:let propertyNameString = __x1__\n  3:return (1) (new ReferenceRecord(\"Base\" -> bv, \"ReferencedName\" -> propertyNameString, \"Strict\" -> strict, \"ThisValue\" -> CONST_empty))\n}"
  }, {
    "code": ["          1. Return ? EvaluateNew(|NewExpression|, ~empty~)."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "NewExpression",
      "rhs": {
        "tokens": [{
          "term": "new"
        }, {
          "args": [],
          "name": "NewExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-new-operator-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (EvaluateNew NewExpression CONST_empty)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Return ? EvaluateNew(|MemberExpression|, |Arguments|)."],
    "head": {
      "idx": 6,
      "methodName": "Evaluation",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "term": "new"
        }, {
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "args": [],
          "name": "Arguments",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-new-operator-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (EvaluateNew MemberExpression Arguments)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["            1. Assert: _constructExpr_ is either a |NewExpression| or a |MemberExpression|.", "            1. Assert: _arguments_ is either ~empty~ or an |Arguments|.", "            1. Let _ref_ be the result of evaluating _constructExpr_.", "            1. Let _constructor_ be ? GetValue(_ref_).", "            1. If _arguments_ is ~empty~, let _argList_ be a new empty List.", "            1. Else,", "              1. Let _argList_ be ? ArgumentListEvaluation of _arguments_.", "            1. If IsConstructor(_constructor_) is *false*, throw a *TypeError* exception.", "            1. Return ? Construct(_constructor_, _argList_)."],
    "head": {
      "name": "EvaluateNew",
      "params": [{
        "kind": "Normal",
        "name": "constructExpr"
      }, {
        "kind": "Normal",
        "name": "arguments"
      }]
    },
    "ids": "sec-evaluatenew",
    "rawBody": "{\n  0:assert (|| (0) (is-instance-of constructExpr NewExpression) (1) (is-instance-of constructExpr MemberExpression))\n  1:assert (|| (= arguments CONST_empty) (2) (is-instance-of arguments Arguments))\n  2:(0) access __x0__ = (constructExpr \"Evaluation\")\n  2:let ref = __x0__\n  3:(1) app __x1__ = (GetValue ref)\n  3:let constructor = [? __x1__]\n  5:if (= arguments CONST_empty) let argList = (3) (new []) else {\n    6:(2) access __x2__ = (arguments \"ArgumentListEvaluation\")\n    6:let argList = [? __x2__]\n  }\n  7:(3) app __x3__ = (IsConstructor constructor)\n  7:if (= __x3__ false) (4) throw TypeError else 8:{}\n  8:(4) app __x4__ = (Construct constructor argList)\n  8:return [? __x4__]\n}"
  }, {
    "code": ["          1. Let _expr_ be CoveredCallExpression of |CoverCallExpressionAndAsyncArrowHead|.", "          1. Let _memberExpr_ be the |MemberExpression| of _expr_.", "          1. Let _arguments_ be the |Arguments| of _expr_.", "          1. Let _ref_ be the result of evaluating _memberExpr_.", "          1. Let _func_ be ? GetValue(_ref_).", "          1. If _ref_ is a Reference Record, IsPropertyReference(_ref_) is *false*, and _ref_.[[ReferencedName]] is *\"eval\"*, then", "            1. If SameValue(_func_, %eval%) is *true*, then", "              1. Let _argList_ be ? ArgumentListEvaluation of _arguments_.", "              1. If _argList_ has no elements, return *undefined*.", "              1. Let _evalArg_ be the first element of _argList_.", "              1. If the source code matching this |CallExpression| is strict mode code, let _strictCaller_ be *true*. Otherwise let _strictCaller_ be *false*.", "              1. Let _evalRealm_ be the current Realm Record.", "              1. [id=\"step-callexpression-evaluation-direct-eval\"] Return ? PerformEval(_evalArg_, _evalRealm_, _strictCaller_, *true*).", "          1. Let _thisCall_ be this |CallExpression|.", "          1. Let _tailCall_ be IsInTailPosition(_thisCall_).", "          1. Return ? EvaluateCall(_func_, _ref_, _arguments_, _tailCall_)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "CallExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CoverCallExpressionAndAsyncArrowHead",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-function-calls-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (CoverCallExpressionAndAsyncArrowHead \"CoveredCallExpression\")\n  0:let expr = __x0__\n  1:(1) access __x1__ = (expr \"MemberExpression\")\n  1:let memberExpr = __x1__\n  2:(2) access __x2__ = (expr \"Arguments\")\n  2:let arguments = __x2__\n  3:(3) access __x3__ = (memberExpr \"Evaluation\")\n  3:let ref = __x3__\n  4:(4) app __x4__ = (GetValue ref)\n  4:let func = [? __x4__]\n  5:let __x5__ = true\n  5:__x5__ = (0) (is-instance-of ref ReferenceRecord)\n  5:if __x5__ {\n    (5) app __x6__ = (IsPropertyReference ref)\n    __x5__ = (= __x6__ false)\n    if __x5__ __x5__ = (= ref[\"ReferencedName\"] \"eval\") else 8:{}\n  } else 8:{}\n  5:if __x5__ {\n    6:(6) app __x7__ = (SameValue func INTRINSIC_eval)\n    6:if (= __x7__ true) {\n      7:(7) access __x8__ = (arguments \"ArgumentListEvaluation\")\n      7:let argList = [? __x8__]\n      8:if (= argList[\"length\"] 0i) return undefined else 8:{}\n      9:let evalArg = argList[0i]\n      10:if true let strictCaller = true else let strictCaller = false\n      11:let evalRealm = REALM\n      12:(8) app __x9__ = (PerformEval evalArg evalRealm strictCaller true)\n      12:return [? __x9__]\n    } else 8:{}\n  } else 8:{}\n  13:let thisCall = this\n  14:(9) app __x10__ = (IsInTailPosition thisCall)\n  14:let tailCall = __x10__\n  15:(10) app __x11__ = (EvaluateCall func ref arguments tailCall)\n  15:return [? __x11__]\n}"
  }, {
    "code": ["          1. Let _ref_ be the result of evaluating |CallExpression|.", "          1. Let _func_ be ? GetValue(_ref_).", "          1. Let _thisCall_ be this |CallExpression|.", "          1. Let _tailCall_ be IsInTailPosition(_thisCall_).", "          1. Return ? EvaluateCall(_func_, _ref_, |Arguments|, _tailCall_)."],
    "head": {
      "idx": 3,
      "methodName": "Evaluation",
      "prod": "CallExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CallExpression",
          "optional": false
        }, {
          "args": [],
          "name": "Arguments",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-function-calls-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (CallExpression \"Evaluation\")\n  0:let ref = __x0__\n  1:(1) app __x1__ = (GetValue ref)\n  1:let func = [? __x1__]\n  2:let thisCall = this\n  3:(2) app __x2__ = (IsInTailPosition thisCall)\n  3:let tailCall = __x2__\n  4:(3) app __x3__ = (EvaluateCall func ref Arguments tailCall)\n  4:return [? __x3__]\n}"
  }, {
    "code": ["          1. If _ref_ is a Reference Record, then", "            1. If IsPropertyReference(_ref_) is *true*, then", "              1. Let _thisValue_ be GetThisValue(_ref_).", "            1. Else,", "              1. Let _refEnv_ be _ref_.[[Base]].", "              1. Assert: _refEnv_ is an Environment Record.", "              1. Let _thisValue_ be _refEnv_.WithBaseObject().", "          1. Else,", "            1. Let _thisValue_ be *undefined*.", "          1. Let _argList_ be ? ArgumentListEvaluation of _arguments_.", "          1. If Type(_func_) is not Object, throw a *TypeError* exception.", "          1. If IsCallable(_func_) is *false*, throw a *TypeError* exception.", "          1. If _tailPosition_ is *true*, perform PrepareForTailCall().", "          1. Let _result_ be Call(_func_, _thisValue_, _argList_).", "          1. Assert: If _tailPosition_ is *true*, the above call will not return here, but instead evaluation will continue as if the following return has already occurred.", "          1. Assert: If _result_ is not an abrupt completion, then Type(_result_) is an ECMAScript language type.", "          1. Return _result_."],
    "head": {
      "name": "EvaluateCall",
      "params": [{
        "kind": "Normal",
        "name": "func"
      }, {
        "kind": "Normal",
        "name": "ref"
      }, {
        "kind": "Normal",
        "name": "arguments"
      }, {
        "kind": "Normal",
        "name": "tailPosition"
      }]
    },
    "ids": "sec-evaluatecall",
    "rawBody": "{\n  7:if (0) (is-instance-of ref ReferenceRecord) {\n    3:(0) app __x0__ = (IsPropertyReference ref)\n    3:if (= __x0__ true) {\n      2:(1) app __x1__ = (GetThisValue ref)\n      2:let thisValue = __x1__\n    } else {\n      4:let refEnv = ref[\"Base\"]\n      5:assert (1) (is-instance-of refEnv EnvironmentRecord)\n      6:(2) app __x2__ = (refEnv[\"WithBaseObject\"] refEnv)\n      6:let thisValue = __x2__\n    }\n  } else let thisValue = undefined\n  9:(3) access __x3__ = (arguments \"ArgumentListEvaluation\")\n  9:let argList = [? __x3__]\n  10:if (! (= (typeof func) Object)) (2) throw TypeError else 15:{}\n  11:(4) app __x4__ = (IsCallable func)\n  11:if (= __x4__ false) (3) throw TypeError else 15:{}\n  12:if (= tailPosition true) {\n    (5) app __x5__ = (PrepareForTailCall)\n    __x5__\n  } else 15:{}\n  13:(6) app __x6__ = (Call func thisValue argList)\n  13:let result = __x6__\n  16:return result\n}"
  }, {
    "code": ["          1. Let _env_ be GetThisEnvironment().", "          1. Let _actualThis_ be ? _env_.GetThisBinding().", "          1. Let _propertyNameReference_ be the result of evaluating |Expression|.", "          1. Let _propertyNameValue_ be ? GetValue(_propertyNameReference_).", "          1. Let _propertyKey_ be ? ToPropertyKey(_propertyNameValue_).", "          1. If the code matched by this |SuperProperty| is strict mode code, let _strict_ be *true*; else let _strict_ be *false*.", "          1. Return ? MakeSuperPropertyReference(_actualThis_, _propertyKey_, _strict_)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "SuperProperty",
      "rhs": {
        "tokens": [{
          "term": "super"
        }, {
          "term": "["
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": "]"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-super-keyword-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (GetThisEnvironment)\n  0:let env = __x0__\n  1:(1) app __x1__ = (env[\"GetThisBinding\"] env)\n  1:let actualThis = [? __x1__]\n  2:(2) access __x2__ = (Expression \"Evaluation\")\n  2:let propertyNameReference = __x2__\n  3:(3) app __x3__ = (GetValue propertyNameReference)\n  3:let propertyNameValue = [? __x3__]\n  4:(4) app __x4__ = (ToPropertyKey propertyNameValue)\n  4:let propertyKey = [? __x4__]\n  5:if true let strict = true else let strict = false\n  6:(5) app __x5__ = (MakeSuperPropertyReference actualThis propertyKey strict)\n  6:return [? __x5__]\n}"
  }, {
    "code": ["          1. Let _env_ be GetThisEnvironment().", "          1. Let _actualThis_ be ? _env_.GetThisBinding().", "          1. Let _propertyKey_ be StringValue of |IdentifierName|.", "          1. If the code matched by this |SuperProperty| is strict mode code, let _strict_ be *true*; else let _strict_ be *false*.", "          1. Return ? MakeSuperPropertyReference(_actualThis_, _propertyKey_, _strict_)."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "SuperProperty",
      "rhs": {
        "tokens": [{
          "term": "super"
        }, {
          "term": "."
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-super-keyword-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (GetThisEnvironment)\n  0:let env = __x0__\n  1:(1) app __x1__ = (env[\"GetThisBinding\"] env)\n  1:let actualThis = [? __x1__]\n  2:(2) access __x2__ = (IdentifierName \"StringValue\")\n  2:let propertyKey = __x2__\n  3:if true let strict = true else let strict = false\n  4:(3) app __x3__ = (MakeSuperPropertyReference actualThis propertyKey strict)\n  4:return [? __x3__]\n}"
  }, {
    "code": ["          1. Let _newTarget_ be GetNewTarget().", "          1. Assert: Type(_newTarget_) is Object.", "          1. Let _func_ be ! GetSuperConstructor().", "          1. Let _argList_ be ? ArgumentListEvaluation of |Arguments|.", "          1. If IsConstructor(_func_) is *false*, throw a *TypeError* exception.", "          1. Let _result_ be ? Construct(_func_, _argList_, _newTarget_).", "          1. Let _thisER_ be GetThisEnvironment().", "          1. Return ? _thisER_.BindThisValue(_result_)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "SuperCall",
      "rhs": {
        "tokens": [{
          "term": "super"
        }, {
          "args": [],
          "name": "Arguments",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-super-keyword-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (GetNewTarget)\n  0:let newTarget = __x0__\n  1:assert (= (typeof newTarget) Object)\n  2:(1) app __x1__ = (GetSuperConstructor)\n  2:let func = [! __x1__]\n  3:(2) access __x2__ = (Arguments \"ArgumentListEvaluation\")\n  3:let argList = [? __x2__]\n  4:(3) app __x3__ = (IsConstructor func)\n  4:if (= __x3__ false) (0) throw TypeError else 15:{}\n  5:(4) app __x4__ = (Construct func argList newTarget)\n  5:let result = [? __x4__]\n  6:(5) app __x5__ = (GetThisEnvironment)\n  6:let thisER = __x5__\n  7:(6) app __x6__ = (thisER[\"BindThisValue\"] thisER result)\n  7:return [? __x6__]\n}"
  }, {
    "code": ["          1. Let _envRec_ be GetThisEnvironment().", "          1. Assert: _envRec_ is a function Environment Record.", "          1. Let _activeFunction_ be _envRec_.[[FunctionObject]].", "          1. Assert: _activeFunction_ is an ECMAScript function object.", "          1. Let _superConstructor_ be ! _activeFunction_.[[GetPrototypeOf]]().", "          1. Return _superConstructor_."],
    "head": {
      "name": "GetSuperConstructor",
      "params": []
    },
    "ids": "sec-getsuperconstructor",
    "rawBody": "{\n  0:(0) app __x0__ = (GetThisEnvironment)\n  0:let envRec = __x0__\n  1:assert (0) (is-instance-of envRec FunctionEnvironmentRecord)\n  2:let activeFunction = envRec[\"FunctionObject\"]\n  3:assert (1) (is-instance-of activeFunction ECMAScriptFunctionObject)\n  4:(1) app __x1__ = (activeFunction[\"GetPrototypeOf\"] activeFunction)\n  4:let superConstructor = [! __x1__]\n  5:return superConstructor\n}"
  }, {
    "code": ["          1. Let _env_ be GetThisEnvironment().", "          1. Assert: _env_.HasSuperBinding() is *true*.", "          1. Let _baseValue_ be ? _env_.GetSuperBase().", "          1. Let _bv_ be ? RequireObjectCoercible(_baseValue_).", "          1. Return the Reference Record { [[Base]]: _bv_, [[ReferencedName]]: _propertyKey_, [[Strict]]: _strict_, [[ThisValue]]: _actualThis_ }.", "          1. NOTE: This returns a Super Reference Record."],
    "head": {
      "name": "MakeSuperPropertyReference",
      "params": [{
        "kind": "Normal",
        "name": "actualThis"
      }, {
        "kind": "Normal",
        "name": "propertyKey"
      }, {
        "kind": "Normal",
        "name": "strict"
      }]
    },
    "ids": "sec-makesuperpropertyreference",
    "rawBody": "{\n  0:(0) app __x0__ = (GetThisEnvironment)\n  0:let env = __x0__\n  1:(1) app __x1__ = (env[\"HasSuperBinding\"] env)\n  1:assert (= __x1__ true)\n  2:(2) app __x2__ = (env[\"GetSuperBase\"] env)\n  2:let baseValue = [? __x2__]\n  3:(3) app __x3__ = (RequireObjectCoercible baseValue)\n  3:let bv = [? __x3__]\n  4:return (0) (new ReferenceRecord(\"Base\" -> bv, \"ReferencedName\" -> propertyKey, \"Strict\" -> strict, \"ThisValue\" -> actualThis))\n}"
  }, {
    "code": ["          1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "ArgumentListEvaluation",
      "prod": "Arguments",
      "rhs": {
        "tokens": [{
          "term": "("
        }, {
          "term": ")"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-runtime-semantics-argumentlistevaluation",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["          1. Let _ref_ be the result of evaluating |AssignmentExpression|.", "          1. Let _arg_ be ? GetValue(_ref_).", "          1. Return a List whose sole element is _arg_."],
    "head": {
      "idx": 0,
      "methodName": "ArgumentListEvaluation",
      "prod": "ArgumentList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-runtime-semantics-argumentlistevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (AssignmentExpression \"Evaluation\")\n  0:let ref = __x0__\n  1:(1) app __x1__ = (GetValue ref)\n  1:let arg = [? __x1__]\n  2:return (0) (new [arg])\n}"
  }, {
    "code": ["          1. Let _list_ be a new empty List.", "          1. Let _spreadRef_ be the result of evaluating |AssignmentExpression|.", "          1. Let _spreadObj_ be ? GetValue(_spreadRef_).", "          1. Let _iteratorRecord_ be ? GetIterator(_spreadObj_).", "          1. Repeat,", "            1. Let _next_ be ? IteratorStep(_iteratorRecord_).", "            1. If _next_ is *false*, return _list_.", "            1. Let _nextArg_ be ? IteratorValue(_next_).", "            1. Append _nextArg_ as the last element of _list_."],
    "head": {
      "idx": 1,
      "methodName": "ArgumentListEvaluation",
      "prod": "ArgumentList",
      "rhs": {
        "tokens": [{
          "term": "..."
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-runtime-semantics-argumentlistevaluation",
    "rawBody": "{\n  0:let list = (0) (new [])\n  1:(0) access __x0__ = (AssignmentExpression \"Evaluation\")\n  1:let spreadRef = __x0__\n  2:(1) app __x1__ = (GetValue spreadRef)\n  2:let spreadObj = [? __x1__]\n  3:(2) app __x2__ = (GetIterator spreadObj)\n  3:let iteratorRecord = [? __x2__]\n  4:while true {\n    5:(3) app __x3__ = (IteratorStep iteratorRecord)\n    5:let next = [? __x3__]\n    6:if (= next false) return list else 5:{}\n    7:(4) app __x4__ = (IteratorValue next)\n    7:let nextArg = [? __x4__]\n    8:append nextArg -> list\n  }\n}"
  }, {
    "code": ["          1. Let _precedingArgs_ be ? ArgumentListEvaluation of |ArgumentList|.", "          1. Let _ref_ be the result of evaluating |AssignmentExpression|.", "          1. Let _arg_ be ? GetValue(_ref_).", "          1. Append _arg_ to the end of _precedingArgs_.", "          1. Return _precedingArgs_."],
    "head": {
      "idx": 2,
      "methodName": "ArgumentListEvaluation",
      "prod": "ArgumentList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ArgumentList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-runtime-semantics-argumentlistevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (ArgumentList \"ArgumentListEvaluation\")\n  0:let precedingArgs = [? __x0__]\n  1:(1) access __x1__ = (AssignmentExpression \"Evaluation\")\n  1:let ref = __x1__\n  2:(2) app __x2__ = (GetValue ref)\n  2:let arg = [? __x2__]\n  3:append arg -> precedingArgs\n  4:return precedingArgs\n}"
  }, {
    "code": ["          1. Let _precedingArgs_ be ? ArgumentListEvaluation of |ArgumentList|.", "          1. Let _spreadRef_ be the result of evaluating |AssignmentExpression|.", "          1. Let _iteratorRecord_ be ? GetIterator(? GetValue(_spreadRef_)).", "          1. Repeat,", "            1. Let _next_ be ? IteratorStep(_iteratorRecord_).", "            1. If _next_ is *false*, return _precedingArgs_.", "            1. Let _nextArg_ be ? IteratorValue(_next_).", "            1. Append _nextArg_ as the last element of _precedingArgs_."],
    "head": {
      "idx": 3,
      "methodName": "ArgumentListEvaluation",
      "prod": "ArgumentList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ArgumentList",
          "optional": false
        }, {
          "term": ","
        }, {
          "term": "..."
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-runtime-semantics-argumentlistevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (ArgumentList \"ArgumentListEvaluation\")\n  0:let precedingArgs = [? __x0__]\n  1:(1) access __x1__ = (AssignmentExpression \"Evaluation\")\n  1:let spreadRef = __x1__\n  2:(2) app __x2__ = (GetValue spreadRef)\n  2:(3) app __x3__ = (GetIterator [? __x2__])\n  2:let iteratorRecord = [? __x3__]\n  3:while true {\n    4:(4) app __x4__ = (IteratorStep iteratorRecord)\n    4:let next = [? __x4__]\n    5:if (= next false) return precedingArgs else 5:{}\n    6:(5) app __x5__ = (IteratorValue next)\n    6:let nextArg = [? __x5__]\n    7:append nextArg -> precedingArgs\n  }\n}"
  }, {
    "code": ["          1. Let _templateLiteral_ be this |TemplateLiteral|.", "          1. Let _siteObj_ be GetTemplateObject(_templateLiteral_).", "          1. Return a List whose sole element is _siteObj_."],
    "head": {
      "idx": 0,
      "methodName": "ArgumentListEvaluation",
      "prod": "TemplateLiteral",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "NoSubstitutionTemplate",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-runtime-semantics-argumentlistevaluation",
    "rawBody": "{\n  0:let templateLiteral = this\n  1:(0) app __x0__ = (GetTemplateObject templateLiteral)\n  1:let siteObj = __x0__\n  2:return (0) (new [siteObj])\n}"
  }, {
    "code": ["          1. Let _templateLiteral_ be this |TemplateLiteral|.", "          1. Let _siteObj_ be GetTemplateObject(_templateLiteral_).", "          1. Let _remaining_ be ? ArgumentListEvaluation of |SubstitutionTemplate|.", "          1. Return a List whose first element is _siteObj_ and whose subsequent elements are the elements of _remaining_."],
    "head": {
      "idx": 1,
      "methodName": "ArgumentListEvaluation",
      "prod": "TemplateLiteral",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "SubstitutionTemplate",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-runtime-semantics-argumentlistevaluation",
    "rawBody": "{\n  0:let templateLiteral = this\n  1:(0) app __x0__ = (GetTemplateObject templateLiteral)\n  1:let siteObj = __x0__\n  2:(1) access __x1__ = (SubstitutionTemplate \"ArgumentListEvaluation\")\n  2:let remaining = [? __x1__]\n  3:return (0) (new [siteObj, remaining])\n}"
  }, {
    "code": ["          1. Let _firstSubRef_ be the result of evaluating |Expression|.", "          1. Let _firstSub_ be ? GetValue(_firstSubRef_).", "          1. Let _restSub_ be ? SubstitutionEvaluation of |TemplateSpans|.", "          1. Assert: _restSub_ is a List.", "          1. Return a List whose first element is _firstSub_ and whose subsequent elements are the elements of _restSub_. _restSub_ may contain no elements."],
    "head": {
      "idx": 0,
      "methodName": "ArgumentListEvaluation",
      "prod": "SubstitutionTemplate",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "TemplateHead",
          "optional": false
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "args": [],
          "name": "TemplateSpans",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-runtime-semantics-argumentlistevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Expression \"Evaluation\")\n  0:let firstSubRef = __x0__\n  1:(1) app __x1__ = (GetValue firstSubRef)\n  1:let firstSub = [? __x1__]\n  2:(2) access __x2__ = (TemplateSpans \"SubstitutionEvaluation\")\n  2:let restSub = [? __x2__]\n  4:return (0) (new [firstSub, restSub])\n}"
  }, {
    "code": ["          1. Let _baseReference_ be the result of evaluating |MemberExpression|.", "          1. Let _baseValue_ be ? GetValue(_baseReference_).", "          1. If _baseValue_ is *undefined* or *null*, then", "            1. Return *undefined*.", "          1. Return the result of performing ChainEvaluation of |OptionalChain| with arguments _baseValue_ and _baseReference_."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "OptionalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "args": [],
          "name": "OptionalChain",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-optional-chaining-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (MemberExpression \"Evaluation\")\n  0:let baseReference = __x0__\n  1:(1) app __x1__ = (GetValue baseReference)\n  1:let baseValue = [? __x1__]\n  2:if (|| (= baseValue undefined) (= baseValue null)) return undefined else 3:{}\n  4:(2) access __x2__ = (OptionalChain \"ChainEvaluation\" baseValue baseReference)\n  4:return __x2__\n}"
  }, {
    "code": ["          1. Let _baseReference_ be the result of evaluating |CallExpression|.", "          1. Let _baseValue_ be ? GetValue(_baseReference_).", "          1. If _baseValue_ is *undefined* or *null*, then", "            1. Return *undefined*.", "          1. Return the result of performing ChainEvaluation of |OptionalChain| with arguments _baseValue_ and _baseReference_."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "OptionalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CallExpression",
          "optional": false
        }, {
          "args": [],
          "name": "OptionalChain",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-optional-chaining-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (CallExpression \"Evaluation\")\n  0:let baseReference = __x0__\n  1:(1) app __x1__ = (GetValue baseReference)\n  1:let baseValue = [? __x1__]\n  2:if (|| (= baseValue undefined) (= baseValue null)) return undefined else 3:{}\n  4:(2) access __x2__ = (OptionalChain \"ChainEvaluation\" baseValue baseReference)\n  4:return __x2__\n}"
  }, {
    "code": ["          1. Let _baseReference_ be the result of evaluating |OptionalExpression|.", "          1. Let _baseValue_ be ? GetValue(_baseReference_).", "          1. If _baseValue_ is *undefined* or *null*, then", "            1. Return *undefined*.", "          1. Return the result of performing ChainEvaluation of |OptionalChain| with arguments _baseValue_ and _baseReference_."],
    "head": {
      "idx": 2,
      "methodName": "Evaluation",
      "prod": "OptionalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "OptionalExpression",
          "optional": false
        }, {
          "args": [],
          "name": "OptionalChain",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-optional-chaining-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (OptionalExpression \"Evaluation\")\n  0:let baseReference = __x0__\n  1:(1) app __x1__ = (GetValue baseReference)\n  1:let baseValue = [? __x1__]\n  2:if (|| (= baseValue undefined) (= baseValue null)) return undefined else 3:{}\n  4:(2) access __x2__ = (OptionalChain \"ChainEvaluation\" baseValue baseReference)\n  4:return __x2__\n}"
  }, {
    "code": ["          1. Let _thisChain_ be this |OptionalChain|.", "          1. Let _tailCall_ be IsInTailPosition(_thisChain_).", "          1. Return ? EvaluateCall(_baseValue_, _baseReference_, |Arguments|, _tailCall_)."],
    "head": {
      "idx": 0,
      "methodName": "ChainEvaluation",
      "prod": "OptionalChain",
      "rhs": {
        "tokens": [{
          "term": "?."
        }, {
          "args": [],
          "name": "Arguments",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "baseValue"
      }, {
        "kind": "Normal",
        "name": "baseReference"
      }]
    },
    "ids": "sec-optional-chaining-chain-evaluation",
    "rawBody": "{\n  0:let thisChain = this\n  1:(0) app __x0__ = (IsInTailPosition thisChain)\n  1:let tailCall = __x0__\n  2:(1) app __x1__ = (EvaluateCall baseValue baseReference Arguments tailCall)\n  2:return [? __x1__]\n}"
  }, {
    "code": ["          1. If the code matched by this |OptionalChain| is strict mode code, let _strict_ be *true*; else let _strict_ be *false*.", "          1. Return ? EvaluatePropertyAccessWithExpressionKey(_baseValue_, |Expression|, _strict_)."],
    "head": {
      "idx": 1,
      "methodName": "ChainEvaluation",
      "prod": "OptionalChain",
      "rhs": {
        "tokens": [{
          "term": "?."
        }, {
          "term": "["
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": "]"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "baseValue"
      }, {
        "kind": "Normal",
        "name": "baseReference"
      }]
    },
    "ids": "sec-optional-chaining-chain-evaluation",
    "rawBody": "{\n  0:if true let strict = true else let strict = false\n  1:(0) app __x0__ = (EvaluatePropertyAccessWithExpressionKey baseValue Expression strict)\n  1:return [? __x0__]\n}"
  }, {
    "code": ["          1. If the code matched by this |OptionalChain| is strict mode code, let _strict_ be *true*; else let _strict_ be *false*.", "          1. Return ? EvaluatePropertyAccessWithIdentifierKey(_baseValue_, |IdentifierName|, _strict_)."],
    "head": {
      "idx": 2,
      "methodName": "ChainEvaluation",
      "prod": "OptionalChain",
      "rhs": {
        "tokens": [{
          "term": "?."
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "baseValue"
      }, {
        "kind": "Normal",
        "name": "baseReference"
      }]
    },
    "ids": "sec-optional-chaining-chain-evaluation",
    "rawBody": "{\n  0:if true let strict = true else let strict = false\n  1:(0) app __x0__ = (EvaluatePropertyAccessWithIdentifierKey baseValue IdentifierName strict)\n  1:return [? __x0__]\n}"
  }, {
    "code": ["          1. Let _optionalChain_ be |OptionalChain|.", "          1. Let _newReference_ be ? ChainEvaluation of _optionalChain_ with arguments _baseValue_ and _baseReference_.", "          1. Let _newValue_ be ? GetValue(_newReference_).", "          1. Let _thisChain_ be this |OptionalChain|.", "          1. Let _tailCall_ be IsInTailPosition(_thisChain_).", "          1. Return ? EvaluateCall(_newValue_, _newReference_, |Arguments|, _tailCall_)."],
    "head": {
      "idx": 4,
      "methodName": "ChainEvaluation",
      "prod": "OptionalChain",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "OptionalChain",
          "optional": false
        }, {
          "args": [],
          "name": "Arguments",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "baseValue"
      }, {
        "kind": "Normal",
        "name": "baseReference"
      }]
    },
    "ids": "sec-optional-chaining-chain-evaluation",
    "rawBody": "{\n  0:let optionalChain = OptionalChain\n  1:(0) access __x0__ = (optionalChain \"ChainEvaluation\" baseValue baseReference)\n  1:let newReference = [? __x0__]\n  2:(1) app __x1__ = (GetValue newReference)\n  2:let newValue = [? __x1__]\n  3:let thisChain = this\n  4:(2) app __x2__ = (IsInTailPosition thisChain)\n  4:let tailCall = __x2__\n  5:(3) app __x3__ = (EvaluateCall newValue newReference Arguments tailCall)\n  5:return [? __x3__]\n}"
  }, {
    "code": ["          1. Let _optionalChain_ be |OptionalChain|.", "          1. Let _newReference_ be ? ChainEvaluation of _optionalChain_ with arguments _baseValue_ and _baseReference_.", "          1. Let _newValue_ be ? GetValue(_newReference_).", "          1. If the code matched by this |OptionalChain| is strict mode code, let _strict_ be *true*; else let _strict_ be *false*.", "          1. Return ? EvaluatePropertyAccessWithExpressionKey(_newValue_, |Expression|, _strict_)."],
    "head": {
      "idx": 5,
      "methodName": "ChainEvaluation",
      "prod": "OptionalChain",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "OptionalChain",
          "optional": false
        }, {
          "term": "["
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": "]"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "baseValue"
      }, {
        "kind": "Normal",
        "name": "baseReference"
      }]
    },
    "ids": "sec-optional-chaining-chain-evaluation",
    "rawBody": "{\n  0:let optionalChain = OptionalChain\n  1:(0) access __x0__ = (optionalChain \"ChainEvaluation\" baseValue baseReference)\n  1:let newReference = [? __x0__]\n  2:(1) app __x1__ = (GetValue newReference)\n  2:let newValue = [? __x1__]\n  3:if true let strict = true else let strict = false\n  4:(2) app __x2__ = (EvaluatePropertyAccessWithExpressionKey newValue Expression strict)\n  4:return [? __x2__]\n}"
  }, {
    "code": ["          1. Let _optionalChain_ be |OptionalChain|.", "          1. Let _newReference_ be ? ChainEvaluation of _optionalChain_ with arguments _baseValue_ and _baseReference_.", "          1. Let _newValue_ be ? GetValue(_newReference_).", "          1. If the code matched by this |OptionalChain| is strict mode code, let _strict_ be *true*; else let _strict_ be *false*.", "          1. Return ? EvaluatePropertyAccessWithIdentifierKey(_newValue_, |IdentifierName|, _strict_)."],
    "head": {
      "idx": 6,
      "methodName": "ChainEvaluation",
      "prod": "OptionalChain",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "OptionalChain",
          "optional": false
        }, {
          "term": "."
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "baseValue"
      }, {
        "kind": "Normal",
        "name": "baseReference"
      }]
    },
    "ids": "sec-optional-chaining-chain-evaluation",
    "rawBody": "{\n  0:let optionalChain = OptionalChain\n  1:(0) access __x0__ = (optionalChain \"ChainEvaluation\" baseValue baseReference)\n  1:let newReference = [? __x0__]\n  2:(1) app __x1__ = (GetValue newReference)\n  2:let newValue = [? __x1__]\n  3:if true let strict = true else let strict = false\n  4:(2) app __x2__ = (EvaluatePropertyAccessWithIdentifierKey newValue IdentifierName strict)\n  4:return [? __x2__]\n}"
  }, {
    "code": ["          1. Let _referencingScriptOrModule_ be ! GetActiveScriptOrModule().", "          1. Let _argRef_ be the result of evaluating |AssignmentExpression|.", "          1. Let _specifier_ be ? GetValue(_argRef_).", "          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).", "          1. Let _specifierString_ be ToString(_specifier_).", "          1. IfAbruptRejectPromise(_specifierString_, _promiseCapability_).", "          1. Perform ! HostImportModuleDynamically(_referencingScriptOrModule_, _specifierString_, _promiseCapability_).", "          1. Return _promiseCapability_.[[Promise]]."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "ImportCall",
      "rhs": {
        "tokens": [{
          "term": "import"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-import-call-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (GetActiveScriptOrModule)\n  0:let referencingScriptOrModule = [! __x0__]\n  1:(1) access __x1__ = (AssignmentExpression \"Evaluation\")\n  1:let argRef = __x1__\n  2:(2) app __x2__ = (GetValue argRef)\n  2:let specifier = [? __x2__]\n  3:(3) app __x3__ = (NewPromiseCapability INTRINSIC_Promise)\n  3:let promiseCapability = [! __x3__]\n  4:(4) app __x4__ = (ToString specifier)\n  4:let specifierString = __x4__\n  5:if (is-completion specifierString) if (= specifierString[\"Type\"] CONST_normal) specifierString = specifierString[\"Value\"] else {\n    (5) app __x5__ = (Call promiseCapability[\"Reject\"] undefined (0) (new [specifierString[\"Value\"]]))\n    if (&& (is-completion __x5__) (! (= __x5__[\"Type\"] CONST_normal))) return __x5__ else 3:{}\n    return promiseCapability[\"Promise\"]\n  } else 3:{}\n  5:specifierString\n  6:(6) app __x6__ = (HostImportModuleDynamically referencingScriptOrModule specifierString promiseCapability)\n  6:[! __x6__]\n  7:return promiseCapability[\"Promise\"]\n}"
  }, {
    "code": ["          1. Let _tagRef_ be the result of evaluating |MemberExpression|.", "          1. Let _tagFunc_ be ? GetValue(_tagRef_).", "          1. Let _thisCall_ be this |MemberExpression|.", "          1. Let _tailCall_ be IsInTailPosition(_thisCall_).", "          1. Return ? EvaluateCall(_tagFunc_, _tagRef_, |TemplateLiteral|, _tailCall_)."],
    "head": {
      "idx": 3,
      "methodName": "Evaluation",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "args": [],
          "name": "TemplateLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-tagged-templates-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (MemberExpression \"Evaluation\")\n  0:let tagRef = __x0__\n  1:(1) app __x1__ = (GetValue tagRef)\n  1:let tagFunc = [? __x1__]\n  2:let thisCall = this\n  3:(2) app __x2__ = (IsInTailPosition thisCall)\n  3:let tailCall = __x2__\n  4:(3) app __x3__ = (EvaluateCall tagFunc tagRef TemplateLiteral tailCall)\n  4:return [? __x3__]\n}"
  }, {
    "code": ["          1. Let _tagRef_ be the result of evaluating |CallExpression|.", "          1. Let _tagFunc_ be ? GetValue(_tagRef_).", "          1. Let _thisCall_ be this |CallExpression|.", "          1. Let _tailCall_ be IsInTailPosition(_thisCall_).", "          1. Return ? EvaluateCall(_tagFunc_, _tagRef_, |TemplateLiteral|, _tailCall_)."],
    "head": {
      "idx": 6,
      "methodName": "Evaluation",
      "prod": "CallExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CallExpression",
          "optional": false
        }, {
          "args": [],
          "name": "TemplateLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-tagged-templates-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (CallExpression \"Evaluation\")\n  0:let tagRef = __x0__\n  1:(1) app __x1__ = (GetValue tagRef)\n  1:let tagFunc = [? __x1__]\n  2:let thisCall = this\n  3:(2) app __x2__ = (IsInTailPosition thisCall)\n  3:let tailCall = __x2__\n  4:(3) app __x3__ = (EvaluateCall tagFunc tagRef TemplateLiteral tailCall)\n  4:return [? __x3__]\n}"
  }, {
    "code": ["          1. Return GetNewTarget()."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "NewTarget",
      "rhs": {
        "tokens": [{
          "term": "new"
        }, {
          "term": "."
        }, {
          "term": "target"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-meta-properties-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (GetNewTarget)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Let _module_ be ! GetActiveScriptOrModule().", "          1. Assert: _module_ is a Source Text Module Record.", "          1. Let _importMeta_ be _module_.[[ImportMeta]].", "          1. If _importMeta_ is ~empty~, then", "            1. Set _importMeta_ to ! OrdinaryObjectCreate(*null*).", "            1. Let _importMetaValues_ be ! HostGetImportMetaProperties(_module_).", "            1. For each Record { [[Key]], [[Value]] } _p_ of _importMetaValues_, do", "              1. Perform ! CreateDataPropertyOrThrow(_importMeta_, _p_.[[Key]], _p_.[[Value]]).", "            1. Perform ! HostFinalizeImportMeta(_importMeta_, _module_).", "            1. Set _module_.[[ImportMeta]] to _importMeta_.", "            1. Return _importMeta_.", "          1. Else,", "            1. Assert: Type(_importMeta_) is Object.", "            1. Return _importMeta_."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "ImportMeta",
      "rhs": {
        "tokens": [{
          "term": "import"
        }, {
          "term": "."
        }, {
          "term": "meta"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-meta-properties-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (GetActiveScriptOrModule)\n  0:let module = [! __x0__]\n  1:assert (0) (is-instance-of module SourceTextModuleRecord)\n  2:let importMeta = module[\"ImportMeta\"]\n  11:if (= importMeta CONST_empty) {\n    4:(1) app __x1__ = (OrdinaryObjectCreate null)\n    4:importMeta = [! __x1__]\n    5:(2) app __x2__ = (HostGetImportMetaProperties module)\n    5:let importMetaValues = [! __x2__]\n    6:let __x3__ = importMetaValues\n    6:let __x4__ = 0i\n    6:while (< __x4__ __x3__[\"length\"]) {\n      let p = __x3__[__x4__]\n      7:(3) app __x5__ = (CreateDataPropertyOrThrow importMeta p[\"Key\"] p[\"Value\"])\n      7:[! __x5__]\n      __x4__ = (+ __x4__ 1i)\n    }\n    8:(4) app __x6__ = (HostFinalizeImportMeta importMeta module)\n    8:[! __x6__]\n    9:module[\"ImportMeta\"] = importMeta\n    10:return importMeta\n  } else {\n    12:assert (= (typeof importMeta) Object)\n    13:return importMeta\n  }\n}"
  }, {
    "code": ["          1. Let _lhs_ be the result of evaluating |LeftHandSideExpression|.", "          1. Let _oldValue_ be ? ToNumeric(? GetValue(_lhs_)).", "          1. Let _newValue_ be ! Type(_oldValue_)::add(_oldValue_, Type(_oldValue_)::unit).", "          1. Perform ? PutValue(_lhs_, _newValue_).", "          1. Return _oldValue_."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "UpdateExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "++"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-postfix-increment-operator-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (LeftHandSideExpression \"Evaluation\")\n  0:let lhs = __x0__\n  1:(1) app __x1__ = (GetValue lhs)\n  1:(2) app __x2__ = (ToNumeric [? __x1__])\n  1:let oldValue = [? __x2__]\n  2:(3) app __x3__ = (PRIMITIVE[(typeof oldValue)][\"add\"] oldValue PRIMITIVE[(typeof oldValue)][\"unit\"])\n  2:let newValue = [! __x3__]\n  3:(4) app __x4__ = (PutValue lhs newValue)\n  3:[? __x4__]\n  4:return oldValue\n}"
  }, {
    "code": ["          1. Let _lhs_ be the result of evaluating |LeftHandSideExpression|.", "          1. Let _oldValue_ be ? ToNumeric(? GetValue(_lhs_)).", "          1. Let _newValue_ be ! Type(_oldValue_)::subtract(_oldValue_, Type(_oldValue_)::unit).", "          1. Perform ? PutValue(_lhs_, _newValue_).", "          1. Return _oldValue_."],
    "head": {
      "idx": 2,
      "methodName": "Evaluation",
      "prod": "UpdateExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "--"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-postfix-decrement-operator-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (LeftHandSideExpression \"Evaluation\")\n  0:let lhs = __x0__\n  1:(1) app __x1__ = (GetValue lhs)\n  1:(2) app __x2__ = (ToNumeric [? __x1__])\n  1:let oldValue = [? __x2__]\n  2:(3) app __x3__ = (PRIMITIVE[(typeof oldValue)][\"subtract\"] oldValue PRIMITIVE[(typeof oldValue)][\"unit\"])\n  2:let newValue = [! __x3__]\n  3:(4) app __x4__ = (PutValue lhs newValue)\n  3:[? __x4__]\n  4:return oldValue\n}"
  }, {
    "code": ["          1. Let _expr_ be the result of evaluating |UnaryExpression|.", "          1. Let _oldValue_ be ? ToNumeric(? GetValue(_expr_)).", "          1. Let _newValue_ be ! Type(_oldValue_)::add(_oldValue_, Type(_oldValue_)::unit).", "          1. Perform ? PutValue(_expr_, _newValue_).", "          1. Return _newValue_."],
    "head": {
      "idx": 3,
      "methodName": "Evaluation",
      "prod": "UpdateExpression",
      "rhs": {
        "tokens": [{
          "term": "++"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-prefix-increment-operator-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (UnaryExpression \"Evaluation\")\n  0:let expr = __x0__\n  1:(1) app __x1__ = (GetValue expr)\n  1:(2) app __x2__ = (ToNumeric [? __x1__])\n  1:let oldValue = [? __x2__]\n  2:(3) app __x3__ = (PRIMITIVE[(typeof oldValue)][\"add\"] oldValue PRIMITIVE[(typeof oldValue)][\"unit\"])\n  2:let newValue = [! __x3__]\n  3:(4) app __x4__ = (PutValue expr newValue)\n  3:[? __x4__]\n  4:return newValue\n}"
  }, {
    "code": ["          1. Let _expr_ be the result of evaluating |UnaryExpression|.", "          1. Let _oldValue_ be ? ToNumeric(? GetValue(_expr_)).", "          1. Let _newValue_ be ! Type(_oldValue_)::subtract(_oldValue_, Type(_oldValue_)::unit).", "          1. Perform ? PutValue(_expr_, _newValue_).", "          1. Return _newValue_."],
    "head": {
      "idx": 4,
      "methodName": "Evaluation",
      "prod": "UpdateExpression",
      "rhs": {
        "tokens": [{
          "term": "--"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-prefix-decrement-operator-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (UnaryExpression \"Evaluation\")\n  0:let expr = __x0__\n  1:(1) app __x1__ = (GetValue expr)\n  1:(2) app __x2__ = (ToNumeric [? __x1__])\n  1:let oldValue = [? __x2__]\n  2:(3) app __x3__ = (PRIMITIVE[(typeof oldValue)][\"subtract\"] oldValue PRIMITIVE[(typeof oldValue)][\"unit\"])\n  2:let newValue = [! __x3__]\n  3:(4) app __x4__ = (PutValue expr newValue)\n  3:[? __x4__]\n  4:return newValue\n}"
  }, {
    "code": ["          1. Let _ref_ be the result of evaluating |UnaryExpression|.", "          1. ReturnIfAbrupt(_ref_).", "          1. If _ref_ is not a Reference Record, return *true*.", "          1. If IsUnresolvableReference(_ref_) is *true*, then", "            1. Assert: _ref_.[[Strict]] is *false*.", "            1. Return *true*.", "          1. If IsPropertyReference(_ref_) is *true*, then", "            1. If IsSuperReference(_ref_) is *true*, throw a *ReferenceError* exception.", "            1. [id=\"step-delete-operator-toobject\"] Let _baseObj_ be ! ToObject(_ref_.[[Base]]).", "            1. Let _deleteStatus_ be ? _baseObj_.[[Delete]](_ref_.[[ReferencedName]]).", "            1. If _deleteStatus_ is *false* and _ref_.[[Strict]] is *true*, throw a *TypeError* exception.", "            1. Return _deleteStatus_.", "          1. Else,", "            1. Let _base_ be _ref_.[[Base]].", "            1. Assert: _base_ is an Environment Record.", "            1. Return ? _base_.DeleteBinding(_ref_.[[ReferencedName]])."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "term": "delete"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-delete-operator-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (UnaryExpression \"Evaluation\")\n  0:let ref = __x0__\n  1:[? ref]\n  2:if (! (0) (is-instance-of ref ReferenceRecord)) return true else 3:{}\n  3:(1) app __x1__ = (IsUnresolvableReference ref)\n  3:if (= __x1__ true) {\n    4:assert (= ref[\"Strict\"] false)\n    5:return true\n  } else 3:{}\n  12:(2) app __x2__ = (IsPropertyReference ref)\n  12:if (= __x2__ true) {\n    7:(3) app __x3__ = (IsSuperReference ref)\n    7:if (= __x3__ true) (1) throw ReferenceError else 3:{}\n    8:(4) app __x4__ = (ToObject ref[\"Base\"])\n    8:let baseObj = [! __x4__]\n    9:(5) app __x5__ = (baseObj[\"Delete\"] baseObj ref[\"ReferencedName\"])\n    9:let deleteStatus = [? __x5__]\n    10:if (&& (= deleteStatus false) (= ref[\"Strict\"] true)) (2) throw TypeError else 3:{}\n    11:return deleteStatus\n  } else {\n    13:let base = ref[\"Base\"]\n    14:assert (3) (is-instance-of base EnvironmentRecord)\n    15:(6) app __x6__ = (base[\"DeleteBinding\"] base ref[\"ReferencedName\"])\n    15:return [? __x6__]\n  }\n}"
  }, {
    "code": ["          1. Let _expr_ be the result of evaluating |UnaryExpression|.", "          1. Perform ? GetValue(_expr_).", "          1. Return *undefined*."],
    "head": {
      "idx": 2,
      "methodName": "Evaluation",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "term": "void"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-void-operator-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (UnaryExpression \"Evaluation\")\n  0:let expr = __x0__\n  1:(1) app __x1__ = (GetValue expr)\n  1:[? __x1__]\n  2:return undefined\n}"
  }, {
    "code": ["          1. Let _val_ be the result of evaluating |UnaryExpression|.", "          1. If _val_ is a Reference Record, then", "            1. If IsUnresolvableReference(_val_) is *true*, return *\"undefined\"*.", "          1. Set _val_ to ? GetValue(_val_).", "          1. Return a String according to <emu-xref href=\"#table-typeof-operator-results\"></emu-xref>."],
    "head": {
      "idx": 3,
      "methodName": "Evaluation",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "term": "typeof"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-typeof-operator-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (UnaryExpression \"Evaluation\")\n  0:let val = __x0__\n  1:if (0) (is-instance-of val ReferenceRecord) {\n    2:(1) app __x1__ = (IsUnresolvableReference val)\n    2:if (= __x1__ true) return \"undefined\" else 3:{}\n  } else 3:{}\n  3:(2) app __x2__ = (GetValue val)\n  3:val = [? __x2__]\n  4:(1) ??? \"Return a String according to link:{table-typeof-operator-results} .\"\n}"
  }, {
    "code": ["          1. Let _expr_ be the result of evaluating |UnaryExpression|.", "          1. Return ? ToNumber(? GetValue(_expr_))."],
    "head": {
      "idx": 4,
      "methodName": "Evaluation",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "term": "+"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-unary-plus-operator-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (UnaryExpression \"Evaluation\")\n  0:let expr = __x0__\n  1:(1) app __x1__ = (GetValue expr)\n  1:(2) app __x2__ = (ToNumber [? __x1__])\n  1:return [? __x2__]\n}"
  }, {
    "code": ["          1. Let _expr_ be the result of evaluating |UnaryExpression|.", "          1. Let _oldValue_ be ? ToNumeric(? GetValue(_expr_)).", "          1. Let _T_ be Type(_oldValue_).", "          1. Return ! _T_::unaryMinus(_oldValue_)."],
    "head": {
      "idx": 5,
      "methodName": "Evaluation",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "term": "-"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-unary-minus-operator-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (UnaryExpression \"Evaluation\")\n  0:let expr = __x0__\n  1:(1) app __x1__ = (GetValue expr)\n  1:(2) app __x2__ = (ToNumeric [? __x1__])\n  1:let oldValue = [? __x2__]\n  2:let T = (typeof oldValue)\n  3:(3) app __x3__ = (PRIMITIVE[T][\"unaryMinus\"] oldValue)\n  3:return [! __x3__]\n}"
  }, {
    "code": ["          1. Let _expr_ be the result of evaluating |UnaryExpression|.", "          1. Let _oldValue_ be ? ToNumeric(? GetValue(_expr_)).", "          1. Let _T_ be Type(_oldValue_).", "          1. Return ! _T_::bitwiseNOT(_oldValue_)."],
    "head": {
      "idx": 6,
      "methodName": "Evaluation",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "term": "~"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-bitwise-not-operator-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (UnaryExpression \"Evaluation\")\n  0:let expr = __x0__\n  1:(1) app __x1__ = (GetValue expr)\n  1:(2) app __x2__ = (ToNumeric [? __x1__])\n  1:let oldValue = [? __x2__]\n  2:let T = (typeof oldValue)\n  3:(3) app __x3__ = (PRIMITIVE[T][\"bitwiseNOT\"] oldValue)\n  3:return [! __x3__]\n}"
  }, {
    "code": ["          1. Let _expr_ be the result of evaluating |UnaryExpression|.", "          1. Let _oldValue_ be ! ToBoolean(? GetValue(_expr_)).", "          1. If _oldValue_ is *true*, return *false*.", "          1. Return *true*."],
    "head": {
      "idx": 7,
      "methodName": "Evaluation",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "term": "!"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-logical-not-operator-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (UnaryExpression \"Evaluation\")\n  0:let expr = __x0__\n  1:(1) app __x1__ = (GetValue expr)\n  1:(2) app __x2__ = (ToBoolean [? __x1__])\n  1:let oldValue = [! __x2__]\n  2:if (= oldValue true) return false else 3:{}\n  3:return true\n}"
  }, {
    "code": ["        1. Return ? EvaluateStringOrNumericBinaryExpression(|UpdateExpression|, `**`, |ExponentiationExpression|)."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "ExponentiationExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "UpdateExpression",
          "optional": false
        }, {
          "term": "**"
        }, {
          "args": [],
          "name": "ExponentiationExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-exp-operator-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (EvaluateStringOrNumericBinaryExpression UpdateExpression \"**\" ExponentiationExpression)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["        1. Let _opText_ be the source text matched by |MultiplicativeOperator|.", "        1. Return ? EvaluateStringOrNumericBinaryExpression(|MultiplicativeExpression|, _opText_, |ExponentiationExpression|)."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "MultiplicativeExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MultiplicativeExpression",
          "optional": false
        }, {
          "args": [],
          "name": "MultiplicativeOperator",
          "optional": false
        }, {
          "args": [],
          "name": "ExponentiationExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-multiplicative-operators-runtime-semantics-evaluation",
    "rawBody": "{\n  0:let opText = (get-syntax MultiplicativeOperator)\n  1:(0) app __x0__ = (EvaluateStringOrNumericBinaryExpression MultiplicativeExpression opText ExponentiationExpression)\n  1:return [? __x0__]\n}"
  }, {
    "code": ["          1. Return ? EvaluateStringOrNumericBinaryExpression(|AdditiveExpression|, `+`, |MultiplicativeExpression|)."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "AdditiveExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AdditiveExpression",
          "optional": false
        }, {
          "term": "+"
        }, {
          "args": [],
          "name": "MultiplicativeExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-addition-operator-plus-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (EvaluateStringOrNumericBinaryExpression AdditiveExpression \"+\" MultiplicativeExpression)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Return ? EvaluateStringOrNumericBinaryExpression(|AdditiveExpression|, `-`, |MultiplicativeExpression|)."],
    "head": {
      "idx": 2,
      "methodName": "Evaluation",
      "prod": "AdditiveExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AdditiveExpression",
          "optional": false
        }, {
          "term": "-"
        }, {
          "args": [],
          "name": "MultiplicativeExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-subtraction-operator-minus-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (EvaluateStringOrNumericBinaryExpression AdditiveExpression \"-\" MultiplicativeExpression)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Return ? EvaluateStringOrNumericBinaryExpression(|ShiftExpression|, `<<`, |AdditiveExpression|)."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "ShiftExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }, {
          "term": "<<"
        }, {
          "args": [],
          "name": "AdditiveExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-left-shift-operator-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (EvaluateStringOrNumericBinaryExpression ShiftExpression \"<<\" AdditiveExpression)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Return ? EvaluateStringOrNumericBinaryExpression(|ShiftExpression|, `>>`, |AdditiveExpression|)."],
    "head": {
      "idx": 2,
      "methodName": "Evaluation",
      "prod": "ShiftExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }, {
          "term": ">>"
        }, {
          "args": [],
          "name": "AdditiveExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-signed-right-shift-operator-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (EvaluateStringOrNumericBinaryExpression ShiftExpression \">>\" AdditiveExpression)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Return ? EvaluateStringOrNumericBinaryExpression(|ShiftExpression|, `>>>`, |AdditiveExpression|)."],
    "head": {
      "idx": 3,
      "methodName": "Evaluation",
      "prod": "ShiftExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }, {
          "term": ">>>"
        }, {
          "args": [],
          "name": "AdditiveExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-unsigned-right-shift-operator-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (EvaluateStringOrNumericBinaryExpression ShiftExpression \">>>\" AdditiveExpression)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["        1. Let _lref_ be the result of evaluating |RelationalExpression|.", "        1. Let _lval_ be ? GetValue(_lref_).", "        1. Let _rref_ be the result of evaluating |ShiftExpression|.", "        1. Let _rval_ be ? GetValue(_rref_).", "        1. Let _r_ be the result of performing Abstract Relational Comparison _lval_ < _rval_.", "        1. ReturnIfAbrupt(_r_).", "        1. If _r_ is *undefined*, return *false*. Otherwise, return _r_."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "RelationalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }, {
          "term": "<"
        }, {
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-relational-operators-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (RelationalExpression \"Evaluation\")\n  0:let lref = __x0__\n  1:(1) app __x1__ = (GetValue lref)\n  1:let lval = [? __x1__]\n  2:(2) access __x2__ = (ShiftExpression \"Evaluation\")\n  2:let rref = __x2__\n  3:(3) app __x3__ = (GetValue rref)\n  3:let rval = [? __x3__]\n  4:(4) app __x4__ = (AbstractRelationalComparison lval rval)\n  4:let r = __x4__\n  5:[? r]\n  6:if (= r undefined) return false else return r\n}"
  }, {
    "code": ["        1. Let _lref_ be the result of evaluating |RelationalExpression|.", "        1. Let _lval_ be ? GetValue(_lref_).", "        1. Let _rref_ be the result of evaluating |ShiftExpression|.", "        1. Let _rval_ be ? GetValue(_rref_).", "        1. Let _r_ be the result of performing Abstract Relational Comparison _rval_ < _lval_ with _LeftFirst_ equal to *false*.", "        1. ReturnIfAbrupt(_r_).", "        1. If _r_ is *undefined*, return *false*. Otherwise, return _r_."],
    "head": {
      "idx": 2,
      "methodName": "Evaluation",
      "prod": "RelationalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }, {
          "term": ">"
        }, {
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-relational-operators-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (RelationalExpression \"Evaluation\")\n  0:let lref = __x0__\n  1:(1) app __x1__ = (GetValue lref)\n  1:let lval = [? __x1__]\n  2:(2) access __x2__ = (ShiftExpression \"Evaluation\")\n  2:let rref = __x2__\n  3:(3) app __x3__ = (GetValue rref)\n  3:let rval = [? __x3__]\n  4:(4) app __x4__ = (AbstractRelationalComparison rval lval false)\n  4:let r = __x4__\n  5:[? r]\n  6:if (= r undefined) return false else return r\n}"
  }, {
    "code": ["        1. Let _lref_ be the result of evaluating |RelationalExpression|.", "        1. Let _lval_ be ? GetValue(_lref_).", "        1. Let _rref_ be the result of evaluating |ShiftExpression|.", "        1. Let _rval_ be ? GetValue(_rref_).", "        1. Let _r_ be the result of performing Abstract Relational Comparison _rval_ < _lval_ with _LeftFirst_ equal to *false*.", "        1. ReturnIfAbrupt(_r_).", "        1. If _r_ is *true* or *undefined*, return *false*. Otherwise, return *true*."],
    "head": {
      "idx": 3,
      "methodName": "Evaluation",
      "prod": "RelationalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }, {
          "term": "<="
        }, {
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-relational-operators-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (RelationalExpression \"Evaluation\")\n  0:let lref = __x0__\n  1:(1) app __x1__ = (GetValue lref)\n  1:let lval = [? __x1__]\n  2:(2) access __x2__ = (ShiftExpression \"Evaluation\")\n  2:let rref = __x2__\n  3:(3) app __x3__ = (GetValue rref)\n  3:let rval = [? __x3__]\n  4:(4) app __x4__ = (AbstractRelationalComparison rval lval false)\n  4:let r = __x4__\n  5:[? r]\n  6:if (|| (= r true) (= r undefined)) return false else return true\n}"
  }, {
    "code": ["        1. Let _lref_ be the result of evaluating |RelationalExpression|.", "        1. Let _lval_ be ? GetValue(_lref_).", "        1. Let _rref_ be the result of evaluating |ShiftExpression|.", "        1. Let _rval_ be ? GetValue(_rref_).", "        1. Let _r_ be the result of performing Abstract Relational Comparison _lval_ < _rval_.", "        1. ReturnIfAbrupt(_r_).", "        1. If _r_ is *true* or *undefined*, return *false*. Otherwise, return *true*."],
    "head": {
      "idx": 4,
      "methodName": "Evaluation",
      "prod": "RelationalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }, {
          "term": ">="
        }, {
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-relational-operators-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (RelationalExpression \"Evaluation\")\n  0:let lref = __x0__\n  1:(1) app __x1__ = (GetValue lref)\n  1:let lval = [? __x1__]\n  2:(2) access __x2__ = (ShiftExpression \"Evaluation\")\n  2:let rref = __x2__\n  3:(3) app __x3__ = (GetValue rref)\n  3:let rval = [? __x3__]\n  4:(4) app __x4__ = (AbstractRelationalComparison lval rval)\n  4:let r = __x4__\n  5:[? r]\n  6:if (|| (= r true) (= r undefined)) return false else return true\n}"
  }, {
    "code": ["        1. Let _lref_ be the result of evaluating |RelationalExpression|.", "        1. Let _lval_ be ? GetValue(_lref_).", "        1. Let _rref_ be the result of evaluating |ShiftExpression|.", "        1. Let _rval_ be ? GetValue(_rref_).", "        1. Return ? InstanceofOperator(_lval_, _rval_)."],
    "head": {
      "idx": 5,
      "methodName": "Evaluation",
      "prod": "RelationalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }, {
          "term": "instanceof"
        }, {
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-relational-operators-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (RelationalExpression \"Evaluation\")\n  0:let lref = __x0__\n  1:(1) app __x1__ = (GetValue lref)\n  1:let lval = [? __x1__]\n  2:(2) access __x2__ = (ShiftExpression \"Evaluation\")\n  2:let rref = __x2__\n  3:(3) app __x3__ = (GetValue rref)\n  3:let rval = [? __x3__]\n  4:(4) app __x4__ = (InstanceofOperator lval rval)\n  4:return [? __x4__]\n}"
  }, {
    "code": ["        1. Let _lref_ be the result of evaluating |RelationalExpression|.", "        1. Let _lval_ be ? GetValue(_lref_).", "        1. Let _rref_ be the result of evaluating |ShiftExpression|.", "        1. Let _rval_ be ? GetValue(_rref_).", "        1. If Type(_rval_) is not Object, throw a *TypeError* exception.", "        1. Return ? HasProperty(_rval_, ? ToPropertyKey(_lval_))."],
    "head": {
      "idx": 6,
      "methodName": "Evaluation",
      "prod": "RelationalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-relational-operators-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (RelationalExpression \"Evaluation\")\n  0:let lref = __x0__\n  1:(1) app __x1__ = (GetValue lref)\n  1:let lval = [? __x1__]\n  2:(2) access __x2__ = (ShiftExpression \"Evaluation\")\n  2:let rref = __x2__\n  3:(3) app __x3__ = (GetValue rref)\n  3:let rval = [? __x3__]\n  4:if (! (= (typeof rval) Object)) (0) throw TypeError else 3:{}\n  5:(4) app __x4__ = (ToPropertyKey lval)\n  5:(5) app __x5__ = (HasProperty rval [? __x4__])\n  5:return [? __x5__]\n}"
  }, {
    "code": ["        1. If Type(_target_) is not Object, throw a *TypeError* exception.", "        1. Let _instOfHandler_ be ? GetMethod(_target_, @@hasInstance).", "        1. If _instOfHandler_ is not *undefined*, then", "          1. Return ! ToBoolean(? Call(_instOfHandler_, _target_, « _V_ »)).", "        1. [id=\"step-instanceof-check-function\"] If IsCallable(_target_) is *false*, throw a *TypeError* exception.", "        1. [id=\"step-instanceof-fallback\"] Return ? OrdinaryHasInstance(_target_, _V_)."],
    "head": {
      "name": "InstanceofOperator",
      "params": [{
        "kind": "Normal",
        "name": "V"
      }, {
        "kind": "Normal",
        "name": "target"
      }]
    },
    "ids": "sec-instanceofoperator",
    "rawBody": "{\n  0:if (! (= (typeof target) Object)) (0) throw TypeError else 3:{}\n  1:(0) app __x0__ = (GetMethod target SYMBOL_hasInstance)\n  1:let instOfHandler = [? __x0__]\n  2:if (! (= instOfHandler undefined)) {\n    3:(1) app __x1__ = (Call instOfHandler target (1) (new [V]))\n    3:(2) app __x2__ = (ToBoolean [? __x1__])\n    3:return [! __x2__]\n  } else 3:{}\n  4:(3) app __x3__ = (IsCallable target)\n  4:if (= __x3__ false) (2) throw TypeError else 3:{}\n  5:(4) app __x4__ = (OrdinaryHasInstance target V)\n  5:return [? __x4__]\n}"
  }, {
    "code": ["        1. Let _lref_ be the result of evaluating |EqualityExpression|.", "        1. Let _lval_ be ? GetValue(_lref_).", "        1. Let _rref_ be the result of evaluating |RelationalExpression|.", "        1. Let _rval_ be ? GetValue(_rref_).", "        1. Return the result of performing Abstract Equality Comparison _rval_ == _lval_."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "EqualityExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "EqualityExpression",
          "optional": false
        }, {
          "term": "=="
        }, {
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-equality-operators-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (EqualityExpression \"Evaluation\")\n  0:let lref = __x0__\n  1:(1) app __x1__ = (GetValue lref)\n  1:let lval = [? __x1__]\n  2:(2) access __x2__ = (RelationalExpression \"Evaluation\")\n  2:let rref = __x2__\n  3:(3) app __x3__ = (GetValue rref)\n  3:let rval = [? __x3__]\n  4:(4) app __x4__ = (AbstractEqualityComparison rval lval)\n  4:return __x4__\n}"
  }, {
    "code": ["        1. Let _lref_ be the result of evaluating |EqualityExpression|.", "        1. Let _lval_ be ? GetValue(_lref_).", "        1. Let _rref_ be the result of evaluating |RelationalExpression|.", "        1. Let _rval_ be ? GetValue(_rref_).", "        1. Let _r_ be the result of performing Abstract Equality Comparison _rval_ == _lval_.", "        1. ReturnIfAbrupt(_r_).", "        1. If _r_ is *true*, return *false*. Otherwise, return *true*."],
    "head": {
      "idx": 2,
      "methodName": "Evaluation",
      "prod": "EqualityExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "EqualityExpression",
          "optional": false
        }, {
          "term": "!="
        }, {
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-equality-operators-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (EqualityExpression \"Evaluation\")\n  0:let lref = __x0__\n  1:(1) app __x1__ = (GetValue lref)\n  1:let lval = [? __x1__]\n  2:(2) access __x2__ = (RelationalExpression \"Evaluation\")\n  2:let rref = __x2__\n  3:(3) app __x3__ = (GetValue rref)\n  3:let rval = [? __x3__]\n  4:(4) app __x4__ = (AbstractEqualityComparison rval lval)\n  4:let r = __x4__\n  5:[? r]\n  6:if (= r true) return false else return true\n}"
  }, {
    "code": ["        1. Let _lref_ be the result of evaluating |EqualityExpression|.", "        1. Let _lval_ be ? GetValue(_lref_).", "        1. Let _rref_ be the result of evaluating |RelationalExpression|.", "        1. Let _rval_ be ? GetValue(_rref_).", "        1. Return the result of performing Strict Equality Comparison _rval_ === _lval_."],
    "head": {
      "idx": 3,
      "methodName": "Evaluation",
      "prod": "EqualityExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "EqualityExpression",
          "optional": false
        }, {
          "term": "==="
        }, {
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-equality-operators-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (EqualityExpression \"Evaluation\")\n  0:let lref = __x0__\n  1:(1) app __x1__ = (GetValue lref)\n  1:let lval = [? __x1__]\n  2:(2) access __x2__ = (RelationalExpression \"Evaluation\")\n  2:let rref = __x2__\n  3:(3) app __x3__ = (GetValue rref)\n  3:let rval = [? __x3__]\n  4:(4) app __x4__ = (StrictEqualityComparison rval lval)\n  4:return __x4__\n}"
  }, {
    "code": ["        1. Let _lref_ be the result of evaluating |EqualityExpression|.", "        1. Let _lval_ be ? GetValue(_lref_).", "        1. Let _rref_ be the result of evaluating |RelationalExpression|.", "        1. Let _rval_ be ? GetValue(_rref_).", "        1. Let _r_ be the result of performing Strict Equality Comparison _rval_ === _lval_.", "        1. Assert: _r_ is a normal completion.", "        1. If _r_.[[Value]] is *true*, return *false*. Otherwise, return *true*."],
    "head": {
      "idx": 4,
      "methodName": "Evaluation",
      "prod": "EqualityExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "EqualityExpression",
          "optional": false
        }, {
          "term": "!=="
        }, {
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-equality-operators-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (EqualityExpression \"Evaluation\")\n  0:let lref = __x0__\n  1:(1) app __x1__ = (GetValue lref)\n  1:let lval = [? __x1__]\n  2:(2) access __x2__ = (RelationalExpression \"Evaluation\")\n  2:let rref = __x2__\n  3:(3) app __x3__ = (GetValue rref)\n  3:let rval = [? __x3__]\n  4:(4) app __x4__ = (StrictEqualityComparison rval lval)\n  4:let r = __x4__\n  5:assert (&& (is-completion r) (= r[\"Type\"] CONST_normal))\n  6:if (= r[\"Value\"] true) return false else return true\n}"
  }, {
    "code": ["        1. Return ? EvaluateStringOrNumericBinaryExpression(|BitwiseANDExpression|, `&`, |EqualityExpression|)."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "BitwiseANDExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BitwiseANDExpression",
          "optional": false
        }, {
          "term": "&"
        }, {
          "args": [],
          "name": "EqualityExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-binary-bitwise-operators-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (EvaluateStringOrNumericBinaryExpression BitwiseANDExpression \"&\" EqualityExpression)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["        1. Return ? EvaluateStringOrNumericBinaryExpression(|BitwiseXORExpression|, `^`, |BitwiseANDExpression|)."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "BitwiseXORExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BitwiseXORExpression",
          "optional": false
        }, {
          "term": "^"
        }, {
          "args": [],
          "name": "BitwiseANDExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-binary-bitwise-operators-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (EvaluateStringOrNumericBinaryExpression BitwiseXORExpression \"^\" BitwiseANDExpression)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["        1. Return ? EvaluateStringOrNumericBinaryExpression(|BitwiseORExpression|, `|`, |BitwiseXORExpression|)."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "BitwiseORExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BitwiseORExpression",
          "optional": false
        }, {
          "term": "|"
        }, {
          "args": [],
          "name": "BitwiseXORExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-binary-bitwise-operators-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (EvaluateStringOrNumericBinaryExpression BitwiseORExpression \"|\" BitwiseXORExpression)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["        1. Let _lref_ be the result of evaluating |LogicalANDExpression|.", "        1. Let _lval_ be ? GetValue(_lref_).", "        1. Let _lbool_ be ! ToBoolean(_lval_).", "        1. If _lbool_ is *false*, return _lval_.", "        1. Let _rref_ be the result of evaluating |BitwiseORExpression|.", "        1. Return ? GetValue(_rref_)."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "LogicalANDExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LogicalANDExpression",
          "optional": false
        }, {
          "term": "&&"
        }, {
          "args": [],
          "name": "BitwiseORExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-binary-logical-operators-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (LogicalANDExpression \"Evaluation\")\n  0:let lref = __x0__\n  1:(1) app __x1__ = (GetValue lref)\n  1:let lval = [? __x1__]\n  2:(2) app __x2__ = (ToBoolean lval)\n  2:let lbool = [! __x2__]\n  3:if (= lbool false) return lval else 3:{}\n  4:(3) access __x3__ = (BitwiseORExpression \"Evaluation\")\n  4:let rref = __x3__\n  5:(4) app __x4__ = (GetValue rref)\n  5:return [? __x4__]\n}"
  }, {
    "code": ["        1. Let _lref_ be the result of evaluating |LogicalORExpression|.", "        1. Let _lval_ be ? GetValue(_lref_).", "        1. Let _lbool_ be ! ToBoolean(_lval_).", "        1. If _lbool_ is *true*, return _lval_.", "        1. Let _rref_ be the result of evaluating |LogicalANDExpression|.", "        1. Return ? GetValue(_rref_)."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "LogicalORExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LogicalORExpression",
          "optional": false
        }, {
          "term": "||"
        }, {
          "args": [],
          "name": "LogicalANDExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-binary-logical-operators-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (LogicalORExpression \"Evaluation\")\n  0:let lref = __x0__\n  1:(1) app __x1__ = (GetValue lref)\n  1:let lval = [? __x1__]\n  2:(2) app __x2__ = (ToBoolean lval)\n  2:let lbool = [! __x2__]\n  3:if (= lbool true) return lval else 3:{}\n  4:(3) access __x3__ = (LogicalANDExpression \"Evaluation\")\n  4:let rref = __x3__\n  5:(4) app __x4__ = (GetValue rref)\n  5:return [? __x4__]\n}"
  }, {
    "code": ["        1. Let _lref_ be the result of evaluating |CoalesceExpressionHead|.", "        1. Let _lval_ be ? GetValue(_lref_).", "        1. If _lval_ is *undefined* or *null*, then", "          1. Let _rref_ be the result of evaluating |BitwiseORExpression|.", "          1. Return ? GetValue(_rref_).", "        1. Otherwise, return _lval_."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "CoalesceExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CoalesceExpressionHead",
          "optional": false
        }, {
          "term": "??"
        }, {
          "args": [],
          "name": "BitwiseORExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-binary-logical-operators-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (CoalesceExpressionHead \"Evaluation\")\n  0:let lref = __x0__\n  1:(1) app __x1__ = (GetValue lref)\n  1:let lval = [? __x1__]\n  5:if (|| (= lval undefined) (= lval null)) {\n    3:(2) access __x2__ = (BitwiseORExpression \"Evaluation\")\n    3:let rref = __x2__\n    4:(3) app __x3__ = (GetValue rref)\n    4:return [? __x3__]\n  } else return lval\n}"
  }, {
    "code": ["        1. Let _lref_ be the result of evaluating |ShortCircuitExpression|.", "        1. Let _lval_ be ! ToBoolean(? GetValue(_lref_)).", "        1. If _lval_ is *true*, then", "          1. Let _trueRef_ be the result of evaluating the first |AssignmentExpression|.", "          1. Return ? GetValue(_trueRef_).", "        1. Else,", "          1. Let _falseRef_ be the result of evaluating the second |AssignmentExpression|.", "          1. Return ? GetValue(_falseRef_)."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "ConditionalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ShortCircuitExpression",
          "optional": false
        }, {
          "term": "?"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-conditional-operator-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (ShortCircuitExpression \"Evaluation\")\n  0:let lref = __x0__\n  1:(1) app __x1__ = (GetValue lref)\n  1:(2) app __x2__ = (ToBoolean [? __x1__])\n  1:let lval = [! __x2__]\n  5:if (= lval true) {\n    3:(3) access __x3__ = (AssignmentExpression0 \"Evaluation\")\n    3:let trueRef = __x3__\n    4:(4) app __x4__ = (GetValue trueRef)\n    4:return [? __x4__]\n  } else {\n    6:(5) access __x5__ = (AssignmentExpression1 \"Evaluation\")\n    6:let falseRef = __x5__\n    7:(6) app __x6__ = (GetValue falseRef)\n    7:return [? __x6__]\n  }\n}"
  }, {
    "code": ["        1. If |LeftHandSideExpression| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then", "          1. Let _lref_ be the result of evaluating |LeftHandSideExpression|.", "          1. ReturnIfAbrupt(_lref_).", "          1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) and IsIdentifierRef of |LeftHandSideExpression| are both *true*, then", "            1. Let _rval_ be NamedEvaluation of |AssignmentExpression| with argument _lref_.[[ReferencedName]].", "          1. Else,", "            1. Let _rref_ be the result of evaluating |AssignmentExpression|.", "            1. Let _rval_ be ? GetValue(_rref_).", "          1. [id=\"step-assignmentexpression-evaluation-simple-putvalue\"] Perform ? PutValue(_lref_, _rval_).", "          1. Return _rval_.", "        1. Let _assignmentPattern_ be the |AssignmentPattern| that is covered by |LeftHandSideExpression|.", "        1. Let _rref_ be the result of evaluating |AssignmentExpression|.", "        1. Let _rval_ be ? GetValue(_rref_).", "        1. Perform ? DestructuringAssignmentEvaluation of _assignmentPattern_ using _rval_ as the argument.", "        1. Return _rval_."],
    "head": {
      "idx": 4,
      "methodName": "Evaluation",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "="
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-assignment-operators-runtime-semantics-evaluation",
    "rawBody": "{\n  0:if (! (|| (0) (is-instance-of LeftHandSideExpression ObjectLiteral) (1) (is-instance-of LeftHandSideExpression ArrayLiteral))) {\n    1:(0) access __x0__ = (LeftHandSideExpression \"Evaluation\")\n    1:let lref = __x0__\n    2:[? lref]\n    5:(1) app __x1__ = (IsAnonymousFunctionDefinition AssignmentExpression)\n    5:(2) access __x2__ = (LeftHandSideExpression \"IsIdentifierRef\")\n    5:if (&& (= __x1__ true) (= __x2__ true)) {\n      4:(3) access __x3__ = (AssignmentExpression \"NamedEvaluation\" lref[\"ReferencedName\"])\n      4:let rval = __x3__\n    } else {\n      6:(4) access __x4__ = (AssignmentExpression \"Evaluation\")\n      6:let rref = __x4__\n      7:(5) app __x5__ = (GetValue rref)\n      7:let rval = [? __x5__]\n    }\n    8:(6) app __x6__ = (PutValue lref rval)\n    8:[? __x6__]\n    9:return rval\n  } else 3:{}\n  10:let assignmentPattern = (parse-syntax LeftHandSideExpression \"AssignmentPattern\" (2) (new []))\n  11:(7) access __x7__ = (AssignmentExpression \"Evaluation\")\n  11:let rref = __x7__\n  12:(8) app __x8__ = (GetValue rref)\n  12:let rval = [? __x8__]\n  13:(9) access __x9__ = (assignmentPattern \"DestructuringAssignmentEvaluation\" rval)\n  13:[? __x9__]\n  14:return rval\n}"
  }, {
    "code": ["        1. Let _lref_ be the result of evaluating |LeftHandSideExpression|.", "        1. [id=\"step-assignmentexpression-evaluation-compound-getvalue\"] Let _lval_ be ? GetValue(_lref_).", "        1. Let _rref_ be the result of evaluating |AssignmentExpression|.", "        1. Let _rval_ be ? GetValue(_rref_).", "        1. Let _assignmentOpText_ be the source text matched by |AssignmentOperator|.", "        1. Let _opText_ be the sequence of Unicode code points associated with _assignmentOpText_ in the following table:", "          <figure>", "            <table class=\"lightweight-table\">", "              <tbody>", "                <tr><th> _assignmentOpText_ </th><th> _opText_       </th></tr>", "                <tr><td> `**=`              </td><td> `**`           </td></tr>", "                <tr><td> `*=`               </td><td> `*`            </td></tr>", "                <tr><td> `/=`               </td><td> `/`            </td></tr>", "                <tr><td> `%=`               </td><td> `%`            </td></tr>", "                <tr><td> `+=`               </td><td> `+`            </td></tr>", "                <tr><td> `-=`               </td><td> `-`            </td></tr>", "                <tr><td> `<<=`        </td><td> `<<`     </td></tr>", "                <tr><td> `>>=`        </td><td> `>>`     </td></tr>", "                <tr><td> `>>>=`    </td><td> `>>>` </td></tr>", "                <tr><td> `&=`           </td><td> `&`        </td></tr>", "                <tr><td> `^=`               </td><td> `^`            </td></tr>", "                <tr><td> `|=`               </td><td> `|`            </td></tr>", "              </tbody>", "            </table>", "          </figure>", "        1. Let _r_ be ApplyStringOrNumericBinaryOperator(_lval_, _opText_, _rval_).", "        1. [id=\"step-assignmentexpression-evaluation-compound-putvalue\"] Perform ? PutValue(_lref_, _r_).", "        1. Return _r_."],
    "head": {
      "idx": 5,
      "methodName": "Evaluation",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "args": [],
          "name": "AssignmentOperator",
          "optional": false
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-assignment-operators-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (LeftHandSideExpression \"Evaluation\")\n  0:let lref = __x0__\n  1:(1) app __x1__ = (GetValue lref)\n  1:let lval = [? __x1__]\n  2:(2) access __x2__ = (AssignmentExpression \"Evaluation\")\n  2:let rref = __x2__\n  3:(3) app __x3__ = (GetValue rref)\n  3:let rval = [? __x3__]\n  4:let assignmentOpText = (get-syntax AssignmentOperator)\n  5:(0) ??? \"Let id:{opText} be the sequence of Unicode code points associated with id:{assignmentOpText} in the following table : in:{} out:{}\"\n  25:(4) app __x4__ = (ApplyStringOrNumericBinaryOperator lval opText rval)\n  25:let r = __x4__\n  26:(5) app __x5__ = (PutValue lref r)\n  26:[? __x5__]\n  27:return r\n}"
  }, {
    "code": ["        1. Let _lref_ be the result of evaluating |LeftHandSideExpression|.", "        1. [id=\"step-assignmentexpression-evaluation-lgcl-and-getvalue\"] Let _lval_ be ? GetValue(_lref_).", "        1. Let _lbool_ be ! ToBoolean(_lval_).", "        1. If _lbool_ is *false*, return _lval_.", "        1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true* and IsIdentifierRef of |LeftHandSideExpression| is *true*, then", "          1. Let _rval_ be NamedEvaluation of |AssignmentExpression| with argument _lref_.[[ReferencedName]].", "        1. Else,", "          1. Let _rref_ be the result of evaluating |AssignmentExpression|.", "          1. Let _rval_ be ? GetValue(_rref_).", "        1. [id=\"step-assignmentexpression-evaluation-lgcl-and-putvalue\"] Perform ? PutValue(_lref_, _rval_).", "        1. Return _rval_."],
    "head": {
      "idx": 6,
      "methodName": "Evaluation",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "&&="
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-assignment-operators-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (LeftHandSideExpression \"Evaluation\")\n  0:let lref = __x0__\n  1:(1) app __x1__ = (GetValue lref)\n  1:let lval = [? __x1__]\n  2:(2) app __x2__ = (ToBoolean lval)\n  2:let lbool = [! __x2__]\n  3:if (= lbool false) return lval else 3:{}\n  6:let __x3__ = true\n  6:(3) app __x4__ = (IsAnonymousFunctionDefinition AssignmentExpression)\n  6:__x3__ = (= __x4__ true)\n  6:if __x3__ {\n    (4) access __x5__ = (LeftHandSideExpression \"IsIdentifierRef\")\n    __x3__ = (= __x5__ true)\n  } else 3:{}\n  6:if __x3__ {\n    5:(5) access __x6__ = (AssignmentExpression \"NamedEvaluation\" lref[\"ReferencedName\"])\n    5:let rval = __x6__\n  } else {\n    7:(6) access __x7__ = (AssignmentExpression \"Evaluation\")\n    7:let rref = __x7__\n    8:(7) app __x8__ = (GetValue rref)\n    8:let rval = [? __x8__]\n  }\n  9:(8) app __x9__ = (PutValue lref rval)\n  9:[? __x9__]\n  10:return rval\n}"
  }, {
    "code": ["        1. Let _lref_ be the result of evaluating |LeftHandSideExpression|.", "        1. [id=\"step-assignmentexpression-evaluation-lgcl-or-getvalue\"] Let _lval_ be ? GetValue(_lref_).", "        1. Let _lbool_ be ! ToBoolean(_lval_).", "        1. If _lbool_ is *true*, return _lval_.", "        1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true* and IsIdentifierRef of |LeftHandSideExpression| is *true*, then", "          1. Let _rval_ be NamedEvaluation of |AssignmentExpression| with argument _lref_.[[ReferencedName]].", "        1. Else,", "          1. Let _rref_ be the result of evaluating |AssignmentExpression|.", "          1. Let _rval_ be ? GetValue(_rref_).", "        1. [id=\"step-assignmentexpression-evaluation-lgcl-or-putvalue\"] Perform ? PutValue(_lref_, _rval_).", "        1. Return _rval_."],
    "head": {
      "idx": 7,
      "methodName": "Evaluation",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "||="
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-assignment-operators-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (LeftHandSideExpression \"Evaluation\")\n  0:let lref = __x0__\n  1:(1) app __x1__ = (GetValue lref)\n  1:let lval = [? __x1__]\n  2:(2) app __x2__ = (ToBoolean lval)\n  2:let lbool = [! __x2__]\n  3:if (= lbool true) return lval else 3:{}\n  6:let __x3__ = true\n  6:(3) app __x4__ = (IsAnonymousFunctionDefinition AssignmentExpression)\n  6:__x3__ = (= __x4__ true)\n  6:if __x3__ {\n    (4) access __x5__ = (LeftHandSideExpression \"IsIdentifierRef\")\n    __x3__ = (= __x5__ true)\n  } else 3:{}\n  6:if __x3__ {\n    5:(5) access __x6__ = (AssignmentExpression \"NamedEvaluation\" lref[\"ReferencedName\"])\n    5:let rval = __x6__\n  } else {\n    7:(6) access __x7__ = (AssignmentExpression \"Evaluation\")\n    7:let rref = __x7__\n    8:(7) app __x8__ = (GetValue rref)\n    8:let rval = [? __x8__]\n  }\n  9:(8) app __x9__ = (PutValue lref rval)\n  9:[? __x9__]\n  10:return rval\n}"
  }, {
    "code": ["        1. Let _lref_ be the result of evaluating |LeftHandSideExpression|.", "        1. [id=\"step-assignmentexpression-evaluation-lgcl-nullish-getvalue\"] Let _lval_ be ? GetValue(_lref_).", "        1. If _lval_ is neither *undefined* nor *null*, return _lval_.", "        1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true* and IsIdentifierRef of |LeftHandSideExpression| is *true*, then", "          1. Let _rval_ be NamedEvaluation of |AssignmentExpression| with argument _lref_.[[ReferencedName]].", "        1. Else,", "          1. Let _rref_ be the result of evaluating |AssignmentExpression|.", "          1. Let _rval_ be ? GetValue(_rref_).", "        1. [id=\"step-assignmentexpression-evaluation-lgcl-nullish-putvalue\"] Perform ? PutValue(_lref_, _rval_).", "        1. Return _rval_."],
    "head": {
      "idx": 8,
      "methodName": "Evaluation",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "??="
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-assignment-operators-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (LeftHandSideExpression \"Evaluation\")\n  0:let lref = __x0__\n  1:(1) app __x1__ = (GetValue lref)\n  1:let lval = [? __x1__]\n  2:if (! (|| (= lval undefined) (= lval null))) return lval else 3:{}\n  5:let __x2__ = true\n  5:(2) app __x3__ = (IsAnonymousFunctionDefinition AssignmentExpression)\n  5:__x2__ = (= __x3__ true)\n  5:if __x2__ {\n    (3) access __x4__ = (LeftHandSideExpression \"IsIdentifierRef\")\n    __x2__ = (= __x4__ true)\n  } else 3:{}\n  5:if __x2__ {\n    4:(4) access __x5__ = (AssignmentExpression \"NamedEvaluation\" lref[\"ReferencedName\"])\n    4:let rval = __x5__\n  } else {\n    6:(5) access __x6__ = (AssignmentExpression \"Evaluation\")\n    6:let rref = __x6__\n    7:(6) app __x7__ = (GetValue rref)\n    7:let rval = [? __x7__]\n  }\n  8:(7) app __x8__ = (PutValue lref rval)\n  8:[? __x8__]\n  9:return rval\n}"
  }, {
    "code": ["        1. Assert: _opText_ is present in the table in step <emu-xref href=\"#step-applystringornumericbinaryoperator-operations-table\"></emu-xref>.", "        1. If _opText_ is `+`, then", "          1. [id=\"step-binary-op-toprimitive-lval\"] Let _lprim_ be ? ToPrimitive(_lval_).", "          1. [id=\"step-binary-op-toprimitive-rval\"] Let _rprim_ be ? ToPrimitive(_rval_).", "          1. [id=\"step-binary-op-string-check\"] If Type(_lprim_) is String or Type(_rprim_) is String, then", "            1. Let _lstr_ be ? ToString(_lprim_).", "            1. Let _rstr_ be ? ToString(_rprim_).", "            1. Return the string-concatenation of _lstr_ and _rstr_.", "          1. Set _lval_ to _lprim_.", "          1. Set _rval_ to _rprim_.", "        1. NOTE: At this point, it must be a numeric operation.", "        1. Let _lnum_ be ? ToNumeric(_lval_).", "        1. Let _rnum_ be ? ToNumeric(_rval_).", "        1. If Type(_lnum_) is different from Type(_rnum_), throw a *TypeError* exception.", "        1. Let _T_ be Type(_lnum_).", "        1. [id=\"step-applystringornumericbinaryoperator-operations-table\"] Let _operation_ be the abstract operation associated with _opText_ in the following table:", "          <figure>", "            <table class=\"lightweight-table\">", "              <tbody>", "                <tr><th> _opText_       </th><th> _operation_             </th></tr>", "                <tr><td> `**`           </td><td> _T_::exponentiate       </td></tr>", "                <tr><td> `*`            </td><td> _T_::multiply           </td></tr>", "                <tr><td> `/`            </td><td> _T_::divide             </td></tr>", "                <tr><td> `%`            </td><td> _T_::remainder          </td></tr>", "                <tr><td> `+`            </td><td> _T_::add                </td></tr>", "                <tr><td> `-`            </td><td> _T_::subtract           </td></tr>", "                <tr><td> `<<`     </td><td> _T_::leftShift          </td></tr>", "                <tr><td> `>>`     </td><td> _T_::signedRightShift   </td></tr>", "                <tr><td> `>>>` </td><td> _T_::unsignedRightShift </td></tr>", "                <tr><td> `&`        </td><td> _T_::bitwiseAND         </td></tr>", "                <tr><td> `^`            </td><td> _T_::bitwiseXOR         </td></tr>", "                <tr><td> `|`            </td><td> _T_::bitwiseOR          </td></tr>", "              </tbody>", "            </table>", "          </figure>", "        1. Return ? _operation_(_lnum_, _rnum_)."],
    "head": {
      "name": "ApplyStringOrNumericBinaryOperator",
      "params": [{
        "kind": "Normal",
        "name": "lval"
      }, {
        "kind": "Normal",
        "name": "opText"
      }, {
        "kind": "Normal",
        "name": "rval"
      }]
    },
    "ids": "sec-applystringornumericbinaryoperator",
    "rawBody": "{\n  1:if (= opText \"+\") {\n    2:(0) app __x0__ = (ToPrimitive lval)\n    2:let lprim = [? __x0__]\n    3:(1) app __x1__ = (ToPrimitive rval)\n    3:let rprim = [? __x1__]\n    4:if (|| (= (typeof lprim) String) (= (typeof rprim) String)) {\n      5:(2) app __x2__ = (ToString lprim)\n      5:let lstr = [? __x2__]\n      6:(3) app __x3__ = (ToString rprim)\n      6:let rstr = [? __x3__]\n      7:return (+ lstr rstr)\n    } else 10:{}\n    8:lval = lprim\n    9:rval = rprim\n  } else 10:{}\n  11:(4) app __x4__ = (ToNumeric lval)\n  11:let lnum = [? __x4__]\n  12:(5) app __x5__ = (ToNumeric rval)\n  12:let rnum = [? __x5__]\n  13:if (! (= (typeof lnum) (typeof rnum))) (0) throw TypeError else 10:{}\n  14:let T = (typeof lnum)\n  15:let m = PRIMITIVE[T]\n  15:if (= opText \"**\") let operation = m[\"exponentiate\"] else if (= opText \"*\") let operation = m[\"multiply\"] else if (= opText \"/\") let operation = m[\"divide\"] else if (= opText \"%\") let operation = m[\"remainder\"] else if (= opText \"+\") let operation = m[\"add\"] else if (= opText \"-\") let operation = m[\"subtract\"] else if (= opText \"<<\") let operation = m[\"leftShift\"] else if (= opText \">>\") let operation = m[\"signedRightShift\"] else if (= opText \">>>\") let operation = m[\"unsignedRightShift\"] else if (= opText \"&\") let operation = m[\"bitwiseAND\"] else if (= opText \"^\") let operation = m[\"bitwiseXOR\"] else if (= opText \"|\") let operation = m[\"bitwiseOR\"] else return 0i\n  35:(6) app __x6__ = (operation lnum rnum)\n  35:return [? __x6__]\n}"
  }, {
    "code": ["        1. Let _lref_ be the result of evaluating _leftOperand_.", "        1. Let _lval_ be ? GetValue(_lref_).", "        1. Let _rref_ be the result of evaluating _rightOperand_.", "        1. Let _rval_ be ? GetValue(_rref_).", "        1. Return ? ApplyStringOrNumericBinaryOperator(_lval_, _opText_, _rval_)."],
    "head": {
      "name": "EvaluateStringOrNumericBinaryExpression",
      "params": [{
        "kind": "Normal",
        "name": "leftOperand"
      }, {
        "kind": "Normal",
        "name": "opText"
      }, {
        "kind": "Normal",
        "name": "rightOperand"
      }]
    },
    "ids": "sec-evaluatestringornumericbinaryexpression",
    "rawBody": "{\n  0:(0) access __x0__ = (leftOperand \"Evaluation\")\n  0:let lref = __x0__\n  1:(1) app __x1__ = (GetValue lref)\n  1:let lval = [? __x1__]\n  2:(2) access __x2__ = (rightOperand \"Evaluation\")\n  2:let rref = __x2__\n  3:(3) app __x3__ = (GetValue rref)\n  3:let rval = [? __x3__]\n  4:(4) app __x4__ = (ApplyStringOrNumericBinaryOperator lval opText rval)\n  4:return [? __x4__]\n}"
  }, {
    "code": ["          1. Perform ? RequireObjectCoercible(_value_).", "          1. Return NormalCompletion(~empty~)."],
    "head": {
      "idx": 0,
      "methodName": "DestructuringAssignmentEvaluation",
      "prod": "ObjectAssignmentPattern",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "sec-runtime-semantics-destructuringassignmentevaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible value)\n  0:[? __x0__]\n  1:return CONST_empty\n}"
  }, {
    "code": ["          1. Perform ? RequireObjectCoercible(_value_).", "          1. Perform ? PropertyDestructuringAssignmentEvaluation for |AssignmentPropertyList| using _value_ as the argument.", "          1. Return NormalCompletion(~empty~)."],
    "head": {
      "idx": 2,
      "methodName": "DestructuringAssignmentEvaluation",
      "prod": "ObjectAssignmentPattern",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "AssignmentPropertyList",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "sec-runtime-semantics-destructuringassignmentevaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible value)\n  0:[? __x0__]\n  1:(1) access __x1__ = (AssignmentPropertyList \"PropertyDestructuringAssignmentEvaluation\" value)\n  1:[? __x1__]\n  2:return CONST_empty\n}"
  }, {
    "code": ["          1. Perform ? RequireObjectCoercible(_value_).", "          1. Perform ? PropertyDestructuringAssignmentEvaluation for |AssignmentPropertyList| using _value_ as the argument.", "          1. Return NormalCompletion(~empty~)."],
    "head": {
      "idx": 3,
      "methodName": "DestructuringAssignmentEvaluation",
      "prod": "ObjectAssignmentPattern",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "AssignmentPropertyList",
          "optional": false
        }, {
          "term": ","
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "sec-runtime-semantics-destructuringassignmentevaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible value)\n  0:[? __x0__]\n  1:(1) access __x1__ = (AssignmentPropertyList \"PropertyDestructuringAssignmentEvaluation\" value)\n  1:[? __x1__]\n  2:return CONST_empty\n}"
  }, {
    "code": ["          1. Let _iteratorRecord_ be ? GetIterator(_value_).", "          1. Return ? IteratorClose(_iteratorRecord_, NormalCompletion(~empty~))."],
    "head": {
      "idx": 0,
      "methodName": "DestructuringAssignmentEvaluation",
      "prod": "ArrayAssignmentPattern",
      "rhs": {
        "tokens": [{
          "term": "["
        }, {
          "term": "]"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "sec-runtime-semantics-destructuringassignmentevaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (GetIterator value)\n  0:let iteratorRecord = [? __x0__]\n  1:(1) app __x1__ = (NormalCompletion CONST_empty)\n  1:(2) app __x2__ = (IteratorClose iteratorRecord __x1__)\n  1:return [? __x2__]\n}"
  }, {
    "code": ["          1. Let _iteratorRecord_ be ? GetIterator(_value_).", "          1. Let _result_ be IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.", "          1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _result_).", "          1. Return _result_."],
    "head": {
      "idx": 0,
      "methodName": "DestructuringAssignmentEvaluation",
      "prod": "ArrayAssignmentPattern",
      "rhs": {
        "tokens": [{
          "term": "["
        }, {
          "args": [],
          "name": "Elision",
          "optional": false
        }, {
          "term": "]"
        }]
      },
      "subIdx": 2,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "sec-runtime-semantics-destructuringassignmentevaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (GetIterator value)\n  0:let iteratorRecord = [? __x0__]\n  1:(1) access __x1__ = (Elision \"IteratorDestructuringAssignmentEvaluation\" iteratorRecord)\n  1:let result = __x1__\n  2:if (= iteratorRecord[\"Done\"] false) {\n    (2) app __x2__ = (IteratorClose iteratorRecord result)\n    return [? __x2__]\n  } else 10:{}\n  3:return result\n}"
  }, {
    "code": ["          1. Let _iteratorRecord_ be ? GetIterator(_value_).", "          1. If |Elision| is present, then", "            1. Let _status_ be IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.", "            1. If _status_ is an abrupt completion, then", "              1. Assert: _iteratorRecord_.[[Done]] is *true*.", "              1. Return Completion(_status_).", "          1. Let _result_ be IteratorDestructuringAssignmentEvaluation of |AssignmentRestElement| with argument _iteratorRecord_.", "          1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _result_).", "          1. Return _result_."],
    "head": {
      "idx": 0,
      "methodName": "DestructuringAssignmentEvaluation",
      "prod": "ArrayAssignmentPattern",
      "rhs": {
        "tokens": [{
          "term": "["
        }, {
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "args": [],
          "name": "AssignmentRestElement",
          "optional": false
        }, {
          "term": "]"
        }]
      },
      "subIdx": 3,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "sec-runtime-semantics-destructuringassignmentevaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (GetIterator value)\n  0:let iteratorRecord = [? __x0__]\n  1:if (! (= Elision absent)) {\n    2:(1) access __x1__ = (Elision \"IteratorDestructuringAssignmentEvaluation\" iteratorRecord)\n    2:let status = __x1__\n    3:(2) app __x2__ = (IsAbruptCompletion status)\n    3:if __x2__ {\n      4:assert (= iteratorRecord[\"Done\"] true)\n      5:return status\n    } else 10:{}\n  } else 10:{}\n  6:(3) access __x3__ = (AssignmentRestElement \"IteratorDestructuringAssignmentEvaluation\" iteratorRecord)\n  6:let result = __x3__\n  7:if (= iteratorRecord[\"Done\"] false) {\n    (4) app __x4__ = (IteratorClose iteratorRecord result)\n    return [? __x4__]\n  } else 10:{}\n  8:return result\n}"
  }, {
    "code": ["          1. Let _iteratorRecord_ be ? GetIterator(_value_).", "          1. Let _result_ be IteratorDestructuringAssignmentEvaluation of |AssignmentElementList| with argument _iteratorRecord_.", "          1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _result_).", "          1. Return _result_."],
    "head": {
      "idx": 1,
      "methodName": "DestructuringAssignmentEvaluation",
      "prod": "ArrayAssignmentPattern",
      "rhs": {
        "tokens": [{
          "term": "["
        }, {
          "args": [],
          "name": "AssignmentElementList",
          "optional": false
        }, {
          "term": "]"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "sec-runtime-semantics-destructuringassignmentevaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (GetIterator value)\n  0:let iteratorRecord = [? __x0__]\n  1:(1) access __x1__ = (AssignmentElementList \"IteratorDestructuringAssignmentEvaluation\" iteratorRecord)\n  1:let result = __x1__\n  2:if (= iteratorRecord[\"Done\"] false) {\n    (2) app __x2__ = (IteratorClose iteratorRecord result)\n    return [? __x2__]\n  } else 10:{}\n  3:return result\n}"
  }, {
    "code": ["          1. Let _iteratorRecord_ be ? GetIterator(_value_).", "          1. Let _status_ be IteratorDestructuringAssignmentEvaluation of |AssignmentElementList| with argument _iteratorRecord_.", "          1. If _status_ is an abrupt completion, then", "            1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _status_).", "            1. Return Completion(_status_).", "          1. If |Elision| is present, then", "            1. Set _status_ to the result of performing IteratorDestructuringAssignmentEvaluation of |Elision| with _iteratorRecord_ as the argument.", "            1. If _status_ is an abrupt completion, then", "              1. Assert: _iteratorRecord_.[[Done]] is *true*.", "              1. Return Completion(_status_).", "          1. If |AssignmentRestElement| is present, then", "            1. Set _status_ to the result of performing IteratorDestructuringAssignmentEvaluation of |AssignmentRestElement| with _iteratorRecord_ as the argument.", "          1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _status_).", "          1. Return Completion(_status_)."],
    "head": {
      "idx": 2,
      "methodName": "DestructuringAssignmentEvaluation",
      "prod": "ArrayAssignmentPattern",
      "rhs": {
        "tokens": [{
          "term": "["
        }, {
          "args": [],
          "name": "AssignmentElementList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "args": [],
          "name": "AssignmentRestElement",
          "optional": true
        }, {
          "term": "]"
        }]
      },
      "subIdx": 3,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "sec-runtime-semantics-destructuringassignmentevaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (GetIterator value)\n  0:let iteratorRecord = [? __x0__]\n  1:(1) access __x1__ = (AssignmentElementList \"IteratorDestructuringAssignmentEvaluation\" iteratorRecord)\n  1:let status = __x1__\n  2:(2) app __x2__ = (IsAbruptCompletion status)\n  2:if __x2__ {\n    3:if (= iteratorRecord[\"Done\"] false) {\n      (3) app __x3__ = (IteratorClose iteratorRecord status)\n      return [? __x3__]\n    } else 10:{}\n    4:return status\n  } else 10:{}\n  5:if (! (= Elision absent)) {\n    6:(4) access __x4__ = (Elision \"IteratorDestructuringAssignmentEvaluation\" iteratorRecord)\n    6:status = __x4__\n    7:(5) app __x5__ = (IsAbruptCompletion status)\n    7:if __x5__ {\n      8:assert (= iteratorRecord[\"Done\"] true)\n      9:return status\n    } else 10:{}\n  } else 10:{}\n  10:if (! (= AssignmentRestElement absent)) {\n    11:(6) access __x6__ = (AssignmentRestElement \"IteratorDestructuringAssignmentEvaluation\" iteratorRecord)\n    11:status = __x6__\n  } else 10:{}\n  12:if (= iteratorRecord[\"Done\"] false) {\n    (7) app __x7__ = (IteratorClose iteratorRecord status)\n    return [? __x7__]\n  } else 10:{}\n  13:return status\n}"
  }, {
    "code": ["          1. Perform ? RequireObjectCoercible(_value_).", "          1. Let _excludedNames_ be a new empty List.", "          1. Return the result of performing RestDestructuringAssignmentEvaluation of |AssignmentRestProperty| with _value_ and _excludedNames_ as the arguments."],
    "head": {
      "idx": 1,
      "methodName": "DestructuringAssignmentEvaluation",
      "prod": "ObjectAssignmentPattern",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "AssignmentRestProperty",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "sec-runtime-semantics-destructuringassignmentevaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible value)\n  0:[? __x0__]\n  1:let excludedNames = (0) (new [])\n  2:(1) access __x1__ = (AssignmentRestProperty \"RestDestructuringAssignmentEvaluation\" value excludedNames)\n  2:return __x1__\n}"
  }, {
    "code": ["          1. Perform ? RequireObjectCoercible(_value_).", "          1. Let _excludedNames_ be ? PropertyDestructuringAssignmentEvaluation of |AssignmentPropertyList| with argument _value_.", "          1. Return the result of performing RestDestructuringAssignmentEvaluation of |AssignmentRestProperty| with arguments _value_ and _excludedNames_."],
    "head": {
      "idx": 3,
      "methodName": "DestructuringAssignmentEvaluation",
      "prod": "ObjectAssignmentPattern",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "AssignmentPropertyList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "AssignmentRestProperty",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "sec-runtime-semantics-destructuringassignmentevaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible value)\n  0:[? __x0__]\n  1:(1) access __x1__ = (AssignmentPropertyList \"PropertyDestructuringAssignmentEvaluation\" value)\n  1:let excludedNames = [? __x1__]\n  2:(2) access __x2__ = (AssignmentRestProperty \"RestDestructuringAssignmentEvaluation\" value excludedNames)\n  2:return __x2__\n}"
  }, {
    "code": ["          1. Let _propertyNames_ be ? PropertyDestructuringAssignmentEvaluation of |AssignmentPropertyList| with argument _value_.", "          1. Let _nextNames_ be ? PropertyDestructuringAssignmentEvaluation of |AssignmentProperty| with argument _value_.", "          1. Append each item in _nextNames_ to the end of _propertyNames_.", "          1. Return _propertyNames_."],
    "head": {
      "idx": 1,
      "methodName": "PropertyDestructuringAssignmentEvaluation",
      "prod": "AssignmentPropertyList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AssignmentPropertyList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "AssignmentProperty",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "sec-runtime-semantics-propertydestructuringassignmentevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (AssignmentPropertyList \"PropertyDestructuringAssignmentEvaluation\" value)\n  0:let propertyNames = [? __x0__]\n  1:(1) access __x1__ = (AssignmentProperty \"PropertyDestructuringAssignmentEvaluation\" value)\n  1:let nextNames = [? __x1__]\n  2:let __x2__ = nextNames\n  2:let __x3__ = 0i\n  2:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> propertyNames\n    __x3__ = (+ __x3__ 1i)\n  }\n  3:return propertyNames\n}"
  }, {
    "code": ["          1. Let _P_ be StringValue of |IdentifierReference|.", "          1. Let _lref_ be ? ResolveBinding(_P_).", "          1. Let _v_ be ? GetV(_value_, _P_).", "          1. If |Initializer_opt| is present and _v_ is *undefined*, then", "            1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then", "              1. Set _v_ to the result of performing NamedEvaluation for |Initializer| with argument _P_.", "            1. Else,", "              1. Let _defaultValue_ be the result of evaluating |Initializer|.", "              1. Set _v_ to ? GetValue(_defaultValue_).", "          1. Perform ? PutValue(_lref_, _v_).", "          1. Return a List whose sole element is _P_."],
    "head": {
      "idx": 0,
      "methodName": "PropertyDestructuringAssignmentEvaluation",
      "prod": "AssignmentProperty",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "IdentifierReference",
          "optional": false
        }, {
          "args": [],
          "name": "Initializer",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "sec-runtime-semantics-propertydestructuringassignmentevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (IdentifierReference \"StringValue\")\n  0:let P = __x0__\n  1:(1) app __x1__ = (ResolveBinding P)\n  1:let lref = [? __x1__]\n  2:(2) app __x2__ = (GetV value P)\n  2:let v = [? __x2__]\n  3:if (&& (! (= Initializer absent)) (= v undefined)) {\n    6:(3) app __x3__ = (IsAnonymousFunctionDefinition Initializer)\n    6:if (= __x3__ true) {\n      5:(4) access __x4__ = (Initializer \"NamedEvaluation\" P)\n      5:v = __x4__\n    } else {\n      7:(5) access __x5__ = (Initializer \"Evaluation\")\n      7:let defaultValue = __x5__\n      8:(6) app __x6__ = (GetValue defaultValue)\n      8:v = [? __x6__]\n    }\n  } else 10:{}\n  9:(7) app __x7__ = (PutValue lref v)\n  9:[? __x7__]\n  10:return (0) (new [P])\n}"
  }, {
    "code": ["          1. Let _name_ be the result of evaluating |PropertyName|.", "          1. ReturnIfAbrupt(_name_).", "          1. Perform ? KeyedDestructuringAssignmentEvaluation of |AssignmentElement| with _value_ and _name_ as the arguments.", "          1. Return a List whose sole element is _name_."],
    "head": {
      "idx": 1,
      "methodName": "PropertyDestructuringAssignmentEvaluation",
      "prod": "AssignmentProperty",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "AssignmentElement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "sec-runtime-semantics-propertydestructuringassignmentevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (PropertyName \"Evaluation\")\n  0:let name = __x0__\n  1:[? name]\n  2:(1) access __x1__ = (AssignmentElement \"KeyedDestructuringAssignmentEvaluation\" value name)\n  2:[? __x1__]\n  3:return (0) (new [name])\n}"
  }, {
    "code": ["          1. Let _lref_ be the result of evaluating |DestructuringAssignmentTarget|.", "          1. ReturnIfAbrupt(_lref_).", "          1. Let _restObj_ be ! OrdinaryObjectCreate(%Object.prototype%).", "          1. Perform ? CopyDataProperties(_restObj_, _value_, _excludedNames_).", "          1. Return PutValue(_lref_, _restObj_)."],
    "head": {
      "idx": 0,
      "methodName": "RestDestructuringAssignmentEvaluation",
      "prod": "AssignmentRestProperty",
      "rhs": {
        "tokens": [{
          "term": "..."
        }, {
          "args": [],
          "name": "DestructuringAssignmentTarget",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "excludedNames"
      }]
    },
    "ids": "sec-runtime-semantics-restdestructuringassignmentevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (DestructuringAssignmentTarget \"Evaluation\")\n  0:let lref = __x0__\n  1:[? lref]\n  2:(1) app __x1__ = (OrdinaryObjectCreate INTRINSIC_Object_prototype)\n  2:let restObj = [! __x1__]\n  3:(2) app __x2__ = (CopyDataProperties restObj value excludedNames)\n  3:[? __x2__]\n  4:(3) app __x3__ = (PutValue lref restObj)\n  4:return __x3__\n}"
  }, {
    "code": ["          1. Return the result of performing IteratorDestructuringAssignmentEvaluation of |AssignmentElisionElement| using _iteratorRecord_ as the argument."],
    "head": {
      "idx": 0,
      "methodName": "IteratorDestructuringAssignmentEvaluation",
      "prod": "AssignmentElementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AssignmentElisionElement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }]
    },
    "ids": "sec-runtime-semantics-iteratordestructuringassignmentevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (AssignmentElisionElement \"IteratorDestructuringAssignmentEvaluation\" iteratorRecord)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Perform ? IteratorDestructuringAssignmentEvaluation of |AssignmentElementList| using _iteratorRecord_ as the argument.", "          1. Return the result of performing IteratorDestructuringAssignmentEvaluation of |AssignmentElisionElement| using _iteratorRecord_ as the argument."],
    "head": {
      "idx": 1,
      "methodName": "IteratorDestructuringAssignmentEvaluation",
      "prod": "AssignmentElementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AssignmentElementList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "AssignmentElisionElement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }]
    },
    "ids": "sec-runtime-semantics-iteratordestructuringassignmentevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (AssignmentElementList \"IteratorDestructuringAssignmentEvaluation\" iteratorRecord)\n  0:[? __x0__]\n  1:(1) access __x1__ = (AssignmentElisionElement \"IteratorDestructuringAssignmentEvaluation\" iteratorRecord)\n  1:return __x1__\n}"
  }, {
    "code": ["          1. Return the result of performing IteratorDestructuringAssignmentEvaluation of |AssignmentElement| with _iteratorRecord_ as the argument."],
    "head": {
      "idx": 0,
      "methodName": "IteratorDestructuringAssignmentEvaluation",
      "prod": "AssignmentElisionElement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AssignmentElement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }]
    },
    "ids": "sec-runtime-semantics-iteratordestructuringassignmentevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (AssignmentElement \"IteratorDestructuringAssignmentEvaluation\" iteratorRecord)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with _iteratorRecord_ as the argument.", "          1. Return the result of performing IteratorDestructuringAssignmentEvaluation of |AssignmentElement| with _iteratorRecord_ as the argument."],
    "head": {
      "idx": 0,
      "methodName": "IteratorDestructuringAssignmentEvaluation",
      "prod": "AssignmentElisionElement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Elision",
          "optional": false
        }, {
          "args": [],
          "name": "AssignmentElement",
          "optional": false
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }]
    },
    "ids": "sec-runtime-semantics-iteratordestructuringassignmentevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Elision \"IteratorDestructuringAssignmentEvaluation\" iteratorRecord)\n  0:[? __x0__]\n  1:(1) access __x1__ = (AssignmentElement \"IteratorDestructuringAssignmentEvaluation\" iteratorRecord)\n  1:return __x1__\n}"
  }, {
    "code": ["          1. If _iteratorRecord_.[[Done]] is *false*, then", "            1. Let _next_ be IteratorStep(_iteratorRecord_).", "            1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.", "            1. ReturnIfAbrupt(_next_).", "            1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.", "          1. Return NormalCompletion(~empty~)."],
    "head": {
      "idx": 0,
      "methodName": "IteratorDestructuringAssignmentEvaluation",
      "prod": "Elision",
      "rhs": {
        "tokens": [{
          "term": ","
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }]
    },
    "ids": "sec-runtime-semantics-iteratordestructuringassignmentevaluation",
    "rawBody": "{\n  0:if (= iteratorRecord[\"Done\"] false) {\n    1:(0) app __x0__ = (IteratorStep iteratorRecord)\n    1:let next = __x0__\n    2:(1) app __x1__ = (IsAbruptCompletion next)\n    2:if __x1__ iteratorRecord[\"Done\"] = true else 10:{}\n    3:[? next]\n    4:if (= next false) iteratorRecord[\"Done\"] = true else 10:{}\n  } else 10:{}\n  5:return CONST_empty\n}"
  }, {
    "code": ["          1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with _iteratorRecord_ as the argument.", "          1. If _iteratorRecord_.[[Done]] is *false*, then", "            1. Let _next_ be IteratorStep(_iteratorRecord_).", "            1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.", "            1. ReturnIfAbrupt(_next_).", "            1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.", "          1. Return NormalCompletion(~empty~)."],
    "head": {
      "idx": 1,
      "methodName": "IteratorDestructuringAssignmentEvaluation",
      "prod": "Elision",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Elision",
          "optional": false
        }, {
          "term": ","
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }]
    },
    "ids": "sec-runtime-semantics-iteratordestructuringassignmentevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Elision \"IteratorDestructuringAssignmentEvaluation\" iteratorRecord)\n  0:[? __x0__]\n  1:if (= iteratorRecord[\"Done\"] false) {\n    2:(1) app __x1__ = (IteratorStep iteratorRecord)\n    2:let next = __x1__\n    3:(2) app __x2__ = (IsAbruptCompletion next)\n    3:if __x2__ iteratorRecord[\"Done\"] = true else 10:{}\n    4:[? next]\n    5:if (= next false) iteratorRecord[\"Done\"] = true else 10:{}\n  } else 10:{}\n  6:return CONST_empty\n}"
  }, {
    "code": ["          1. If |DestructuringAssignmentTarget| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then", "            1. Let _lref_ be the result of evaluating |DestructuringAssignmentTarget|.", "            1. ReturnIfAbrupt(_lref_).", "          1. If _iteratorRecord_.[[Done]] is *false*, then", "            1. Let _next_ be IteratorStep(_iteratorRecord_).", "            1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.", "            1. ReturnIfAbrupt(_next_).", "            1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.", "            1. Else,", "              1. Let _value_ be IteratorValue(_next_).", "              1. If _value_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.", "              1. ReturnIfAbrupt(_value_).", "          1. If _iteratorRecord_.[[Done]] is *true*, let _value_ be *undefined*.", "          1. If |Initializer| is present and _value_ is *undefined*, then", "            1. If IsAnonymousFunctionDefinition(|Initializer|) is *true* and IsIdentifierRef of |DestructuringAssignmentTarget| is *true*, then", "              1. Let _v_ be ? NamedEvaluation of |Initializer| with argument _lref_.[[ReferencedName]].", "            1. Else,", "              1. Let _defaultValue_ be the result of evaluating |Initializer|.", "              1. Let _v_ be ? GetValue(_defaultValue_).", "          1. Else, let _v_ be _value_.", "          1. If |DestructuringAssignmentTarget| is an |ObjectLiteral| or an |ArrayLiteral|, then", "            1. Let _nestedAssignmentPattern_ be the |AssignmentPattern| that is covered by |DestructuringAssignmentTarget|.", "            1. Return the result of performing DestructuringAssignmentEvaluation of _nestedAssignmentPattern_ with _v_ as the argument.", "          1. Return ? PutValue(_lref_, _v_)."],
    "head": {
      "idx": 0,
      "methodName": "IteratorDestructuringAssignmentEvaluation",
      "prod": "AssignmentElement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "DestructuringAssignmentTarget",
          "optional": false
        }, {
          "args": [],
          "name": "Initializer",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }]
    },
    "ids": "sec-runtime-semantics-iteratordestructuringassignmentevaluation",
    "rawBody": "{\n  0:if (! (|| (0) (is-instance-of DestructuringAssignmentTarget ObjectLiteral) (1) (is-instance-of DestructuringAssignmentTarget ArrayLiteral))) {\n    1:(0) access __x0__ = (DestructuringAssignmentTarget \"Evaluation\")\n    1:let lref = __x0__\n    2:[? lref]\n  } else 10:{}\n  3:if (= iteratorRecord[\"Done\"] false) {\n    4:(1) app __x1__ = (IteratorStep iteratorRecord)\n    4:let next = __x1__\n    5:(2) app __x2__ = (IsAbruptCompletion next)\n    5:if __x2__ iteratorRecord[\"Done\"] = true else 10:{}\n    6:[? next]\n    8:if (= next false) iteratorRecord[\"Done\"] = true else {\n      9:(3) app __x3__ = (IteratorValue next)\n      9:let value = __x3__\n      10:(4) app __x4__ = (IsAbruptCompletion value)\n      10:if __x4__ iteratorRecord[\"Done\"] = true else 10:{}\n      11:[? value]\n    }\n  } else 10:{}\n  12:if (= iteratorRecord[\"Done\"] true) let value = undefined else 10:{}\n  19:if (&& (! (= Initializer absent)) (= value undefined)) {\n    16:let __x5__ = true\n    16:(5) app __x6__ = (IsAnonymousFunctionDefinition Initializer)\n    16:__x5__ = (= __x6__ true)\n    16:if __x5__ {\n      (6) access __x7__ = (DestructuringAssignmentTarget \"IsIdentifierRef\")\n      __x5__ = (= __x7__ true)\n    } else 10:{}\n    16:if __x5__ {\n      15:(7) access __x8__ = (Initializer \"NamedEvaluation\" lref[\"ReferencedName\"])\n      15:let v = [? __x8__]\n    } else {\n      17:(8) access __x9__ = (Initializer \"Evaluation\")\n      17:let defaultValue = __x9__\n      18:(9) app __x10__ = (GetValue defaultValue)\n      18:let v = [? __x10__]\n    }\n  } else let v = value\n  20:if (|| (2) (is-instance-of DestructuringAssignmentTarget ObjectLiteral) (3) (is-instance-of DestructuringAssignmentTarget ArrayLiteral)) {\n    21:let nestedAssignmentPattern = (parse-syntax DestructuringAssignmentTarget \"AssignmentPattern\" (4) (new []))\n    22:(10) access __x11__ = (nestedAssignmentPattern \"DestructuringAssignmentEvaluation\" v)\n    22:return __x11__\n  } else 10:{}\n  23:(11) app __x12__ = (PutValue lref v)\n  23:return [? __x12__]\n}"
  }, {
    "code": ["          1. If |DestructuringAssignmentTarget| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then", "            1. Let _lref_ be the result of evaluating |DestructuringAssignmentTarget|.", "            1. ReturnIfAbrupt(_lref_).", "          1. Let _A_ be ! ArrayCreate(0).", "          1. Let _n_ be 0.", "          1. Repeat, while _iteratorRecord_.[[Done]] is *false*,", "            1. Let _next_ be IteratorStep(_iteratorRecord_).", "            1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.", "            1. ReturnIfAbrupt(_next_).", "            1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.", "            1. Else,", "              1. Let _nextValue_ be IteratorValue(_next_).", "              1. If _nextValue_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.", "              1. ReturnIfAbrupt(_nextValue_).", "              1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _nextValue_).", "              1. Set _n_ to _n_ + 1.", "          1. If |DestructuringAssignmentTarget| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then", "            1. Return ? PutValue(_lref_, _A_).", "          1. Let _nestedAssignmentPattern_ be the |AssignmentPattern| that is covered by |DestructuringAssignmentTarget|.", "          1. Return the result of performing DestructuringAssignmentEvaluation of _nestedAssignmentPattern_ with _A_ as the argument."],
    "head": {
      "idx": 0,
      "methodName": "IteratorDestructuringAssignmentEvaluation",
      "prod": "AssignmentRestElement",
      "rhs": {
        "tokens": [{
          "term": "..."
        }, {
          "args": [],
          "name": "DestructuringAssignmentTarget",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }]
    },
    "ids": "sec-runtime-semantics-iteratordestructuringassignmentevaluation",
    "rawBody": "{\n  0:if (! (|| (0) (is-instance-of DestructuringAssignmentTarget ObjectLiteral) (1) (is-instance-of DestructuringAssignmentTarget ArrayLiteral))) {\n    1:(0) access __x0__ = (DestructuringAssignmentTarget \"Evaluation\")\n    1:let lref = __x0__\n    2:[? lref]\n  } else 10:{}\n  3:(1) app __x1__ = (ArrayCreate 0i)\n  3:let A = [! __x1__]\n  4:let n = 0i\n  5:while (= iteratorRecord[\"Done\"] false) {\n    6:(2) app __x2__ = (IteratorStep iteratorRecord)\n    6:let next = __x2__\n    7:(3) app __x3__ = (IsAbruptCompletion next)\n    7:if __x3__ iteratorRecord[\"Done\"] = true else 10:{}\n    8:[? next]\n    10:if (= next false) iteratorRecord[\"Done\"] = true else {\n      11:(4) app __x4__ = (IteratorValue next)\n      11:let nextValue = __x4__\n      12:(5) app __x5__ = (IsAbruptCompletion nextValue)\n      12:if __x5__ iteratorRecord[\"Done\"] = true else 10:{}\n      13:[? nextValue]\n      14:(6) app __x6__ = (ToString n)\n      14:(7) app __x7__ = (CreateDataPropertyOrThrow A [! __x6__] nextValue)\n      14:[! __x7__]\n      15:n = (+ n 1i)\n    }\n  }\n  16:if (! (|| (2) (is-instance-of DestructuringAssignmentTarget ObjectLiteral) (3) (is-instance-of DestructuringAssignmentTarget ArrayLiteral))) {\n    17:(8) app __x8__ = (PutValue lref A)\n    17:return [? __x8__]\n  } else 10:{}\n  18:let nestedAssignmentPattern = (parse-syntax DestructuringAssignmentTarget \"AssignmentPattern\" (4) (new []))\n  19:(9) access __x9__ = (nestedAssignmentPattern \"DestructuringAssignmentEvaluation\" A)\n  19:return __x9__\n}"
  }, {
    "code": ["          1. If |DestructuringAssignmentTarget| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then", "            1. Let _lref_ be the result of evaluating |DestructuringAssignmentTarget|.", "            1. ReturnIfAbrupt(_lref_).", "          1. Let _v_ be ? GetV(_value_, _propertyName_).", "          1. If |Initializer| is present and _v_ is *undefined*, then", "            1. If IsAnonymousFunctionDefinition(|Initializer|) and IsIdentifierRef of |DestructuringAssignmentTarget| are both *true*, then", "              1. Let _rhsValue_ be ? NamedEvaluation of |Initializer| with argument _lref_.[[ReferencedName]].", "            1. Else,", "              1. Let _defaultValue_ be the result of evaluating |Initializer|.", "              1. Let _rhsValue_ be ? GetValue(_defaultValue_).", "          1. Else, let _rhsValue_ be _v_.", "          1. If |DestructuringAssignmentTarget| is an |ObjectLiteral| or an |ArrayLiteral|, then", "            1. Let _assignmentPattern_ be the |AssignmentPattern| that is covered by |DestructuringAssignmentTarget|.", "            1. Return the result of performing DestructuringAssignmentEvaluation of _assignmentPattern_ with _rhsValue_ as the argument.", "          1. Return ? PutValue(_lref_, _rhsValue_)."],
    "head": {
      "idx": 0,
      "methodName": "KeyedDestructuringAssignmentEvaluation",
      "prod": "AssignmentElement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "DestructuringAssignmentTarget",
          "optional": false
        }, {
          "args": [],
          "name": "Initializer",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "propertyName"
      }]
    },
    "ids": "sec-runtime-semantics-keyeddestructuringassignmentevaluation",
    "rawBody": "{\n  0:if (! (|| (0) (is-instance-of DestructuringAssignmentTarget ObjectLiteral) (1) (is-instance-of DestructuringAssignmentTarget ArrayLiteral))) {\n    1:(0) access __x0__ = (DestructuringAssignmentTarget \"Evaluation\")\n    1:let lref = __x0__\n    2:[? lref]\n  } else 10:{}\n  3:(1) app __x1__ = (GetV value propertyName)\n  3:let v = [? __x1__]\n  10:if (&& (! (= Initializer absent)) (= v undefined)) {\n    7:(2) app __x2__ = (IsAnonymousFunctionDefinition Initializer)\n    7:(3) access __x3__ = (DestructuringAssignmentTarget \"IsIdentifierRef\")\n    7:if (&& (= __x2__ true) (= __x3__ true)) {\n      6:(4) access __x4__ = (Initializer \"NamedEvaluation\" lref[\"ReferencedName\"])\n      6:let rhsValue = [? __x4__]\n    } else {\n      8:(5) access __x5__ = (Initializer \"Evaluation\")\n      8:let defaultValue = __x5__\n      9:(6) app __x6__ = (GetValue defaultValue)\n      9:let rhsValue = [? __x6__]\n    }\n  } else let rhsValue = v\n  11:if (|| (2) (is-instance-of DestructuringAssignmentTarget ObjectLiteral) (3) (is-instance-of DestructuringAssignmentTarget ArrayLiteral)) {\n    12:let assignmentPattern = (parse-syntax DestructuringAssignmentTarget \"AssignmentPattern\" (4) (new []))\n    13:(7) access __x7__ = (assignmentPattern \"DestructuringAssignmentEvaluation\" rhsValue)\n    13:return __x7__\n  } else 10:{}\n  14:(8) app __x8__ = (PutValue lref rhsValue)\n  14:return [? __x8__]\n}"
  }, {
    "code": ["        1. Let _lref_ be the result of evaluating |Expression|.", "        1. Perform ? GetValue(_lref_).", "        1. Let _rref_ be the result of evaluating |AssignmentExpression|.", "        1. Return ? GetValue(_rref_)."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "Expression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-comma-operator-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Expression \"Evaluation\")\n  0:let lref = __x0__\n  1:(1) app __x1__ = (GetValue lref)\n  1:[? __x1__]\n  2:(2) access __x2__ = (AssignmentExpression \"Evaluation\")\n  2:let rref = __x2__\n  3:(3) app __x3__ = (GetValue rref)\n  3:return [? __x3__]\n}"
  }, {
    "code": ["        1. Return NormalCompletion(~empty~)."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "HoistableDeclaration",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "GeneratorDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-statement-semantics-runtime-semantics-evaluation",
    "rawBody": "return CONST_empty"
  }, {
    "code": ["        1. Return NormalCompletion(~empty~)."],
    "head": {
      "idx": 2,
      "methodName": "Evaluation",
      "prod": "HoistableDeclaration",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AsyncFunctionDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-statement-semantics-runtime-semantics-evaluation",
    "rawBody": "return CONST_empty"
  }, {
    "code": ["        1. Return NormalCompletion(~empty~)."],
    "head": {
      "idx": 3,
      "methodName": "Evaluation",
      "prod": "HoistableDeclaration",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AsyncGeneratorDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-statement-semantics-runtime-semantics-evaluation",
    "rawBody": "return CONST_empty"
  }, {
    "code": ["        1. Return the result of evaluating |FunctionDeclaration|."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "HoistableDeclaration",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FunctionDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-statement-semantics-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (FunctionDeclaration \"Evaluation\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Let _newLabelSet_ be a new empty List.", "        1. Return the result of performing LabelledEvaluation of this |BreakableStatement| with argument _newLabelSet_."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "BreakableStatement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "IterationStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-statement-semantics-runtime-semantics-evaluation",
    "rawBody": "{\n  0:let newLabelSet = (0) (new [])\n  1:(0) access __x0__ = (this \"LabelledEvaluation\" newLabelSet)\n  1:return __x0__\n}"
  }, {
    "code": ["        1. Let _newLabelSet_ be a new empty List.", "        1. Return the result of performing LabelledEvaluation of this |BreakableStatement| with argument _newLabelSet_."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "BreakableStatement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "SwitchStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-statement-semantics-runtime-semantics-evaluation",
    "rawBody": "{\n  0:let newLabelSet = (0) (new [])\n  1:(0) access __x0__ = (this \"LabelledEvaluation\" newLabelSet)\n  1:return __x0__\n}"
  }, {
    "code": ["        1. Return NormalCompletion(~empty~)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "Block",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-block-runtime-semantics-evaluation",
    "rawBody": "return CONST_empty"
  }, {
    "code": ["        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.", "        1. Let _blockEnv_ be NewDeclarativeEnvironment(_oldEnv_).", "        1. Perform BlockDeclarationInstantiation(|StatementList|, _blockEnv_).", "        1. Set the running execution context's LexicalEnvironment to _blockEnv_.", "        1. Let _blockValue_ be the result of evaluating |StatementList|.", "        1. Set the running execution context's LexicalEnvironment to _oldEnv_.", "        1. Return _blockValue_."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "Block",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "StatementList",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-block-runtime-semantics-evaluation",
    "rawBody": "{\n  0:let oldEnv = CONTEXT[\"LexicalEnvironment\"]\n  1:(0) app __x0__ = (NewDeclarativeEnvironment oldEnv)\n  1:let blockEnv = __x0__\n  2:(1) app __x1__ = (BlockDeclarationInstantiation StatementList blockEnv)\n  2:__x1__\n  3:CONTEXT[\"LexicalEnvironment\"] = blockEnv\n  4:(2) access __x2__ = (StatementList \"Evaluation\")\n  4:let blockValue = __x2__\n  5:CONTEXT[\"LexicalEnvironment\"] = oldEnv\n  6:return blockValue\n}"
  }, {
    "code": ["        1. Let _sl_ be the result of evaluating |StatementList|.", "        1. ReturnIfAbrupt(_sl_).", "        1. Let _s_ be the result of evaluating |StatementListItem|.", "        1. Return Completion(UpdateEmpty(_s_, _sl_))."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "StatementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StatementList",
          "optional": false
        }, {
          "args": [],
          "name": "StatementListItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-block-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (StatementList \"Evaluation\")\n  0:let sl = __x0__\n  1:[? sl]\n  2:(1) access __x1__ = (StatementListItem \"Evaluation\")\n  2:let s = __x1__\n  3:(2) app __x2__ = (UpdateEmpty s sl)\n  3:return __x2__\n}"
  }, {
    "code": ["        1. Assert: _env_ is a declarative Environment Record.", "        1. Let _declarations_ be the LexicallyScopedDeclarations of _code_.", "        1. For each element _d_ of _declarations_, do", "          1. For each element _dn_ of the BoundNames of _d_, do", "            1. If IsConstantDeclaration of _d_ is *true*, then", "              1. Perform ! _env_.CreateImmutableBinding(_dn_, *true*).", "            1. Else,", "              1. [id=\"step-blockdeclarationinstantiation-createmutablebinding\"] Perform ! _env_.CreateMutableBinding(_dn_, *false*). NOTE: This step is replaced in section <emu-xref href=\"#sec-web-compat-blockdeclarationinstantiation\"></emu-xref>.", "          1. If _d_ is a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|, then", "            1. Let _fn_ be the sole element of the BoundNames of _d_.", "            1. Let _fo_ be InstantiateFunctionObject of _d_ with argument _env_.", "            1. [id=\"step-blockdeclarationinstantiation-initializebinding\"] Perform _env_.InitializeBinding(_fn_, _fo_). NOTE: This step is replaced in section <emu-xref href=\"#sec-web-compat-blockdeclarationinstantiation\"></emu-xref>."],
    "head": {
      "name": "BlockDeclarationInstantiation",
      "params": [{
        "kind": "Normal",
        "name": "code"
      }, {
        "kind": "Normal",
        "name": "env"
      }]
    },
    "ids": "sec-blockdeclarationinstantiation",
    "rawBody": "{\n  0:assert (0) (is-instance-of env DeclarativeEnvironmentRecord)\n  1:(0) access __x0__ = (code \"LexicallyScopedDeclarations\")\n  1:let declarations = __x0__\n  2:let __x1__ = declarations\n  2:let __x2__ = 0i\n  2:while (< __x2__ __x1__[\"length\"]) {\n    let d = __x1__[__x2__]\n    3:(1) access __x3__ = (d \"BoundNames\")\n    3:let __x4__ = __x3__\n    3:let __x5__ = 0i\n    3:while (< __x5__ __x4__[\"length\"]) {\n      let dn = __x4__[__x5__]\n      6:(2) access __x6__ = (d \"IsConstantDeclaration\")\n      6:if (= __x6__ true) {\n        5:(3) app __x7__ = (env[\"CreateImmutableBinding\"] env dn true)\n        5:[! __x7__]\n      } else {\n        7:(4) app __x8__ = (env[\"CreateMutableBinding\"] env dn false)\n        7:[! __x8__]\n      }\n      __x5__ = (+ __x5__ 1i)\n    }\n    8:if (|| (|| (|| (1) (is-instance-of d FunctionDeclaration) (2) (is-instance-of d GeneratorDeclaration)) (3) (is-instance-of d AsyncFunctionDeclaration)) (4) (is-instance-of d AsyncGeneratorDeclaration)) {\n      9:(5) access __x9__ = (d \"BoundNames\")\n      9:let fn = __x9__[0i]\n      10:(6) access __x10__ = (d \"InstantiateFunctionObject\" env)\n      10:let fo = __x10__\n      11:(7) app __x11__ = (env[\"InitializeBinding\"] env fn fo)\n      11:__x11__\n    } else 10:{}\n    __x2__ = (+ __x2__ 1i)\n  }\n}"
  }, {
    "code": ["          1. Let _next_ be the result of evaluating |BindingList|.", "          1. ReturnIfAbrupt(_next_).", "          1. Return NormalCompletion(~empty~)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "LexicalDeclaration",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LetOrConst",
          "optional": false
        }, {
          "args": [],
          "name": "BindingList",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-let-and-const-declarations-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingList \"Evaluation\")\n  0:let next = __x0__\n  1:[? next]\n  2:return CONST_empty\n}"
  }, {
    "code": ["          1. Let _next_ be the result of evaluating |BindingList|.", "          1. ReturnIfAbrupt(_next_).", "          1. Return the result of evaluating |LexicalBinding|."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "BindingList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "LexicalBinding",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-let-and-const-declarations-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingList \"Evaluation\")\n  0:let next = __x0__\n  1:[? next]\n  2:(1) access __x1__ = (LexicalBinding \"Evaluation\")\n  2:return __x1__\n}"
  }, {
    "code": ["          1. Let _lhs_ be ResolveBinding(StringValue of |BindingIdentifier|).", "          1. Return InitializeReferencedBinding(_lhs_, *undefined*)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "LexicalBinding",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-let-and-const-declarations-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingIdentifier \"StringValue\")\n  0:(1) app __x1__ = (ResolveBinding __x0__)\n  0:let lhs = __x1__\n  1:(2) app __x2__ = (InitializeReferencedBinding lhs undefined)\n  1:return __x2__\n}"
  }, {
    "code": ["          1. Let _bindingId_ be StringValue of |BindingIdentifier|.", "          1. Let _lhs_ be ResolveBinding(_bindingId_).", "          1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then", "            1. Let _value_ be NamedEvaluation of |Initializer| with argument _bindingId_.", "          1. Else,", "            1. Let _rhs_ be the result of evaluating |Initializer|.", "            1. Let _value_ be ? GetValue(_rhs_).", "          1. Return InitializeReferencedBinding(_lhs_, _value_)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "LexicalBinding",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "args": [],
          "name": "Initializer",
          "optional": false
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-let-and-const-declarations-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingIdentifier \"StringValue\")\n  0:let bindingId = __x0__\n  1:(1) app __x1__ = (ResolveBinding bindingId)\n  1:let lhs = __x1__\n  4:(2) app __x2__ = (IsAnonymousFunctionDefinition Initializer)\n  4:if (= __x2__ true) {\n    3:(3) access __x3__ = (Initializer \"NamedEvaluation\" bindingId)\n    3:let value = __x3__\n  } else {\n    5:(4) access __x4__ = (Initializer \"Evaluation\")\n    5:let rhs = __x4__\n    6:(5) app __x5__ = (GetValue rhs)\n    6:let value = [? __x5__]\n  }\n  7:(6) app __x6__ = (InitializeReferencedBinding lhs value)\n  7:return __x6__\n}"
  }, {
    "code": ["          1. Let _rhs_ be the result of evaluating |Initializer|.", "          1. Let _value_ be ? GetValue(_rhs_).", "          1. Let _env_ be the running execution context's LexicalEnvironment.", "          1. Return the result of performing BindingInitialization for |BindingPattern| using _value_ and _env_ as the arguments."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "LexicalBinding",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingPattern",
          "optional": false
        }, {
          "args": [],
          "name": "Initializer",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-let-and-const-declarations-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Initializer \"Evaluation\")\n  0:let rhs = __x0__\n  1:(1) app __x1__ = (GetValue rhs)\n  1:let value = [? __x1__]\n  2:let env = CONTEXT[\"LexicalEnvironment\"]\n  3:(2) access __x2__ = (BindingPattern \"BindingInitialization\" value env)\n  3:return __x2__\n}"
  }, {
    "code": ["          1. Let _next_ be the result of evaluating |VariableDeclarationList|.", "          1. ReturnIfAbrupt(_next_).", "          1. Return NormalCompletion(~empty~)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "VariableStatement",
      "rhs": {
        "tokens": [{
          "term": "var"
        }, {
          "args": [],
          "name": "VariableDeclarationList",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-variable-statement-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (VariableDeclarationList \"Evaluation\")\n  0:let next = __x0__\n  1:[? next]\n  2:return CONST_empty\n}"
  }, {
    "code": ["          1. Let _next_ be the result of evaluating |VariableDeclarationList|.", "          1. ReturnIfAbrupt(_next_).", "          1. Return the result of evaluating |VariableDeclaration|."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "VariableDeclarationList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "VariableDeclarationList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "VariableDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-variable-statement-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (VariableDeclarationList \"Evaluation\")\n  0:let next = __x0__\n  1:[? next]\n  2:(1) access __x1__ = (VariableDeclaration \"Evaluation\")\n  2:return __x1__\n}"
  }, {
    "code": ["          1. Return NormalCompletion(~empty~)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "VariableDeclaration",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-variable-statement-runtime-semantics-evaluation",
    "rawBody": "return CONST_empty"
  }, {
    "code": ["          1. Let _bindingId_ be StringValue of |BindingIdentifier|.", "          1. Let _lhs_ be ? ResolveBinding(_bindingId_).", "          1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then", "            1. Let _value_ be NamedEvaluation of |Initializer| with argument _bindingId_.", "          1. Else,", "            1. Let _rhs_ be the result of evaluating |Initializer|.", "            1. Let _value_ be ? GetValue(_rhs_).", "          1. [id=\"step-vardecllist-evaluation-putvalue\"] Return ? PutValue(_lhs_, _value_)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "VariableDeclaration",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "args": [],
          "name": "Initializer",
          "optional": false
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-variable-statement-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingIdentifier \"StringValue\")\n  0:let bindingId = __x0__\n  1:(1) app __x1__ = (ResolveBinding bindingId)\n  1:let lhs = [? __x1__]\n  4:(2) app __x2__ = (IsAnonymousFunctionDefinition Initializer)\n  4:if (= __x2__ true) {\n    3:(3) access __x3__ = (Initializer \"NamedEvaluation\" bindingId)\n    3:let value = __x3__\n  } else {\n    5:(4) access __x4__ = (Initializer \"Evaluation\")\n    5:let rhs = __x4__\n    6:(5) app __x5__ = (GetValue rhs)\n    6:let value = [? __x5__]\n  }\n  7:(6) app __x6__ = (PutValue lhs value)\n  7:return [? __x6__]\n}"
  }, {
    "code": ["          1. Let _rhs_ be the result of evaluating |Initializer|.", "          1. Let _rval_ be ? GetValue(_rhs_).", "          1. Return the result of performing BindingInitialization for |BindingPattern| passing _rval_ and *undefined* as arguments."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "VariableDeclaration",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingPattern",
          "optional": false
        }, {
          "args": [],
          "name": "Initializer",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-variable-statement-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Initializer \"Evaluation\")\n  0:let rhs = __x0__\n  1:(1) app __x1__ = (GetValue rhs)\n  1:let rval = [? __x1__]\n  2:(2) access __x2__ = (BindingPattern \"BindingInitialization\" rval undefined)\n  2:return __x2__\n}"
  }, {
    "code": ["          1. Let _boundNames_ be ? PropertyBindingInitialization of |BindingPropertyList| with arguments _value_ and _environment_.", "          1. Let _nextNames_ be ? PropertyBindingInitialization of |BindingProperty| with arguments _value_ and _environment_.", "          1. Append each item in _nextNames_ to the end of _boundNames_.", "          1. Return _boundNames_."],
    "head": {
      "idx": 1,
      "methodName": "PropertyBindingInitialization",
      "prod": "BindingPropertyList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingPropertyList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "BindingProperty",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-destructuring-binding-patterns-runtime-semantics-propertybindinginitialization",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingPropertyList \"PropertyBindingInitialization\" value environment)\n  0:let boundNames = [? __x0__]\n  1:(1) access __x1__ = (BindingProperty \"PropertyBindingInitialization\" value environment)\n  1:let nextNames = [? __x1__]\n  2:let __x2__ = nextNames\n  2:let __x3__ = 0i\n  2:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> boundNames\n    __x3__ = (+ __x3__ 1i)\n  }\n  3:return boundNames\n}"
  }, {
    "code": ["          1. Let _name_ be the string that is the only element of BoundNames of |SingleNameBinding|.", "          1. Perform ? KeyedBindingInitialization for |SingleNameBinding| using _value_, _environment_, and _name_ as the arguments.", "          1. Return a List whose sole element is _name_."],
    "head": {
      "idx": 0,
      "methodName": "PropertyBindingInitialization",
      "prod": "BindingProperty",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "SingleNameBinding",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-destructuring-binding-patterns-runtime-semantics-propertybindinginitialization",
    "rawBody": "{\n  0:(0) access __snb__ = (SingleNameBinding \"BoundNames\")\n  0:let name = __snb__[0i]\n  1:(1) access __x0__ = (SingleNameBinding \"KeyedBindingInitialization\" value environment name)\n  1:[? __x0__]\n  2:return (0) (new [name])\n}"
  }, {
    "code": ["          1. Let _P_ be the result of evaluating |PropertyName|.", "          1. ReturnIfAbrupt(_P_).", "          1. Perform ? KeyedBindingInitialization of |BindingElement| with _value_, _environment_, and _P_ as the arguments.", "          1. Return a List whose sole element is _P_."],
    "head": {
      "idx": 1,
      "methodName": "PropertyBindingInitialization",
      "prod": "BindingProperty",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "BindingElement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-destructuring-binding-patterns-runtime-semantics-propertybindinginitialization",
    "rawBody": "{\n  0:(0) access __x0__ = (PropertyName \"Evaluation\")\n  0:let P = __x0__\n  1:[? P]\n  2:(1) access __x1__ = (BindingElement \"KeyedBindingInitialization\" value environment P)\n  2:[? __x1__]\n  3:return (0) (new [P])\n}"
  }, {
    "code": ["          1. Let _lhs_ be ? ResolveBinding(StringValue of |BindingIdentifier|, _environment_).", "          1. Let _restObj_ be ! OrdinaryObjectCreate(%Object.prototype%).", "          1. Perform ? CopyDataProperties(_restObj_, _value_, _excludedNames_).", "          1. If _environment_ is *undefined*, return PutValue(_lhs_, _restObj_).", "          1. Return InitializeReferencedBinding(_lhs_, _restObj_)."],
    "head": {
      "idx": 0,
      "methodName": "RestBindingInitialization",
      "prod": "BindingRestProperty",
      "rhs": {
        "tokens": [{
          "term": "..."
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "environment"
      }, {
        "kind": "Normal",
        "name": "excludedNames"
      }]
    },
    "ids": "sec-destructuring-binding-patterns-runtime-semantics-restbindinginitialization",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingIdentifier \"StringValue\")\n  0:(1) app __x1__ = (ResolveBinding __x0__ environment)\n  0:let lhs = [? __x1__]\n  1:(2) app __x2__ = (OrdinaryObjectCreate INTRINSIC_Object_prototype)\n  1:let restObj = [! __x2__]\n  2:(3) app __x3__ = (CopyDataProperties restObj value excludedNames)\n  2:[? __x3__]\n  3:if (= environment undefined) {\n    (4) app __x4__ = (PutValue lhs restObj)\n    return __x4__\n  } else 10:{}\n  4:(5) app __x5__ = (InitializeReferencedBinding lhs restObj)\n  4:return __x5__\n}"
  }, {
    "code": ["          1. Let _v_ be ? GetV(_value_, _propertyName_).", "          1. If |Initializer| is present and _v_ is *undefined*, then", "            1. Let _defaultValue_ be the result of evaluating |Initializer|.", "            1. Set _v_ to ? GetValue(_defaultValue_).", "          1. Return the result of performing BindingInitialization for |BindingPattern| passing _v_ and _environment_ as arguments."],
    "head": {
      "idx": 1,
      "methodName": "KeyedBindingInitialization",
      "prod": "BindingElement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingPattern",
          "optional": false
        }, {
          "args": [],
          "name": "Initializer",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "environment"
      }, {
        "kind": "Normal",
        "name": "propertyName"
      }]
    },
    "ids": "sec-runtime-semantics-keyedbindinginitialization",
    "rawBody": "{\n  0:(0) app __x0__ = (GetV value propertyName)\n  0:let v = [? __x0__]\n  1:if (&& (! (= Initializer absent)) (= v undefined)) {\n    2:(1) access __x1__ = (Initializer \"Evaluation\")\n    2:let defaultValue = __x1__\n    3:(2) app __x2__ = (GetValue defaultValue)\n    3:v = [? __x2__]\n  } else 10:{}\n  4:(3) access __x3__ = (BindingPattern \"BindingInitialization\" v environment)\n  4:return __x3__\n}"
  }, {
    "code": ["          1. Let _bindingId_ be StringValue of |BindingIdentifier|.", "          1. Let _lhs_ be ? ResolveBinding(_bindingId_, _environment_).", "          1. Let _v_ be ? GetV(_value_, _propertyName_).", "          1. If |Initializer| is present and _v_ is *undefined*, then", "            1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then", "              1. Set _v_ to the result of performing NamedEvaluation for |Initializer| with argument _bindingId_.", "            1. Else,", "              1. Let _defaultValue_ be the result of evaluating |Initializer|.", "              1. Set _v_ to ? GetValue(_defaultValue_).", "          1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _v_).", "          1. Return InitializeReferencedBinding(_lhs_, _v_)."],
    "head": {
      "idx": 0,
      "methodName": "KeyedBindingInitialization",
      "prod": "SingleNameBinding",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "args": [],
          "name": "Initializer",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "environment"
      }, {
        "kind": "Normal",
        "name": "propertyName"
      }]
    },
    "ids": "sec-runtime-semantics-keyedbindinginitialization",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingIdentifier \"StringValue\")\n  0:let bindingId = __x0__\n  1:(1) app __x1__ = (ResolveBinding bindingId environment)\n  1:let lhs = [? __x1__]\n  2:(2) app __x2__ = (GetV value propertyName)\n  2:let v = [? __x2__]\n  3:if (&& (! (= Initializer absent)) (= v undefined)) {\n    6:(3) app __x3__ = (IsAnonymousFunctionDefinition Initializer)\n    6:if (= __x3__ true) {\n      5:(4) access __x4__ = (Initializer \"NamedEvaluation\" bindingId)\n      5:v = __x4__\n    } else {\n      7:(5) access __x5__ = (Initializer \"Evaluation\")\n      7:let defaultValue = __x5__\n      8:(6) app __x6__ = (GetValue defaultValue)\n      8:v = [? __x6__]\n    }\n  } else 10:{}\n  9:if (= environment undefined) {\n    (7) app __x7__ = (PutValue lhs v)\n    return [? __x7__]\n  } else 10:{}\n  10:(8) app __x8__ = (InitializeReferencedBinding lhs v)\n  10:return __x8__\n}"
  }, {
    "code": ["        1. Return NormalCompletion(~empty~)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "EmptyStatement",
      "rhs": {
        "tokens": [{
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-empty-statement-runtime-semantics-evaluation",
    "rawBody": "return CONST_empty"
  }, {
    "code": ["        1. Let _exprRef_ be the result of evaluating |Expression|.", "        1. Return ? GetValue(_exprRef_)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "ExpressionStatement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-expression-statement-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Expression \"Evaluation\")\n  0:let exprRef = __x0__\n  1:(1) app __x1__ = (GetValue exprRef)\n  1:return [? __x1__]\n}"
  }, {
    "code": ["        1. Let _exprRef_ be the result of evaluating |Expression|.", "        1. Let _exprValue_ be ! ToBoolean(? GetValue(_exprRef_)).", "        1. If _exprValue_ is *true*, then", "          1. Let _stmtCompletion_ be the result of evaluating the first |Statement|.", "        1. Else,", "          1. Let _stmtCompletion_ be the result of evaluating the second |Statement|.", "        1. Return Completion(UpdateEmpty(_stmtCompletion_, *undefined*))."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "IfStatement",
      "rhs": {
        "tokens": [{
          "term": "if"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }, {
          "term": "else"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-if-statement-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Expression \"Evaluation\")\n  0:let exprRef = __x0__\n  1:(1) app __x1__ = (GetValue exprRef)\n  1:(2) app __x2__ = (ToBoolean [? __x1__])\n  1:let exprValue = [! __x2__]\n  4:if (= exprValue true) {\n    3:(3) access __x3__ = (Statement0 \"Evaluation\")\n    3:let stmtCompletion = __x3__\n  } else {\n    5:(4) access __x4__ = (Statement1 \"Evaluation\")\n    5:let stmtCompletion = __x4__\n  }\n  6:(5) app __x5__ = (UpdateEmpty stmtCompletion undefined)\n  6:return __x5__\n}"
  }, {
    "code": ["        1. Let _exprRef_ be the result of evaluating |Expression|.", "        1. Let _exprValue_ be ! ToBoolean(? GetValue(_exprRef_)).", "        1. If _exprValue_ is *false*, then", "          1. Return NormalCompletion(*undefined*).", "        1. Else,", "          1. Let _stmtCompletion_ be the result of evaluating |Statement|.", "          1. Return Completion(UpdateEmpty(_stmtCompletion_, *undefined*))."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "IfStatement",
      "rhs": {
        "tokens": [{
          "term": "if"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-if-statement-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Expression \"Evaluation\")\n  0:let exprRef = __x0__\n  1:(1) app __x1__ = (GetValue exprRef)\n  1:(2) app __x2__ = (ToBoolean [? __x1__])\n  1:let exprValue = [! __x2__]\n  4:if (= exprValue false) return undefined else {\n    5:(3) access __x3__ = (Statement \"Evaluation\")\n    5:let stmtCompletion = __x3__\n    6:(4) app __x4__ = (UpdateEmpty stmtCompletion undefined)\n    6:return __x4__\n  }\n}"
  }, {
    "code": ["          1. If _completion_.[[Type]] is ~normal~, return *true*.", "          1. If _completion_.[[Type]] is not ~continue~, return *false*.", "          1. If _completion_.[[Target]] is ~empty~, return *true*.", "          1. If _completion_.[[Target]] is an element of _labelSet_, return *true*.", "          1. Return *false*."],
    "head": {
      "name": "LoopContinues",
      "params": [{
        "kind": "Normal",
        "name": "completion"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-loopcontinues",
    "rawBody": "{\n  0:if (= completion[\"Type\"] CONST_normal) return true else 10:{}\n  1:if (! (= completion[\"Type\"] CONST_continue)) return false else 10:{}\n  2:if (= completion[\"Target\"] CONST_empty) return true else 10:{}\n  3:if (contains labelSet completion[\"Target\"]) return true else 10:{}\n  4:return false\n}"
  }, {
    "code": ["          1. Return ? DoWhileLoopEvaluation of |DoWhileStatement| with argument _labelSet_."],
    "head": {
      "idx": 0,
      "methodName": "LoopEvaluation",
      "prod": "IterationStatement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "DoWhileStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-loopevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (DoWhileStatement \"DoWhileLoopEvaluation\" labelSet)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Return ? WhileLoopEvaluation of |WhileStatement| with argument _labelSet_."],
    "head": {
      "idx": 1,
      "methodName": "LoopEvaluation",
      "prod": "IterationStatement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "WhileStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-loopevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (WhileStatement \"WhileLoopEvaluation\" labelSet)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Return ? ForLoopEvaluation of |ForStatement| with argument _labelSet_."],
    "head": {
      "idx": 2,
      "methodName": "LoopEvaluation",
      "prod": "IterationStatement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ForStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-loopevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (ForStatement \"ForLoopEvaluation\" labelSet)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Return ? ForInOfLoopEvaluation of |ForInOfStatement| with argument _labelSet_."],
    "head": {
      "idx": 3,
      "methodName": "LoopEvaluation",
      "prod": "IterationStatement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ForInOfStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-loopevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (ForInOfStatement \"ForInOfLoopEvaluation\" labelSet)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Let _V_ be *undefined*.", "          1. Repeat,", "            1. Let _stmtResult_ be the result of evaluating |Statement|.", "            1. If LoopContinues(_stmtResult_, _labelSet_) is *false*, return Completion(UpdateEmpty(_stmtResult_, _V_)).", "            1. If _stmtResult_.[[Value]] is not ~empty~, set _V_ to _stmtResult_.[[Value]].", "            1. Let _exprRef_ be the result of evaluating |Expression|.", "            1. Let _exprValue_ be ? GetValue(_exprRef_).", "            1. If ! ToBoolean(_exprValue_) is *false*, return NormalCompletion(_V_)."],
    "head": {
      "idx": 0,
      "methodName": "DoWhileLoopEvaluation",
      "prod": "DoWhileStatement",
      "rhs": {
        "tokens": [{
          "term": "do"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }, {
          "term": "while"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-dowhileloopevaluation",
    "rawBody": "{\n  0:let V = undefined\n  1:while true {\n    2:(0) access __x0__ = (Statement \"Evaluation\")\n    2:let stmtResult = __x0__\n    3:(1) app __x1__ = (LoopContinues stmtResult labelSet)\n    3:if (= __x1__ false) {\n      (2) app __x2__ = (UpdateEmpty stmtResult V)\n      return __x2__\n    } else 10:{}\n    4:if (! (= stmtResult[\"Value\"] CONST_empty)) V = stmtResult[\"Value\"] else 10:{}\n    5:(3) access __x3__ = (Expression \"Evaluation\")\n    5:let exprRef = __x3__\n    6:(4) app __x4__ = (GetValue exprRef)\n    6:let exprValue = [? __x4__]\n    7:(5) app __x5__ = (ToBoolean exprValue)\n    7:if (= [! __x5__] false) return V else 10:{}\n  }\n}"
  }, {
    "code": ["          1. Let _V_ be *undefined*.", "          1. Repeat,", "            1. Let _exprRef_ be the result of evaluating |Expression|.", "            1. Let _exprValue_ be ? GetValue(_exprRef_).", "            1. If ! ToBoolean(_exprValue_) is *false*, return NormalCompletion(_V_).", "            1. Let _stmtResult_ be the result of evaluating |Statement|.", "            1. If LoopContinues(_stmtResult_, _labelSet_) is *false*, return Completion(UpdateEmpty(_stmtResult_, _V_)).", "            1. If _stmtResult_.[[Value]] is not ~empty~, set _V_ to _stmtResult_.[[Value]]."],
    "head": {
      "idx": 0,
      "methodName": "WhileLoopEvaluation",
      "prod": "WhileStatement",
      "rhs": {
        "tokens": [{
          "term": "while"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-whileloopevaluation",
    "rawBody": "{\n  0:let V = undefined\n  1:while true {\n    2:(0) access __x0__ = (Expression \"Evaluation\")\n    2:let exprRef = __x0__\n    3:(1) app __x1__ = (GetValue exprRef)\n    3:let exprValue = [? __x1__]\n    4:(2) app __x2__ = (ToBoolean exprValue)\n    4:if (= [! __x2__] false) return V else 10:{}\n    5:(3) access __x3__ = (Statement \"Evaluation\")\n    5:let stmtResult = __x3__\n    6:(4) app __x4__ = (LoopContinues stmtResult labelSet)\n    6:if (= __x4__ false) {\n      (5) app __x5__ = (UpdateEmpty stmtResult V)\n      return __x5__\n    } else 10:{}\n    7:if (! (= stmtResult[\"Value\"] CONST_empty)) V = stmtResult[\"Value\"] else 10:{}\n  }\n}"
  }, {
    "code": ["          1. If the first |Expression| is present, then", "            1. Let _exprRef_ be the result of evaluating the first |Expression|.", "            1. Perform ? GetValue(_exprRef_).", "          1. Return ? ForBodyEvaluation(the second |Expression|, the third |Expression|, |Statement|, « », _labelSet_)."],
    "head": {
      "idx": 0,
      "methodName": "ForLoopEvaluation",
      "prod": "ForStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 7,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-forloopevaluation",
    "rawBody": "{\n  0:if (! (= Expression0 absent)) {\n    1:(0) access __x0__ = (Expression0 \"Evaluation\")\n    1:let exprRef = __x0__\n    2:(1) app __x1__ = (GetValue exprRef)\n    2:[? __x1__]\n  } else 10:{}\n  3:(2) app __x2__ = (ForBodyEvaluation Expression1 Expression2 Statement (0) (new []) labelSet)\n  3:return [? __x2__]\n}"
  }, {
    "code": ["          1. Let _varDcl_ be the result of evaluating |VariableDeclarationList|.", "          1. ReturnIfAbrupt(_varDcl_).", "          1. Return ? ForBodyEvaluation(the first |Expression|, the second |Expression|, |Statement|, « », _labelSet_)."],
    "head": {
      "idx": 1,
      "methodName": "ForLoopEvaluation",
      "prod": "ForStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "VariableDeclarationList",
          "optional": false
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 3,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-forloopevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (VariableDeclarationList \"Evaluation\")\n  0:let varDcl = __x0__\n  1:[? varDcl]\n  2:(1) app __x1__ = (ForBodyEvaluation Expression0 Expression1 Statement (0) (new []) labelSet)\n  2:return [? __x1__]\n}"
  }, {
    "code": ["          1. Let _oldEnv_ be the running execution context's LexicalEnvironment.", "          1. Let _loopEnv_ be NewDeclarativeEnvironment(_oldEnv_).", "          1. Let _isConst_ be IsConstantDeclaration of |LexicalDeclaration|.", "          1. Let _boundNames_ be the BoundNames of |LexicalDeclaration|.", "          1. For each element _dn_ of _boundNames_, do", "            1. If _isConst_ is *true*, then", "              1. Perform ! _loopEnv_.CreateImmutableBinding(_dn_, *true*).", "            1. Else,", "              1. Perform ! _loopEnv_.CreateMutableBinding(_dn_, *false*).", "          1. Set the running execution context's LexicalEnvironment to _loopEnv_.", "          1. Let _forDcl_ be the result of evaluating |LexicalDeclaration|.", "          1. If _forDcl_ is an abrupt completion, then", "            1. Set the running execution context's LexicalEnvironment to _oldEnv_.", "            1. Return Completion(_forDcl_).", "          1. If _isConst_ is *false*, let _perIterationLets_ be _boundNames_; otherwise let _perIterationLets_ be « ».", "          1. Let _bodyResult_ be ForBodyEvaluation(the first |Expression|, the second |Expression|, |Statement|, _perIterationLets_, _labelSet_).", "          1. Set the running execution context's LexicalEnvironment to _oldEnv_.", "          1. Return Completion(_bodyResult_)."],
    "head": {
      "idx": 2,
      "methodName": "ForLoopEvaluation",
      "prod": "ForStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LexicalDeclaration",
          "optional": false
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 3,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-forloopevaluation",
    "rawBody": "{\n  0:let oldEnv = CONTEXT[\"LexicalEnvironment\"]\n  1:(0) app __x0__ = (NewDeclarativeEnvironment oldEnv)\n  1:let loopEnv = __x0__\n  2:(1) access __x1__ = (LexicalDeclaration \"IsConstantDeclaration\")\n  2:let isConst = __x1__\n  3:(2) access __x2__ = (LexicalDeclaration \"BoundNames\")\n  3:let boundNames = __x2__\n  4:let __x3__ = boundNames\n  4:let __x4__ = 0i\n  4:while (< __x4__ __x3__[\"length\"]) {\n    let dn = __x3__[__x4__]\n    7:if (= isConst true) {\n      6:(3) app __x5__ = (loopEnv[\"CreateImmutableBinding\"] loopEnv dn true)\n      6:[! __x5__]\n    } else {\n      8:(4) app __x6__ = (loopEnv[\"CreateMutableBinding\"] loopEnv dn false)\n      8:[! __x6__]\n    }\n    __x4__ = (+ __x4__ 1i)\n  }\n  9:CONTEXT[\"LexicalEnvironment\"] = loopEnv\n  10:(5) access __x7__ = (LexicalDeclaration \"Evaluation\")\n  10:let forDcl = __x7__\n  11:(6) app __x8__ = (IsAbruptCompletion forDcl)\n  11:if __x8__ {\n    12:CONTEXT[\"LexicalEnvironment\"] = oldEnv\n    13:return forDcl\n  } else 10:{}\n  14:if (= isConst false) let perIterationLets = boundNames else let perIterationLets = (0) (new [])\n  15:(7) app __x9__ = (ForBodyEvaluation Expression0 Expression1 Statement perIterationLets labelSet)\n  15:let bodyResult = __x9__\n  16:CONTEXT[\"LexicalEnvironment\"] = oldEnv\n  17:return bodyResult\n}"
  }, {
    "code": ["          1. Let _V_ be *undefined*.", "          1. Perform ? CreatePerIterationEnvironment(_perIterationBindings_).", "          1. Repeat,", "            1. If _test_ is not ~[empty]~, then", "              1. Let _testRef_ be the result of evaluating _test_.", "              1. Let _testValue_ be ? GetValue(_testRef_).", "              1. If ! ToBoolean(_testValue_) is *false*, return NormalCompletion(_V_).", "            1. Let _result_ be the result of evaluating _stmt_.", "            1. If LoopContinues(_result_, _labelSet_) is *false*, return Completion(UpdateEmpty(_result_, _V_)).", "            1. If _result_.[[Value]] is not ~empty~, set _V_ to _result_.[[Value]].", "            1. Perform ? CreatePerIterationEnvironment(_perIterationBindings_).", "            1. If _increment_ is not ~[empty]~, then", "              1. Let _incRef_ be the result of evaluating _increment_.", "              1. Perform ? GetValue(_incRef_)."],
    "head": {
      "name": "ForBodyEvaluation",
      "params": [{
        "kind": "Normal",
        "name": "test"
      }, {
        "kind": "Normal",
        "name": "increment"
      }, {
        "kind": "Normal",
        "name": "stmt"
      }, {
        "kind": "Normal",
        "name": "perIterationBindings"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-forbodyevaluation",
    "rawBody": "{\n  0:let V = undefined\n  1:(0) app __x0__ = (CreatePerIterationEnvironment perIterationBindings)\n  1:[? __x0__]\n  2:while true {\n    3:if (! (= test absent)) {\n      4:(1) access __x1__ = (test \"Evaluation\")\n      4:let testRef = __x1__\n      5:(2) app __x2__ = (GetValue testRef)\n      5:let testValue = [? __x2__]\n      6:(3) app __x3__ = (ToBoolean testValue)\n      6:if (= [! __x3__] false) return V else 10:{}\n    } else 10:{}\n    7:(4) access __x4__ = (stmt \"Evaluation\")\n    7:let result = __x4__\n    8:(5) app __x5__ = (LoopContinues result labelSet)\n    8:if (= __x5__ false) {\n      (6) app __x6__ = (UpdateEmpty result V)\n      return __x6__\n    } else 10:{}\n    9:if (! (= result[\"Value\"] CONST_empty)) V = result[\"Value\"] else 10:{}\n    10:(7) app __x7__ = (CreatePerIterationEnvironment perIterationBindings)\n    10:[? __x7__]\n    11:if (! (= increment absent)) {\n      12:(8) access __x8__ = (increment \"Evaluation\")\n      12:let incRef = __x8__\n      13:(9) app __x9__ = (GetValue incRef)\n      13:[? __x9__]\n    } else 10:{}\n  }\n}"
  }, {
    "code": ["          1. If _perIterationBindings_ has any elements, then", "            1. Let _lastIterationEnv_ be the running execution context's LexicalEnvironment.", "            1. Let _outer_ be _lastIterationEnv_.[[OuterEnv]].", "            1. Assert: _outer_ is not *null*.", "            1. Let _thisIterationEnv_ be NewDeclarativeEnvironment(_outer_).", "            1. For each element _bn_ of _perIterationBindings_, do", "              1. Perform ! _thisIterationEnv_.CreateMutableBinding(_bn_, *false*).", "              1. Let _lastValue_ be ? _lastIterationEnv_.GetBindingValue(_bn_, *true*).", "              1. Perform _thisIterationEnv_.InitializeBinding(_bn_, _lastValue_).", "            1. Set the running execution context's LexicalEnvironment to _thisIterationEnv_.", "          1. Return *undefined*."],
    "head": {
      "name": "CreatePerIterationEnvironment",
      "params": [{
        "kind": "Normal",
        "name": "perIterationBindings"
      }]
    },
    "ids": "sec-createperiterationenvironment",
    "rawBody": "{\n  0:if (< 0i perIterationBindings[\"length\"]) {\n    1:let lastIterationEnv = CONTEXT[\"LexicalEnvironment\"]\n    2:let outer = lastIterationEnv[\"OuterEnv\"]\n    3:assert (! (= outer null))\n    4:(0) app __x0__ = (NewDeclarativeEnvironment outer)\n    4:let thisIterationEnv = __x0__\n    5:let __x1__ = perIterationBindings\n    5:let __x2__ = 0i\n    5:while (< __x2__ __x1__[\"length\"]) {\n      let bn = __x1__[__x2__]\n      6:(1) app __x3__ = (thisIterationEnv[\"CreateMutableBinding\"] thisIterationEnv bn false)\n      6:[! __x3__]\n      7:(2) app __x4__ = (lastIterationEnv[\"GetBindingValue\"] lastIterationEnv bn true)\n      7:let lastValue = [? __x4__]\n      8:(3) app __x5__ = (thisIterationEnv[\"InitializeBinding\"] thisIterationEnv bn lastValue)\n      8:__x5__\n      __x2__ = (+ __x2__ 1i)\n    }\n    9:CONTEXT[\"LexicalEnvironment\"] = thisIterationEnv\n  } else 10:{}\n  10:return undefined\n}"
  }, {
    "code": ["          1. If |PrimaryExpression| is either an |ObjectLiteral| or an |ArrayLiteral|, return *true*.", "          1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "IsDestructuring",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "PrimaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isdestructuring",
    "rawBody": "{\n  0:if (|| (0) (is-instance-of PrimaryExpression ObjectLiteral) (1) (is-instance-of PrimaryExpression ArrayLiteral)) return true else 10:{}\n  1:return false\n}"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsDestructuring",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "term": "["
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": "]"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isdestructuring",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "IsDestructuring",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "term": "."
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isdestructuring",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 3,
      "methodName": "IsDestructuring",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "args": [],
          "name": "TemplateLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isdestructuring",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 4,
      "methodName": "IsDestructuring",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "SuperProperty",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isdestructuring",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 5,
      "methodName": "IsDestructuring",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MetaProperty",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isdestructuring",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 6,
      "methodName": "IsDestructuring",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "term": "new"
        }, {
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "args": [],
          "name": "Arguments",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isdestructuring",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsDestructuring",
      "prod": "NewExpression",
      "rhs": {
        "tokens": [{
          "term": "new"
        }, {
          "args": [],
          "name": "NewExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isdestructuring",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsDestructuring",
      "prod": "LeftHandSideExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CallExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isdestructuring",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "IsDestructuring",
      "prod": "LeftHandSideExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "OptionalExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isdestructuring",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return IsDestructuring of |ForBinding|."],
    "head": {
      "idx": 0,
      "methodName": "IsDestructuring",
      "prod": "ForDeclaration",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LetOrConst",
          "optional": false
        }, {
          "args": [],
          "name": "ForBinding",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isdestructuring",
    "rawBody": "{\n  0:(0) access __x0__ = (ForBinding \"IsDestructuring\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "IsDestructuring",
      "prod": "ForBinding",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isdestructuring",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *true*."],
    "head": {
      "idx": 1,
      "methodName": "IsDestructuring",
      "prod": "ForBinding",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingPattern",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isdestructuring",
    "rawBody": "return true"
  }, {
    "code": ["          1. Return the result of performing BindingInitialization for |ForBinding| passing _value_ and _environment_ as the arguments."],
    "head": {
      "idx": 0,
      "methodName": "ForDeclarationBindingInitialization",
      "prod": "ForDeclaration",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LetOrConst",
          "optional": false
        }, {
          "args": [],
          "name": "ForBinding",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-runtime-semantics-fordeclarationbindinginitialization",
    "rawBody": "{\n  0:(0) access __x0__ = (ForBinding \"BindingInitialization\" value environment)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Assert: _environment_ is a declarative Environment Record.", "          1. For each element _name_ of the BoundNames of |ForBinding|, do", "            1. If IsConstantDeclaration of |LetOrConst| is *true*, then", "              1. Perform ! _environment_.CreateImmutableBinding(_name_, *true*).", "            1. Else,", "              1. Perform ! _environment_.CreateMutableBinding(_name_, *false*)."],
    "head": {
      "idx": 0,
      "methodName": "ForDeclarationBindingInstantiation",
      "prod": "ForDeclaration",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LetOrConst",
          "optional": false
        }, {
          "args": [],
          "name": "ForBinding",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "environment"
      }]
    },
    "ids": "sec-runtime-semantics-fordeclarationbindinginstantiation",
    "rawBody": "{\n  0:assert (0) (is-instance-of environment DeclarativeEnvironmentRecord)\n  1:(0) access __x0__ = (ForBinding \"BoundNames\")\n  1:let __x1__ = __x0__\n  1:let __x2__ = 0i\n  1:while (< __x2__ __x1__[\"length\"]) {\n    let name = __x1__[__x2__]\n    4:(1) access __x3__ = (LetOrConst \"IsConstantDeclaration\")\n    4:if (= __x3__ true) {\n      3:(2) app __x4__ = (environment[\"CreateImmutableBinding\"] environment name true)\n      3:[! __x4__]\n    } else {\n      5:(3) app __x5__ = (environment[\"CreateMutableBinding\"] environment name false)\n      5:[! __x5__]\n    }\n    __x2__ = (+ __x2__ 1i)\n  }\n}"
  }, {
    "code": ["          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |Expression|, ~enumerate~).", "          1. Return ? ForIn/OfBodyEvaluation(|LeftHandSideExpression|, |Statement|, _keyResult_, ~enumerate~, ~assignment~, _labelSet_)."],
    "head": {
      "idx": 0,
      "methodName": "ForInOfLoopEvaluation",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-forinofloopevaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (ForInOfHeadEvaluation (0) (new []) Expression CONST_enumerate)\n  0:let keyResult = [? __x0__]\n  1:(1) app __x1__ = (ForInOfBodyEvaluation LeftHandSideExpression Statement keyResult CONST_enumerate CONST_assignment labelSet)\n  1:return [? __x1__]\n}"
  }, {
    "code": ["          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |Expression|, ~enumerate~).", "          1. Return ? ForIn/OfBodyEvaluation(|ForBinding|, |Statement|, _keyResult_, ~enumerate~, ~varBinding~, _labelSet_)."],
    "head": {
      "idx": 1,
      "methodName": "ForInOfLoopEvaluation",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "ForBinding",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-forinofloopevaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (ForInOfHeadEvaluation (0) (new []) Expression CONST_enumerate)\n  0:let keyResult = [? __x0__]\n  1:(1) app __x1__ = (ForInOfBodyEvaluation ForBinding Statement keyResult CONST_enumerate CONST_varBinding labelSet)\n  1:return [? __x1__]\n}"
  }, {
    "code": ["          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |Expression|, ~enumerate~).", "          1. Return ? ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~enumerate~, ~lexicalBinding~, _labelSet_)."],
    "head": {
      "idx": 2,
      "methodName": "ForInOfLoopEvaluation",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "ForDeclaration",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-forinofloopevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (ForDeclaration \"BoundNames\")\n  0:(1) app __x1__ = (ForInOfHeadEvaluation __x0__ Expression CONST_enumerate)\n  0:let keyResult = [? __x1__]\n  1:(2) app __x2__ = (ForInOfBodyEvaluation ForDeclaration Statement keyResult CONST_enumerate CONST_lexicalBinding labelSet)\n  1:return [? __x2__]\n}"
  }, {
    "code": ["          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~iterate~).", "          1. Return ? ForIn/OfBodyEvaluation(|LeftHandSideExpression|, |Statement|, _keyResult_, ~iterate~, ~assignment~, _labelSet_)."],
    "head": {
      "idx": 3,
      "methodName": "ForInOfLoopEvaluation",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-forinofloopevaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (ForInOfHeadEvaluation (0) (new []) AssignmentExpression CONST_iterate)\n  0:let keyResult = [? __x0__]\n  1:(1) app __x1__ = (ForInOfBodyEvaluation LeftHandSideExpression Statement keyResult CONST_iterate CONST_assignment labelSet)\n  1:return [? __x1__]\n}"
  }, {
    "code": ["          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~iterate~).", "          1. Return ? ForIn/OfBodyEvaluation(|ForBinding|, |Statement|, _keyResult_, ~iterate~, ~varBinding~, _labelSet_)."],
    "head": {
      "idx": 4,
      "methodName": "ForInOfLoopEvaluation",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "ForBinding",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-forinofloopevaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (ForInOfHeadEvaluation (0) (new []) AssignmentExpression CONST_iterate)\n  0:let keyResult = [? __x0__]\n  1:(1) app __x1__ = (ForInOfBodyEvaluation ForBinding Statement keyResult CONST_iterate CONST_varBinding labelSet)\n  1:return [? __x1__]\n}"
  }, {
    "code": ["          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |AssignmentExpression|, ~iterate~).", "          1. Return ? ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~iterate~, ~lexicalBinding~, _labelSet_)."],
    "head": {
      "idx": 5,
      "methodName": "ForInOfLoopEvaluation",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "ForDeclaration",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-forinofloopevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (ForDeclaration \"BoundNames\")\n  0:(1) app __x1__ = (ForInOfHeadEvaluation __x0__ AssignmentExpression CONST_iterate)\n  0:let keyResult = [? __x1__]\n  1:(2) app __x2__ = (ForInOfBodyEvaluation ForDeclaration Statement keyResult CONST_iterate CONST_lexicalBinding labelSet)\n  1:return [? __x2__]\n}"
  }, {
    "code": ["          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~async-iterate~).", "          1. Return ? ForIn/OfBodyEvaluation(|LeftHandSideExpression|, |Statement|, _keyResult_, ~iterate~, ~assignment~, _labelSet_, ~async~)."],
    "head": {
      "idx": 6,
      "methodName": "ForInOfLoopEvaluation",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "await"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-forinofloopevaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (ForInOfHeadEvaluation (0) (new []) AssignmentExpression CONST_asyncDASHiterate)\n  0:let keyResult = [? __x0__]\n  1:(1) app __x1__ = (ForInOfBodyEvaluation LeftHandSideExpression Statement keyResult CONST_iterate CONST_assignment labelSet CONST_async)\n  1:return [? __x1__]\n}"
  }, {
    "code": ["          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~async-iterate~).", "          1. Return ? ForIn/OfBodyEvaluation(|ForBinding|, |Statement|, _keyResult_, ~iterate~, ~varBinding~, _labelSet_, ~async~)."],
    "head": {
      "idx": 7,
      "methodName": "ForInOfLoopEvaluation",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "await"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "ForBinding",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-forinofloopevaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (ForInOfHeadEvaluation (0) (new []) AssignmentExpression CONST_asyncDASHiterate)\n  0:let keyResult = [? __x0__]\n  1:(1) app __x1__ = (ForInOfBodyEvaluation ForBinding Statement keyResult CONST_iterate CONST_varBinding labelSet CONST_async)\n  1:return [? __x1__]\n}"
  }, {
    "code": ["          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |AssignmentExpression|, ~async-iterate~).", "          1. Return ? ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~iterate~, ~lexicalBinding~, _labelSet_, ~async~)."],
    "head": {
      "idx": 8,
      "methodName": "ForInOfLoopEvaluation",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "await"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "ForDeclaration",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-forinofloopevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (ForDeclaration \"BoundNames\")\n  0:(1) app __x1__ = (ForInOfHeadEvaluation __x0__ AssignmentExpression CONST_asyncDASHiterate)\n  0:let keyResult = [? __x1__]\n  1:(2) app __x2__ = (ForInOfBodyEvaluation ForDeclaration Statement keyResult CONST_iterate CONST_lexicalBinding labelSet CONST_async)\n  1:return [? __x2__]\n}"
  }, {
    "code": ["          1. Let _oldEnv_ be the running execution context's LexicalEnvironment.", "          1. If _uninitializedBoundNames_ is not an empty List, then", "            1. Assert: _uninitializedBoundNames_ has no duplicate entries.", "            1. Let _newEnv_ be NewDeclarativeEnvironment(_oldEnv_).", "            1. For each String _name_ of _uninitializedBoundNames_, do", "              1. Perform ! _newEnv_.CreateMutableBinding(_name_, *false*).", "            1. Set the running execution context's LexicalEnvironment to _newEnv_.", "          1. Let _exprRef_ be the result of evaluating _expr_.", "          1. Set the running execution context's LexicalEnvironment to _oldEnv_.", "          1. Let _exprValue_ be ? GetValue(_exprRef_).", "          1. If _iterationKind_ is ~enumerate~, then", "            1. If _exprValue_ is *undefined* or *null*, then", "              1. Return Completion { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]: ~empty~ }.", "            1. Let _obj_ be ! ToObject(_exprValue_).", "            1. Let _iterator_ be ? EnumerateObjectProperties(_obj_).", "            1. Let _nextMethod_ be ! GetV(_iterator_, *\"next\"*).", "            1. Return the Record { [[Iterator]]: _iterator_, [[NextMethod]]: _nextMethod_, [[Done]]: *false* }.", "          1. Else,", "            1. Assert: _iterationKind_ is ~iterate~ or ~async-iterate~.", "            1. If _iterationKind_ is ~async-iterate~, let _iteratorHint_ be ~async~.", "            1. Else, let _iteratorHint_ be ~sync~.", "            1. Return ? GetIterator(_exprValue_, _iteratorHint_)."],
    "head": {
      "name": "ForInOfHeadEvaluation",
      "params": [{
        "kind": "Normal",
        "name": "uninitializedBoundNames"
      }, {
        "kind": "Normal",
        "name": "expr"
      }, {
        "kind": "Normal",
        "name": "iterationKind"
      }]
    },
    "ids": "sec-runtime-semantics-forinofheadevaluation",
    "rawBody": "{\n  0:let oldEnv = CONTEXT[\"LexicalEnvironment\"]\n  1:if (< 0i uninitializedBoundNames[\"length\"]) {\n    3:(0) app __x0__ = (NewDeclarativeEnvironment oldEnv)\n    3:let newEnv = __x0__\n    4:let __x1__ = uninitializedBoundNames\n    4:let __x2__ = 0i\n    4:while (< __x2__ __x1__[\"length\"]) {\n      let name = __x1__[__x2__]\n      5:(1) app __x3__ = (newEnv[\"CreateMutableBinding\"] newEnv name false)\n      5:[! __x3__]\n      __x2__ = (+ __x2__ 1i)\n    }\n    6:CONTEXT[\"LexicalEnvironment\"] = newEnv\n  } else 2:{}\n  7:(2) access __x4__ = (expr \"Evaluation\")\n  7:let exprRef = __x4__\n  8:CONTEXT[\"LexicalEnvironment\"] = oldEnv\n  9:(3) app __x5__ = (GetValue exprRef)\n  9:let exprValue = [? __x5__]\n  17:if (= iterationKind CONST_enumerate) {\n    11:if (|| (= exprValue undefined) (= exprValue null)) return (0) (new Completion(\"Type\" -> CONST_break, \"Value\" -> CONST_empty, \"Target\" -> CONST_empty)) else 2:{}\n    13:(4) app __x6__ = (ToObject exprValue)\n    13:let obj = [! __x6__]\n    14:(5) app __x7__ = (EnumerateObjectProperties obj)\n    14:let iterator = [? __x7__]\n    15:(6) app __x8__ = (GetV iterator \"next\")\n    15:let nextMethod = [! __x8__]\n    16:return (1) (new Record(\"Iterator\" -> iterator, \"NextMethod\" -> nextMethod, \"Done\" -> false))\n  } else {\n    18:assert (|| (= iterationKind CONST_iterate) (= iterationKind CONST_asyncDASHiterate))\n    20:if (= iterationKind CONST_asyncDASHiterate) let iteratorHint = CONST_async else let iteratorHint = CONST_sync\n    21:(7) app __x9__ = (GetIterator exprValue iteratorHint)\n    21:return [? __x9__]\n  }\n}"
  }, {
    "code": ["          1. If _iteratorKind_ is not present, set _iteratorKind_ to ~sync~.", "          1. Let _oldEnv_ be the running execution context's LexicalEnvironment.", "          1. Let _V_ be *undefined*.", "          1. Let _destructuring_ be IsDestructuring of _lhs_.", "          1. If _destructuring_ is *true* and if _lhsKind_ is ~assignment~, then", "            1. Assert: _lhs_ is a |LeftHandSideExpression|.", "            1. Let _assignmentPattern_ be the |AssignmentPattern| that is covered by _lhs_.", "          1. Repeat,", "            1. Let _nextResult_ be ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]]).", "            1. If _iteratorKind_ is ~async~, set _nextResult_ to ? Await(_nextResult_).", "            1. If Type(_nextResult_) is not Object, throw a *TypeError* exception.", "            1. Let _done_ be ? IteratorComplete(_nextResult_).", "            1. If _done_ is *true*, return NormalCompletion(_V_).", "            1. Let _nextValue_ be ? IteratorValue(_nextResult_).", "            1. If _lhsKind_ is either ~assignment~ or ~varBinding~, then", "              1. If _destructuring_ is *false*, then", "                1. Let _lhsRef_ be the result of evaluating _lhs_. (It may be evaluated repeatedly.)", "            1. Else,", "              1. Assert: _lhsKind_ is ~lexicalBinding~.", "              1. Assert: _lhs_ is a |ForDeclaration|.", "              1. Let _iterationEnv_ be NewDeclarativeEnvironment(_oldEnv_).", "              1. Perform ForDeclarationBindingInstantiation for _lhs_ passing _iterationEnv_ as the argument.", "              1. Set the running execution context's LexicalEnvironment to _iterationEnv_.", "              1. If _destructuring_ is *false*, then", "                1. Assert: _lhs_ binds a single name.", "                1. Let _lhsName_ be the sole element of BoundNames of _lhs_.", "                1. Let _lhsRef_ be ! ResolveBinding(_lhsName_).", "            1. If _destructuring_ is *false*, then", "              1. If _lhsRef_ is an abrupt completion, then", "                1. Let _status_ be _lhsRef_.", "              1. Else if _lhsKind_ is ~lexicalBinding~, then", "                1. Let _status_ be InitializeReferencedBinding(_lhsRef_, _nextValue_).", "              1. Else,", "                1. Let _status_ be PutValue(_lhsRef_, _nextValue_).", "            1. Else,", "              1. If _lhsKind_ is ~assignment~, then", "                1. Let _status_ be DestructuringAssignmentEvaluation of _assignmentPattern_ with argument _nextValue_.", "              1. Else if _lhsKind_ is ~varBinding~, then", "                1. Assert: _lhs_ is a |ForBinding|.", "                1. Let _status_ be BindingInitialization of _lhs_ with arguments _nextValue_ and *undefined*.", "              1. Else,", "                1. Assert: _lhsKind_ is ~lexicalBinding~.", "                1. Assert: _lhs_ is a |ForDeclaration|.", "                1. Let _status_ be ForDeclarationBindingInitialization of _lhs_ with arguments _nextValue_ and _iterationEnv_.", "            1. If _status_ is an abrupt completion, then", "              1. Set the running execution context's LexicalEnvironment to _oldEnv_.", "              1. If _iteratorKind_ is ~async~, return ? AsyncIteratorClose(_iteratorRecord_, _status_).", "              1. If _iterationKind_ is ~enumerate~, then", "                1. Return _status_.", "              1. Else,", "                1. Assert: _iterationKind_ is ~iterate~.", "                1. Return ? IteratorClose(_iteratorRecord_, _status_).", "            1. Let _result_ be the result of evaluating _stmt_.", "            1. Set the running execution context's LexicalEnvironment to _oldEnv_.", "            1. If LoopContinues(_result_, _labelSet_) is *false*, then", "              1. If _iterationKind_ is ~enumerate~, then", "                1. Return Completion(UpdateEmpty(_result_, _V_)).", "              1. Else,", "                1. Assert: _iterationKind_ is ~iterate~.", "                1. Set _status_ to UpdateEmpty(_result_, _V_).", "                1. If _iteratorKind_ is ~async~, return ? AsyncIteratorClose(_iteratorRecord_, _status_).", "                1. Return ? IteratorClose(_iteratorRecord_, _status_).", "            1. If _result_.[[Value]] is not ~empty~, set _V_ to _result_.[[Value]]."],
    "head": {
      "name": "ForInOfBodyEvaluation",
      "params": [{
        "kind": "Normal",
        "name": "lhs"
      }, {
        "kind": "Normal",
        "name": "stmt"
      }, {
        "kind": "Normal",
        "name": "iteratorRecord"
      }, {
        "kind": "Normal",
        "name": "iterationKind"
      }, {
        "kind": "Normal",
        "name": "lhsKind"
      }, {
        "kind": "Normal",
        "name": "labelSet"
      }, {
        "kind": "Optional",
        "name": "iteratorKind"
      }]
    },
    "ids": "sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset",
    "rawBody": "{\n  0:if (= iteratorKind absent) iteratorKind = CONST_sync else 24:{}\n  1:let oldEnv = CONTEXT[\"LexicalEnvironment\"]\n  2:let V = undefined\n  3:(0) access __x0__ = (lhs \"IsDestructuring\")\n  3:let destructuring = __x0__\n  4:if (&& (= destructuring true) (= lhsKind CONST_assignment)) {\n    5:assert (0) (is-instance-of lhs LeftHandSideExpression)\n    6:let assignmentPattern = (parse-syntax lhs \"AssignmentPattern\" (1) (new []))\n  } else 24:{}\n  7:while true {\n    8:(1) app __x1__ = (Call iteratorRecord[\"NextMethod\"] iteratorRecord[\"Iterator\"])\n    8:let nextResult = [? __x1__]\n    9:if (= iteratorKind CONST_async) {\n      (2) app __x2__ = (Await nextResult)\n      nextResult = [? __x2__]\n    } else 24:{}\n    10:if (! (= (typeof nextResult) Object)) (2) throw TypeError else 24:{}\n    11:(3) app __x3__ = (IteratorComplete nextResult)\n    11:let done = [? __x3__]\n    12:if (= done true) return V else 24:{}\n    13:(4) app __x4__ = (IteratorValue nextResult)\n    13:let nextValue = [? __x4__]\n    17:if (|| (= lhsKind CONST_assignment) (= lhsKind CONST_varBinding)) if (= destructuring false) {\n      16:(5) access __x5__ = (lhs \"Evaluation\")\n      16:let lhsRef = __x5__\n    } else 24:{} else {\n      18:assert (= lhsKind CONST_lexicalBinding)\n      19:assert (3) (is-instance-of lhs ForDeclaration)\n      20:(6) app __x6__ = (NewDeclarativeEnvironment oldEnv)\n      20:let iterationEnv = __x6__\n      21:(7) access __x7__ = (lhs \"ForDeclarationBindingInstantiation\" iterationEnv)\n      21:__x7__\n      22:CONTEXT[\"LexicalEnvironment\"] = iterationEnv\n      23:if (= destructuring false) {\n        25:(8) access __x8__ = (lhs \"BoundNames\")\n        25:let lhsName = __x8__[0i]\n        26:(9) app __x9__ = (ResolveBinding lhsName)\n        26:let lhsRef = [! __x9__]\n      } else 24:{}\n    }\n    34:if (= destructuring false) {\n      32:(10) app __x10__ = (IsAbruptCompletion lhsRef)\n      32:if __x10__ let status = lhsRef else if (= lhsKind CONST_lexicalBinding) {\n        31:(11) app __x11__ = (InitializeReferencedBinding lhsRef nextValue)\n        31:let status = __x11__\n      } else {\n        33:(12) app __x12__ = (PutValue lhsRef nextValue)\n        33:let status = __x12__\n      }\n    } else if (= lhsKind CONST_assignment) {\n      36:(13) access __x13__ = (assignmentPattern \"DestructuringAssignmentEvaluation\" nextValue)\n      36:let status = __x13__\n    } else if (= lhsKind CONST_varBinding) {\n      38:assert (4) (is-instance-of lhs ForBinding)\n      39:(14) access __x14__ = (lhs \"BindingInitialization\" nextValue undefined)\n      39:let status = __x14__\n    } else {\n      41:assert (= lhsKind CONST_lexicalBinding)\n      42:assert (5) (is-instance-of lhs ForDeclaration)\n      43:(15) access __x15__ = (lhs \"ForDeclarationBindingInitialization\" nextValue iterationEnv)\n      43:let status = __x15__\n    }\n    44:(16) app __x16__ = (IsAbruptCompletion status)\n    44:if __x16__ {\n      45:CONTEXT[\"LexicalEnvironment\"] = oldEnv\n      46:if (= iteratorKind CONST_async) {\n        (17) app __x17__ = (AsyncIteratorClose iteratorRecord status)\n        return [? __x17__]\n      } else 24:{}\n      49:if (= iterationKind CONST_enumerate) return status else {\n        50:assert (= iterationKind CONST_iterate)\n        51:(18) app __x18__ = (IteratorClose iteratorRecord status)\n        51:return [? __x18__]\n      }\n    } else 24:{}\n    52:(19) access __x19__ = (stmt \"Evaluation\")\n    52:let result = __x19__\n    53:CONTEXT[\"LexicalEnvironment\"] = oldEnv\n    54:(20) app __x20__ = (LoopContinues result labelSet)\n    54:if (= __x20__ false) if (= iterationKind CONST_enumerate) {\n      56:(21) app __x21__ = (UpdateEmpty result V)\n      56:return __x21__\n    } else {\n      58:assert (= iterationKind CONST_iterate)\n      59:(22) app __x22__ = (UpdateEmpty result V)\n      59:status = __x22__\n      60:if (= iteratorKind CONST_async) {\n        (23) app __x23__ = (AsyncIteratorClose iteratorRecord status)\n        return [? __x23__]\n      } else 24:{}\n      61:(24) app __x24__ = (IteratorClose iteratorRecord status)\n      61:return [? __x24__]\n    } else 24:{}\n    62:if (! (= result[\"Value\"] CONST_empty)) V = result[\"Value\"] else 24:{}\n  }\n}"
  }, {
    "code": ["          1. Let _bindingId_ be StringValue of |BindingIdentifier|.", "          1. Return ? ResolveBinding(_bindingId_)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "ForBinding",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-for-in-and-for-of-statements-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingIdentifier \"StringValue\")\n  0:let bindingId = __x0__\n  1:(1) app __x1__ = (ResolveBinding bindingId)\n  1:return [? __x1__]\n}"
  }, {
    "code": ["          1. Assert: Type(_O_) is Object.", "          1. Return an Iterator object (<emu-xref href=\"#sec-iterator-interface\"></emu-xref>) whose `next` method iterates over all the String-valued keys of enumerable properties of _O_. The iterator object is never directly accessible to ECMAScript code. The mechanics and order of enumerating the properties is not specified but must conform to the rules specified below."],
    "head": {
      "name": "EnumerateObjectProperties",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }]
    },
    "ids": "sec-enumerate-object-properties",
    "rawBody": "{\n  0:assert (= (typeof O) Object)\n  1:return (0) (new Object())\n}"
  }, {
    "code": ["            1. Assert: Type(_object_) is Object.", "            1. Let _iterator_ be ! OrdinaryObjectCreate(%ForInIteratorPrototype%, « [[Object]], [[ObjectWasVisited]], [[VisitedKeys]], [[RemainingKeys]] »).", "            1. Set _iterator_.[[Object]] to _object_.", "            1. Set _iterator_.[[ObjectWasVisited]] to *false*.", "            1. Set _iterator_.[[VisitedKeys]] to a new empty List.", "            1. Set _iterator_.[[RemainingKeys]] to a new empty List.", "            1. Return _iterator_."],
    "head": {
      "name": "CreateForInIterator",
      "params": [{
        "kind": "Normal",
        "name": "object"
      }]
    },
    "ids": "sec-createforiniterator",
    "rawBody": "{\n  0:assert (= (typeof object) Object)\n  1:(0) app __x0__ = (OrdinaryObjectCreate INTRINSIC_ForInIteratorPrototype (0) (new [\"Object\", \"ObjectWasVisited\", \"VisitedKeys\", \"RemainingKeys\"]))\n  1:let iterator = [! __x0__]\n  2:iterator[\"Object\"] = object\n  3:iterator[\"ObjectWasVisited\"] = false\n  4:iterator[\"VisitedKeys\"] = (1) (new [])\n  5:iterator[\"RemainingKeys\"] = (2) (new [])\n  6:return iterator\n}"
  }, {
    "code": ["              1. Let _O_ be the *this* value.", "              1. Assert: Type(_O_) is Object.", "              1. Assert: _O_ has all of the internal slots of a For-In Iterator Instance (<emu-xref href=\"#sec-properties-of-for-in-iterator-instances\"></emu-xref>).", "              1. Let _object_ be _O_.[[Object]].", "              1. Let _visited_ be _O_.[[VisitedKeys]].", "              1. Let _remaining_ be _O_.[[RemainingKeys]].", "              1. Repeat,", "                1. If _O_.[[ObjectWasVisited]] is *false*, then", "                  1. Let _keys_ be ? _object_.[[OwnPropertyKeys]]().", "                  1. For each element _key_ of _keys_, do", "                    1. If Type(_key_) is String, then", "                      1. Append _key_ to _remaining_.", "                  1. Set _O_.[[ObjectWasVisited]] to *true*.", "                1. Repeat, while _remaining_ is not empty,", "                  1. Let _r_ be the first element of _remaining_.", "                  1. Remove the first element from _remaining_.", "                  1. If there does not exist an element _v_ of _visited_ such that SameValue(_r_, _v_) is *true*, then", "                    1. Let _desc_ be ? _object_.[[GetOwnProperty]](_r_).", "                    1. If _desc_ is not *undefined*, then", "                      1. Append _r_ to _visited_.", "                      1. If _desc_.[[Enumerable]] is *true*, return CreateIterResultObject(_r_, *false*).", "                1. Set _object_ to ? _object_.[[GetPrototypeOf]]().", "                1. Set _O_.[[Object]] to _object_.", "                1. Set _O_.[[ObjectWasVisited]] to *false*.", "                1. If _object_ is *null*, return CreateIterResultObject(*undefined*, *true*)."],
    "head": {
      "name": "%ForInIteratorPrototype%.next",
      "params": []
    },
    "ids": "sec-%foriniteratorprototype%.next",
    "rawBody": "{\n  0:let O = this\n  1:assert (= (typeof O) Object)\n  3:let object = O[\"Object\"]\n  4:let visited = O[\"VisitedKeys\"]\n  5:let remaining = O[\"RemainingKeys\"]\n  6:while true {\n    7:if (= O[\"ObjectWasVisited\"] false) {\n      8:(0) app __x0__ = (object[\"OwnPropertyKeys\"] object)\n      8:let keys = [? __x0__]\n      9:let __x1__ = keys\n      9:let __x2__ = 0i\n      9:while (< __x2__ __x1__[\"length\"]) {\n        let key = __x1__[__x2__]\n        10:if (= (typeof key) String) append key -> remaining else 2:{}\n        __x2__ = (+ __x2__ 1i)\n      }\n      12:O[\"ObjectWasVisited\"] = true\n    } else 2:{}\n    13:while (< 0i remaining[\"length\"]) {\n      14:let r = remaining[0i]\n      15:let __x3__ = (pop remaining 0i)\n      16:(0) ??? \"If there does not exist an element id:{v} of id:{visited} such that SameValue ( id:{r} , id:{v} ) is value:{true} , then in:{} out:{}\"\n    }\n    21:(1) app __x4__ = (object[\"GetPrototypeOf\"] object)\n    21:object = [? __x4__]\n    22:O[\"Object\"] = object\n    23:O[\"ObjectWasVisited\"] = false\n    24:if (= object null) {\n      (2) app __x5__ = (CreateIterResultObject undefined true)\n      return __x5__\n    } else 2:{}\n  }\n}"
  }, {
    "code": ["        1. Return Completion { [[Type]]: ~continue~, [[Value]]: ~empty~, [[Target]]: ~empty~ }."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "ContinueStatement",
      "rhs": {
        "tokens": [{
          "term": "continue"
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-continue-statement-runtime-semantics-evaluation",
    "rawBody": "return (0) (new Completion(\"Type\" -> CONST_continue, \"Value\" -> CONST_empty, \"Target\" -> CONST_empty))"
  }, {
    "code": ["        1. Let _label_ be the StringValue of |LabelIdentifier|.", "        1. Return Completion { [[Type]]: ~continue~, [[Value]]: ~empty~, [[Target]]: _label_ }."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "ContinueStatement",
      "rhs": {
        "tokens": [{
          "term": "continue"
        }, {
          "args": [],
          "name": "LabelIdentifier",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-continue-statement-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (LabelIdentifier \"StringValue\")\n  0:let label = __x0__\n  1:return (0) (new Completion(\"Type\" -> CONST_continue, \"Value\" -> CONST_empty, \"Target\" -> label))\n}"
  }, {
    "code": ["        1. Return Completion { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]: ~empty~ }."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "BreakStatement",
      "rhs": {
        "tokens": [{
          "term": "break"
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-break-statement-runtime-semantics-evaluation",
    "rawBody": "return (0) (new Completion(\"Type\" -> CONST_break, \"Value\" -> CONST_empty, \"Target\" -> CONST_empty))"
  }, {
    "code": ["        1. Let _label_ be the StringValue of |LabelIdentifier|.", "        1. Return Completion { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]: _label_ }."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "BreakStatement",
      "rhs": {
        "tokens": [{
          "term": "break"
        }, {
          "args": [],
          "name": "LabelIdentifier",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-break-statement-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (LabelIdentifier \"StringValue\")\n  0:let label = __x0__\n  1:return (0) (new Completion(\"Type\" -> CONST_break, \"Value\" -> CONST_empty, \"Target\" -> label))\n}"
  }, {
    "code": ["        1. Return Completion { [[Type]]: ~return~, [[Value]]: *undefined*, [[Target]]: ~empty~ }."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "ReturnStatement",
      "rhs": {
        "tokens": [{
          "term": "return"
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-return-statement-runtime-semantics-evaluation",
    "rawBody": "return (0) (new Completion(\"Type\" -> CONST_return, \"Value\" -> undefined, \"Target\" -> CONST_empty))"
  }, {
    "code": ["        1. Let _exprRef_ be the result of evaluating |Expression|.", "        1. Let _exprValue_ be ? GetValue(_exprRef_).", "        1. If ! GetGeneratorKind() is ~async~, set _exprValue_ to ? Await(_exprValue_).", "        1. Return Completion { [[Type]]: ~return~, [[Value]]: _exprValue_, [[Target]]: ~empty~ }."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "ReturnStatement",
      "rhs": {
        "tokens": [{
          "term": "return"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-return-statement-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Expression \"Evaluation\")\n  0:let exprRef = __x0__\n  1:(1) app __x1__ = (GetValue exprRef)\n  1:let exprValue = [? __x1__]\n  2:(2) app __x2__ = (GetGeneratorKind)\n  2:if (= [! __x2__] CONST_async) {\n    (3) app __x3__ = (Await exprValue)\n    exprValue = [? __x3__]\n  } else 2:{}\n  3:return (0) (new Completion(\"Type\" -> CONST_return, \"Value\" -> exprValue, \"Target\" -> CONST_empty))\n}"
  }, {
    "code": ["        1. Let _val_ be the result of evaluating |Expression|.", "        1. Let _obj_ be ? ToObject(? GetValue(_val_)).", "        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.", "        1. Let _newEnv_ be NewObjectEnvironment(_obj_, _oldEnv_).", "        1. Set the _withEnvironment_ flag of _newEnv_ to *true*.", "        1. Set the running execution context's LexicalEnvironment to _newEnv_.", "        1. Let _C_ be the result of evaluating |Statement|.", "        1. Set the running execution context's LexicalEnvironment to _oldEnv_.", "        1. Return Completion(UpdateEmpty(_C_, *undefined*))."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "WithStatement",
      "rhs": {
        "tokens": [{
          "term": "with"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-with-statement-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Expression \"Evaluation\")\n  0:let val = __x0__\n  1:(1) app __x1__ = (GetValue val)\n  1:(2) app __x2__ = (ToObject [? __x1__])\n  1:let obj = [? __x2__]\n  2:let oldEnv = CONTEXT[\"LexicalEnvironment\"]\n  3:(3) app __x3__ = (NewObjectEnvironment obj oldEnv)\n  3:let newEnv = __x3__\n  4:newEnv[\"withEnvironment\"] = true\n  5:CONTEXT[\"LexicalEnvironment\"] = newEnv\n  6:(4) access __x4__ = (Statement \"Evaluation\")\n  6:let C = __x4__\n  7:CONTEXT[\"LexicalEnvironment\"] = oldEnv\n  8:(5) app __x5__ = (UpdateEmpty C undefined)\n  8:return __x5__\n}"
  }, {
    "code": ["        1. Return NormalCompletion(*undefined*)."],
    "head": {
      "idx": 0,
      "methodName": "CaseBlockEvaluation",
      "prod": "CaseBlock",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "input"
      }]
    },
    "ids": "sec-runtime-semantics-caseblockevaluation",
    "rawBody": "return undefined"
  }, {
    "code": ["        1. Let _V_ be *undefined*.", "        1. Let _A_ be the List of |CaseClause| items in |CaseClauses|, in source text order.", "        1. Let _found_ be *false*.", "        1. For each |CaseClause| _C_ of _A_, do", "          1. If _found_ is *false*, then", "            1. Set _found_ to ? CaseClauseIsSelected(_C_, _input_).", "          1. If _found_ is *true*, then", "            1. Let _R_ be the result of evaluating _C_.", "            1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].", "            1. If _R_ is an abrupt completion, return Completion(UpdateEmpty(_R_, _V_)).", "        1. Return NormalCompletion(_V_)."],
    "head": {
      "idx": 0,
      "methodName": "CaseBlockEvaluation",
      "prod": "CaseBlock",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "CaseClauses",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Normal",
        "name": "input"
      }]
    },
    "ids": "sec-runtime-semantics-caseblockevaluation",
    "rawBody": "{\n  0:let V = undefined\n  1:(0) ??? \"Let id:{A} be the List of nt:{CaseClause} items in nt:{CaseClauses} , in source text order .\"\n  2:let found = false\n  3:let __x0__ = A\n  3:let __x1__ = 0i\n  3:while (< __x1__ __x0__[\"length\"]) {\n    let C = __x0__[__x1__]\n    4:if (= found false) {\n      5:(0) app __x2__ = (CaseClauseIsSelected C input)\n      5:found = [? __x2__]\n    } else 2:{}\n    6:if (= found true) {\n      7:(1) access __x3__ = (C \"Evaluation\")\n      7:let R = __x3__\n      8:if (! (= R[\"Value\"] CONST_empty)) V = R[\"Value\"] else 2:{}\n      9:(2) app __x4__ = (IsAbruptCompletion R)\n      9:if __x4__ {\n        (3) app __x5__ = (UpdateEmpty R V)\n        return __x5__\n      } else 2:{}\n    } else 2:{}\n    __x1__ = (+ __x1__ 1i)\n  }\n  10:return V\n}"
  }, {
    "code": ["        1. Let _V_ be *undefined*.", "        1. If the first |CaseClauses| is present, then", "          1. Let _A_ be the List of |CaseClause| items in the first |CaseClauses|, in source text order.", "        1. Else,", "          1. Let _A_ be « ».", "        1. Let _found_ be *false*.", "        1. For each |CaseClause| _C_ of _A_, do", "          1. If _found_ is *false*, then", "            1. Set _found_ to ? CaseClauseIsSelected(_C_, _input_).", "          1. If _found_ is *true*, then", "            1. Let _R_ be the result of evaluating _C_.", "            1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].", "            1. If _R_ is an abrupt completion, return Completion(UpdateEmpty(_R_, _V_)).", "        1. Let _foundInB_ be *false*.", "        1. If the second |CaseClauses| is present, then", "          1. Let _B_ be the List of |CaseClause| items in the second |CaseClauses|, in source text order.", "        1. Else,", "          1. Let _B_ be « ».", "        1. If _found_ is *false*, then", "          1. For each |CaseClause| _C_ of _B_, do", "            1. If _foundInB_ is *false*, then", "              1. Set _foundInB_ to ? CaseClauseIsSelected(_C_, _input_).", "            1. If _foundInB_ is *true*, then", "              1. Let _R_ be the result of evaluating |CaseClause| _C_.", "              1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].", "              1. If _R_ is an abrupt completion, return Completion(UpdateEmpty(_R_, _V_)).", "        1. If _foundInB_ is *true*, return NormalCompletion(_V_).", "        1. Let _R_ be the result of evaluating |DefaultClause|.", "        1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].", "        1. If _R_ is an abrupt completion, return Completion(UpdateEmpty(_R_, _V_)).", "        1. NOTE: The following is another complete iteration of the second |CaseClauses|.", "        1. For each |CaseClause| _C_ of _B_, do", "          1. Let _R_ be the result of evaluating |CaseClause| _C_.", "          1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].", "          1. If _R_ is an abrupt completion, return Completion(UpdateEmpty(_R_, _V_)).", "        1. Return NormalCompletion(_V_)."],
    "head": {
      "idx": 1,
      "methodName": "CaseBlockEvaluation",
      "prod": "CaseBlock",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "CaseClauses",
          "optional": true
        }, {
          "args": [],
          "name": "DefaultClause",
          "optional": false
        }, {
          "args": [],
          "name": "CaseClauses",
          "optional": true
        }, {
          "term": "}"
        }]
      },
      "subIdx": 3,
      "withParams": [{
        "kind": "Normal",
        "name": "input"
      }]
    },
    "ids": "sec-runtime-semantics-caseblockevaluation",
    "rawBody": "{\n  0:let V = undefined\n  3:if (! (= CaseClauses0 absent)) (0) ??? \"Let id:{A} be the List of nt:{CaseClause} items in the first nt:{CaseClauses} , in source text order .\" else let A = (1) (new [])\n  5:let found = false\n  6:let __x0__ = A\n  6:let __x1__ = 0i\n  6:while (< __x1__ __x0__[\"length\"]) {\n    let C = __x0__[__x1__]\n    7:if (= found false) {\n      8:(0) app __x2__ = (CaseClauseIsSelected C input)\n      8:found = [? __x2__]\n    } else 30:{}\n    9:if (= found true) {\n      10:(1) access __x3__ = (C \"Evaluation\")\n      10:let R = __x3__\n      11:if (! (= R[\"Value\"] CONST_empty)) V = R[\"Value\"] else 30:{}\n      12:(2) app __x4__ = (IsAbruptCompletion R)\n      12:if __x4__ {\n        (3) app __x5__ = (UpdateEmpty R V)\n        return __x5__\n      } else 30:{}\n    } else 30:{}\n    __x1__ = (+ __x1__ 1i)\n  }\n  13:let foundInB = false\n  16:if (! (= CaseClauses1 absent)) (2) ??? \"Let id:{B} be the List of nt:{CaseClause} items in the second nt:{CaseClauses} , in source text order .\" else let B = (3) (new [])\n  18:if (= found false) {\n    19:let __x6__ = B\n    19:let __x7__ = 0i\n    19:while (< __x7__ __x6__[\"length\"]) {\n      let C = __x6__[__x7__]\n      20:if (= foundInB false) {\n        21:(4) app __x8__ = (CaseClauseIsSelected C input)\n        21:foundInB = [? __x8__]\n      } else 30:{}\n      22:if (= foundInB true) {\n        23:(5) access __x9__ = (C \"Evaluation\")\n        23:let R = __x9__\n        24:if (! (= R[\"Value\"] CONST_empty)) V = R[\"Value\"] else 30:{}\n        25:(6) app __x10__ = (IsAbruptCompletion R)\n        25:if __x10__ {\n          (7) app __x11__ = (UpdateEmpty R V)\n          return __x11__\n        } else 30:{}\n      } else 30:{}\n      __x7__ = (+ __x7__ 1i)\n    }\n  } else 30:{}\n  26:if (= foundInB true) return V else 30:{}\n  27:(8) access __x12__ = (DefaultClause \"Evaluation\")\n  27:let R = __x12__\n  28:if (! (= R[\"Value\"] CONST_empty)) V = R[\"Value\"] else 30:{}\n  29:(9) app __x13__ = (IsAbruptCompletion R)\n  29:if __x13__ {\n    (10) app __x14__ = (UpdateEmpty R V)\n    return __x14__\n  } else 30:{}\n  31:let __x15__ = B\n  31:let __x16__ = 0i\n  31:while (< __x16__ __x15__[\"length\"]) {\n    let C = __x15__[__x16__]\n    32:(11) access __x17__ = (C \"Evaluation\")\n    32:let R = __x17__\n    33:if (! (= R[\"Value\"] CONST_empty)) V = R[\"Value\"] else 30:{}\n    34:(12) app __x18__ = (IsAbruptCompletion R)\n    34:if __x18__ {\n      (13) app __x19__ = (UpdateEmpty R V)\n      return __x19__\n    } else 30:{}\n    __x16__ = (+ __x16__ 1i)\n  }\n  35:return V\n}"
  }, {
    "code": ["        1. Assert: _C_ is an instance of the production <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>.", "        1. Let _exprRef_ be the result of evaluating the |Expression| of _C_.", "        1. Let _clauseSelector_ be ? GetValue(_exprRef_).", "        1. Return the result of performing Strict Equality Comparison _input_ === _clauseSelector_."],
    "head": {
      "name": "CaseClauseIsSelected",
      "params": [{
        "kind": "Normal",
        "name": "C"
      }, {
        "kind": "Normal",
        "name": "input"
      }]
    },
    "ids": "sec-runtime-semantics-caseclauseisselected",
    "rawBody": "{\n  1:(0) access __x0__ = (C \"Expression\")\n  1:(1) access __x1__ = (__x0__ \"Evaluation\")\n  1:let exprRef = __x1__\n  2:(2) app __x2__ = (GetValue exprRef)\n  2:let clauseSelector = [? __x2__]\n  3:(3) app __x3__ = (StrictEqualityComparison input clauseSelector)\n  3:return __x3__\n}"
  }, {
    "code": ["        1. Let _exprRef_ be the result of evaluating |Expression|.", "        1. Let _switchValue_ be ? GetValue(_exprRef_).", "        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.", "        1. Let _blockEnv_ be NewDeclarativeEnvironment(_oldEnv_).", "        1. Perform BlockDeclarationInstantiation(|CaseBlock|, _blockEnv_).", "        1. Set the running execution context's LexicalEnvironment to _blockEnv_.", "        1. Let _R_ be CaseBlockEvaluation of |CaseBlock| with argument _switchValue_.", "        1. Set the running execution context's LexicalEnvironment to _oldEnv_.", "        1. Return _R_."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "SwitchStatement",
      "rhs": {
        "tokens": [{
          "term": "switch"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "CaseBlock",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-switch-statement-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Expression \"Evaluation\")\n  0:let exprRef = __x0__\n  1:(1) app __x1__ = (GetValue exprRef)\n  1:let switchValue = [? __x1__]\n  2:let oldEnv = CONTEXT[\"LexicalEnvironment\"]\n  3:(2) app __x2__ = (NewDeclarativeEnvironment oldEnv)\n  3:let blockEnv = __x2__\n  4:(3) app __x3__ = (BlockDeclarationInstantiation CaseBlock blockEnv)\n  4:__x3__\n  5:CONTEXT[\"LexicalEnvironment\"] = blockEnv\n  6:(4) access __x4__ = (CaseBlock \"CaseBlockEvaluation\" switchValue)\n  6:let R = __x4__\n  7:CONTEXT[\"LexicalEnvironment\"] = oldEnv\n  8:return R\n}"
  }, {
    "code": ["        1. Return NormalCompletion(~empty~)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "CaseClause",
      "rhs": {
        "tokens": [{
          "term": "case"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ":"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-switch-statement-runtime-semantics-evaluation",
    "rawBody": "return CONST_empty"
  }, {
    "code": ["        1. Return the result of evaluating |StatementList|."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "CaseClause",
      "rhs": {
        "tokens": [{
          "term": "case"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "StatementList",
          "optional": false
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-switch-statement-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (StatementList \"Evaluation\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return NormalCompletion(~empty~)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "DefaultClause",
      "rhs": {
        "tokens": [{
          "term": "default"
        }, {
          "term": ":"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-switch-statement-runtime-semantics-evaluation",
    "rawBody": "return CONST_empty"
  }, {
    "code": ["        1. Return the result of evaluating |StatementList|."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "DefaultClause",
      "rhs": {
        "tokens": [{
          "term": "default"
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "StatementList",
          "optional": false
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-switch-statement-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (StatementList \"Evaluation\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. If _stmt_ is not a |LabelledStatement|, return *false*.", "        1. Let _item_ be the |LabelledItem| of _stmt_.", "        1. If _item_ is <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar> , return *true*.", "        1. Let _subStmt_ be the |Statement| of _item_.", "        1. Return IsLabelledFunction(_subStmt_)."],
    "head": {
      "name": "IsLabelledFunction",
      "params": [{
        "kind": "Normal",
        "name": "stmt"
      }]
    },
    "ids": "sec-islabelledfunction",
    "rawBody": "{\n  0:if (! (0) (is-instance-of stmt LabelledStatement)) return false else 0:{}\n  1:(0) access __x0__ = (stmt \"LabelledItem\")\n  1:let item = __x0__\n  2:if (1) (is-instance-of item LabelledItem1) {\n    (1) access FunctionDeclaration = (item \"FunctionDeclaration\")\n    return true\n  } else 0:{}\n  3:(2) access __x1__ = (item \"Statement\")\n  3:let subStmt = __x1__\n  4:(3) app __x2__ = (IsLabelledFunction subStmt)\n  4:return __x2__\n}"
  }, {
    "code": ["        1. Let _newLabelSet_ be a new empty List.", "        1. Return LabelledEvaluation of this |LabelledStatement| with argument _newLabelSet_."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "LabelledStatement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LabelIdentifier",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "LabelledItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-labelled-statements-runtime-semantics-evaluation",
    "rawBody": "{\n  0:let newLabelSet = (0) (new [])\n  1:(0) access __x0__ = (this \"LabelledEvaluation\" newLabelSet)\n  1:return __x0__\n}"
  }, {
    "code": ["        1. Let _stmtResult_ be LoopEvaluation of |IterationStatement| with argument _labelSet_.", "        1. If _stmtResult_.[[Type]] is ~break~, then", "          1. If _stmtResult_.[[Target]] is ~empty~, then", "            1. If _stmtResult_.[[Value]] is ~empty~, set _stmtResult_ to NormalCompletion(*undefined*).", "            1. Else, set _stmtResult_ to NormalCompletion(_stmtResult_.[[Value]]).", "        1. Return Completion(_stmtResult_)."],
    "head": {
      "idx": 0,
      "methodName": "LabelledEvaluation",
      "prod": "BreakableStatement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "IterationStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-labelledevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (IterationStatement \"LoopEvaluation\" labelSet)\n  0:let stmtResult = __x0__\n  1:if (= stmtResult[\"Type\"] CONST_break) if (= stmtResult[\"Target\"] CONST_empty) if (= stmtResult[\"Value\"] CONST_empty) {\n    (1) app __x1__ = (NormalCompletion undefined)\n    stmtResult = __x1__\n  } else {\n    (2) app __x2__ = (NormalCompletion stmtResult[\"Value\"])\n    stmtResult = __x2__\n  } else 0:{} else 0:{}\n  5:return stmtResult\n}"
  }, {
    "code": ["        1. Let _stmtResult_ be the result of evaluating |SwitchStatement|.", "        1. If _stmtResult_.[[Type]] is ~break~, then", "          1. If _stmtResult_.[[Target]] is ~empty~, then", "            1. If _stmtResult_.[[Value]] is ~empty~, set _stmtResult_ to NormalCompletion(*undefined*).", "            1. Else, set _stmtResult_ to NormalCompletion(_stmtResult_.[[Value]]).", "        1. Return Completion(_stmtResult_)."],
    "head": {
      "idx": 1,
      "methodName": "LabelledEvaluation",
      "prod": "BreakableStatement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "SwitchStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-labelledevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (SwitchStatement \"Evaluation\")\n  0:let stmtResult = __x0__\n  1:if (= stmtResult[\"Type\"] CONST_break) if (= stmtResult[\"Target\"] CONST_empty) if (= stmtResult[\"Value\"] CONST_empty) {\n    (1) app __x1__ = (NormalCompletion undefined)\n    stmtResult = __x1__\n  } else {\n    (2) app __x2__ = (NormalCompletion stmtResult[\"Value\"])\n    stmtResult = __x2__\n  } else 0:{} else 0:{}\n  5:return stmtResult\n}"
  }, {
    "code": ["        1. Let _label_ be the StringValue of |LabelIdentifier|.", "        1. Append _label_ as an element of _labelSet_.", "        1. Let _stmtResult_ be LabelledEvaluation of |LabelledItem| with argument _labelSet_.", "        1. If _stmtResult_.[[Type]] is ~break~ and SameValue(_stmtResult_.[[Target]], _label_) is *true*, then", "          1. Set _stmtResult_ to NormalCompletion(_stmtResult_.[[Value]]).", "        1. Return Completion(_stmtResult_)."],
    "head": {
      "idx": 0,
      "methodName": "LabelledEvaluation",
      "prod": "LabelledStatement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LabelIdentifier",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "LabelledItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-labelledevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (LabelIdentifier \"StringValue\")\n  0:let label = __x0__\n  1:append label -> labelSet\n  2:(1) access __x1__ = (LabelledItem \"LabelledEvaluation\" labelSet)\n  2:let stmtResult = __x1__\n  3:let __x2__ = true\n  3:__x2__ = (= stmtResult[\"Type\"] CONST_break)\n  3:if __x2__ {\n    (2) app __x3__ = (SameValue stmtResult[\"Target\"] label)\n    __x2__ = (= __x3__ true)\n  } else 0:{}\n  3:if __x2__ {\n    4:(3) app __x4__ = (NormalCompletion stmtResult[\"Value\"])\n    4:stmtResult = __x4__\n  } else 0:{}\n  5:return stmtResult\n}"
  }, {
    "code": ["        1. Return the result of evaluating |FunctionDeclaration|."],
    "head": {
      "idx": 1,
      "methodName": "LabelledEvaluation",
      "prod": "LabelledItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FunctionDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-labelledevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (FunctionDeclaration \"Evaluation\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the result of evaluating |Statement|."],
    "head": {
      "idx": 0,
      "methodName": "LabelledEvaluation",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BlockStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-labelledevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"Evaluation\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the result of evaluating |Statement|."],
    "head": {
      "idx": 1,
      "methodName": "LabelledEvaluation",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "VariableStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-labelledevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"Evaluation\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the result of evaluating |Statement|."],
    "head": {
      "idx": 2,
      "methodName": "LabelledEvaluation",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "EmptyStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-labelledevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"Evaluation\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the result of evaluating |Statement|."],
    "head": {
      "idx": 3,
      "methodName": "LabelledEvaluation",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExpressionStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-labelledevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"Evaluation\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the result of evaluating |Statement|."],
    "head": {
      "idx": 4,
      "methodName": "LabelledEvaluation",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "IfStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-labelledevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"Evaluation\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the result of evaluating |Statement|."],
    "head": {
      "idx": 6,
      "methodName": "LabelledEvaluation",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ContinueStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-labelledevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"Evaluation\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the result of evaluating |Statement|."],
    "head": {
      "idx": 7,
      "methodName": "LabelledEvaluation",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BreakStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-labelledevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"Evaluation\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the result of evaluating |Statement|."],
    "head": {
      "idx": 8,
      "methodName": "LabelledEvaluation",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ReturnStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-labelledevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"Evaluation\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the result of evaluating |Statement|."],
    "head": {
      "idx": 9,
      "methodName": "LabelledEvaluation",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "WithStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-labelledevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"Evaluation\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the result of evaluating |Statement|."],
    "head": {
      "idx": 11,
      "methodName": "LabelledEvaluation",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ThrowStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-labelledevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"Evaluation\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the result of evaluating |Statement|."],
    "head": {
      "idx": 12,
      "methodName": "LabelledEvaluation",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "TryStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-labelledevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"Evaluation\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return the result of evaluating |Statement|."],
    "head": {
      "idx": 13,
      "methodName": "LabelledEvaluation",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "DebuggerStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "labelSet"
      }]
    },
    "ids": "sec-runtime-semantics-labelledevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"Evaluation\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Let _exprRef_ be the result of evaluating |Expression|.", "        1. Let _exprValue_ be ? GetValue(_exprRef_).", "        1. Return ThrowCompletion(_exprValue_)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "ThrowStatement",
      "rhs": {
        "tokens": [{
          "term": "throw"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-throw-statement-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Expression \"Evaluation\")\n  0:let exprRef = __x0__\n  1:(1) app __x1__ = (GetValue exprRef)\n  1:let exprValue = [? __x1__]\n  2:(2) app __x2__ = (ThrowCompletion exprValue)\n  2:return __x2__\n}"
  }, {
    "code": ["        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.", "        1. Let _catchEnv_ be NewDeclarativeEnvironment(_oldEnv_).", "        1. For each element _argName_ of the BoundNames of |CatchParameter|, do", "          1. Perform ! _catchEnv_.CreateMutableBinding(_argName_, *false*).", "        1. Set the running execution context's LexicalEnvironment to _catchEnv_.", "        1. Let _status_ be BindingInitialization of |CatchParameter| with arguments _thrownValue_ and _catchEnv_.", "        1. If _status_ is an abrupt completion, then", "          1. Set the running execution context's LexicalEnvironment to _oldEnv_.", "          1. Return Completion(_status_).", "        1. Let _B_ be the result of evaluating |Block|.", "        1. Set the running execution context's LexicalEnvironment to _oldEnv_.", "        1. Return Completion(_B_)."],
    "head": {
      "idx": 0,
      "methodName": "CatchClauseEvaluation",
      "prod": "Catch",
      "rhs": {
        "tokens": [{
          "term": "catch"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "CatchParameter",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Block",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "thrownValue"
      }]
    },
    "ids": "sec-runtime-semantics-catchclauseevaluation",
    "rawBody": "{\n  0:let oldEnv = CONTEXT[\"LexicalEnvironment\"]\n  1:(0) app __x0__ = (NewDeclarativeEnvironment oldEnv)\n  1:let catchEnv = __x0__\n  2:(1) access __x1__ = (CatchParameter \"BoundNames\")\n  2:let __x2__ = __x1__\n  2:let __x3__ = 0i\n  2:while (< __x3__ __x2__[\"length\"]) {\n    let argName = __x2__[__x3__]\n    3:(2) app __x4__ = (catchEnv[\"CreateMutableBinding\"] catchEnv argName false)\n    3:[! __x4__]\n    __x3__ = (+ __x3__ 1i)\n  }\n  4:CONTEXT[\"LexicalEnvironment\"] = catchEnv\n  5:(3) access __x5__ = (CatchParameter \"BindingInitialization\" thrownValue catchEnv)\n  5:let status = __x5__\n  6:(4) app __x6__ = (IsAbruptCompletion status)\n  6:if __x6__ {\n    7:CONTEXT[\"LexicalEnvironment\"] = oldEnv\n    8:return status\n  } else 0:{}\n  9:(5) access __x7__ = (Block \"Evaluation\")\n  9:let B = __x7__\n  10:CONTEXT[\"LexicalEnvironment\"] = oldEnv\n  11:return B\n}"
  }, {
    "code": ["        1. Return the result of evaluating |Block|."],
    "head": {
      "idx": 1,
      "methodName": "CatchClauseEvaluation",
      "prod": "Catch",
      "rhs": {
        "tokens": [{
          "term": "catch"
        }, {
          "args": [],
          "name": "Block",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "thrownValue"
      }]
    },
    "ids": "sec-runtime-semantics-catchclauseevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Block \"Evaluation\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Let _B_ be the result of evaluating |Block|.", "        1. If _B_.[[Type]] is ~throw~, let _C_ be CatchClauseEvaluation of |Catch| with argument _B_.[[Value]].", "        1. Else, let _C_ be _B_.", "        1. Return Completion(UpdateEmpty(_C_, *undefined*))."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "TryStatement",
      "rhs": {
        "tokens": [{
          "term": "try"
        }, {
          "args": [],
          "name": "Block",
          "optional": false
        }, {
          "args": [],
          "name": "Catch",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-try-statement-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Block \"Evaluation\")\n  0:let B = __x0__\n  2:if (= B[\"Type\"] CONST_throw) {\n    (1) access __x1__ = (Catch \"CatchClauseEvaluation\" B[\"Value\"])\n    let C = __x1__\n  } else let C = B\n  3:(2) app __x2__ = (UpdateEmpty C undefined)\n  3:return __x2__\n}"
  }, {
    "code": ["        1. Let _B_ be the result of evaluating |Block|.", "        1. Let _F_ be the result of evaluating |Finally|.", "        1. If _F_.[[Type]] is ~normal~, set _F_ to _B_.", "        1. Return Completion(UpdateEmpty(_F_, *undefined*))."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "TryStatement",
      "rhs": {
        "tokens": [{
          "term": "try"
        }, {
          "args": [],
          "name": "Block",
          "optional": false
        }, {
          "args": [],
          "name": "Finally",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-try-statement-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Block \"Evaluation\")\n  0:let B = __x0__\n  1:(1) access __x1__ = (Finally \"Evaluation\")\n  1:let F = __x1__\n  2:if (= F[\"Type\"] CONST_normal) F = B else 0:{}\n  3:(2) app __x2__ = (UpdateEmpty F undefined)\n  3:return __x2__\n}"
  }, {
    "code": ["        1. Let _B_ be the result of evaluating |Block|.", "        1. If _B_.[[Type]] is ~throw~, let _C_ be CatchClauseEvaluation of |Catch| with argument _B_.[[Value]].", "        1. Else, let _C_ be _B_.", "        1. Let _F_ be the result of evaluating |Finally|.", "        1. If _F_.[[Type]] is ~normal~, set _F_ to _C_.", "        1. Return Completion(UpdateEmpty(_F_, *undefined*))."],
    "head": {
      "idx": 2,
      "methodName": "Evaluation",
      "prod": "TryStatement",
      "rhs": {
        "tokens": [{
          "term": "try"
        }, {
          "args": [],
          "name": "Block",
          "optional": false
        }, {
          "args": [],
          "name": "Catch",
          "optional": false
        }, {
          "args": [],
          "name": "Finally",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-try-statement-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Block \"Evaluation\")\n  0:let B = __x0__\n  2:if (= B[\"Type\"] CONST_throw) {\n    (1) access __x1__ = (Catch \"CatchClauseEvaluation\" B[\"Value\"])\n    let C = __x1__\n  } else let C = B\n  3:(2) access __x2__ = (Finally \"Evaluation\")\n  3:let F = __x2__\n  4:if (= F[\"Type\"] CONST_normal) F = C else 0:{}\n  5:(3) app __x3__ = (UpdateEmpty F undefined)\n  5:return __x3__\n}"
  }, {
    "code": ["        1. If an implementation-defined debugging facility is available and enabled, then", "          1. Perform an implementation-defined debugging action.", "          1. Let _result_ be an implementation-defined Completion value.", "        1. Else,", "          1. Let _result_ be NormalCompletion(~empty~).", "        1. Return _result_."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "DebuggerStatement",
      "rhs": {
        "tokens": [{
          "term": "debugger"
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-debugger-statement-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) ??? \"If an implementation - defined debugging facility is available and enabled , then in:{} out:{}\"\n  3:(1) ??? \"Else , in:{} out:{}\"\n  5:return result\n}"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "ContainsExpression",
      "prod": "ObjectBindingPattern",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-containsexpression",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "ContainsExpression",
      "prod": "ObjectBindingPattern",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "BindingRestProperty",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-containsexpression",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return ContainsExpression of |BindingPropertyList|."],
    "head": {
      "idx": 3,
      "methodName": "ContainsExpression",
      "prod": "ObjectBindingPattern",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "BindingPropertyList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "BindingRestProperty",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-containsexpression",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingPropertyList \"ContainsExpression\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "ContainsExpression",
      "prod": "ArrayBindingPattern",
      "rhs": {
        "tokens": [{
          "term": "["
        }, {
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "term": "]"
        }]
      },
      "subIdx": 2,
      "withParams": []
    },
    "ids": "sec-static-semantics-containsexpression",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return ContainsExpression of |BindingRestElement|."],
    "head": {
      "idx": 0,
      "methodName": "ContainsExpression",
      "prod": "ArrayBindingPattern",
      "rhs": {
        "tokens": [{
          "term": "["
        }, {
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "args": [],
          "name": "BindingRestElement",
          "optional": false
        }, {
          "term": "]"
        }]
      },
      "subIdx": 3,
      "withParams": []
    },
    "ids": "sec-static-semantics-containsexpression",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingRestElement \"ContainsExpression\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ContainsExpression of |BindingElementList|."],
    "head": {
      "idx": 2,
      "methodName": "ContainsExpression",
      "prod": "ArrayBindingPattern",
      "rhs": {
        "tokens": [{
          "term": "["
        }, {
          "args": [],
          "name": "BindingElementList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "term": "]"
        }]
      },
      "subIdx": 2,
      "withParams": []
    },
    "ids": "sec-static-semantics-containsexpression",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingElementList \"ContainsExpression\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Let _has_ be ContainsExpression of |BindingElementList|.", "        1. If _has_ is *true*, return *true*.", "        1. Return ContainsExpression of |BindingRestElement|."],
    "head": {
      "idx": 2,
      "methodName": "ContainsExpression",
      "prod": "ArrayBindingPattern",
      "rhs": {
        "tokens": [{
          "term": "["
        }, {
          "args": [],
          "name": "BindingElementList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "args": [],
          "name": "BindingRestElement",
          "optional": false
        }, {
          "term": "]"
        }]
      },
      "subIdx": 3,
      "withParams": []
    },
    "ids": "sec-static-semantics-containsexpression",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingElementList \"ContainsExpression\")\n  0:let has = __x0__\n  1:if (= has true) return true else 0:{}\n  2:(1) access __x1__ = (BindingRestElement \"ContainsExpression\")\n  2:return __x1__\n}"
  }, {
    "code": ["        1. Let _has_ be ContainsExpression of |BindingPropertyList|.", "        1. If _has_ is *true*, return *true*.", "        1. Return ContainsExpression of |BindingProperty|."],
    "head": {
      "idx": 1,
      "methodName": "ContainsExpression",
      "prod": "BindingPropertyList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingPropertyList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "BindingProperty",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-containsexpression",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingPropertyList \"ContainsExpression\")\n  0:let has = __x0__\n  1:if (= has true) return true else 0:{}\n  2:(1) access __x1__ = (BindingProperty \"ContainsExpression\")\n  2:return __x1__\n}"
  }, {
    "code": ["        1. Let _has_ be ContainsExpression of |BindingElementList|.", "        1. If _has_ is *true*, return *true*.", "        1. Return ContainsExpression of |BindingElisionElement|."],
    "head": {
      "idx": 1,
      "methodName": "ContainsExpression",
      "prod": "BindingElementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingElementList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "BindingElisionElement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-containsexpression",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingElementList \"ContainsExpression\")\n  0:let has = __x0__\n  1:if (= has true) return true else 0:{}\n  2:(1) access __x1__ = (BindingElisionElement \"ContainsExpression\")\n  2:return __x1__\n}"
  }, {
    "code": ["        1. Return ContainsExpression of |BindingElement|."],
    "head": {
      "idx": 0,
      "methodName": "ContainsExpression",
      "prod": "BindingElisionElement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "args": [],
          "name": "BindingElement",
          "optional": false
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-containsexpression",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingElement \"ContainsExpression\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Let _has_ be IsComputedPropertyKey of |PropertyName|.", "        1. If _has_ is *true*, return *true*.", "        1. Return ContainsExpression of |BindingElement|."],
    "head": {
      "idx": 1,
      "methodName": "ContainsExpression",
      "prod": "BindingProperty",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "BindingElement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-containsexpression",
    "rawBody": "{\n  0:(0) access __x0__ = (PropertyName \"IsComputedPropertyKey\")\n  0:let has = __x0__\n  1:if (= has true) return true else 0:{}\n  2:(1) access __x1__ = (BindingElement \"ContainsExpression\")\n  2:return __x1__\n}"
  }, {
    "code": ["        1. Return *true*."],
    "head": {
      "idx": 1,
      "methodName": "ContainsExpression",
      "prod": "BindingElement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingPattern",
          "optional": false
        }, {
          "args": [],
          "name": "Initializer",
          "optional": false
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-containsexpression",
    "rawBody": "return true"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "ContainsExpression",
      "prod": "SingleNameBinding",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-containsexpression",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *true*."],
    "head": {
      "idx": 0,
      "methodName": "ContainsExpression",
      "prod": "SingleNameBinding",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "args": [],
          "name": "Initializer",
          "optional": false
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-containsexpression",
    "rawBody": "return true"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "ContainsExpression",
      "prod": "BindingRestElement",
      "rhs": {
        "tokens": [{
          "term": "..."
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-containsexpression",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return ContainsExpression of |BindingPattern|."],
    "head": {
      "idx": 1,
      "methodName": "ContainsExpression",
      "prod": "BindingRestElement",
      "rhs": {
        "tokens": [{
          "term": "..."
        }, {
          "args": [],
          "name": "BindingPattern",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-containsexpression",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingPattern \"ContainsExpression\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "ContainsExpression",
      "prod": "FormalParameters",
      "rhs": {
        "tokens": [{
          "empty": null
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-containsexpression",
    "rawBody": "return false"
  }, {
    "code": ["        1. If ContainsExpression of |FormalParameterList| is *true*, return *true*.", "        1. Return ContainsExpression of |FunctionRestParameter|."],
    "head": {
      "idx": 4,
      "methodName": "ContainsExpression",
      "prod": "FormalParameters",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FormalParameterList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "FunctionRestParameter",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-containsexpression",
    "rawBody": "{\n  0:(0) access __x0__ = (FormalParameterList \"ContainsExpression\")\n  0:if (= __x0__ true) return true else 0:{}\n  1:(1) access __x1__ = (FunctionRestParameter \"ContainsExpression\")\n  1:return __x1__\n}"
  }, {
    "code": ["        1. If ContainsExpression of |FormalParameterList| is *true*, return *true*.", "        1. Return ContainsExpression of |FormalParameter|."],
    "head": {
      "idx": 1,
      "methodName": "ContainsExpression",
      "prod": "FormalParameterList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FormalParameterList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "FormalParameter",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-containsexpression",
    "rawBody": "{\n  0:(0) access __x0__ = (FormalParameterList \"ContainsExpression\")\n  0:if (= __x0__ true) return true else 0:{}\n  1:(1) access __x1__ = (FormalParameter \"ContainsExpression\")\n  1:return __x1__\n}"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "ContainsExpression",
      "prod": "ArrowParameters",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-containsexpression",
    "rawBody": "return false"
  }, {
    "code": ["        1. Let _formals_ be CoveredFormalsList of |CoverParenthesizedExpressionAndArrowParameterList|.", "        1. Return ContainsExpression of _formals_."],
    "head": {
      "idx": 1,
      "methodName": "ContainsExpression",
      "prod": "ArrowParameters",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CoverParenthesizedExpressionAndArrowParameterList",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-containsexpression",
    "rawBody": "{\n  0:(0) access __x0__ = (CoverParenthesizedExpressionAndArrowParameterList \"CoveredFormalsList\")\n  0:let formals = __x0__\n  1:(1) access __x1__ = (formals \"ContainsExpression\")\n  1:return __x1__\n}"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "ContainsExpression",
      "prod": "AsyncArrowBindingIdentifier",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-containsexpression",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsSimpleParameterList",
      "prod": "BindingElement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingPattern",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-issimpleparameterlist",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsSimpleParameterList",
      "prod": "BindingElement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingPattern",
          "optional": false
        }, {
          "args": [],
          "name": "Initializer",
          "optional": false
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-issimpleparameterlist",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *true*."],
    "head": {
      "idx": 0,
      "methodName": "IsSimpleParameterList",
      "prod": "SingleNameBinding",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-issimpleparameterlist",
    "rawBody": "return true"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "IsSimpleParameterList",
      "prod": "SingleNameBinding",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "args": [],
          "name": "Initializer",
          "optional": false
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-issimpleparameterlist",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *true*."],
    "head": {
      "idx": 0,
      "methodName": "IsSimpleParameterList",
      "prod": "FormalParameters",
      "rhs": {
        "tokens": [{
          "empty": null
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-issimpleparameterlist",
    "rawBody": "return true"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsSimpleParameterList",
      "prod": "FormalParameters",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FunctionRestParameter",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-issimpleparameterlist",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 4,
      "methodName": "IsSimpleParameterList",
      "prod": "FormalParameters",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FormalParameterList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "FunctionRestParameter",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-issimpleparameterlist",
    "rawBody": "return false"
  }, {
    "code": ["        1. If IsSimpleParameterList of |FormalParameterList| is *false*, return *false*.", "        1. Return IsSimpleParameterList of |FormalParameter|."],
    "head": {
      "idx": 1,
      "methodName": "IsSimpleParameterList",
      "prod": "FormalParameterList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FormalParameterList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "FormalParameter",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-issimpleparameterlist",
    "rawBody": "{\n  0:(0) access __x0__ = (FormalParameterList \"IsSimpleParameterList\")\n  0:if (= __x0__ false) return false else 0:{}\n  1:(1) access __x1__ = (FormalParameter \"IsSimpleParameterList\")\n  1:return __x1__\n}"
  }, {
    "code": ["        1. Return IsSimpleParameterList of |BindingElement|."],
    "head": {
      "idx": 0,
      "methodName": "IsSimpleParameterList",
      "prod": "FormalParameter",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingElement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-issimpleparameterlist",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingElement \"IsSimpleParameterList\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return *true*."],
    "head": {
      "idx": 0,
      "methodName": "IsSimpleParameterList",
      "prod": "ArrowParameters",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-issimpleparameterlist",
    "rawBody": "return true"
  }, {
    "code": ["        1. Let _formals_ be CoveredFormalsList of |CoverParenthesizedExpressionAndArrowParameterList|.", "        1. Return IsSimpleParameterList of _formals_."],
    "head": {
      "idx": 1,
      "methodName": "IsSimpleParameterList",
      "prod": "ArrowParameters",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CoverParenthesizedExpressionAndArrowParameterList",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-issimpleparameterlist",
    "rawBody": "{\n  0:(0) access __x0__ = (CoverParenthesizedExpressionAndArrowParameterList \"CoveredFormalsList\")\n  0:let formals = __x0__\n  1:(1) access __x1__ = (formals \"IsSimpleParameterList\")\n  1:return __x1__\n}"
  }, {
    "code": ["        1. Return *true*."],
    "head": {
      "idx": 0,
      "methodName": "IsSimpleParameterList",
      "prod": "AsyncArrowBindingIdentifier",
      "rhs": {
        "tokens": [{
          "args": ["?Yield", "+Await"],
          "name": "BindingIdentifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-issimpleparameterlist",
    "rawBody": "return true"
  }, {
    "code": ["        1. Let _head_ be CoveredAsyncArrowHead of |CoverCallExpressionAndAsyncArrowHead|.", "        1. Return IsSimpleParameterList of _head_."],
    "head": {
      "idx": 0,
      "methodName": "IsSimpleParameterList",
      "prod": "CoverCallExpressionAndAsyncArrowHead",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "args": [],
          "name": "Arguments",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-issimpleparameterlist",
    "rawBody": "{\n  0:(0) access __x0__ = (CoverCallExpressionAndAsyncArrowHead \"CoveredAsyncArrowHead\")\n  0:let head = __x0__\n  1:(1) access __x1__ = (head \"IsSimpleParameterList\")\n  1:return __x1__\n}"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "HasInitializer",
      "prod": "BindingElement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingPattern",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-hasinitializer",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *true*."],
    "head": {
      "idx": 1,
      "methodName": "HasInitializer",
      "prod": "BindingElement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingPattern",
          "optional": false
        }, {
          "args": [],
          "name": "Initializer",
          "optional": false
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-hasinitializer",
    "rawBody": "return true"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "HasInitializer",
      "prod": "SingleNameBinding",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-hasinitializer",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *true*."],
    "head": {
      "idx": 0,
      "methodName": "HasInitializer",
      "prod": "SingleNameBinding",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "args": [],
          "name": "Initializer",
          "optional": false
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-hasinitializer",
    "rawBody": "return true"
  }, {
    "code": ["        1. If HasInitializer of |FormalParameterList| is *true*, return *true*.", "        1. Return HasInitializer of |FormalParameter|."],
    "head": {
      "idx": 1,
      "methodName": "HasInitializer",
      "prod": "FormalParameterList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FormalParameterList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "FormalParameter",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-hasinitializer",
    "rawBody": "{\n  0:(0) access __x0__ = (FormalParameterList \"HasInitializer\")\n  0:if (= __x0__ true) return true else 0:{}\n  1:(1) access __x1__ = (FormalParameter \"HasInitializer\")\n  1:return __x1__\n}"
  }, {
    "code": ["        1. Return 0."],
    "head": {
      "idx": 0,
      "methodName": "ExpectedArgumentCount",
      "prod": "FormalParameters",
      "rhs": {
        "tokens": [{
          "empty": null
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-expectedargumentcount",
    "rawBody": "return 0i"
  }, {
    "code": ["        1. Return 0."],
    "head": {
      "idx": 1,
      "methodName": "ExpectedArgumentCount",
      "prod": "FormalParameters",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FunctionRestParameter",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-expectedargumentcount",
    "rawBody": "return 0i"
  }, {
    "code": ["        1. Return ExpectedArgumentCount of |FormalParameterList|."],
    "head": {
      "idx": 4,
      "methodName": "ExpectedArgumentCount",
      "prod": "FormalParameters",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FormalParameterList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "FunctionRestParameter",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-expectedargumentcount",
    "rawBody": "{\n  0:(0) access __x0__ = (FormalParameterList \"ExpectedArgumentCount\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. If HasInitializer of |FormalParameter| is *true*, return 0.", "        1. Return 1."],
    "head": {
      "idx": 0,
      "methodName": "ExpectedArgumentCount",
      "prod": "FormalParameterList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FormalParameter",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-expectedargumentcount",
    "rawBody": "{\n  0:(0) access __x0__ = (FormalParameter \"HasInitializer\")\n  0:if (= __x0__ true) return 0i else 0:{}\n  1:return 1i\n}"
  }, {
    "code": ["        1. Let _count_ be ExpectedArgumentCount of |FormalParameterList|.", "        1. If HasInitializer of |FormalParameterList| is *true* or HasInitializer of |FormalParameter| is *true*, return _count_.", "        1. Return _count_ + 1."],
    "head": {
      "idx": 1,
      "methodName": "ExpectedArgumentCount",
      "prod": "FormalParameterList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FormalParameterList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "FormalParameter",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-expectedargumentcount",
    "rawBody": "{\n  0:(0) access __x0__ = (FormalParameterList \"ExpectedArgumentCount\")\n  0:let count = __x0__\n  1:let __x1__ = true\n  1:(1) access __x2__ = (FormalParameterList \"HasInitializer\")\n  1:__x1__ = (= __x2__ true)\n  1:if __x1__ 0:{} else {\n    (2) access __x3__ = (FormalParameter \"HasInitializer\")\n    __x1__ = (= __x3__ true)\n  }\n  1:if __x1__ return count else 0:{}\n  2:return (+ count 1i)\n}"
  }, {
    "code": ["        1. Return 1."],
    "head": {
      "idx": 0,
      "methodName": "ExpectedArgumentCount",
      "prod": "ArrowParameters",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-expectedargumentcount",
    "rawBody": "return 1i"
  }, {
    "code": ["        1. Let _formals_ be CoveredFormalsList of |CoverParenthesizedExpressionAndArrowParameterList|.", "        1. Return ExpectedArgumentCount of _formals_."],
    "head": {
      "idx": 1,
      "methodName": "ExpectedArgumentCount",
      "prod": "ArrowParameters",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CoverParenthesizedExpressionAndArrowParameterList",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-expectedargumentcount",
    "rawBody": "{\n  0:(0) access __x0__ = (CoverParenthesizedExpressionAndArrowParameterList \"CoveredFormalsList\")\n  0:let formals = __x0__\n  1:(1) access __x1__ = (formals \"ExpectedArgumentCount\")\n  1:return __x1__\n}"
  }, {
    "code": ["        1. If HasInitializer of |FormalParameter| is *true*, return 0.", "        1. Return 1."],
    "head": {
      "idx": 0,
      "methodName": "ExpectedArgumentCount",
      "prod": "PropertySetParameterList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FormalParameter",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-expectedargumentcount",
    "rawBody": "{\n  0:(0) access __x0__ = (FormalParameter \"HasInitializer\")\n  0:if (= __x0__ true) return 0i else 0:{}\n  1:return 1i\n}"
  }, {
    "code": ["        1. Return 1."],
    "head": {
      "idx": 0,
      "methodName": "ExpectedArgumentCount",
      "prod": "AsyncArrowBindingIdentifier",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-expectedargumentcount",
    "rawBody": "return 1i"
  }, {
    "code": ["        1. If the Directive Prologue of |FunctionBody| contains a Use Strict Directive, return *true*; otherwise, return *false*."],
    "head": {
      "idx": 0,
      "methodName": "FunctionBodyContainsUseStrict",
      "prod": "FunctionBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FunctionStatementList",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-functionbodycontainsusestrict",
    "rawBody": "(0) ??? \"If the Directive Prologue of nt:{FunctionBody} contains a Use Strict Directive , return value:{true} ; otherwise , return value:{false} .\""
  }, {
    "code": ["        1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).", "        1. Return the result of evaluating |FunctionStatementList|."],
    "head": {
      "idx": 0,
      "methodName": "EvaluateFunctionBody",
      "prod": "FunctionBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FunctionStatementList",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "functionObject"
      }, {
        "kind": "Normal",
        "name": "argumentsList"
      }]
    },
    "ids": "sec-runtime-semantics-evaluatefunctionbody",
    "rawBody": "{\n  0:(0) app __x0__ = (FunctionDeclarationInstantiation functionObject argumentsList)\n  0:[? __x0__]\n  1:(1) access __x1__ = (FunctionStatementList \"Evaluation\")\n  1:return __x1__\n}"
  }, {
    "code": ["        1. Let _name_ be StringValue of |BindingIdentifier|.", "        1. Let _sourceText_ be the source text matched by |FunctionDeclaration|.", "        1. Let _F_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _scope_).", "        1. Perform SetFunctionName(_F_, _name_).", "        1. Perform MakeConstructor(_F_).", "        1. Return _F_."],
    "head": {
      "idx": 0,
      "methodName": "InstantiateOrdinaryFunctionObject",
      "prod": "FunctionDeclaration",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "scope"
      }]
    },
    "ids": "sec-runtime-semantics-instantiateordinaryfunctionobject",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingIdentifier \"StringValue\")\n  0:let name = __x0__\n  1:let sourceText = (get-syntax FunctionDeclaration)\n  2:(1) app __x1__ = (OrdinaryFunctionCreate INTRINSIC_Function_prototype sourceText FormalParameters FunctionBody CONST_nonDASHlexicalDASHthis scope)\n  2:let F = __x1__\n  3:(2) app __x2__ = (SetFunctionName F name)\n  3:__x2__\n  4:(3) app __x3__ = (MakeConstructor F)\n  4:__x3__\n  5:return F\n}"
  }, {
    "code": ["        1. Let _sourceText_ be the source text matched by |FunctionDeclaration|.", "        1. Let _F_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _scope_).", "        1. Perform SetFunctionName(_F_, *\"default\"*).", "        1. Perform MakeConstructor(_F_).", "        1. Return _F_."],
    "head": {
      "idx": 1,
      "methodName": "InstantiateOrdinaryFunctionObject",
      "prod": "FunctionDeclaration",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "scope"
      }]
    },
    "ids": "sec-runtime-semantics-instantiateordinaryfunctionobject",
    "rawBody": "{\n  0:let sourceText = (get-syntax FunctionDeclaration)\n  1:(0) app __x0__ = (OrdinaryFunctionCreate INTRINSIC_Function_prototype sourceText FormalParameters FunctionBody CONST_nonDASHlexicalDASHthis scope)\n  1:let F = __x0__\n  2:(1) app __x1__ = (SetFunctionName F \"default\")\n  2:__x1__\n  3:(2) app __x2__ = (MakeConstructor F)\n  3:__x2__\n  4:return F\n}"
  }, {
    "code": ["        1. If _name_ is not present, set _name_ to *\"\"*.", "        1. Let _scope_ be the LexicalEnvironment of the running execution context.", "        1. Let _sourceText_ be the source text matched by |FunctionExpression|.", "        1. Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _scope_).", "        1. Perform SetFunctionName(_closure_, _name_).", "        1. Perform MakeConstructor(_closure_).", "        1. Return _closure_."],
    "head": {
      "idx": 0,
      "methodName": "InstantiateOrdinaryFunctionExpression",
      "prod": "FunctionExpression",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Optional",
        "name": "name"
      }]
    },
    "ids": "sec-runtime-semantics-instantiateordinaryfunctionexpression",
    "rawBody": "{\n  0:if (= name absent) name = \"\" else 0:{}\n  1:(0) access __x0__ = (CONTEXT \"LexicalEnvironment\")\n  1:let scope = __x0__\n  2:let sourceText = (get-syntax FunctionExpression)\n  3:(1) app __x1__ = (OrdinaryFunctionCreate INTRINSIC_Function_prototype sourceText FormalParameters FunctionBody CONST_nonDASHlexicalDASHthis scope)\n  3:let closure = __x1__\n  4:(2) app __x2__ = (SetFunctionName closure name)\n  4:__x2__\n  5:(3) app __x3__ = (MakeConstructor closure)\n  5:__x3__\n  6:return closure\n}"
  }, {
    "code": ["        1. Assert: _name_ is not present.", "        1. Set _name_ to StringValue of |BindingIdentifier|.", "        1. Let _scope_ be the running execution context's LexicalEnvironment.", "        1. Let _funcEnv_ be NewDeclarativeEnvironment(_scope_).", "        1. Perform _funcEnv_.CreateImmutableBinding(_name_, *false*).", "        1. Let _sourceText_ be the source text matched by |FunctionExpression|.", "        1. Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _funcEnv_).", "        1. Perform SetFunctionName(_closure_, _name_).", "        1. Perform MakeConstructor(_closure_).", "        1. Perform _funcEnv_.InitializeBinding(_name_, _closure_).", "        1. Return _closure_."],
    "head": {
      "idx": 0,
      "methodName": "InstantiateOrdinaryFunctionExpression",
      "prod": "FunctionExpression",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Optional",
        "name": "name"
      }]
    },
    "ids": "sec-runtime-semantics-instantiateordinaryfunctionexpression",
    "rawBody": "{\n  0:assert (= name absent)\n  1:(0) access __x0__ = (BindingIdentifier \"StringValue\")\n  1:name = __x0__\n  2:let scope = CONTEXT[\"LexicalEnvironment\"]\n  3:(1) app __x1__ = (NewDeclarativeEnvironment scope)\n  3:let funcEnv = __x1__\n  4:(2) app __x2__ = (funcEnv[\"CreateImmutableBinding\"] funcEnv name false)\n  4:__x2__\n  5:let sourceText = (get-syntax FunctionExpression)\n  6:(3) app __x3__ = (OrdinaryFunctionCreate INTRINSIC_Function_prototype sourceText FormalParameters FunctionBody CONST_nonDASHlexicalDASHthis funcEnv)\n  6:let closure = __x3__\n  7:(4) app __x4__ = (SetFunctionName closure name)\n  7:__x4__\n  8:(5) app __x5__ = (MakeConstructor closure)\n  8:__x5__\n  9:(6) app __x6__ = (funcEnv[\"InitializeBinding\"] funcEnv name closure)\n  9:__x6__\n  10:return closure\n}"
  }, {
    "code": ["        1. Return NormalCompletion(~empty~)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "FunctionDeclaration",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-function-definitions-runtime-semantics-evaluation",
    "rawBody": "return CONST_empty"
  }, {
    "code": ["        1. Return NormalCompletion(~empty~)."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "FunctionDeclaration",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-function-definitions-runtime-semantics-evaluation",
    "rawBody": "return CONST_empty"
  }, {
    "code": ["        1. Return InstantiateOrdinaryFunctionExpression of |FunctionExpression|."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "FunctionExpression",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": true
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-function-definitions-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (FunctionExpression \"InstantiateOrdinaryFunctionExpression\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return NormalCompletion(*undefined*)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "FunctionStatementList",
      "rhs": {
        "tokens": [{
          "empty": null
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-function-definitions-runtime-semantics-evaluation",
    "rawBody": "return undefined"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "ConciseBodyContainsUseStrict",
      "prod": "ConciseBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExpressionBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-concisebodycontainsusestrict",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return FunctionBodyContainsUseStrict of |FunctionBody|."],
    "head": {
      "idx": 1,
      "methodName": "ConciseBodyContainsUseStrict",
      "prod": "ConciseBody",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-concisebodycontainsusestrict",
    "rawBody": "{\n  0:(0) access __x0__ = (FunctionBody \"FunctionBodyContainsUseStrict\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return this |ArrowParameters|."],
    "head": {
      "idx": 0,
      "methodName": "CoveredFormalsList",
      "prod": "ArrowParameters",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-coveredformalslist",
    "rawBody": "return this"
  }, {
    "code": ["        1. Return the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|."],
    "head": {
      "idx": 0,
      "methodName": "CoveredFormalsList",
      "prod": "CoverParenthesizedExpressionAndArrowParameterList",
      "rhs": {
        "tokens": [{
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-coveredformalslist",
    "rawBody": "return (parse-syntax CoverParenthesizedExpressionAndArrowParameterList \"ArrowFormalParameters\" (0) (new []))"
  }, {
    "code": ["        1. Return the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|."],
    "head": {
      "idx": 1,
      "methodName": "CoveredFormalsList",
      "prod": "CoverParenthesizedExpressionAndArrowParameterList",
      "rhs": {
        "tokens": [{
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ","
        }, {
          "term": ")"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-coveredformalslist",
    "rawBody": "return (parse-syntax CoverParenthesizedExpressionAndArrowParameterList \"ArrowFormalParameters\" (0) (new []))"
  }, {
    "code": ["        1. Return the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|."],
    "head": {
      "idx": 2,
      "methodName": "CoveredFormalsList",
      "prod": "CoverParenthesizedExpressionAndArrowParameterList",
      "rhs": {
        "tokens": [{
          "term": "("
        }, {
          "term": ")"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-coveredformalslist",
    "rawBody": "return (parse-syntax CoverParenthesizedExpressionAndArrowParameterList \"ArrowFormalParameters\" (0) (new []))"
  }, {
    "code": ["        1. Return the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|."],
    "head": {
      "idx": 3,
      "methodName": "CoveredFormalsList",
      "prod": "CoverParenthesizedExpressionAndArrowParameterList",
      "rhs": {
        "tokens": [{
          "term": "("
        }, {
          "term": "..."
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": ")"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-coveredformalslist",
    "rawBody": "return (parse-syntax CoverParenthesizedExpressionAndArrowParameterList \"ArrowFormalParameters\" (0) (new []))"
  }, {
    "code": ["        1. Return the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|."],
    "head": {
      "idx": 4,
      "methodName": "CoveredFormalsList",
      "prod": "CoverParenthesizedExpressionAndArrowParameterList",
      "rhs": {
        "tokens": [{
          "term": "("
        }, {
          "term": "..."
        }, {
          "args": [],
          "name": "BindingPattern",
          "optional": false
        }, {
          "term": ")"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-coveredformalslist",
    "rawBody": "return (parse-syntax CoverParenthesizedExpressionAndArrowParameterList \"ArrowFormalParameters\" (0) (new []))"
  }, {
    "code": ["        1. Return the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|."],
    "head": {
      "idx": 5,
      "methodName": "CoveredFormalsList",
      "prod": "CoverParenthesizedExpressionAndArrowParameterList",
      "rhs": {
        "tokens": [{
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ","
        }, {
          "term": "..."
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": ")"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-coveredformalslist",
    "rawBody": "return (parse-syntax CoverParenthesizedExpressionAndArrowParameterList \"ArrowFormalParameters\" (0) (new []))"
  }, {
    "code": ["        1. Return the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|."],
    "head": {
      "idx": 6,
      "methodName": "CoveredFormalsList",
      "prod": "CoverParenthesizedExpressionAndArrowParameterList",
      "rhs": {
        "tokens": [{
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ","
        }, {
          "term": "..."
        }, {
          "args": [],
          "name": "BindingPattern",
          "optional": false
        }, {
          "term": ")"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-coveredformalslist",
    "rawBody": "return (parse-syntax CoverParenthesizedExpressionAndArrowParameterList \"ArrowFormalParameters\" (0) (new []))"
  }, {
    "code": ["        1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).", "        1. Return the result of evaluating |ExpressionBody|."],
    "head": {
      "idx": 0,
      "methodName": "EvaluateConciseBody",
      "prod": "ConciseBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExpressionBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "functionObject"
      }, {
        "kind": "Normal",
        "name": "argumentsList"
      }]
    },
    "ids": "sec-runtime-semantics-evaluateconcisebody",
    "rawBody": "{\n  0:(0) app __x0__ = (FunctionDeclarationInstantiation functionObject argumentsList)\n  0:[? __x0__]\n  1:(1) access __x1__ = (ExpressionBody \"Evaluation\")\n  1:return __x1__\n}"
  }, {
    "code": ["        1. If _name_ is not present, set _name_ to *\"\"*.", "        1. Let _scope_ be the LexicalEnvironment of the running execution context.", "        1. Let _sourceText_ be the source text matched by |ArrowFunction|.", "        1. Let _parameters_ be CoveredFormalsList of |ArrowParameters|.", "        1. [id=\"step-arrowfunction-evaluation-functioncreate\"] Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, _parameters_, |ConciseBody|, ~lexical-this~, _scope_).", "        1. Perform SetFunctionName(_closure_, _name_).", "        1. Return _closure_."],
    "head": {
      "idx": 0,
      "methodName": "InstantiateArrowFunctionExpression",
      "prod": "ArrowFunction",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ArrowParameters",
          "optional": false
        }, {
          "term": "=>"
        }, {
          "args": [],
          "name": "ConciseBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Optional",
        "name": "name"
      }]
    },
    "ids": "sec-runtime-semantics-instantiatearrowfunctionexpression",
    "rawBody": "{\n  0:if (= name absent) name = \"\" else 0:{}\n  1:(0) access __x0__ = (CONTEXT \"LexicalEnvironment\")\n  1:let scope = __x0__\n  2:let sourceText = (get-syntax ArrowFunction)\n  3:(1) access __x1__ = (ArrowParameters \"CoveredFormalsList\")\n  3:let parameters = __x1__\n  4:(2) app __x2__ = (OrdinaryFunctionCreate INTRINSIC_Function_prototype sourceText parameters ConciseBody CONST_lexicalDASHthis scope)\n  4:let closure = __x2__\n  5:(3) app __x3__ = (SetFunctionName closure name)\n  5:__x3__\n  6:return closure\n}"
  }, {
    "code": ["        1. Return InstantiateArrowFunctionExpression of |ArrowFunction|."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "ArrowFunction",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ArrowParameters",
          "optional": false
        }, {
          "term": "=>"
        }, {
          "args": [],
          "name": "ConciseBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-arrow-function-definitions-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (ArrowFunction \"InstantiateArrowFunctionExpression\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Let _exprRef_ be the result of evaluating |AssignmentExpression|.", "        1. Let _exprValue_ be ? GetValue(_exprRef_).", "        1. Return Completion { [[Type]]: ~return~, [[Value]]: _exprValue_, [[Target]]: ~empty~ }."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "ExpressionBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-arrow-function-definitions-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (AssignmentExpression \"Evaluation\")\n  0:let exprRef = __x0__\n  1:(1) app __x1__ = (GetValue exprRef)\n  1:let exprValue = [? __x1__]\n  2:return (0) (new Completion(\"Type\" -> CONST_return, \"Value\" -> exprValue, \"Target\" -> CONST_empty))\n}"
  }, {
    "code": ["        1. If |UniqueFormalParameters| Contains |SuperCall| is *true*, return *true*.", "        1. Return |FunctionBody| Contains |SuperCall|."],
    "head": {
      "idx": 0,
      "methodName": "HasDirectSuper",
      "prod": "MethodDefinition",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-hasdirectsuper",
    "rawBody": "{\n  0:(0) access __x0__ = (UniqueFormalParameters \"Contains\" \"SuperCall\")\n  0:if (= __x0__ true) return true else 0:{}\n  1:(1) access __x1__ = (FunctionBody \"Contains\" \"SuperCall\")\n  1:return __x1__\n}"
  }, {
    "code": ["        1. Return |FunctionBody| Contains |SuperCall|."],
    "head": {
      "idx": 4,
      "methodName": "HasDirectSuper",
      "prod": "MethodDefinition",
      "rhs": {
        "tokens": [{
          "term": "get"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-hasdirectsuper",
    "rawBody": "{\n  0:(0) access __x0__ = (FunctionBody \"Contains\" \"SuperCall\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. If |PropertySetParameterList| Contains |SuperCall| is *true*, return *true*.", "        1. Return |FunctionBody| Contains |SuperCall|."],
    "head": {
      "idx": 5,
      "methodName": "HasDirectSuper",
      "prod": "MethodDefinition",
      "rhs": {
        "tokens": [{
          "term": "set"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "PropertySetParameterList",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-hasdirectsuper",
    "rawBody": "{\n  0:(0) access __x0__ = (PropertySetParameterList \"Contains\" \"SuperCall\")\n  0:if (= __x0__ true) return true else 0:{}\n  1:(1) access __x1__ = (FunctionBody \"Contains\" \"SuperCall\")\n  1:return __x1__\n}"
  }, {
    "code": ["        1. If |UniqueFormalParameters| Contains |SuperCall| is *true*, return *true*.", "        1. Return |GeneratorBody| Contains |SuperCall|."],
    "head": {
      "idx": 0,
      "methodName": "HasDirectSuper",
      "prod": "GeneratorMethod",
      "rhs": {
        "tokens": [{
          "term": "*"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-hasdirectsuper",
    "rawBody": "{\n  0:(0) access __x0__ = (UniqueFormalParameters \"Contains\" \"SuperCall\")\n  0:if (= __x0__ true) return true else 0:{}\n  1:(1) access __x1__ = (GeneratorBody \"Contains\" \"SuperCall\")\n  1:return __x1__\n}"
  }, {
    "code": ["        1. If |UniqueFormalParameters| Contains |SuperCall| is *true*, return *true*.", "        1. Return |AsyncGeneratorBody| Contains |SuperCall|."],
    "head": {
      "idx": 0,
      "methodName": "HasDirectSuper",
      "prod": "AsyncGeneratorMethod",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-hasdirectsuper",
    "rawBody": "{\n  0:(0) access __x0__ = (UniqueFormalParameters \"Contains\" \"SuperCall\")\n  0:if (= __x0__ true) return true else 0:{}\n  1:(1) access __x1__ = (AsyncGeneratorBody \"Contains\" \"SuperCall\")\n  1:return __x1__\n}"
  }, {
    "code": ["        1. If |UniqueFormalParameters| Contains |SuperCall| is *true*, return *true*.", "        1. Return |AsyncFunctionBody| Contains |SuperCall|."],
    "head": {
      "idx": 0,
      "methodName": "HasDirectSuper",
      "prod": "AsyncMethod",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-hasdirectsuper",
    "rawBody": "{\n  0:(0) access __x0__ = (UniqueFormalParameters \"Contains\" \"SuperCall\")\n  0:if (= __x0__ true) return true else 0:{}\n  1:(1) access __x1__ = (AsyncFunctionBody \"Contains\" \"SuperCall\")\n  1:return __x1__\n}"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "SpecialMethod",
      "prod": "MethodDefinition",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-specialmethod",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *true*."],
    "head": {
      "idx": 1,
      "methodName": "SpecialMethod",
      "prod": "MethodDefinition",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "GeneratorMethod",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-specialmethod",
    "rawBody": "return true"
  }, {
    "code": ["        1. Return *true*."],
    "head": {
      "idx": 2,
      "methodName": "SpecialMethod",
      "prod": "MethodDefinition",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AsyncMethod",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-specialmethod",
    "rawBody": "return true"
  }, {
    "code": ["        1. Return *true*."],
    "head": {
      "idx": 3,
      "methodName": "SpecialMethod",
      "prod": "MethodDefinition",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AsyncGeneratorMethod",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-specialmethod",
    "rawBody": "return true"
  }, {
    "code": ["        1. Return *true*."],
    "head": {
      "idx": 4,
      "methodName": "SpecialMethod",
      "prod": "MethodDefinition",
      "rhs": {
        "tokens": [{
          "term": "get"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-specialmethod",
    "rawBody": "return true"
  }, {
    "code": ["        1. Return *true*."],
    "head": {
      "idx": 5,
      "methodName": "SpecialMethod",
      "prod": "MethodDefinition",
      "rhs": {
        "tokens": [{
          "term": "set"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "PropertySetParameterList",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-specialmethod",
    "rawBody": "return true"
  }, {
    "code": ["        1. Let _propKey_ be the result of evaluating |PropertyName|.", "        1. ReturnIfAbrupt(_propKey_).", "        1. Let _scope_ be the running execution context's LexicalEnvironment.", "        1. If _functionPrototype_ is present, then", "          1. Let _prototype_ be _functionPrototype_.", "        1. Else,", "          1. Let _prototype_ be %Function.prototype%.", "        1. Let _sourceText_ be the source text matched by |MethodDefinition|.", "        1. Let _closure_ be OrdinaryFunctionCreate(_prototype_, _sourceText_, |UniqueFormalParameters|, |FunctionBody|, ~non-lexical-this~, _scope_).", "        1. Perform MakeMethod(_closure_, _object_).", "        1. Return the Record { [[Key]]: _propKey_, [[Closure]]: _closure_ }."],
    "head": {
      "idx": 0,
      "methodName": "DefineMethod",
      "prod": "MethodDefinition",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "object"
      }, {
        "kind": "Optional",
        "name": "functionPrototype"
      }]
    },
    "ids": "sec-runtime-semantics-definemethod",
    "rawBody": "{\n  0:(0) access __x0__ = (PropertyName \"Evaluation\")\n  0:let propKey = __x0__\n  1:[? propKey]\n  2:let scope = CONTEXT[\"LexicalEnvironment\"]\n  5:if (! (= functionPrototype absent)) let prototype = functionPrototype else let prototype = INTRINSIC_Function_prototype\n  7:let sourceText = (get-syntax MethodDefinition)\n  8:(1) app __x1__ = (OrdinaryFunctionCreate prototype sourceText UniqueFormalParameters FunctionBody CONST_nonDASHlexicalDASHthis scope)\n  8:let closure = __x1__\n  9:(2) app __x2__ = (MakeMethod closure object)\n  9:__x2__\n  10:return (0) (new Record(\"Key\" -> propKey, \"Closure\" -> closure))\n}"
  }, {
    "code": ["        1. Let _methodDef_ be ? DefineMethod of |MethodDefinition| with argument _object_.", "        1. Perform SetFunctionName(_methodDef_.[[Closure]], _methodDef_.[[Key]]).", "        1. Let _desc_ be the PropertyDescriptor { [[Value]]: _methodDef_.[[Closure]], [[Writable]]: *true*, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.", "        1. Return ? DefinePropertyOrThrow(_object_, _methodDef_.[[Key]], _desc_)."],
    "head": {
      "idx": 0,
      "methodName": "MethodDefinitionEvaluation",
      "prod": "MethodDefinition",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "object"
      }, {
        "kind": "Normal",
        "name": "enumerable"
      }]
    },
    "ids": "sec-runtime-semantics-methoddefinitionevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (MethodDefinition \"DefineMethod\" object)\n  0:let methodDef = [? __x0__]\n  1:(1) app __x1__ = (SetFunctionName methodDef[\"Closure\"] methodDef[\"Key\"])\n  1:__x1__\n  2:let desc = (0) (new PropertyDescriptor(\"Value\" -> methodDef[\"Closure\"], \"Writable\" -> true, \"Enumerable\" -> enumerable, \"Configurable\" -> true))\n  3:(2) app __x2__ = (DefinePropertyOrThrow object methodDef[\"Key\"] desc)\n  3:return [? __x2__]\n}"
  }, {
    "code": ["        1. Let _propKey_ be the result of evaluating |PropertyName|.", "        1. ReturnIfAbrupt(_propKey_).", "        1. Let _scope_ be the running execution context's LexicalEnvironment.", "        1. Let _sourceText_ be the source text matched by |MethodDefinition|.", "        1. Let _formalParameterList_ be an instance of the production <emu-grammar>FormalParameters : [empty]</emu-grammar>.", "        1. Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, _formalParameterList_, |FunctionBody|, ~non-lexical-this~, _scope_).", "        1. Perform MakeMethod(_closure_, _object_).", "        1. Perform SetFunctionName(_closure_, _propKey_, *\"get\"*).", "        1. Let _desc_ be the PropertyDescriptor { [[Get]]: _closure_, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.", "        1. Return ? DefinePropertyOrThrow(_object_, _propKey_, _desc_)."],
    "head": {
      "idx": 4,
      "methodName": "MethodDefinitionEvaluation",
      "prod": "MethodDefinition",
      "rhs": {
        "tokens": [{
          "term": "get"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "object"
      }, {
        "kind": "Normal",
        "name": "enumerable"
      }]
    },
    "ids": "sec-runtime-semantics-methoddefinitionevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (PropertyName \"Evaluation\")\n  0:let propKey = __x0__\n  1:[? propKey]\n  2:let scope = CONTEXT[\"LexicalEnvironment\"]\n  3:let sourceText = (get-syntax MethodDefinition)\n  4:(0) ??? \"Let id:{formalParameterList} be an instance of the production grammar:{FormalParameters0, []} .\"\n  5:(1) app __x1__ = (OrdinaryFunctionCreate INTRINSIC_Function_prototype sourceText formalParameterList FunctionBody CONST_nonDASHlexicalDASHthis scope)\n  5:let closure = __x1__\n  6:(2) app __x2__ = (MakeMethod closure object)\n  6:__x2__\n  7:(3) app __x3__ = (SetFunctionName closure propKey \"get\")\n  7:__x3__\n  8:let desc = (1) (new PropertyDescriptor(\"Get\" -> closure, \"Enumerable\" -> enumerable, \"Configurable\" -> true))\n  9:(4) app __x4__ = (DefinePropertyOrThrow object propKey desc)\n  9:return [? __x4__]\n}"
  }, {
    "code": ["        1. Let _propKey_ be the result of evaluating |PropertyName|.", "        1. ReturnIfAbrupt(_propKey_).", "        1. Let _scope_ be the running execution context's LexicalEnvironment.", "        1. Let _sourceText_ be the source text matched by |MethodDefinition|.", "        1. Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |PropertySetParameterList|, |FunctionBody|, ~non-lexical-this~, _scope_).", "        1. Perform MakeMethod(_closure_, _object_).", "        1. Perform SetFunctionName(_closure_, _propKey_, *\"set\"*).", "        1. Let _desc_ be the PropertyDescriptor { [[Set]]: _closure_, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.", "        1. Return ? DefinePropertyOrThrow(_object_, _propKey_, _desc_)."],
    "head": {
      "idx": 5,
      "methodName": "MethodDefinitionEvaluation",
      "prod": "MethodDefinition",
      "rhs": {
        "tokens": [{
          "term": "set"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "PropertySetParameterList",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "object"
      }, {
        "kind": "Normal",
        "name": "enumerable"
      }]
    },
    "ids": "sec-runtime-semantics-methoddefinitionevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (PropertyName \"Evaluation\")\n  0:let propKey = __x0__\n  1:[? propKey]\n  2:let scope = CONTEXT[\"LexicalEnvironment\"]\n  3:let sourceText = (get-syntax MethodDefinition)\n  4:(1) app __x1__ = (OrdinaryFunctionCreate INTRINSIC_Function_prototype sourceText PropertySetParameterList FunctionBody CONST_nonDASHlexicalDASHthis scope)\n  4:let closure = __x1__\n  5:(2) app __x2__ = (MakeMethod closure object)\n  5:__x2__\n  6:(3) app __x3__ = (SetFunctionName closure propKey \"set\")\n  6:__x3__\n  7:let desc = (0) (new PropertyDescriptor(\"Set\" -> closure, \"Enumerable\" -> enumerable, \"Configurable\" -> true))\n  8:(4) app __x4__ = (DefinePropertyOrThrow object propKey desc)\n  8:return [? __x4__]\n}"
  }, {
    "code": ["        1. Let _propKey_ be the result of evaluating |PropertyName|.", "        1. ReturnIfAbrupt(_propKey_).", "        1. Let _scope_ be the running execution context's LexicalEnvironment.", "        1. Let _sourceText_ be the source text matched by |GeneratorMethod|.", "        1. Let _closure_ be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |UniqueFormalParameters|, |GeneratorBody|, ~non-lexical-this~, _scope_).", "        1. Perform MakeMethod(_closure_, _object_).", "        1. Perform SetFunctionName(_closure_, _propKey_).", "        1. Let _prototype_ be ! OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).", "        1. Perform DefinePropertyOrThrow(_closure_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).", "        1. Let _desc_ be the PropertyDescriptor { [[Value]]: _closure_, [[Writable]]: *true*, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.", "        1. Return ? DefinePropertyOrThrow(_object_, _propKey_, _desc_)."],
    "head": {
      "idx": 0,
      "methodName": "MethodDefinitionEvaluation",
      "prod": "GeneratorMethod",
      "rhs": {
        "tokens": [{
          "term": "*"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "object"
      }, {
        "kind": "Normal",
        "name": "enumerable"
      }]
    },
    "ids": "sec-runtime-semantics-methoddefinitionevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (PropertyName \"Evaluation\")\n  0:let propKey = __x0__\n  1:[? propKey]\n  2:let scope = CONTEXT[\"LexicalEnvironment\"]\n  3:let sourceText = (get-syntax GeneratorMethod)\n  4:(1) app __x1__ = (OrdinaryFunctionCreate INTRINSIC_GeneratorFunction_prototype sourceText UniqueFormalParameters GeneratorBody CONST_nonDASHlexicalDASHthis scope)\n  4:let closure = __x1__\n  5:(2) app __x2__ = (MakeMethod closure object)\n  5:__x2__\n  6:(3) app __x3__ = (SetFunctionName closure propKey)\n  6:__x3__\n  7:(4) app __x4__ = (OrdinaryObjectCreate INTRINSIC_GeneratorFunction_prototype_prototype)\n  7:let prototype = [! __x4__]\n  8:(5) app __x5__ = (DefinePropertyOrThrow closure \"prototype\" (0) (new PropertyDescriptor(\"Value\" -> prototype, \"Writable\" -> true, \"Enumerable\" -> false, \"Configurable\" -> false)))\n  8:__x5__\n  9:let desc = (1) (new PropertyDescriptor(\"Value\" -> closure, \"Writable\" -> true, \"Enumerable\" -> enumerable, \"Configurable\" -> true))\n  10:(6) app __x6__ = (DefinePropertyOrThrow object propKey desc)\n  10:return [? __x6__]\n}"
  }, {
    "code": ["        1. Let _propKey_ be the result of evaluating |PropertyName|.", "        1. ReturnIfAbrupt(_propKey_).", "        1. Let _scope_ be the running execution context's LexicalEnvironment.", "        1. Let _sourceText_ be the source text matched by |AsyncGeneratorMethod|.", "        1. Let _closure_ be ! OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |UniqueFormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _scope_).", "        1. Perform ! MakeMethod(_closure_, _object_).", "        1. Perform ! SetFunctionName(_closure_, _propKey_).", "        1. Let _prototype_ be ! OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).", "        1. Perform ! DefinePropertyOrThrow(_closure_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).", "        1. Let _desc_ be PropertyDescriptor { [[Value]]: _closure_, [[Writable]]: *true*, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.", "        1. Return ? DefinePropertyOrThrow(_object_, _propKey_, _desc_)."],
    "head": {
      "idx": 0,
      "methodName": "MethodDefinitionEvaluation",
      "prod": "AsyncGeneratorMethod",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "object"
      }, {
        "kind": "Normal",
        "name": "enumerable"
      }]
    },
    "ids": "sec-runtime-semantics-methoddefinitionevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (PropertyName \"Evaluation\")\n  0:let propKey = __x0__\n  1:[? propKey]\n  2:let scope = CONTEXT[\"LexicalEnvironment\"]\n  3:let sourceText = (get-syntax AsyncGeneratorMethod)\n  4:(1) app __x1__ = (OrdinaryFunctionCreate INTRINSIC_AsyncGeneratorFunction_prototype sourceText UniqueFormalParameters AsyncGeneratorBody CONST_nonDASHlexicalDASHthis scope)\n  4:let closure = [! __x1__]\n  5:(2) app __x2__ = (MakeMethod closure object)\n  5:[! __x2__]\n  6:(3) app __x3__ = (SetFunctionName closure propKey)\n  6:[! __x3__]\n  7:(4) app __x4__ = (OrdinaryObjectCreate INTRINSIC_AsyncGeneratorFunction_prototype_prototype)\n  7:let prototype = [! __x4__]\n  8:(5) app __x5__ = (DefinePropertyOrThrow closure \"prototype\" (0) (new PropertyDescriptor(\"Value\" -> prototype, \"Writable\" -> true, \"Enumerable\" -> false, \"Configurable\" -> false)))\n  8:[! __x5__]\n  9:let desc = (1) (new PropertyDescriptor(\"Value\" -> closure, \"Writable\" -> true, \"Enumerable\" -> enumerable, \"Configurable\" -> true))\n  10:(6) app __x6__ = (DefinePropertyOrThrow object propKey desc)\n  10:return [? __x6__]\n}"
  }, {
    "code": ["        1. Let _propKey_ be the result of evaluating |PropertyName|.", "        1. ReturnIfAbrupt(_propKey_).", "        1. Let _scope_ be the LexicalEnvironment of the running execution context.", "        1. Let _sourceText_ be the source text matched by |AsyncMethod|.", "        1. Let _closure_ be ! OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |UniqueFormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _scope_).", "        1. Perform ! MakeMethod(_closure_, _object_).", "        1. Perform ! SetFunctionName(_closure_, _propKey_).", "        1. Let _desc_ be the PropertyDescriptor { [[Value]]: _closure_, [[Writable]]: *true*, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.", "        1. Return ? DefinePropertyOrThrow(_object_, _propKey_, _desc_)."],
    "head": {
      "idx": 0,
      "methodName": "MethodDefinitionEvaluation",
      "prod": "AsyncMethod",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "object"
      }, {
        "kind": "Normal",
        "name": "enumerable"
      }]
    },
    "ids": "sec-runtime-semantics-methoddefinitionevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (PropertyName \"Evaluation\")\n  0:let propKey = __x0__\n  1:[? propKey]\n  2:(1) access __x1__ = (CONTEXT \"LexicalEnvironment\")\n  2:let scope = __x1__\n  3:let sourceText = (get-syntax AsyncMethod)\n  4:(2) app __x2__ = (OrdinaryFunctionCreate INTRINSIC_AsyncFunction_prototype sourceText UniqueFormalParameters AsyncFunctionBody CONST_nonDASHlexicalDASHthis scope)\n  4:let closure = [! __x2__]\n  5:(3) app __x3__ = (MakeMethod closure object)\n  5:[! __x3__]\n  6:(4) app __x4__ = (SetFunctionName closure propKey)\n  6:[! __x4__]\n  7:let desc = (0) (new PropertyDescriptor(\"Value\" -> closure, \"Writable\" -> true, \"Enumerable\" -> enumerable, \"Configurable\" -> true))\n  8:(5) app __x5__ = (DefinePropertyOrThrow object propKey desc)\n  8:return [? __x5__]\n}"
  }, {
    "code": ["        1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).", "        1. Let _G_ be ? OrdinaryCreateFromConstructor(_functionObject_, *\"%GeneratorFunction.prototype.prototype%\"*, « [[GeneratorState]], [[GeneratorContext]], [[GeneratorBrand]] »).", "        1. Set _G_.[[GeneratorBrand]] to ~empty~.", "        1. Perform GeneratorStart(_G_, |FunctionBody|).", "        1. Return Completion { [[Type]]: ~return~, [[Value]]: _G_, [[Target]]: ~empty~ }."],
    "head": {
      "idx": 0,
      "methodName": "EvaluateGeneratorBody",
      "prod": "GeneratorBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "functionObject"
      }, {
        "kind": "Normal",
        "name": "argumentsList"
      }]
    },
    "ids": "sec-runtime-semantics-evaluategeneratorbody",
    "rawBody": "{\n  0:(0) app __x0__ = (FunctionDeclarationInstantiation functionObject argumentsList)\n  0:[? __x0__]\n  1:(1) app __x1__ = (OrdinaryCreateFromConstructor functionObject \"%GeneratorFunction.prototype.prototype%\" (0) (new [\"GeneratorState\", \"GeneratorContext\", \"GeneratorBrand\"]))\n  1:let G = [? __x1__]\n  2:G[\"GeneratorBrand\"] = CONST_empty\n  3:(2) app __x2__ = (GeneratorStart G FunctionBody)\n  3:__x2__\n  4:return (1) (new Completion(\"Type\" -> CONST_return, \"Value\" -> G, \"Target\" -> CONST_empty))\n}"
  }, {
    "code": ["        1. Let _name_ be StringValue of |BindingIdentifier|.", "        1. Let _sourceText_ be the source text matched by |GeneratorDeclaration|.", "        1. Let _F_ be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _scope_).", "        1. Perform SetFunctionName(_F_, _name_).", "        1. Let _prototype_ be ! OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).", "        1. Perform DefinePropertyOrThrow(_F_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).", "        1. Return _F_."],
    "head": {
      "idx": 0,
      "methodName": "InstantiateGeneratorFunctionObject",
      "prod": "GeneratorDeclaration",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "scope"
      }]
    },
    "ids": "sec-runtime-semantics-instantiategeneratorfunctionobject",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingIdentifier \"StringValue\")\n  0:let name = __x0__\n  1:let sourceText = (get-syntax GeneratorDeclaration)\n  2:(1) app __x1__ = (OrdinaryFunctionCreate INTRINSIC_GeneratorFunction_prototype sourceText FormalParameters GeneratorBody CONST_nonDASHlexicalDASHthis scope)\n  2:let F = __x1__\n  3:(2) app __x2__ = (SetFunctionName F name)\n  3:__x2__\n  4:(3) app __x3__ = (OrdinaryObjectCreate INTRINSIC_GeneratorFunction_prototype_prototype)\n  4:let prototype = [! __x3__]\n  5:(4) app __x4__ = (DefinePropertyOrThrow F \"prototype\" (0) (new PropertyDescriptor(\"Value\" -> prototype, \"Writable\" -> true, \"Enumerable\" -> false, \"Configurable\" -> false)))\n  5:__x4__\n  6:return F\n}"
  }, {
    "code": ["        1. Let _sourceText_ be the source text matched by |GeneratorDeclaration|.", "        1. Let _F_ be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _scope_).", "        1. Perform SetFunctionName(_F_, *\"default\"*).", "        1. Let _prototype_ be ! OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).", "        1. Perform DefinePropertyOrThrow(_F_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).", "        1. Return _F_."],
    "head": {
      "idx": 1,
      "methodName": "InstantiateGeneratorFunctionObject",
      "prod": "GeneratorDeclaration",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "*"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "scope"
      }]
    },
    "ids": "sec-runtime-semantics-instantiategeneratorfunctionobject",
    "rawBody": "{\n  0:let sourceText = (get-syntax GeneratorDeclaration)\n  1:(0) app __x0__ = (OrdinaryFunctionCreate INTRINSIC_GeneratorFunction_prototype sourceText FormalParameters GeneratorBody CONST_nonDASHlexicalDASHthis scope)\n  1:let F = __x0__\n  2:(1) app __x1__ = (SetFunctionName F \"default\")\n  2:__x1__\n  3:(2) app __x2__ = (OrdinaryObjectCreate INTRINSIC_GeneratorFunction_prototype_prototype)\n  3:let prototype = [! __x2__]\n  4:(3) app __x3__ = (DefinePropertyOrThrow F \"prototype\" (0) (new PropertyDescriptor(\"Value\" -> prototype, \"Writable\" -> true, \"Enumerable\" -> false, \"Configurable\" -> false)))\n  4:__x3__\n  5:return F\n}"
  }, {
    "code": ["        1. If _name_ is not present, set _name_ to *\"\"*.", "        1. Let _scope_ be the LexicalEnvironment of the running execution context.", "        1. Let _sourceText_ be the source text matched by |GeneratorExpression|.", "        1. Let _closure_ be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _scope_).", "        1. Perform SetFunctionName(_closure_, _name_).", "        1. Let _prototype_ be ! OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).", "        1. Perform DefinePropertyOrThrow(_closure_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).", "        1. Return _closure_."],
    "head": {
      "idx": 0,
      "methodName": "InstantiateGeneratorFunctionExpression",
      "prod": "GeneratorExpression",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "*"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Optional",
        "name": "name"
      }]
    },
    "ids": "sec-runtime-semantics-instantiategeneratorfunctionexpression",
    "rawBody": "{\n  0:if (= name absent) name = \"\" else 0:{}\n  1:(0) access __x0__ = (CONTEXT \"LexicalEnvironment\")\n  1:let scope = __x0__\n  2:let sourceText = (get-syntax GeneratorExpression)\n  3:(1) app __x1__ = (OrdinaryFunctionCreate INTRINSIC_GeneratorFunction_prototype sourceText FormalParameters GeneratorBody CONST_nonDASHlexicalDASHthis scope)\n  3:let closure = __x1__\n  4:(2) app __x2__ = (SetFunctionName closure name)\n  4:__x2__\n  5:(3) app __x3__ = (OrdinaryObjectCreate INTRINSIC_GeneratorFunction_prototype_prototype)\n  5:let prototype = [! __x3__]\n  6:(4) app __x4__ = (DefinePropertyOrThrow closure \"prototype\" (0) (new PropertyDescriptor(\"Value\" -> prototype, \"Writable\" -> true, \"Enumerable\" -> false, \"Configurable\" -> false)))\n  6:__x4__\n  7:return closure\n}"
  }, {
    "code": ["        1. Assert: _name_ is not present.", "        1. Set _name_ to StringValue of |BindingIdentifier|.", "        1. Let _scope_ be the running execution context's LexicalEnvironment.", "        1. Let _funcEnv_ be NewDeclarativeEnvironment(_scope_).", "        1. Perform _funcEnv_.CreateImmutableBinding(_name_, *false*).", "        1. Let _sourceText_ be the source text matched by |GeneratorExpression|.", "        1. Let _closure_ be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _funcEnv_).", "        1. Perform SetFunctionName(_closure_, _name_).", "        1. Let _prototype_ be ! OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).", "        1. Perform DefinePropertyOrThrow(_closure_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).", "        1. Perform _funcEnv_.InitializeBinding(_name_, _closure_).", "        1. Return _closure_."],
    "head": {
      "idx": 0,
      "methodName": "InstantiateGeneratorFunctionExpression",
      "prod": "GeneratorExpression",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Optional",
        "name": "name"
      }]
    },
    "ids": "sec-runtime-semantics-instantiategeneratorfunctionexpression",
    "rawBody": "{\n  0:assert (= name absent)\n  1:(0) access __x0__ = (BindingIdentifier \"StringValue\")\n  1:name = __x0__\n  2:let scope = CONTEXT[\"LexicalEnvironment\"]\n  3:(1) app __x1__ = (NewDeclarativeEnvironment scope)\n  3:let funcEnv = __x1__\n  4:(2) app __x2__ = (funcEnv[\"CreateImmutableBinding\"] funcEnv name false)\n  4:__x2__\n  5:let sourceText = (get-syntax GeneratorExpression)\n  6:(3) app __x3__ = (OrdinaryFunctionCreate INTRINSIC_GeneratorFunction_prototype sourceText FormalParameters GeneratorBody CONST_nonDASHlexicalDASHthis funcEnv)\n  6:let closure = __x3__\n  7:(4) app __x4__ = (SetFunctionName closure name)\n  7:__x4__\n  8:(5) app __x5__ = (OrdinaryObjectCreate INTRINSIC_GeneratorFunction_prototype_prototype)\n  8:let prototype = [! __x5__]\n  9:(6) app __x6__ = (DefinePropertyOrThrow closure \"prototype\" (0) (new PropertyDescriptor(\"Value\" -> prototype, \"Writable\" -> true, \"Enumerable\" -> false, \"Configurable\" -> false)))\n  9:__x6__\n  10:(7) app __x7__ = (funcEnv[\"InitializeBinding\"] funcEnv name closure)\n  10:__x7__\n  11:return closure\n}"
  }, {
    "code": ["        1. Return InstantiateGeneratorFunctionExpression of |GeneratorExpression|."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "GeneratorExpression",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": true
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-generator-function-definitions-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (GeneratorExpression \"InstantiateGeneratorFunctionExpression\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return ? Yield(*undefined*)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "YieldExpression",
      "rhs": {
        "tokens": [{
          "term": "yield"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-generator-function-definitions-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (Yield undefined)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["        1. Let _exprRef_ be the result of evaluating |AssignmentExpression|.", "        1. Let _value_ be ? GetValue(_exprRef_).", "        1. Return ? Yield(_value_)."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "YieldExpression",
      "rhs": {
        "tokens": [{
          "term": "yield"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-generator-function-definitions-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (AssignmentExpression \"Evaluation\")\n  0:let exprRef = __x0__\n  1:(1) app __x1__ = (GetValue exprRef)\n  1:let value = [? __x1__]\n  2:(2) app __x2__ = (Yield value)\n  2:return [? __x2__]\n}"
  }, {
    "code": ["        1. Let _generatorKind_ be ! GetGeneratorKind().", "        1. Let _exprRef_ be the result of evaluating |AssignmentExpression|.", "        1. Let _value_ be ? GetValue(_exprRef_).", "        1. Let _iteratorRecord_ be ? GetIterator(_value_, _generatorKind_).", "        1. Let _iterator_ be _iteratorRecord_.[[Iterator]].", "        1. Let _received_ be NormalCompletion(*undefined*).", "        1. Repeat,", "          1. If _received_.[[Type]] is ~normal~, then", "            1. Let _innerResult_ be ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]], « _received_.[[Value]] »).", "            1. If _generatorKind_ is ~async~, set _innerResult_ to ? Await(_innerResult_).", "            1. If Type(_innerResult_) is not Object, throw a *TypeError* exception.", "            1. Let _done_ be ? IteratorComplete(_innerResult_).", "            1. If _done_ is *true*, then", "              1. Return ? IteratorValue(_innerResult_).", "            1. If _generatorKind_ is ~async~, set _received_ to AsyncGeneratorYield(? IteratorValue(_innerResult_)).", "            1. Else, set _received_ to GeneratorYield(_innerResult_).", "          1. Else if _received_.[[Type]] is ~throw~, then", "            1. Let _throw_ be ? GetMethod(_iterator_, *\"throw\"*).", "            1. If _throw_ is not *undefined*, then", "              1. Let _innerResult_ be ? Call(_throw_, _iterator_, « _received_.[[Value]] »).", "              1. If _generatorKind_ is ~async~, set _innerResult_ to ? Await(_innerResult_).", "              1. NOTE: Exceptions from the inner iterator `throw` method are propagated. Normal completions from an inner `throw` method are processed similarly to an inner `next`.", "              1. If Type(_innerResult_) is not Object, throw a *TypeError* exception.", "              1. Let _done_ be ? IteratorComplete(_innerResult_).", "              1. If _done_ is *true*, then", "                1. Return ? IteratorValue(_innerResult_).", "              1. If _generatorKind_ is ~async~, set _received_ to AsyncGeneratorYield(? IteratorValue(_innerResult_)).", "              1. Else, set _received_ to GeneratorYield(_innerResult_).", "            1. Else,", "              1. NOTE: If _iterator_ does not have a `throw` method, this throw is going to terminate the `yield*` loop. But first we need to give _iterator_ a chance to clean up.", "              1. Let _closeCompletion_ be Completion { [[Type]]: ~normal~, [[Value]]: ~empty~, [[Target]]: ~empty~ }.", "              1. If _generatorKind_ is ~async~, perform ? AsyncIteratorClose(_iteratorRecord_, _closeCompletion_).", "              1. Else, perform ? IteratorClose(_iteratorRecord_, _closeCompletion_).", "              1. NOTE: The next step throws a *TypeError* to indicate that there was a `yield*` protocol violation: _iterator_ does not have a `throw` method.", "              1. Throw a *TypeError* exception.", "          1. Else,", "            1. Assert: _received_.[[Type]] is ~return~.", "            1. Let _return_ be ? GetMethod(_iterator_, *\"return\"*).", "            1. If _return_ is *undefined*, then", "              1. If _generatorKind_ is ~async~, set _received_.[[Value]] to ? Await(_received_.[[Value]]).", "              1. Return Completion(_received_).", "            1. Let _innerReturnResult_ be ? Call(_return_, _iterator_, « _received_.[[Value]] »).", "            1. If _generatorKind_ is ~async~, set _innerReturnResult_ to ? Await(_innerReturnResult_).", "            1. If Type(_innerReturnResult_) is not Object, throw a *TypeError* exception.", "            1. Let _done_ be ? IteratorComplete(_innerReturnResult_).", "            1. If _done_ is *true*, then", "              1. Let _value_ be ? IteratorValue(_innerReturnResult_).", "              1. Return Completion { [[Type]]: ~return~, [[Value]]: _value_, [[Target]]: ~empty~ }.", "            1. If _generatorKind_ is ~async~, set _received_ to AsyncGeneratorYield(? IteratorValue(_innerReturnResult_)).", "            1. Else, set _received_ to GeneratorYield(_innerReturnResult_)."],
    "head": {
      "idx": 2,
      "methodName": "Evaluation",
      "prod": "YieldExpression",
      "rhs": {
        "tokens": [{
          "term": "yield"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-generator-function-definitions-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) app __x0__ = (GetGeneratorKind)\n  0:let generatorKind = [! __x0__]\n  1:(1) access __x1__ = (AssignmentExpression \"Evaluation\")\n  1:let exprRef = __x1__\n  2:(2) app __x2__ = (GetValue exprRef)\n  2:let value = [? __x2__]\n  3:(3) app __x3__ = (GetIterator value generatorKind)\n  3:let iteratorRecord = [? __x3__]\n  4:let iterator = iteratorRecord[\"Iterator\"]\n  5:(4) app __x4__ = (NormalCompletion undefined)\n  5:let received = __x4__\n  6:while true if (= received[\"Type\"] CONST_normal) {\n    8:(5) app __x5__ = (Call iteratorRecord[\"NextMethod\"] iteratorRecord[\"Iterator\"] (0) (new [received[\"Value\"]]))\n    8:let innerResult = [? __x5__]\n    9:if (= generatorKind CONST_async) {\n      (6) app __x6__ = (Await innerResult)\n      innerResult = [? __x6__]\n    } else 33:{}\n    10:if (! (= (typeof innerResult) Object)) (1) throw TypeError else 33:{}\n    11:(7) app __x7__ = (IteratorComplete innerResult)\n    11:let done = [? __x7__]\n    12:if (= done true) {\n      13:(8) app __x8__ = (IteratorValue innerResult)\n      13:return [? __x8__]\n    } else 33:{}\n    15:if (= generatorKind CONST_async) {\n      (9) app __x9__ = (IteratorValue innerResult)\n      (10) app __x10__ = (AsyncGeneratorYield [? __x9__])\n      received = __x10__\n    } else {\n      (11) app __x11__ = (GeneratorYield innerResult)\n      received = __x11__\n    }\n  } else if (= received[\"Type\"] CONST_throw) {\n    17:(12) app __x12__ = (GetMethod iterator \"throw\")\n    17:let throw = [? __x12__]\n    28:if (! (= throw undefined)) {\n      19:(13) app __x13__ = (Call throw iterator (2) (new [received[\"Value\"]]))\n      19:let innerResult = [? __x13__]\n      20:if (= generatorKind CONST_async) {\n        (14) app __x14__ = (Await innerResult)\n        innerResult = [? __x14__]\n      } else 33:{}\n      22:if (! (= (typeof innerResult) Object)) (3) throw TypeError else 33:{}\n      23:(15) app __x15__ = (IteratorComplete innerResult)\n      23:let done = [? __x15__]\n      24:if (= done true) {\n        25:(16) app __x16__ = (IteratorValue innerResult)\n        25:return [? __x16__]\n      } else 33:{}\n      27:if (= generatorKind CONST_async) {\n        (17) app __x17__ = (IteratorValue innerResult)\n        (18) app __x18__ = (AsyncGeneratorYield [? __x17__])\n        received = __x18__\n      } else {\n        (19) app __x19__ = (GeneratorYield innerResult)\n        received = __x19__\n      }\n    } else {\n      30:let closeCompletion = (4) (new Completion(\"Type\" -> CONST_normal, \"Value\" -> CONST_empty, \"Target\" -> CONST_empty))\n      32:if (= generatorKind CONST_async) {\n        (20) app __x20__ = (AsyncIteratorClose iteratorRecord closeCompletion)\n        [? __x20__]\n      } else {\n        (21) app __x21__ = (IteratorClose iteratorRecord closeCompletion)\n        [? __x21__]\n      }\n      34:(5) throw TypeError\n    }\n  } else {\n    36:assert (= received[\"Type\"] CONST_return)\n    37:(22) app __x22__ = (GetMethod iterator \"return\")\n    37:let return = [? __x22__]\n    38:if (= return undefined) {\n      39:if (= generatorKind CONST_async) {\n        (23) app __x23__ = (Await received[\"Value\"])\n        received[\"Value\"] = [? __x23__]\n      } else 33:{}\n      40:return received\n    } else 33:{}\n    41:(24) app __x24__ = (Call return iterator (6) (new [received[\"Value\"]]))\n    41:let innerReturnResult = [? __x24__]\n    42:if (= generatorKind CONST_async) {\n      (25) app __x25__ = (Await innerReturnResult)\n      innerReturnResult = [? __x25__]\n    } else 33:{}\n    43:if (! (= (typeof innerReturnResult) Object)) (7) throw TypeError else 33:{}\n    44:(26) app __x26__ = (IteratorComplete innerReturnResult)\n    44:let done = [? __x26__]\n    45:if (= done true) {\n      46:(27) app __x27__ = (IteratorValue innerReturnResult)\n      46:let value = [? __x27__]\n      47:return (8) (new Completion(\"Type\" -> CONST_return, \"Value\" -> value, \"Target\" -> CONST_empty))\n    } else 33:{}\n    49:if (= generatorKind CONST_async) {\n      (28) app __x28__ = (IteratorValue innerReturnResult)\n      (29) app __x29__ = (AsyncGeneratorYield [? __x28__])\n      received = __x29__\n    } else {\n      (30) app __x30__ = (GeneratorYield innerReturnResult)\n      received = __x30__\n    }\n  }\n}"
  }, {
    "code": ["        1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).", "        1. Let _generator_ be ? OrdinaryCreateFromConstructor(_functionObject_, *\"%AsyncGeneratorFunction.prototype.prototype%\"*, « [[AsyncGeneratorState]], [[AsyncGeneratorContext]], [[AsyncGeneratorQueue]], [[GeneratorBrand]] »).", "        1. Set _generator_.[[GeneratorBrand]] to ~empty~.", "        1. Perform ! AsyncGeneratorStart(_generator_, |FunctionBody|).", "        1. Return Completion { [[Type]]: ~return~, [[Value]]: _generator_, [[Target]]: ~empty~ }."],
    "head": {
      "idx": 0,
      "methodName": "EvaluateAsyncGeneratorBody",
      "prod": "AsyncGeneratorBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "functionObject"
      }, {
        "kind": "Normal",
        "name": "argumentsList"
      }]
    },
    "ids": "sec-runtime-semantics-evaluateasyncgeneratorbody",
    "rawBody": "{\n  0:(0) app __x0__ = (FunctionDeclarationInstantiation functionObject argumentsList)\n  0:[? __x0__]\n  1:(1) app __x1__ = (OrdinaryCreateFromConstructor functionObject \"%AsyncGeneratorFunction.prototype.prototype%\" (0) (new [\"AsyncGeneratorState\", \"AsyncGeneratorContext\", \"AsyncGeneratorQueue\", \"GeneratorBrand\"]))\n  1:let generator = [? __x1__]\n  2:generator[\"GeneratorBrand\"] = CONST_empty\n  3:(2) app __x2__ = (AsyncGeneratorStart generator FunctionBody)\n  3:[! __x2__]\n  4:return (1) (new Completion(\"Type\" -> CONST_return, \"Value\" -> generator, \"Target\" -> CONST_empty))\n}"
  }, {
    "code": ["        1. Let _name_ be StringValue of |BindingIdentifier|.", "        1. Let _sourceText_ be the source text matched by |AsyncGeneratorDeclaration|.", "        1. Let _F_ be ! OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _scope_).", "        1. Perform ! SetFunctionName(_F_, _name_).", "        1. Let _prototype_ be ! OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).", "        1. Perform ! DefinePropertyOrThrow(_F_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).", "        1. Return _F_."],
    "head": {
      "idx": 0,
      "methodName": "InstantiateAsyncGeneratorFunctionObject",
      "prod": "AsyncGeneratorDeclaration",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "scope"
      }]
    },
    "ids": "sec-runtime-semantics-instantiateasyncgeneratorfunctionobject",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingIdentifier \"StringValue\")\n  0:let name = __x0__\n  1:let sourceText = (get-syntax AsyncGeneratorDeclaration)\n  2:(1) app __x1__ = (OrdinaryFunctionCreate INTRINSIC_AsyncGeneratorFunction_prototype sourceText FormalParameters AsyncGeneratorBody CONST_nonDASHlexicalDASHthis scope)\n  2:let F = [! __x1__]\n  3:(2) app __x2__ = (SetFunctionName F name)\n  3:[! __x2__]\n  4:(3) app __x3__ = (OrdinaryObjectCreate INTRINSIC_AsyncGeneratorFunction_prototype_prototype)\n  4:let prototype = [! __x3__]\n  5:(4) app __x4__ = (DefinePropertyOrThrow F \"prototype\" (0) (new PropertyDescriptor(\"Value\" -> prototype, \"Writable\" -> true, \"Enumerable\" -> false, \"Configurable\" -> false)))\n  5:[! __x4__]\n  6:return F\n}"
  }, {
    "code": ["        1. Let _sourceText_ be the source text matched by |AsyncGeneratorDeclaration|.", "        1. Let _F_ be OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _scope_).", "        1. Perform SetFunctionName(_F_, *\"default\"*).", "        1. Let _prototype_ be ! OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).", "        1. Perform DefinePropertyOrThrow(_F_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).", "        1. Return _F_."],
    "head": {
      "idx": 1,
      "methodName": "InstantiateAsyncGeneratorFunctionObject",
      "prod": "AsyncGeneratorDeclaration",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "*"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "scope"
      }]
    },
    "ids": "sec-runtime-semantics-instantiateasyncgeneratorfunctionobject",
    "rawBody": "{\n  0:let sourceText = (get-syntax AsyncGeneratorDeclaration)\n  1:(0) app __x0__ = (OrdinaryFunctionCreate INTRINSIC_AsyncGeneratorFunction_prototype sourceText FormalParameters AsyncGeneratorBody CONST_nonDASHlexicalDASHthis scope)\n  1:let F = __x0__\n  2:(1) app __x1__ = (SetFunctionName F \"default\")\n  2:__x1__\n  3:(2) app __x2__ = (OrdinaryObjectCreate INTRINSIC_AsyncGeneratorFunction_prototype_prototype)\n  3:let prototype = [! __x2__]\n  4:(3) app __x3__ = (DefinePropertyOrThrow F \"prototype\" (0) (new PropertyDescriptor(\"Value\" -> prototype, \"Writable\" -> true, \"Enumerable\" -> false, \"Configurable\" -> false)))\n  4:__x3__\n  5:return F\n}"
  }, {
    "code": ["        1. If _name_ is not present, set _name_ to *\"\"*.", "        1. Let _scope_ be the LexicalEnvironment of the running execution context.", "        1. Let _sourceText_ be the source text matched by |AsyncGeneratorExpression|.", "        1. Let _closure_ be ! OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _scope_).", "        1. Perform SetFunctionName(_closure_, _name_).", "        1. Let _prototype_ be ! OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).", "        1. Perform ! DefinePropertyOrThrow(_closure_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).", "        1. Return _closure_."],
    "head": {
      "idx": 0,
      "methodName": "InstantiateAsyncGeneratorFunctionExpression",
      "prod": "AsyncGeneratorExpression",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "*"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Optional",
        "name": "name"
      }]
    },
    "ids": "sec-runtime-semantics-instantiateasyncgeneratorfunctionexpression",
    "rawBody": "{\n  0:if (= name absent) name = \"\" else 33:{}\n  1:(0) access __x0__ = (CONTEXT \"LexicalEnvironment\")\n  1:let scope = __x0__\n  2:let sourceText = (get-syntax AsyncGeneratorExpression)\n  3:(1) app __x1__ = (OrdinaryFunctionCreate INTRINSIC_AsyncGeneratorFunction_prototype sourceText FormalParameters AsyncGeneratorBody CONST_nonDASHlexicalDASHthis scope)\n  3:let closure = [! __x1__]\n  4:(2) app __x2__ = (SetFunctionName closure name)\n  4:__x2__\n  5:(3) app __x3__ = (OrdinaryObjectCreate INTRINSIC_AsyncGeneratorFunction_prototype_prototype)\n  5:let prototype = [! __x3__]\n  6:(4) app __x4__ = (DefinePropertyOrThrow closure \"prototype\" (0) (new PropertyDescriptor(\"Value\" -> prototype, \"Writable\" -> true, \"Enumerable\" -> false, \"Configurable\" -> false)))\n  6:[! __x4__]\n  7:return closure\n}"
  }, {
    "code": ["        1. Assert: _name_ is not present.", "        1. Set _name_ to StringValue of |BindingIdentifier|.", "        1. Let _scope_ be the running execution context's LexicalEnvironment.", "        1. Let _funcEnv_ be ! NewDeclarativeEnvironment(_scope_).", "        1. Perform ! _funcEnv_.CreateImmutableBinding(_name_, *false*).", "        1. Let _sourceText_ be the source text matched by |AsyncGeneratorExpression|.", "        1. Let _closure_ be ! OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _funcEnv_).", "        1. Perform ! SetFunctionName(_closure_, _name_).", "        1. Let _prototype_ be ! OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).", "        1. Perform ! DefinePropertyOrThrow(_closure_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).", "        1. Perform ! _funcEnv_.InitializeBinding(_name_, _closure_).", "        1. Return _closure_."],
    "head": {
      "idx": 0,
      "methodName": "InstantiateAsyncGeneratorFunctionExpression",
      "prod": "AsyncGeneratorExpression",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Optional",
        "name": "name"
      }]
    },
    "ids": "sec-runtime-semantics-instantiateasyncgeneratorfunctionexpression",
    "rawBody": "{\n  0:assert (= name absent)\n  1:(0) access __x0__ = (BindingIdentifier \"StringValue\")\n  1:name = __x0__\n  2:let scope = CONTEXT[\"LexicalEnvironment\"]\n  3:(1) app __x1__ = (NewDeclarativeEnvironment scope)\n  3:let funcEnv = [! __x1__]\n  4:(2) app __x2__ = (funcEnv[\"CreateImmutableBinding\"] funcEnv name false)\n  4:[! __x2__]\n  5:let sourceText = (get-syntax AsyncGeneratorExpression)\n  6:(3) app __x3__ = (OrdinaryFunctionCreate INTRINSIC_AsyncGeneratorFunction_prototype sourceText FormalParameters AsyncGeneratorBody CONST_nonDASHlexicalDASHthis funcEnv)\n  6:let closure = [! __x3__]\n  7:(4) app __x4__ = (SetFunctionName closure name)\n  7:[! __x4__]\n  8:(5) app __x5__ = (OrdinaryObjectCreate INTRINSIC_AsyncGeneratorFunction_prototype_prototype)\n  8:let prototype = [! __x5__]\n  9:(6) app __x6__ = (DefinePropertyOrThrow closure \"prototype\" (0) (new PropertyDescriptor(\"Value\" -> prototype, \"Writable\" -> true, \"Enumerable\" -> false, \"Configurable\" -> false)))\n  9:[! __x6__]\n  10:(7) app __x7__ = (funcEnv[\"InitializeBinding\"] funcEnv name closure)\n  10:[! __x7__]\n  11:return closure\n}"
  }, {
    "code": ["        1. Return InstantiateAsyncGeneratorFunctionExpression of |AsyncGeneratorExpression|."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "AsyncGeneratorExpression",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": true
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-asyncgenerator-definitions-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (AsyncGeneratorExpression \"InstantiateAsyncGeneratorFunctionExpression\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. If PropName of |MethodDefinition| is *\"constructor\"*, return ~ConstructorMethod~.", "        1. Return ~NonConstructorMethod~."],
    "head": {
      "idx": 0,
      "methodName": "ClassElementKind",
      "prod": "ClassElement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MethodDefinition",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-classelementkind",
    "rawBody": "{\n  0:(0) access __x0__ = (MethodDefinition \"PropName\")\n  0:if (= __x0__ \"constructor\") return CONST_ConstructorMethod else 33:{}\n  1:return CONST_NonConstructorMethod\n}"
  }, {
    "code": ["        1. Return ~NonConstructorMethod~."],
    "head": {
      "idx": 1,
      "methodName": "ClassElementKind",
      "prod": "ClassElement",
      "rhs": {
        "tokens": [{
          "term": "static"
        }, {
          "args": [],
          "name": "MethodDefinition",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-classelementkind",
    "rawBody": "return CONST_NonConstructorMethod"
  }, {
    "code": ["        1. Return ~empty~."],
    "head": {
      "idx": 2,
      "methodName": "ClassElementKind",
      "prod": "ClassElement",
      "rhs": {
        "tokens": [{
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-classelementkind",
    "rawBody": "return CONST_empty"
  }, {
    "code": ["        1. If ClassElementKind of |ClassElement| is ~ConstructorMethod~, return |ClassElement|.", "        1. Return ~empty~."],
    "head": {
      "idx": 0,
      "methodName": "ConstructorMethod",
      "prod": "ClassElementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ClassElement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-constructormethod",
    "rawBody": "{\n  0:(0) access __x0__ = (ClassElement \"ClassElementKind\")\n  0:if (= __x0__ CONST_ConstructorMethod) return ClassElement else 33:{}\n  1:return CONST_empty\n}"
  }, {
    "code": ["        1. Let _head_ be ConstructorMethod of |ClassElementList|.", "        1. If _head_ is not ~empty~, return _head_.", "        1. If ClassElementKind of |ClassElement| is ~ConstructorMethod~, return |ClassElement|.", "        1. Return ~empty~."],
    "head": {
      "idx": 1,
      "methodName": "ConstructorMethod",
      "prod": "ClassElementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ClassElementList",
          "optional": false
        }, {
          "args": [],
          "name": "ClassElement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-constructormethod",
    "rawBody": "{\n  0:(0) access __x0__ = (ClassElementList \"ConstructorMethod\")\n  0:let head = __x0__\n  1:if (! (= head CONST_empty)) return head else 33:{}\n  2:(1) access __x1__ = (ClassElement \"ClassElementKind\")\n  2:if (= __x1__ CONST_ConstructorMethod) return ClassElement else 33:{}\n  3:return CONST_empty\n}"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "IsStatic",
      "prod": "ClassElement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MethodDefinition",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isstatic",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return *true*."],
    "head": {
      "idx": 1,
      "methodName": "IsStatic",
      "prod": "ClassElement",
      "rhs": {
        "tokens": [{
          "term": "static"
        }, {
          "args": [],
          "name": "MethodDefinition",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isstatic",
    "rawBody": "return true"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "IsStatic",
      "prod": "ClassElement",
      "rhs": {
        "tokens": [{
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-isstatic",
    "rawBody": "return false"
  }, {
    "code": ["        1. If ClassElementKind of |ClassElement| is ~NonConstructorMethod~, then", "          1. Return a List whose sole element is |ClassElement|.", "        1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "NonConstructorMethodDefinitions",
      "prod": "ClassElementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ClassElement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-nonconstructormethoddefinitions",
    "rawBody": "{\n  0:(0) access __x0__ = (ClassElement \"ClassElementKind\")\n  0:if (= __x0__ CONST_NonConstructorMethod) return (0) (new [ClassElement]) else 33:{}\n  2:return (1) (new [])\n}"
  }, {
    "code": ["        1. Let _list_ be NonConstructorMethodDefinitions of |ClassElementList|.", "        1. If ClassElementKind of |ClassElement| is ~NonConstructorMethod~, then", "          1. Append |ClassElement| to the end of _list_.", "        1. Return _list_."],
    "head": {
      "idx": 1,
      "methodName": "NonConstructorMethodDefinitions",
      "prod": "ClassElementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ClassElementList",
          "optional": false
        }, {
          "args": [],
          "name": "ClassElement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-nonconstructormethoddefinitions",
    "rawBody": "{\n  0:(0) access __x0__ = (ClassElementList \"NonConstructorMethodDefinitions\")\n  0:let list = __x0__\n  1:(1) access __x1__ = (ClassElement \"ClassElementKind\")\n  1:if (= __x1__ CONST_NonConstructorMethod) append ClassElement -> list else 33:{}\n  3:return list\n}"
  }, {
    "code": ["        1. If PropName of |ClassElement| is ~empty~, return a new empty List.", "        1. If IsStatic of |ClassElement| is *true*, return a new empty List.", "        1. Return a List whose sole element is PropName of |ClassElement|."],
    "head": {
      "idx": 0,
      "methodName": "PrototypePropertyNameList",
      "prod": "ClassElementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ClassElement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-prototypepropertynamelist",
    "rawBody": "{\n  0:(0) access __x0__ = (ClassElement \"PropName\")\n  0:if (= __x0__ CONST_empty) return (0) (new []) else 33:{}\n  1:(1) access __x1__ = (ClassElement \"IsStatic\")\n  1:if (= __x1__ true) return (1) (new []) else 33:{}\n  2:(2) access __x2__ = (ClassElement \"PropName\")\n  2:return (2) (new [__x2__])\n}"
  }, {
    "code": ["        1. Let _list_ be PrototypePropertyNameList of |ClassElementList|.", "        1. If PropName of |ClassElement| is ~empty~, return _list_.", "        1. If IsStatic of |ClassElement| is *true*, return _list_.", "        1. Append PropName of |ClassElement| to the end of _list_.", "        1. Return _list_."],
    "head": {
      "idx": 1,
      "methodName": "PrototypePropertyNameList",
      "prod": "ClassElementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ClassElementList",
          "optional": false
        }, {
          "args": [],
          "name": "ClassElement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-prototypepropertynamelist",
    "rawBody": "{\n  0:(0) access __x0__ = (ClassElementList \"PrototypePropertyNameList\")\n  0:let list = __x0__\n  1:(1) access __x1__ = (ClassElement \"PropName\")\n  1:if (= __x1__ CONST_empty) return list else 33:{}\n  2:(2) access __x2__ = (ClassElement \"IsStatic\")\n  2:if (= __x2__ true) return list else 33:{}\n  3:(3) access __x3__ = (ClassElement \"PropName\")\n  3:append __x3__ -> list\n  4:return list\n}"
  }, {
    "code": ["        1. Let _env_ be the LexicalEnvironment of the running execution context.", "        1. Let _classScope_ be NewDeclarativeEnvironment(_env_).", "        1. If _classBinding_ is not *undefined*, then", "          1. Perform _classScope_.CreateImmutableBinding(_classBinding_, *true*).", "        1. If |ClassHeritage_opt| is not present, then", "          1. Let _protoParent_ be %Object.prototype%.", "          1. Let _constructorParent_ be %Function.prototype%.", "        1. Else,", "          1. Set the running execution context's LexicalEnvironment to _classScope_.", "          1. Let _superclassRef_ be the result of evaluating |ClassHeritage|.", "          1. Set the running execution context's LexicalEnvironment to _env_.", "          1. Let _superclass_ be ? GetValue(_superclassRef_).", "          1. If _superclass_ is *null*, then", "            1. Let _protoParent_ be *null*.", "            1. Let _constructorParent_ be %Function.prototype%.", "          1. Else if IsConstructor(_superclass_) is *false*, throw a *TypeError* exception.", "          1. Else,", "            1. Let _protoParent_ be ? Get(_superclass_, *\"prototype\"*).", "            1. If Type(_protoParent_) is neither Object nor Null, throw a *TypeError* exception.", "            1. Let _constructorParent_ be _superclass_.", "        1. Let _proto_ be ! OrdinaryObjectCreate(_protoParent_).", "        1. If |ClassBody_opt| is not present, let _constructor_ be ~empty~.", "        1. Else, let _constructor_ be ConstructorMethod of |ClassBody|.", "        1. Set the running execution context's LexicalEnvironment to _classScope_.", "        1. If _constructor_ is ~empty~, then", "          1. Let _steps_ be the algorithm steps defined in <emu-xref href=\"#sec-default-constructor-functions\" title></emu-xref>.", "          1. Let _F_ be ! CreateBuiltinFunction(_steps_, 0, _className_, « [[ConstructorKind]], [[SourceText]] », ~empty~, _constructorParent_).", "        1. Else,", "          1. Let _constructorInfo_ be ! DefineMethod of _constructor_ with arguments _proto_ and _constructorParent_.", "          1. Let _F_ be _constructorInfo_.[[Closure]].", "          1. Perform ! MakeClassConstructor(_F_).", "          1. Perform ! SetFunctionName(_F_, _className_).", "        1. Perform ! MakeConstructor(_F_, *false*, _proto_).", "        1. If |ClassHeritage_opt| is present, set _F_.[[ConstructorKind]] to ~derived~.", "        1. Perform ! CreateMethodProperty(_proto_, *\"constructor\"*, _F_).", "        1. If |ClassBody_opt| is not present, let _methods_ be a new empty List.", "        1. Else, let _methods_ be NonConstructorMethodDefinitions of |ClassBody|.", "        1. For each |ClassElement| _m_ of _methods_, do", "          1. If IsStatic of _m_ is *false*, then", "            1. Let _status_ be PropertyDefinitionEvaluation of _m_ with arguments _proto_ and *false*.", "          1. Else,", "            1. Let _status_ be PropertyDefinitionEvaluation of _m_ with arguments _F_ and *false*.", "          1. If _status_ is an abrupt completion, then", "            1. Set the running execution context's LexicalEnvironment to _env_.", "            1. Return Completion(_status_).", "        1. Set the running execution context's LexicalEnvironment to _env_.", "        1. If _classBinding_ is not *undefined*, then", "          1. Perform _classScope_.InitializeBinding(_classBinding_, _F_).", "        1. Return _F_."],
    "head": {
      "idx": 0,
      "methodName": "ClassDefinitionEvaluation",
      "prod": "ClassTail",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ClassHeritage",
          "optional": true
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "ClassBody",
          "optional": true
        }, {
          "term": "}"
        }]
      },
      "subIdx": 3,
      "withParams": [{
        "kind": "Normal",
        "name": "classBinding"
      }, {
        "kind": "Normal",
        "name": "className"
      }]
    },
    "ids": "sec-runtime-semantics-classdefinitionevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (CONTEXT \"LexicalEnvironment\")\n  0:let env = __x0__\n  1:(1) app __x1__ = (NewDeclarativeEnvironment env)\n  1:let classScope = __x1__\n  2:if (! (= classBinding undefined)) {\n    3:(2) app __x2__ = (classScope[\"CreateImmutableBinding\"] classScope classBinding true)\n    3:__x2__\n  } else 33:{}\n  7:if (= ClassHeritage absent) {\n    5:let protoParent = INTRINSIC_Object_prototype\n    6:let constructorParent = INTRINSIC_Function_prototype\n  } else {\n    8:CONTEXT[\"LexicalEnvironment\"] = classScope\n    9:(3) access __x3__ = (ClassHeritage \"Evaluation\")\n    9:let superclassRef = __x3__\n    10:CONTEXT[\"LexicalEnvironment\"] = env\n    11:(4) app __x4__ = (GetValue superclassRef)\n    11:let superclass = [? __x4__]\n    16:if (= superclass null) {\n      13:let protoParent = null\n      14:let constructorParent = INTRINSIC_Function_prototype\n    } else {\n      (5) app __x5__ = (IsConstructor superclass)\n      if (= __x5__ false) (0) throw TypeError else {\n        17:(6) app __x6__ = (Get superclass \"prototype\")\n        17:let protoParent = [? __x6__]\n        18:if (! (|| (= (typeof protoParent) Object) (= (typeof protoParent) Null))) (1) throw TypeError else 33:{}\n        19:let constructorParent = superclass\n      }\n    }\n  }\n  20:(7) app __x7__ = (OrdinaryObjectCreate protoParent)\n  20:let proto = [! __x7__]\n  22:if (= ClassBody absent) let constructor = CONST_empty else {\n    (8) access __x8__ = (ClassBody \"ConstructorMethod\")\n    let constructor = __x8__\n  }\n  23:CONTEXT[\"LexicalEnvironment\"] = classScope\n  27:if (= constructor CONST_empty) {\n    25:(2) ??? \"Let id:{steps} be the algorithm steps defined in link:{sec-default-constructor-functions} .\"\n    26:(9) app __x9__ = (CreateBuiltinFunction steps 0i className (3) (new [\"ConstructorKind\", \"SourceText\"]) CONST_empty constructorParent)\n    26:let F = [! __x9__]\n  } else {\n    28:(10) access __x10__ = (constructor \"DefineMethod\" proto constructorParent)\n    28:let constructorInfo = [! __x10__]\n    29:let F = constructorInfo[\"Closure\"]\n    30:(11) app __x11__ = (MakeClassConstructor F)\n    30:[! __x11__]\n    31:(12) app __x12__ = (SetFunctionName F className)\n    31:[! __x12__]\n  }\n  32:(13) app __x13__ = (MakeConstructor F false proto)\n  32:[! __x13__]\n  33:if (! (= ClassHeritage absent)) F[\"ConstructorKind\"] = CONST_derived else 33:{}\n  34:(14) app __x14__ = (CreateMethodProperty proto \"constructor\" F)\n  34:[! __x14__]\n  36:if (= ClassBody absent) let methods = (4) (new []) else {\n    (15) access __x15__ = (ClassBody \"NonConstructorMethodDefinitions\")\n    let methods = __x15__\n  }\n  37:let __x16__ = methods\n  37:let __x17__ = 0i\n  37:while (< __x17__ __x16__[\"length\"]) {\n    let m = __x16__[__x17__]\n    40:(16) access __x18__ = (m \"IsStatic\")\n    40:if (= __x18__ false) {\n      39:(17) access __x19__ = (m \"PropertyDefinitionEvaluation\" proto false)\n      39:let status = __x19__\n    } else {\n      41:(18) access __x20__ = (m \"PropertyDefinitionEvaluation\" F false)\n      41:let status = __x20__\n    }\n    42:(19) app __x21__ = (IsAbruptCompletion status)\n    42:if __x21__ {\n      43:CONTEXT[\"LexicalEnvironment\"] = env\n      44:return status\n    } else 33:{}\n    __x17__ = (+ __x17__ 1i)\n  }\n  45:CONTEXT[\"LexicalEnvironment\"] = env\n  46:if (! (= classBinding undefined)) {\n    47:(20) app __x22__ = (classScope[\"InitializeBinding\"] classScope classBinding F)\n    47:__x22__\n  } else 33:{}\n  48:return F\n}"
  }, {
    "code": ["          1. If NewTarget is *undefined*, throw a *TypeError* exception.", "          1. Let _F_ be the active function object.", "          1. If _F_.[[ConstructorKind]] is ~derived~, then", "            1. NOTE: This branch behaves similarly to `constructor(...args) { super(...args); }`. The most notable distinction is that while the aforementioned ECMAScript source text observably calls the @@iterator method on `%Array.prototype%`, a Default Constructor Function does not.", "            1. Let _func_ be ! _F_.[[GetPrototypeOf]]().", "            1. If IsConstructor(_func_) is *false*, throw a *TypeError* exception.", "            1. Return ? Construct(_func_, _args_, NewTarget).", "          1. Else,", "            1. NOTE: This branch behaves similarly to `constructor() {}`.", "            1. Return ? OrdinaryCreateFromConstructor(NewTarget, *\"%Object.prototype%\"*)."],
    "head": {
      "name": "DefaultConstructorFunctions",
      "params": []
    },
    "ids": "sec-default-constructor-functions",
    "rawBody": "{\n  0:if (= NewTarget undefined) (0) throw TypeError else 8:{}\n  1:let F = CONTEXT[\"Function\"]\n  7:if (= F[\"ConstructorKind\"] CONST_derived) {\n    4:(0) app __x0__ = (F[\"GetPrototypeOf\"] F)\n    4:let func = [! __x0__]\n    5:(1) app __x1__ = (IsConstructor func)\n    5:if (= __x1__ false) (1) throw TypeError else 8:{}\n    6:(2) app __x2__ = (Construct func args NewTarget)\n    6:return [? __x2__]\n  } else {\n    9:(3) app __x3__ = (OrdinaryCreateFromConstructor NewTarget \"%Object.prototype%\")\n    9:return [? __x3__]\n  }\n}"
  }, {
    "code": ["        1. Let _className_ be StringValue of |BindingIdentifier|.", "        1. Let _value_ be ? ClassDefinitionEvaluation of |ClassTail| with arguments _className_ and _className_.", "        1. Set _value_.[[SourceText]] to the source text matched by |ClassDeclaration|.", "        1. Let _env_ be the running execution context's LexicalEnvironment.", "        1. Perform ? InitializeBoundName(_className_, _value_, _env_).", "        1. Return _value_."],
    "head": {
      "idx": 0,
      "methodName": "BindingClassDeclarationEvaluation",
      "prod": "ClassDeclaration",
      "rhs": {
        "tokens": [{
          "term": "class"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "args": [],
          "name": "ClassTail",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-runtime-semantics-bindingclassdeclarationevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingIdentifier \"StringValue\")\n  0:let className = __x0__\n  1:(1) access __x1__ = (ClassTail \"ClassDefinitionEvaluation\" className className)\n  1:let value = [? __x1__]\n  2:value[\"SourceText\"] = (get-syntax ClassDeclaration)\n  3:let env = CONTEXT[\"LexicalEnvironment\"]\n  4:(2) app __x2__ = (InitializeBoundName className value env)\n  4:[? __x2__]\n  5:return value\n}"
  }, {
    "code": ["        1. Let _value_ be ? ClassDefinitionEvaluation of |ClassTail| with arguments *undefined* and *\"default\"*.", "        1. Set _value_.[[SourceText]] to the source text matched by |ClassDeclaration|.", "        1. Return _value_."],
    "head": {
      "idx": 1,
      "methodName": "BindingClassDeclarationEvaluation",
      "prod": "ClassDeclaration",
      "rhs": {
        "tokens": [{
          "term": "class"
        }, {
          "args": [],
          "name": "ClassTail",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-runtime-semantics-bindingclassdeclarationevaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (ClassTail \"ClassDefinitionEvaluation\" undefined \"default\")\n  0:let value = [? __x0__]\n  1:value[\"SourceText\"] = (get-syntax ClassDeclaration)\n  2:return value\n}"
  }, {
    "code": ["        1. Perform ? BindingClassDeclarationEvaluation of this |ClassDeclaration|.", "        1. Return NormalCompletion(~empty~)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "ClassDeclaration",
      "rhs": {
        "tokens": [{
          "term": "class"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "args": [],
          "name": "ClassTail",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-class-definitions-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (this \"BindingClassDeclarationEvaluation\")\n  0:[? __x0__]\n  1:return CONST_empty\n}"
  }, {
    "code": ["        1. Let _value_ be ? ClassDefinitionEvaluation of |ClassTail| with arguments *undefined* and *\"\"*.", "        1. Set _value_.[[SourceText]] to the source text matched by |ClassExpression|.", "        1. Return _value_."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "ClassExpression",
      "rhs": {
        "tokens": [{
          "term": "class"
        }, {
          "args": [],
          "name": "ClassTail",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-class-definitions-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (ClassTail \"ClassDefinitionEvaluation\" undefined \"\")\n  0:let value = [? __x0__]\n  1:value[\"SourceText\"] = (get-syntax ClassExpression)\n  2:return value\n}"
  }, {
    "code": ["        1. Let _className_ be StringValue of |BindingIdentifier|.", "        1. Let _value_ be ? ClassDefinitionEvaluation of |ClassTail| with arguments _className_ and _className_.", "        1. Set _value_.[[SourceText]] to the source text matched by |ClassExpression|.", "        1. Return _value_."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "ClassExpression",
      "rhs": {
        "tokens": [{
          "term": "class"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "args": [],
          "name": "ClassTail",
          "optional": false
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-class-definitions-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingIdentifier \"StringValue\")\n  0:let className = __x0__\n  1:(1) access __x1__ = (ClassTail \"ClassDefinitionEvaluation\" className className)\n  1:let value = [? __x1__]\n  2:value[\"SourceText\"] = (get-syntax ClassExpression)\n  3:return value\n}"
  }, {
    "code": ["        1. Let _name_ be StringValue of |BindingIdentifier|.", "        1. Let _sourceText_ be the source text matched by |AsyncFunctionDeclaration|.", "        1. Let _F_ be ! OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _scope_).", "        1. Perform ! SetFunctionName(_F_, _name_).", "        1. Return _F_."],
    "head": {
      "idx": 0,
      "methodName": "InstantiateAsyncFunctionObject",
      "prod": "AsyncFunctionDeclaration",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "scope"
      }]
    },
    "ids": "sec-runtime-semantics-instantiateasyncfunctionobject",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingIdentifier \"StringValue\")\n  0:let name = __x0__\n  1:let sourceText = (get-syntax AsyncFunctionDeclaration)\n  2:(1) app __x1__ = (OrdinaryFunctionCreate INTRINSIC_AsyncFunction_prototype sourceText FormalParameters AsyncFunctionBody CONST_nonDASHlexicalDASHthis scope)\n  2:let F = [! __x1__]\n  3:(2) app __x2__ = (SetFunctionName F name)\n  3:[! __x2__]\n  4:return F\n}"
  }, {
    "code": ["        1. Let _sourceText_ be the source text matched by |AsyncFunctionDeclaration|.", "        1. Let _F_ be ! OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _scope_).", "        1. Perform ! SetFunctionName(_F_, *\"default\"*).", "        1. Return _F_."],
    "head": {
      "idx": 1,
      "methodName": "InstantiateAsyncFunctionObject",
      "prod": "AsyncFunctionDeclaration",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "scope"
      }]
    },
    "ids": "sec-runtime-semantics-instantiateasyncfunctionobject",
    "rawBody": "{\n  0:let sourceText = (get-syntax AsyncFunctionDeclaration)\n  1:(0) app __x0__ = (OrdinaryFunctionCreate INTRINSIC_AsyncFunction_prototype sourceText FormalParameters AsyncFunctionBody CONST_nonDASHlexicalDASHthis scope)\n  1:let F = [! __x0__]\n  2:(1) app __x1__ = (SetFunctionName F \"default\")\n  2:[! __x1__]\n  3:return F\n}"
  }, {
    "code": ["        1. If _name_ is not present, set _name_ to *\"\"*.", "        1. Let _scope_ be the LexicalEnvironment of the running execution context.", "        1. Let _sourceText_ be the source text matched by |AsyncFunctionExpression|.", "        1. Let _closure_ be ! OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _scope_).", "        1. Perform SetFunctionName(_closure_, _name_).", "        1. Return _closure_."],
    "head": {
      "idx": 0,
      "methodName": "InstantiateAsyncFunctionExpression",
      "prod": "AsyncFunctionExpression",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Optional",
        "name": "name"
      }]
    },
    "ids": "sec-runtime-semantics-instantiateasyncfunctionexpression",
    "rawBody": "{\n  0:if (= name absent) name = \"\" else 8:{}\n  1:(0) access __x0__ = (CONTEXT \"LexicalEnvironment\")\n  1:let scope = __x0__\n  2:let sourceText = (get-syntax AsyncFunctionExpression)\n  3:(1) app __x1__ = (OrdinaryFunctionCreate INTRINSIC_AsyncFunction_prototype sourceText FormalParameters AsyncFunctionBody CONST_nonDASHlexicalDASHthis scope)\n  3:let closure = [! __x1__]\n  4:(2) app __x2__ = (SetFunctionName closure name)\n  4:__x2__\n  5:return closure\n}"
  }, {
    "code": ["        1. Assert: _name_ is not present.", "        1. Set _name_ to StringValue of |BindingIdentifier|.", "        1. Let _scope_ be the LexicalEnvironment of the running execution context.", "        1. Let _funcEnv_ be ! NewDeclarativeEnvironment(_scope_).", "        1. Perform ! _funcEnv_.CreateImmutableBinding(_name_, *false*).", "        1. Let _sourceText_ be the source text matched by |AsyncFunctionExpression|.", "        1. Let _closure_ be ! OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _funcEnv_).", "        1. Perform ! SetFunctionName(_closure_, _name_).", "        1. Perform ! _funcEnv_.InitializeBinding(_name_, _closure_).", "        1. Return _closure_."],
    "head": {
      "idx": 0,
      "methodName": "InstantiateAsyncFunctionExpression",
      "prod": "AsyncFunctionExpression",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Optional",
        "name": "name"
      }]
    },
    "ids": "sec-runtime-semantics-instantiateasyncfunctionexpression",
    "rawBody": "{\n  0:assert (= name absent)\n  1:(0) access __x0__ = (BindingIdentifier \"StringValue\")\n  1:name = __x0__\n  2:(1) access __x1__ = (CONTEXT \"LexicalEnvironment\")\n  2:let scope = __x1__\n  3:(2) app __x2__ = (NewDeclarativeEnvironment scope)\n  3:let funcEnv = [! __x2__]\n  4:(3) app __x3__ = (funcEnv[\"CreateImmutableBinding\"] funcEnv name false)\n  4:[! __x3__]\n  5:let sourceText = (get-syntax AsyncFunctionExpression)\n  6:(4) app __x4__ = (OrdinaryFunctionCreate INTRINSIC_AsyncFunction_prototype sourceText FormalParameters AsyncFunctionBody CONST_nonDASHlexicalDASHthis funcEnv)\n  6:let closure = [! __x4__]\n  7:(5) app __x5__ = (SetFunctionName closure name)\n  7:[! __x5__]\n  8:(6) app __x6__ = (funcEnv[\"InitializeBinding\"] funcEnv name closure)\n  8:[! __x6__]\n  9:return closure\n}"
  }, {
    "code": ["        1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).", "        1. Let _declResult_ be FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).", "        1. If _declResult_ is not an abrupt completion, then", "          1. Perform ! AsyncFunctionStart(_promiseCapability_, |FunctionBody|).", "        1. Else,", "          1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _declResult_.[[Value]] »).", "        1. Return Completion { [[Type]]: ~return~, [[Value]]: _promiseCapability_.[[Promise]], [[Target]]: ~empty~ }."],
    "head": {
      "idx": 0,
      "methodName": "EvaluateAsyncFunctionBody",
      "prod": "AsyncFunctionBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "functionObject"
      }, {
        "kind": "Normal",
        "name": "argumentsList"
      }]
    },
    "ids": "sec-runtime-semantics-evaluateasyncfunctionbody",
    "rawBody": "{\n  0:(0) app __x0__ = (NewPromiseCapability INTRINSIC_Promise)\n  0:let promiseCapability = [! __x0__]\n  1:(1) app __x1__ = (FunctionDeclarationInstantiation functionObject argumentsList)\n  1:let declResult = __x1__\n  4:(2) app __x2__ = (IsAbruptCompletion declResult)\n  4:if (! __x2__) {\n    3:(3) app __x3__ = (AsyncFunctionStart promiseCapability FunctionBody)\n    3:[! __x3__]\n  } else {\n    5:(4) app __x4__ = (Call promiseCapability[\"Reject\"] undefined (0) (new [declResult[\"Value\"]]))\n    5:[! __x4__]\n  }\n  6:return (1) (new Completion(\"Type\" -> CONST_return, \"Value\" -> promiseCapability[\"Promise\"], \"Target\" -> CONST_empty))\n}"
  }, {
    "code": ["        1. Return NormalCompletion(~empty~)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "AsyncFunctionDeclaration",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-async-function-definitions-runtime-semantics-evaluation",
    "rawBody": "return CONST_empty"
  }, {
    "code": ["        1. Return NormalCompletion(~empty~)."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "AsyncFunctionDeclaration",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-async-function-definitions-runtime-semantics-evaluation",
    "rawBody": "return CONST_empty"
  }, {
    "code": ["        1. Return InstantiateAsyncFunctionExpression of |AsyncFunctionExpression|."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "AsyncFunctionExpression",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": true
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-async-function-definitions-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (AsyncFunctionExpression \"InstantiateAsyncFunctionExpression\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Let _exprRef_ be the result of evaluating |UnaryExpression|.", "        1. Let _value_ be ? GetValue(_exprRef_).", "        1. Return ? Await(_value_)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "AwaitExpression",
      "rhs": {
        "tokens": [{
          "term": "await"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-async-function-definitions-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (UnaryExpression \"Evaluation\")\n  0:let exprRef = __x0__\n  1:(1) app __x1__ = (GetValue exprRef)\n  1:let value = [? __x1__]\n  2:(2) app __x2__ = (Await value)\n  2:return [? __x2__]\n}"
  }, {
    "code": ["        1. Return the |AsyncArrowHead| that is covered by |CoverCallExpressionAndAsyncArrowHead|."],
    "head": {
      "idx": 0,
      "methodName": "CoveredAsyncArrowHead",
      "prod": "CoverCallExpressionAndAsyncArrowHead",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "args": [],
          "name": "Arguments",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-async-arrow-function-definitions-static-semantics-CoveredAsyncArrowHead",
    "rawBody": "return (parse-syntax CoverCallExpressionAndAsyncArrowHead \"AsyncArrowHead\" (0) (new []))"
  }, {
    "code": ["        1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "AsyncConciseBodyContainsUseStrict",
      "prod": "AsyncConciseBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExpressionBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-asyncconcisebodycontainsusestrict",
    "rawBody": "return false"
  }, {
    "code": ["        1. Return FunctionBodyContainsUseStrict of |AsyncFunctionBody|."],
    "head": {
      "idx": 1,
      "methodName": "AsyncConciseBodyContainsUseStrict",
      "prod": "AsyncConciseBody",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-asyncconcisebodycontainsusestrict",
    "rawBody": "{\n  0:(0) access __x0__ = (AsyncFunctionBody \"FunctionBodyContainsUseStrict\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).", "        1. Let _declResult_ be FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).", "        1. If _declResult_ is not an abrupt completion, then", "          1. Perform ! AsyncFunctionStart(_promiseCapability_, |ExpressionBody|).", "        1. Else,", "          1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _declResult_.[[Value]] »).", "        1. Return Completion { [[Type]]: ~return~, [[Value]]: _promiseCapability_.[[Promise]], [[Target]]: ~empty~ }."],
    "head": {
      "idx": 0,
      "methodName": "EvaluateAsyncConciseBody",
      "prod": "AsyncConciseBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExpressionBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "functionObject"
      }, {
        "kind": "Normal",
        "name": "argumentsList"
      }]
    },
    "ids": "sec-runtime-semantics-evaluateasyncconcisebody",
    "rawBody": "{\n  0:(0) app __x0__ = (NewPromiseCapability INTRINSIC_Promise)\n  0:let promiseCapability = [! __x0__]\n  1:(1) app __x1__ = (FunctionDeclarationInstantiation functionObject argumentsList)\n  1:let declResult = __x1__\n  4:(2) app __x2__ = (IsAbruptCompletion declResult)\n  4:if (! __x2__) {\n    3:(3) app __x3__ = (AsyncFunctionStart promiseCapability ExpressionBody)\n    3:[! __x3__]\n  } else {\n    5:(4) app __x4__ = (Call promiseCapability[\"Reject\"] undefined (0) (new [declResult[\"Value\"]]))\n    5:[! __x4__]\n  }\n  6:return (1) (new Completion(\"Type\" -> CONST_return, \"Value\" -> promiseCapability[\"Promise\"], \"Target\" -> CONST_empty))\n}"
  }, {
    "code": ["        1. If _name_ is not present, set _name_ to *\"\"*.", "        1. Let _scope_ be the LexicalEnvironment of the running execution context.", "        1. Let _sourceText_ be the source text matched by |AsyncArrowFunction|.", "        1. Let _parameters_ be |AsyncArrowBindingIdentifier|.", "        1. Let _closure_ be ! OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, _parameters_, |AsyncConciseBody|, ~lexical-this~, _scope_).", "        1. Perform SetFunctionName(_closure_, _name_).", "        1. Return _closure_."],
    "head": {
      "idx": 0,
      "methodName": "InstantiateAsyncArrowFunctionExpression",
      "prod": "AsyncArrowFunction",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "args": [],
          "name": "AsyncArrowBindingIdentifier",
          "optional": false
        }, {
          "term": "=>"
        }, {
          "args": [],
          "name": "AsyncConciseBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Optional",
        "name": "name"
      }]
    },
    "ids": "sec-runtime-semantics-instantiateasyncarrowfunctionexpression",
    "rawBody": "{\n  0:if (= name absent) name = \"\" else 8:{}\n  1:(0) access __x0__ = (CONTEXT \"LexicalEnvironment\")\n  1:let scope = __x0__\n  2:let sourceText = (get-syntax AsyncArrowFunction)\n  3:let parameters = AsyncArrowBindingIdentifier\n  4:(1) app __x1__ = (OrdinaryFunctionCreate INTRINSIC_AsyncFunction_prototype sourceText parameters AsyncConciseBody CONST_lexicalDASHthis scope)\n  4:let closure = [! __x1__]\n  5:(2) app __x2__ = (SetFunctionName closure name)\n  5:__x2__\n  6:return closure\n}"
  }, {
    "code": ["        1. If _name_ is not present, set _name_ to *\"\"*.", "        1. Let _scope_ be the LexicalEnvironment of the running execution context.", "        1. Let _sourceText_ be the source text matched by |AsyncArrowFunction|.", "        1. Let _head_ be CoveredAsyncArrowHead of |CoverCallExpressionAndAsyncArrowHead|.", "        1. Let _parameters_ be the |ArrowFormalParameters| of _head_.", "        1. Let _closure_ be ! OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, _parameters_, |AsyncConciseBody|, ~lexical-this~, _scope_).", "        1. Perform SetFunctionName(_closure_, _name_).", "        1. Return _closure_."],
    "head": {
      "idx": 1,
      "methodName": "InstantiateAsyncArrowFunctionExpression",
      "prod": "AsyncArrowFunction",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CoverCallExpressionAndAsyncArrowHead",
          "optional": false
        }, {
          "term": "=>"
        }, {
          "args": [],
          "name": "AsyncConciseBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Optional",
        "name": "name"
      }]
    },
    "ids": "sec-runtime-semantics-instantiateasyncarrowfunctionexpression",
    "rawBody": "{\n  0:if (= name absent) name = \"\" else 8:{}\n  1:(0) access __x0__ = (CONTEXT \"LexicalEnvironment\")\n  1:let scope = __x0__\n  2:let sourceText = (get-syntax AsyncArrowFunction)\n  3:(1) access __x1__ = (CoverCallExpressionAndAsyncArrowHead \"CoveredAsyncArrowHead\")\n  3:let head = __x1__\n  4:(2) access __x2__ = (head \"ArrowFormalParameters\")\n  4:let parameters = __x2__\n  5:(3) app __x3__ = (OrdinaryFunctionCreate INTRINSIC_AsyncFunction_prototype sourceText parameters AsyncConciseBody CONST_lexicalDASHthis scope)\n  5:let closure = [! __x3__]\n  6:(4) app __x4__ = (SetFunctionName closure name)\n  6:__x4__\n  7:return closure\n}"
  }, {
    "code": ["        1. Return InstantiateAsyncArrowFunctionExpression of |AsyncArrowFunction|."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "AsyncArrowFunction",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "args": [],
          "name": "AsyncArrowBindingIdentifier",
          "optional": false
        }, {
          "term": "=>"
        }, {
          "args": [],
          "name": "AsyncConciseBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-async-arrow-function-definitions-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (AsyncArrowFunction \"InstantiateAsyncArrowFunctionExpression\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Return InstantiateAsyncArrowFunctionExpression of |AsyncArrowFunction|."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "AsyncArrowFunction",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CoverCallExpressionAndAsyncArrowHead",
          "optional": false
        }, {
          "term": "=>"
        }, {
          "args": [],
          "name": "AsyncConciseBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-async-arrow-function-definitions-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (AsyncArrowFunction \"InstantiateAsyncArrowFunctionExpression\")\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Assert: _call_ is a Parse Node.", "        1. If the source code matching _call_ is non-strict code, return *false*.", "        1. If _call_ is not contained within a |FunctionBody|, |ConciseBody|, or |AsyncConciseBody|, return *false*.", "        1. Let _body_ be the |FunctionBody|, |ConciseBody|, or |AsyncConciseBody| that most closely contains _call_.", "        1. If _body_ is the |FunctionBody| of a |GeneratorBody|, return *false*.", "        1. If _body_ is the |FunctionBody| of an |AsyncFunctionBody|, return *false*.", "        1. If _body_ is the |FunctionBody| of an |AsyncGeneratorBody|, return *false*.", "        1. If _body_ is an |AsyncConciseBody|, return *false*.", "        1. Return the result of HasCallInTailPosition of _body_ with argument _call_."],
    "head": {
      "name": "IsInTailPosition",
      "params": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-isintailposition",
    "rawBody": "{\n  1:if false return false else 0:{}\n  2:(0) ??? \"If id:{call} is not contained within a nt:{FunctionBody} , nt:{ConciseBody} , or nt:{AsyncConciseBody} , return value:{false} .\"\n  3:(1) ??? \"Let id:{body} be the nt:{FunctionBody} , nt:{ConciseBody} , or nt:{AsyncConciseBody} that most closely contains id:{call} .\"\n  4:(2) ??? \"If id:{body} is the nt:{FunctionBody} of a nt:{GeneratorBody} , return value:{false} .\"\n  5:(3) ??? \"If id:{body} is the nt:{FunctionBody} of an nt:{AsyncFunctionBody} , return value:{false} .\"\n  6:(4) ??? \"If id:{body} is the nt:{FunctionBody} of an nt:{AsyncGeneratorBody} , return value:{false} .\"\n  7:if (5) (is-instance-of body AsyncConciseBody) return false else 0:{}\n  8:(0) access __x0__ = (body \"HasCallInTailPosition\" call)\n  8:return __x0__\n}"
  }, {
    "code": ["          1. Let _has_ be HasCallInTailPosition of |StatementList| with argument _call_.", "          1. If _has_ is *true*, return *true*.", "          1. Return HasCallInTailPosition of |StatementListItem| with argument _call_."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "StatementList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StatementList",
          "optional": false
        }, {
          "args": [],
          "name": "StatementListItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (StatementList \"HasCallInTailPosition\" call)\n  0:let has = __x0__\n  1:if (= has true) return true else 0:{}\n  2:(1) access __x1__ = (StatementListItem \"HasCallInTailPosition\" call)\n  2:return __x1__\n}"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "HasCallInTailPosition",
      "prod": "FunctionStatementList",
      "rhs": {
        "tokens": [{
          "empty": null
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "StatementListItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Declaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "VariableStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "HasCallInTailPosition",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "EmptyStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 3,
      "methodName": "HasCallInTailPosition",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExpressionStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 6,
      "methodName": "HasCallInTailPosition",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ContinueStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 7,
      "methodName": "HasCallInTailPosition",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BreakStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 11,
      "methodName": "HasCallInTailPosition",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ThrowStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 13,
      "methodName": "HasCallInTailPosition",
      "prod": "Statement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "DebuggerStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "HasCallInTailPosition",
      "prod": "Block",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "HasCallInTailPosition",
      "prod": "ReturnStatement",
      "rhs": {
        "tokens": [{
          "term": "return"
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "LabelledItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FunctionDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 3,
      "methodName": "HasCallInTailPosition",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 4,
      "methodName": "HasCallInTailPosition",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "ForBinding",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 5,
      "methodName": "HasCallInTailPosition",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "ForDeclaration",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "HasCallInTailPosition",
      "prod": "CaseBlock",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Let _has_ be HasCallInTailPosition of the first |Statement| with argument _call_.", "          1. If _has_ is *true*, return *true*.", "          1. Return HasCallInTailPosition of the second |Statement| with argument _call_."],
    "head": {
      "idx": 0,
      "methodName": "HasCallInTailPosition",
      "prod": "IfStatement",
      "rhs": {
        "tokens": [{
          "term": "if"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }, {
          "term": "else"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement0 \"HasCallInTailPosition\" call)\n  0:let has = __x0__\n  1:if (= has true) return true else 0:{}\n  2:(1) access __x1__ = (Statement1 \"HasCallInTailPosition\" call)\n  2:return __x1__\n}"
  }, {
    "code": ["          1. Return HasCallInTailPosition of |Statement| with argument _call_."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "IfStatement",
      "rhs": {
        "tokens": [{
          "term": "if"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"HasCallInTailPosition\" call)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return HasCallInTailPosition of |Statement| with argument _call_."],
    "head": {
      "idx": 0,
      "methodName": "HasCallInTailPosition",
      "prod": "DoWhileStatement",
      "rhs": {
        "tokens": [{
          "term": "do"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }, {
          "term": "while"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"HasCallInTailPosition\" call)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return HasCallInTailPosition of |Statement| with argument _call_."],
    "head": {
      "idx": 0,
      "methodName": "HasCallInTailPosition",
      "prod": "WhileStatement",
      "rhs": {
        "tokens": [{
          "term": "while"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"HasCallInTailPosition\" call)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return HasCallInTailPosition of |Statement| with argument _call_."],
    "head": {
      "idx": 0,
      "methodName": "HasCallInTailPosition",
      "prod": "ForStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 7,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"HasCallInTailPosition\" call)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return HasCallInTailPosition of |Statement| with argument _call_."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "ForStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "VariableDeclarationList",
          "optional": false
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 3,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"HasCallInTailPosition\" call)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return HasCallInTailPosition of |Statement| with argument _call_."],
    "head": {
      "idx": 2,
      "methodName": "HasCallInTailPosition",
      "prod": "ForStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LexicalDeclaration",
          "optional": false
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 3,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"HasCallInTailPosition\" call)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return HasCallInTailPosition of |Statement| with argument _call_."],
    "head": {
      "idx": 0,
      "methodName": "HasCallInTailPosition",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"HasCallInTailPosition\" call)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return HasCallInTailPosition of |Statement| with argument _call_."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "ForBinding",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"HasCallInTailPosition\" call)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return HasCallInTailPosition of |Statement| with argument _call_."],
    "head": {
      "idx": 2,
      "methodName": "HasCallInTailPosition",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "ForDeclaration",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"HasCallInTailPosition\" call)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return HasCallInTailPosition of |Statement| with argument _call_."],
    "head": {
      "idx": 6,
      "methodName": "HasCallInTailPosition",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "await"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"HasCallInTailPosition\" call)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return HasCallInTailPosition of |Statement| with argument _call_."],
    "head": {
      "idx": 7,
      "methodName": "HasCallInTailPosition",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "await"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "ForBinding",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"HasCallInTailPosition\" call)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return HasCallInTailPosition of |Statement| with argument _call_."],
    "head": {
      "idx": 8,
      "methodName": "HasCallInTailPosition",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "await"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "ForDeclaration",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"HasCallInTailPosition\" call)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return HasCallInTailPosition of |Statement| with argument _call_."],
    "head": {
      "idx": 0,
      "methodName": "HasCallInTailPosition",
      "prod": "WithStatement",
      "rhs": {
        "tokens": [{
          "term": "with"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (Statement \"HasCallInTailPosition\" call)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return HasCallInTailPosition of |LabelledItem| with argument _call_."],
    "head": {
      "idx": 0,
      "methodName": "HasCallInTailPosition",
      "prod": "LabelledStatement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LabelIdentifier",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "LabelledItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (LabelledItem \"HasCallInTailPosition\" call)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return HasCallInTailPosition of |Expression| with argument _call_."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "ReturnStatement",
      "rhs": {
        "tokens": [{
          "term": "return"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (Expression \"HasCallInTailPosition\" call)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return HasCallInTailPosition of |CaseBlock| with argument _call_."],
    "head": {
      "idx": 0,
      "methodName": "HasCallInTailPosition",
      "prod": "SwitchStatement",
      "rhs": {
        "tokens": [{
          "term": "switch"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "CaseBlock",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (CaseBlock \"HasCallInTailPosition\" call)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Let _has_ be *false*.", "          1. If the first |CaseClauses| is present, let _has_ be HasCallInTailPosition of the first |CaseClauses| with argument _call_.", "          1. If _has_ is *true*, return *true*.", "          1. Let _has_ be HasCallInTailPosition of |DefaultClause| with argument _call_.", "          1. If _has_ is *true*, return *true*.", "          1. If the second |CaseClauses| is present, let _has_ be HasCallInTailPosition of the second |CaseClauses| with argument _call_.", "          1. Return _has_."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "CaseBlock",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "CaseClauses",
          "optional": true
        }, {
          "args": [],
          "name": "DefaultClause",
          "optional": false
        }, {
          "args": [],
          "name": "CaseClauses",
          "optional": true
        }, {
          "term": "}"
        }]
      },
      "subIdx": 3,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "{\n  0:let has = false\n  1:if (! (= CaseClauses0 absent)) {\n    (0) access __x0__ = (CaseClauses0 \"HasCallInTailPosition\" call)\n    let has = __x0__\n  } else 0:{}\n  2:if (= has true) return true else 0:{}\n  3:(1) access __x1__ = (DefaultClause \"HasCallInTailPosition\" call)\n  3:let has = __x1__\n  4:if (= has true) return true else 0:{}\n  5:if (! (= CaseClauses1 absent)) {\n    (2) access __x2__ = (CaseClauses1 \"HasCallInTailPosition\" call)\n    let has = __x2__\n  } else 0:{}\n  6:return has\n}"
  }, {
    "code": ["          1. Let _has_ be HasCallInTailPosition of |CaseClauses| with argument _call_.", "          1. If _has_ is *true*, return *true*.", "          1. Return HasCallInTailPosition of |CaseClause| with argument _call_."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "CaseClauses",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CaseClauses",
          "optional": false
        }, {
          "args": [],
          "name": "CaseClause",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (CaseClauses \"HasCallInTailPosition\" call)\n  0:let has = __x0__\n  1:if (= has true) return true else 0:{}\n  2:(1) access __x1__ = (CaseClause \"HasCallInTailPosition\" call)\n  2:return __x1__\n}"
  }, {
    "code": ["          1. If |StatementList| is present, return HasCallInTailPosition of |StatementList| with argument _call_.", "          1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "HasCallInTailPosition",
      "prod": "CaseClause",
      "rhs": {
        "tokens": [{
          "term": "case"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "StatementList",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "{\n  0:if (! (= StatementList absent)) {\n    (0) access __x0__ = (StatementList \"HasCallInTailPosition\" call)\n    return __x0__\n  } else 0:{}\n  1:return false\n}"
  }, {
    "code": ["          1. If |StatementList| is present, return HasCallInTailPosition of |StatementList| with argument _call_.", "          1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "HasCallInTailPosition",
      "prod": "DefaultClause",
      "rhs": {
        "tokens": [{
          "term": "default"
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "StatementList",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "{\n  0:if (! (= StatementList absent)) {\n    (0) access __x0__ = (StatementList \"HasCallInTailPosition\" call)\n    return __x0__\n  } else 0:{}\n  1:return false\n}"
  }, {
    "code": ["          1. Return HasCallInTailPosition of |Catch| with argument _call_."],
    "head": {
      "idx": 0,
      "methodName": "HasCallInTailPosition",
      "prod": "TryStatement",
      "rhs": {
        "tokens": [{
          "term": "try"
        }, {
          "args": [],
          "name": "Block",
          "optional": false
        }, {
          "args": [],
          "name": "Catch",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (Catch \"HasCallInTailPosition\" call)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return HasCallInTailPosition of |Finally| with argument _call_."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "TryStatement",
      "rhs": {
        "tokens": [{
          "term": "try"
        }, {
          "args": [],
          "name": "Block",
          "optional": false
        }, {
          "args": [],
          "name": "Finally",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (Finally \"HasCallInTailPosition\" call)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return HasCallInTailPosition of |Finally| with argument _call_."],
    "head": {
      "idx": 2,
      "methodName": "HasCallInTailPosition",
      "prod": "TryStatement",
      "rhs": {
        "tokens": [{
          "term": "try"
        }, {
          "args": [],
          "name": "Block",
          "optional": false
        }, {
          "args": [],
          "name": "Catch",
          "optional": false
        }, {
          "args": [],
          "name": "Finally",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (Finally \"HasCallInTailPosition\" call)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return HasCallInTailPosition of |Block| with argument _call_."],
    "head": {
      "idx": 0,
      "methodName": "HasCallInTailPosition",
      "prod": "Catch",
      "rhs": {
        "tokens": [{
          "term": "catch"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "CatchParameter",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Block",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-statement-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (Block \"HasCallInTailPosition\" call)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "YieldExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "HasCallInTailPosition",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ArrowFunction",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 3,
      "methodName": "HasCallInTailPosition",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AsyncArrowFunction",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 4,
      "methodName": "HasCallInTailPosition",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "="
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 5,
      "methodName": "HasCallInTailPosition",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "args": [],
          "name": "AssignmentOperator",
          "optional": false
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 6,
      "methodName": "HasCallInTailPosition",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "&&="
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 7,
      "methodName": "HasCallInTailPosition",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "||="
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 8,
      "methodName": "HasCallInTailPosition",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "??="
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "BitwiseANDExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BitwiseANDExpression",
          "optional": false
        }, {
          "term": "&"
        }, {
          "args": [],
          "name": "EqualityExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "BitwiseXORExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BitwiseXORExpression",
          "optional": false
        }, {
          "term": "^"
        }, {
          "args": [],
          "name": "BitwiseANDExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "BitwiseORExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BitwiseORExpression",
          "optional": false
        }, {
          "term": "|"
        }, {
          "args": [],
          "name": "BitwiseXORExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "EqualityExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "EqualityExpression",
          "optional": false
        }, {
          "term": "=="
        }, {
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "HasCallInTailPosition",
      "prod": "EqualityExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "EqualityExpression",
          "optional": false
        }, {
          "term": "!="
        }, {
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 3,
      "methodName": "HasCallInTailPosition",
      "prod": "EqualityExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "EqualityExpression",
          "optional": false
        }, {
          "term": "==="
        }, {
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 4,
      "methodName": "HasCallInTailPosition",
      "prod": "EqualityExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "EqualityExpression",
          "optional": false
        }, {
          "term": "!=="
        }, {
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "RelationalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }, {
          "term": "<"
        }, {
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "HasCallInTailPosition",
      "prod": "RelationalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }, {
          "term": ">"
        }, {
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 3,
      "methodName": "HasCallInTailPosition",
      "prod": "RelationalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }, {
          "term": "<="
        }, {
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 4,
      "methodName": "HasCallInTailPosition",
      "prod": "RelationalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }, {
          "term": ">="
        }, {
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 5,
      "methodName": "HasCallInTailPosition",
      "prod": "RelationalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }, {
          "term": "instanceof"
        }, {
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 6,
      "methodName": "HasCallInTailPosition",
      "prod": "RelationalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RelationalExpression",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "ShiftExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }, {
          "term": "<<"
        }, {
          "args": [],
          "name": "AdditiveExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "HasCallInTailPosition",
      "prod": "ShiftExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }, {
          "term": ">>"
        }, {
          "args": [],
          "name": "AdditiveExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 3,
      "methodName": "HasCallInTailPosition",
      "prod": "ShiftExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ShiftExpression",
          "optional": false
        }, {
          "term": ">>>"
        }, {
          "args": [],
          "name": "AdditiveExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "AdditiveExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AdditiveExpression",
          "optional": false
        }, {
          "term": "+"
        }, {
          "args": [],
          "name": "MultiplicativeExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "HasCallInTailPosition",
      "prod": "AdditiveExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AdditiveExpression",
          "optional": false
        }, {
          "term": "-"
        }, {
          "args": [],
          "name": "MultiplicativeExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "MultiplicativeExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MultiplicativeExpression",
          "optional": false
        }, {
          "args": [],
          "name": "MultiplicativeOperator",
          "optional": false
        }, {
          "args": [],
          "name": "ExponentiationExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "ExponentiationExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "UpdateExpression",
          "optional": false
        }, {
          "term": "**"
        }, {
          "args": [],
          "name": "ExponentiationExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "UpdateExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "++"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "HasCallInTailPosition",
      "prod": "UpdateExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "--"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 3,
      "methodName": "HasCallInTailPosition",
      "prod": "UpdateExpression",
      "rhs": {
        "tokens": [{
          "term": "++"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 4,
      "methodName": "HasCallInTailPosition",
      "prod": "UpdateExpression",
      "rhs": {
        "tokens": [{
          "term": "--"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "term": "delete"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "HasCallInTailPosition",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "term": "void"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 3,
      "methodName": "HasCallInTailPosition",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "term": "typeof"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 4,
      "methodName": "HasCallInTailPosition",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "term": "+"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 5,
      "methodName": "HasCallInTailPosition",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "term": "-"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 6,
      "methodName": "HasCallInTailPosition",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "term": "~"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 7,
      "methodName": "HasCallInTailPosition",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "term": "!"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 8,
      "methodName": "HasCallInTailPosition",
      "prod": "UnaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AwaitExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "CallExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "SuperCall",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 4,
      "methodName": "HasCallInTailPosition",
      "prod": "CallExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CallExpression",
          "optional": false
        }, {
          "term": "["
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": "]"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 5,
      "methodName": "HasCallInTailPosition",
      "prod": "CallExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CallExpression",
          "optional": false
        }, {
          "term": "."
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "NewExpression",
      "rhs": {
        "tokens": [{
          "term": "new"
        }, {
          "args": [],
          "name": "NewExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "term": "["
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": "]"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "HasCallInTailPosition",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "term": "."
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 4,
      "methodName": "HasCallInTailPosition",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "SuperProperty",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 5,
      "methodName": "HasCallInTailPosition",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MetaProperty",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 6,
      "methodName": "HasCallInTailPosition",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "term": "new"
        }, {
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "args": [],
          "name": "Arguments",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "HasCallInTailPosition",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "term": "this"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "IdentifierReference",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "HasCallInTailPosition",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Literal",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 3,
      "methodName": "HasCallInTailPosition",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ArrayLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 4,
      "methodName": "HasCallInTailPosition",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ObjectLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 5,
      "methodName": "HasCallInTailPosition",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FunctionExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 6,
      "methodName": "HasCallInTailPosition",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ClassExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 7,
      "methodName": "HasCallInTailPosition",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "GeneratorExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 8,
      "methodName": "HasCallInTailPosition",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AsyncFunctionExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 9,
      "methodName": "HasCallInTailPosition",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AsyncGeneratorExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 10,
      "methodName": "HasCallInTailPosition",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RegularExpressionLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 11,
      "methodName": "HasCallInTailPosition",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "TemplateLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return HasCallInTailPosition of |AssignmentExpression| with argument _call_."],
    "head": {
      "idx": 0,
      "methodName": "HasCallInTailPosition",
      "prod": "Expression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (AssignmentExpression \"HasCallInTailPosition\" call)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return HasCallInTailPosition of |AssignmentExpression| with argument _call_."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "Expression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (AssignmentExpression \"HasCallInTailPosition\" call)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Let _has_ be HasCallInTailPosition of the first |AssignmentExpression| with argument _call_.", "          1. If _has_ is *true*, return *true*.", "          1. Return HasCallInTailPosition of the second |AssignmentExpression| with argument _call_."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "ConditionalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ShortCircuitExpression",
          "optional": false
        }, {
          "term": "?"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (AssignmentExpression0 \"HasCallInTailPosition\" call)\n  0:let has = __x0__\n  1:if (= has true) return true else 0:{}\n  2:(1) access __x1__ = (AssignmentExpression1 \"HasCallInTailPosition\" call)\n  2:return __x1__\n}"
  }, {
    "code": ["          1. Return HasCallInTailPosition of |BitwiseORExpression| with argument _call_."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "LogicalANDExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LogicalANDExpression",
          "optional": false
        }, {
          "term": "&&"
        }, {
          "args": [],
          "name": "BitwiseORExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (BitwiseORExpression \"HasCallInTailPosition\" call)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return HasCallInTailPosition of |LogicalANDExpression| with argument _call_."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "LogicalORExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LogicalORExpression",
          "optional": false
        }, {
          "term": "||"
        }, {
          "args": [],
          "name": "LogicalANDExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (LogicalANDExpression \"HasCallInTailPosition\" call)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return HasCallInTailPosition of |BitwiseORExpression| with argument _call_."],
    "head": {
      "idx": 0,
      "methodName": "HasCallInTailPosition",
      "prod": "CoalesceExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CoalesceExpressionHead",
          "optional": false
        }, {
          "term": "??"
        }, {
          "args": [],
          "name": "BitwiseORExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (BitwiseORExpression \"HasCallInTailPosition\" call)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. If this |CallExpression| is _call_, return *true*.", "          1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "HasCallInTailPosition",
      "prod": "CallExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CoverCallExpressionAndAsyncArrowHead",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "{\n  0:if (= this call) return true else 0:{}\n  1:return false\n}"
  }, {
    "code": ["          1. If this |CallExpression| is _call_, return *true*.", "          1. Return *false*."],
    "head": {
      "idx": 3,
      "methodName": "HasCallInTailPosition",
      "prod": "CallExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CallExpression",
          "optional": false
        }, {
          "args": [],
          "name": "Arguments",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "{\n  0:if (= this call) return true else 0:{}\n  1:return false\n}"
  }, {
    "code": ["          1. If this |CallExpression| is _call_, return *true*.", "          1. Return *false*."],
    "head": {
      "idx": 6,
      "methodName": "HasCallInTailPosition",
      "prod": "CallExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CallExpression",
          "optional": false
        }, {
          "args": [],
          "name": "TemplateLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "{\n  0:if (= this call) return true else 0:{}\n  1:return false\n}"
  }, {
    "code": ["          1. Return HasCallInTailPosition of |OptionalChain| with argument _call_."],
    "head": {
      "idx": 0,
      "methodName": "HasCallInTailPosition",
      "prod": "OptionalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "args": [],
          "name": "OptionalChain",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (OptionalChain \"HasCallInTailPosition\" call)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return HasCallInTailPosition of |OptionalChain| with argument _call_."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "OptionalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CallExpression",
          "optional": false
        }, {
          "args": [],
          "name": "OptionalChain",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (OptionalChain \"HasCallInTailPosition\" call)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return HasCallInTailPosition of |OptionalChain| with argument _call_."],
    "head": {
      "idx": 2,
      "methodName": "HasCallInTailPosition",
      "prod": "OptionalExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "OptionalExpression",
          "optional": false
        }, {
          "args": [],
          "name": "OptionalChain",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (OptionalChain \"HasCallInTailPosition\" call)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "HasCallInTailPosition",
      "prod": "OptionalChain",
      "rhs": {
        "tokens": [{
          "term": "?."
        }, {
          "term": "["
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": "]"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 2,
      "methodName": "HasCallInTailPosition",
      "prod": "OptionalChain",
      "rhs": {
        "tokens": [{
          "term": "?."
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 5,
      "methodName": "HasCallInTailPosition",
      "prod": "OptionalChain",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "OptionalChain",
          "optional": false
        }, {
          "term": "["
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": "]"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 6,
      "methodName": "HasCallInTailPosition",
      "prod": "OptionalChain",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "OptionalChain",
          "optional": false
        }, {
          "term": "."
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "return false"
  }, {
    "code": ["          1. If this |OptionalChain| is _call_, return *true*.", "          1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "HasCallInTailPosition",
      "prod": "OptionalChain",
      "rhs": {
        "tokens": [{
          "term": "?."
        }, {
          "args": [],
          "name": "Arguments",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "{\n  0:if (= this call) return true else 0:{}\n  1:return false\n}"
  }, {
    "code": ["          1. If this |OptionalChain| is _call_, return *true*.", "          1. Return *false*."],
    "head": {
      "idx": 4,
      "methodName": "HasCallInTailPosition",
      "prod": "OptionalChain",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "OptionalChain",
          "optional": false
        }, {
          "args": [],
          "name": "Arguments",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "{\n  0:if (= this call) return true else 0:{}\n  1:return false\n}"
  }, {
    "code": ["          1. If this |MemberExpression| is _call_, return *true*.", "          1. Return *false*."],
    "head": {
      "idx": 3,
      "methodName": "HasCallInTailPosition",
      "prod": "MemberExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MemberExpression",
          "optional": false
        }, {
          "args": [],
          "name": "TemplateLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "{\n  0:if (= this call) return true else 0:{}\n  1:return false\n}"
  }, {
    "code": ["          1. Let _expr_ be CoveredParenthesizedExpression of |CoverParenthesizedExpressionAndArrowParameterList|.", "          1. Return HasCallInTailPosition of _expr_ with argument _call_."],
    "head": {
      "idx": 12,
      "methodName": "HasCallInTailPosition",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CoverParenthesizedExpressionAndArrowParameterList",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (CoverParenthesizedExpressionAndArrowParameterList \"CoveredParenthesizedExpression\")\n  0:let expr = __x0__\n  1:(1) access __x1__ = (expr \"HasCallInTailPosition\" call)\n  1:return __x1__\n}"
  }, {
    "code": ["          1. Return HasCallInTailPosition of |Expression| with argument _call_."],
    "head": {
      "idx": 0,
      "methodName": "HasCallInTailPosition",
      "prod": "ParenthesizedExpression",
      "rhs": {
        "tokens": [{
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "sec-expression-rules",
    "rawBody": "{\n  0:(0) access __x0__ = (Expression \"HasCallInTailPosition\" call)\n  0:return __x0__\n}"
  }, {
    "code": ["        1. Let _leafContext_ be the running execution context.", "        1. Suspend _leafContext_.", "        1. Pop _leafContext_ from the execution context stack. The execution context now on the top of the stack becomes the running execution context.", "        1. Assert: _leafContext_ has no further use. It will never be activated as the running execution context."],
    "head": {
      "name": "PrepareForTailCall",
      "params": []
    },
    "ids": "sec-preparefortailcall",
    "rawBody": "{\n  0:let leafContext = CONTEXT\n  1:CONTEXT = null\n  2:(0) ??? \"Pop id:{leafContext} from the execution context stack . The execution context now on the top of the stack becomes the running execution context .\"\n}"
  }, {
    "code": ["        1. If |ScriptBody| is present and the Directive Prologue of |ScriptBody| contains a Use Strict Directive, return *true*; otherwise, return *false*."],
    "head": {
      "idx": 0,
      "methodName": "IsStrict",
      "prod": "Script",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ScriptBody",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-isstrict",
    "rawBody": "(0) ??? \"If nt:{ScriptBody} is present and the Directive Prologue of nt:{ScriptBody} contains a Use Strict Directive , return value:{true} ; otherwise , return value:{false} .\""
  }, {
    "code": ["        1. Return NormalCompletion(*undefined*)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "Script",
      "rhs": {
        "tokens": [{
          "empty": null
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-script-semantics-runtime-semantics-evaluation",
    "rawBody": "return undefined"
  }, {
    "code": ["        1. Assert: _sourceText_ is an ECMAScript source text (see clause <emu-xref href=\"#sec-ecmascript-language-source-code\"></emu-xref>).", "        1. Let _body_ be ParseText(_sourceText_, |Script|).", "        1. If _body_ is a List of errors, return _body_.", "        1. Return Script Record { [[Realm]]: _realm_, [[Environment]]: *undefined*, [[ECMAScriptCode]]: _body_, [[HostDefined]]: _hostDefined_ }."],
    "head": {
      "name": "ParseScript",
      "params": [{
        "kind": "Normal",
        "name": "sourceText"
      }, {
        "kind": "Normal",
        "name": "realm"
      }, {
        "kind": "Normal",
        "name": "hostDefined"
      }]
    },
    "ids": "sec-parse-script",
    "rawBody": "{\n  1:let body = sourceText\n  3:return (0) (new ScriptRecord(\"Realm\" -> realm, \"Environment\" -> undefined, \"ECMAScriptCode\" -> body, \"HostDefined\" -> hostDefined))\n}"
  }, {
    "code": ["        1. Let _globalEnv_ be _scriptRecord_.[[Realm]].[[GlobalEnv]].", "        1. Let _scriptContext_ be a new ECMAScript code execution context.", "        1. Set the Function of _scriptContext_ to *null*.", "        1. Set the Realm of _scriptContext_ to _scriptRecord_.[[Realm]].", "        1. Set the ScriptOrModule of _scriptContext_ to _scriptRecord_.", "        1. Set the VariableEnvironment of _scriptContext_ to _globalEnv_.", "        1. Set the LexicalEnvironment of _scriptContext_ to _globalEnv_.", "        1. Suspend the currently running execution context.", "        1. Push _scriptContext_ onto the execution context stack; _scriptContext_ is now the running execution context.", "        1. Let _scriptBody_ be _scriptRecord_.[[ECMAScriptCode]].", "        1. Let _result_ be GlobalDeclarationInstantiation(_scriptBody_, _globalEnv_).", "        1. If _result_.[[Type]] is ~normal~, then", "          1. Set _result_ to the result of evaluating _scriptBody_.", "        1. If _result_.[[Type]] is ~normal~ and _result_.[[Value]] is ~empty~, then", "          1. Set _result_ to NormalCompletion(*undefined*).", "        1. Suspend _scriptContext_ and remove it from the execution context stack.", "        1. Assert: The execution context stack is not empty.", "        1. Resume the context that is now on the top of the execution context stack as the running execution context.", "        1. Return Completion(_result_)."],
    "head": {
      "name": "ScriptEvaluation",
      "params": [{
        "kind": "Normal",
        "name": "scriptRecord"
      }]
    },
    "ids": "sec-runtime-semantics-scriptevaluation",
    "rawBody": "{\n  0:let globalEnv = scriptRecord[\"Realm\"][\"GlobalEnv\"]\n  1:let scriptContext = (0) (new ExecutionContext())\n  2:scriptContext[\"Function\"] = null\n  3:scriptContext[\"Realm\"] = scriptRecord[\"Realm\"]\n  4:scriptContext[\"ScriptOrModule\"] = scriptRecord\n  5:scriptContext[\"VariableEnvironment\"] = globalEnv\n  6:scriptContext[\"LexicalEnvironment\"] = globalEnv\n  7:CONTEXT = null\n  8:append scriptContext -> EXECUTION_STACK\n  8:CONTEXT = EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)]\n  9:let scriptBody = scriptRecord[\"ECMAScriptCode\"]\n  10:(0) app __x0__ = (GlobalDeclarationInstantiation scriptBody globalEnv)\n  10:let result = __x0__\n  11:if (= result[\"Type\"] CONST_normal) {\n    12:(1) access __x1__ = (scriptBody \"Evaluation\")\n    12:result = __x1__\n  } else 2:{}\n  13:if (&& (= result[\"Type\"] CONST_normal) (= result[\"Value\"] CONST_empty)) {\n    14:(2) app __x2__ = (NormalCompletion undefined)\n    14:result = __x2__\n  } else 2:{}\n  15:CONTEXT = null\n  15:if (= EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)] scriptContext) (pop EXECUTION_STACK (- EXECUTION_STACK[\"length\"] 1i)) else 2:{}\n  16:assert (< 0i EXECUTION_STACK[\"length\"])\n  17:CONTEXT = EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)]\n  18:return result\n}"
  }, {
    "code": ["        1. Assert: _env_ is a global Environment Record.", "        1. Let _lexNames_ be the LexicallyDeclaredNames of _script_.", "        1. Let _varNames_ be the VarDeclaredNames of _script_.", "        1. For each element _name_ of _lexNames_, do", "          1. If _env_.HasVarDeclaration(_name_) is *true*, throw a *SyntaxError* exception.", "          1. If _env_.HasLexicalDeclaration(_name_) is *true*, throw a *SyntaxError* exception.", "          1. Let _hasRestrictedGlobal_ be ? _env_.HasRestrictedGlobalProperty(_name_).", "          1. If _hasRestrictedGlobal_ is *true*, throw a *SyntaxError* exception.", "        1. For each element _name_ of _varNames_, do", "          1. If _env_.HasLexicalDeclaration(_name_) is *true*, throw a *SyntaxError* exception.", "        1. Let _varDeclarations_ be the VarScopedDeclarations of _script_.", "        1. Let _functionsToInitialize_ be a new empty List.", "        1. Let _declaredFunctionNames_ be a new empty List.", "        1. For each element _d_ of _varDeclarations_, in reverse List order, do", "          1. If _d_ is neither a |VariableDeclaration| nor a |ForBinding| nor a |BindingIdentifier|, then", "            1. Assert: _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|.", "            1. NOTE: If there are multiple function declarations for the same name, the last declaration is used.", "            1. Let _fn_ be the sole element of the BoundNames of _d_.", "            1. If _fn_ is not an element of _declaredFunctionNames_, then", "              1. Let _fnDefinable_ be ? _env_.CanDeclareGlobalFunction(_fn_).", "              1. If _fnDefinable_ is *false*, throw a *TypeError* exception.", "              1. Append _fn_ to _declaredFunctionNames_.", "              1. Insert _d_ as the first element of _functionsToInitialize_.", "        1. Let _declaredVarNames_ be a new empty List.", "        1. For each element _d_ of _varDeclarations_, do", "          1. If _d_ is a |VariableDeclaration|, a |ForBinding|, or a |BindingIdentifier|, then", "            1. For each String _vn_ of the BoundNames of _d_, do", "              1. If _vn_ is not an element of _declaredFunctionNames_, then", "                1. Let _vnDefinable_ be ? _env_.CanDeclareGlobalVar(_vn_).", "                1. If _vnDefinable_ is *false*, throw a *TypeError* exception.", "                1. If _vn_ is not an element of _declaredVarNames_, then", "                  1. Append _vn_ to _declaredVarNames_.", "        1. NOTE: No abnormal terminations occur after this algorithm step if the global object is an ordinary object. However, if the global object is a Proxy exotic object it may exhibit behaviours that cause abnormal terminations in some of the following steps.", "        1. [id=\"step-globaldeclarationinstantiation-web-compat-insertion-point\"] NOTE: Annex <emu-xref href=\"#sec-web-compat-globaldeclarationinstantiation\"></emu-xref> adds additional steps at this point.", "        1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _script_.", "        1. For each element _d_ of _lexDeclarations_, do", "          1. NOTE: Lexically declared names are only instantiated here but not initialized.", "          1. For each element _dn_ of the BoundNames of _d_, do", "            1. If IsConstantDeclaration of _d_ is *true*, then", "              1. Perform ? _env_.CreateImmutableBinding(_dn_, *true*).", "            1. Else,", "              1. Perform ? _env_.CreateMutableBinding(_dn_, *false*).", "        1. For each Parse Node _f_ of _functionsToInitialize_, do", "          1. Let _fn_ be the sole element of the BoundNames of _f_.", "          1. Let _fo_ be InstantiateFunctionObject of _f_ with argument _env_.", "          1. Perform ? _env_.CreateGlobalFunctionBinding(_fn_, _fo_, *false*).", "        1. For each String _vn_ of _declaredVarNames_, do", "          1. Perform ? _env_.CreateGlobalVarBinding(_vn_, *false*).", "        1. Return NormalCompletion(~empty~)."],
    "head": {
      "name": "GlobalDeclarationInstantiation",
      "params": [{
        "kind": "Normal",
        "name": "script"
      }, {
        "kind": "Normal",
        "name": "env"
      }]
    },
    "ids": "sec-globaldeclarationinstantiation",
    "rawBody": "{\n  0:assert (0) (is-instance-of env GlobalEnvironmentRecord)\n  1:(0) access __x0__ = (script \"LexicallyDeclaredNames\")\n  1:let lexNames = __x0__\n  2:(1) access __x1__ = (script \"VarDeclaredNames\")\n  2:let varNames = __x1__\n  3:let __x2__ = lexNames\n  3:let __x3__ = 0i\n  3:while (< __x3__ __x2__[\"length\"]) {\n    let name = __x2__[__x3__]\n    4:(2) app __x4__ = (env[\"HasVarDeclaration\"] env name)\n    4:if (= __x4__ true) (1) throw SyntaxError else 36:{}\n    5:(3) app __x5__ = (env[\"HasLexicalDeclaration\"] env name)\n    5:if (= __x5__ true) (2) throw SyntaxError else 36:{}\n    6:(4) app __x6__ = (env[\"HasRestrictedGlobalProperty\"] env name)\n    6:let hasRestrictedGlobal = [? __x6__]\n    7:if (= hasRestrictedGlobal true) (3) throw SyntaxError else 36:{}\n    __x3__ = (+ __x3__ 1i)\n  }\n  8:let __x7__ = varNames\n  8:let __x8__ = 0i\n  8:while (< __x8__ __x7__[\"length\"]) {\n    let name = __x7__[__x8__]\n    9:(5) app __x9__ = (env[\"HasLexicalDeclaration\"] env name)\n    9:if (= __x9__ true) (4) throw SyntaxError else 36:{}\n    __x8__ = (+ __x8__ 1i)\n  }\n  10:(6) access __x10__ = (script \"VarScopedDeclarations\")\n  10:let varDeclarations = __x10__\n  11:let functionsToInitialize = (5) (new [])\n  12:let declaredFunctionNames = (6) (new [])\n  13:let __x11__ = varDeclarations\n  13:let __x12__ = __x11__[\"length\"]\n  13:while (< 0i __x12__) {\n    __x12__ = (- __x12__ 1i)\n    let d = __x11__[__x12__]\n    14:if (! (|| (|| (7) (is-instance-of d VariableDeclaration) (8) (is-instance-of d ForBinding)) (9) (is-instance-of d BindingIdentifier))) {\n      15:assert (|| (|| (|| (10) (is-instance-of d FunctionDeclaration) (11) (is-instance-of d GeneratorDeclaration)) (12) (is-instance-of d AsyncFunctionDeclaration)) (13) (is-instance-of d AsyncGeneratorDeclaration))\n      17:(7) access __x13__ = (d \"BoundNames\")\n      17:let fn = __x13__[0i]\n      18:if (! (contains declaredFunctionNames fn)) {\n        19:(8) app __x14__ = (env[\"CanDeclareGlobalFunction\"] env fn)\n        19:let fnDefinable = [? __x14__]\n        20:if (= fnDefinable false) (14) throw TypeError else 36:{}\n        21:append fn -> declaredFunctionNames\n        22:prepend d -> functionsToInitialize\n      } else 36:{}\n    } else 36:{}\n  }\n  23:let declaredVarNames = (15) (new [])\n  24:let __x15__ = varDeclarations\n  24:let __x16__ = 0i\n  24:while (< __x16__ __x15__[\"length\"]) {\n    let d = __x15__[__x16__]\n    25:if (|| (|| (16) (is-instance-of d VariableDeclaration) (17) (is-instance-of d ForBinding)) (18) (is-instance-of d BindingIdentifier)) {\n      26:(9) access __x17__ = (d \"BoundNames\")\n      26:let __x18__ = __x17__\n      26:let __x19__ = 0i\n      26:while (< __x19__ __x18__[\"length\"]) {\n        let vn = __x18__[__x19__]\n        27:if (! (contains declaredFunctionNames vn)) {\n          28:(10) app __x20__ = (env[\"CanDeclareGlobalVar\"] env vn)\n          28:let vnDefinable = [? __x20__]\n          29:if (= vnDefinable false) (19) throw TypeError else 36:{}\n          30:if (! (contains declaredVarNames vn)) append vn -> declaredVarNames else 36:{}\n        } else 36:{}\n        __x19__ = (+ __x19__ 1i)\n      }\n    } else 36:{}\n    __x16__ = (+ __x16__ 1i)\n  }\n  34:(11) access __x21__ = (script \"LexicallyScopedDeclarations\")\n  34:let lexDeclarations = __x21__\n  35:let __x22__ = lexDeclarations\n  35:let __x23__ = 0i\n  35:while (< __x23__ __x22__[\"length\"]) {\n    let d = __x22__[__x23__]\n    37:(12) access __x24__ = (d \"BoundNames\")\n    37:let __x25__ = __x24__\n    37:let __x26__ = 0i\n    37:while (< __x26__ __x25__[\"length\"]) {\n      let dn = __x25__[__x26__]\n      40:(13) access __x27__ = (d \"IsConstantDeclaration\")\n      40:if (= __x27__ true) {\n        39:(14) app __x28__ = (env[\"CreateImmutableBinding\"] env dn true)\n        39:[? __x28__]\n      } else {\n        41:(15) app __x29__ = (env[\"CreateMutableBinding\"] env dn false)\n        41:[? __x29__]\n      }\n      __x26__ = (+ __x26__ 1i)\n    }\n    __x23__ = (+ __x23__ 1i)\n  }\n  42:let __x30__ = functionsToInitialize\n  42:let __x31__ = 0i\n  42:while (< __x31__ __x30__[\"length\"]) {\n    let f = __x30__[__x31__]\n    43:(16) access __x32__ = (f \"BoundNames\")\n    43:let fn = __x32__[0i]\n    44:(17) access __x33__ = (f \"InstantiateFunctionObject\" env)\n    44:let fo = __x33__\n    45:(18) app __x34__ = (env[\"CreateGlobalFunctionBinding\"] env fn fo false)\n    45:[? __x34__]\n    __x31__ = (+ __x31__ 1i)\n  }\n  46:let __x35__ = declaredVarNames\n  46:let __x36__ = 0i\n  46:while (< __x36__ __x35__[\"length\"]) {\n    let vn = __x35__[__x36__]\n    47:(19) app __x37__ = (env[\"CreateGlobalVarBinding\"] env vn false)\n    47:[? __x37__]\n    __x36__ = (+ __x36__ 1i)\n  }\n  48:return CONST_empty\n}"
  }, {
    "code": ["          1. Let _localNames_ be a new empty List.", "          1. For each ImportEntry Record _i_ of _importEntries_, do", "            1. Append _i_.[[LocalName]] to _localNames_.", "          1. Return _localNames_."],
    "head": {
      "name": "ImportedLocalNames",
      "params": [{
        "kind": "Normal",
        "name": "importEntries"
      }]
    },
    "ids": "sec-importedlocalnames",
    "rawBody": "{\n  0:let localNames = (0) (new [])\n  1:let __x0__ = importEntries\n  1:let __x1__ = 0i\n  1:while (< __x1__ __x0__[\"length\"]) {\n    let i = __x0__[__x1__]\n    2:append i[\"LocalName\"] -> localNames\n    __x1__ = (+ __x1__ 1i)\n  }\n  3:return localNames\n}"
  }, {
    "code": ["          1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "ModuleRequests",
      "prod": "Module",
      "rhs": {
        "tokens": [{
          "empty": null
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-modulerequests",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["          1. Return ModuleRequests of |ModuleItem|."],
    "head": {
      "idx": 0,
      "methodName": "ModuleRequests",
      "prod": "ModuleItemList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ModuleItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-modulerequests",
    "rawBody": "{\n  0:(0) access __x0__ = (ModuleItem \"ModuleRequests\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Let _moduleNames_ be ModuleRequests of |ModuleItemList|.", "          1. Let _additionalNames_ be ModuleRequests of |ModuleItem|.", "          1. Append to _moduleNames_ each element of _additionalNames_ that is not already an element of _moduleNames_.", "          1. Return _moduleNames_."],
    "head": {
      "idx": 1,
      "methodName": "ModuleRequests",
      "prod": "ModuleItemList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ModuleItemList",
          "optional": false
        }, {
          "args": [],
          "name": "ModuleItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-modulerequests",
    "rawBody": "{\n  0:(0) access __x0__ = (ModuleItemList \"ModuleRequests\")\n  0:let moduleNames = __x0__\n  1:(1) access __x1__ = (ModuleItem \"ModuleRequests\")\n  1:let additionalNames = __x1__\n  2:let __i__ = 0i\n  2:while (< __i__ additionalNames[\"length\"]) if (contains moduleNames additionalNames[__i__]) {} else append additionalNames[__i__] -> moduleNames\n  3:return moduleNames\n}"
  }, {
    "code": ["          1. Return a new empty List."],
    "head": {
      "idx": 2,
      "methodName": "ModuleRequests",
      "prod": "ModuleItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StatementListItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-modulerequests",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["          1. Return ModuleRequests of |FromClause|."],
    "head": {
      "idx": 0,
      "methodName": "ModuleRequests",
      "prod": "ImportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "import"
        }, {
          "args": [],
          "name": "ImportClause",
          "optional": false
        }, {
          "args": [],
          "name": "FromClause",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-modulerequests",
    "rawBody": "{\n  0:(0) access __x0__ = (FromClause \"ModuleRequests\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return a List whose sole element is the SV of |StringLiteral|."],
    "head": {
      "idx": 0,
      "methodName": "ModuleRequests",
      "prod": "ModuleSpecifier",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StringLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-modulerequests",
    "rawBody": "{\n  0:(0) access __x0__ = (StringLiteral \"SV\")\n  0:return (0) (new [__x0__])\n}"
  }, {
    "code": ["          1. Return the ModuleRequests of |FromClause|."],
    "head": {
      "idx": 0,
      "methodName": "ModuleRequests",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "ExportFromClause",
          "optional": false
        }, {
          "args": [],
          "name": "FromClause",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-modulerequests",
    "rawBody": "{\n  0:(0) access __x0__ = (FromClause \"ModuleRequests\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return a new empty List."],
    "head": {
      "idx": 1,
      "methodName": "ModuleRequests",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "NamedExports",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-modulerequests",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["          1. Return a new empty List."],
    "head": {
      "idx": 2,
      "methodName": "ModuleRequests",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "VariableStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-modulerequests",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["          1. Return a new empty List."],
    "head": {
      "idx": 3,
      "methodName": "ModuleRequests",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "Declaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-modulerequests",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["          1. Return a new empty List."],
    "head": {
      "idx": 4,
      "methodName": "ModuleRequests",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "term": "default"
        }, {
          "args": [],
          "name": "HoistableDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-modulerequests",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["          1. Return a new empty List."],
    "head": {
      "idx": 5,
      "methodName": "ModuleRequests",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "term": "default"
        }, {
          "args": [],
          "name": "ClassDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-modulerequests",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["          1. Return a new empty List."],
    "head": {
      "idx": 6,
      "methodName": "ModuleRequests",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "term": "default"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-modulerequests",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["            1. Assert: _module_.[[Status]] is not ~linking~ or ~evaluating~.", "            1. Let _stack_ be a new empty List.", "            1. Let _result_ be InnerModuleLinking(_module_, _stack_, 0).", "            1. If _result_ is an abrupt completion, then", "              1. For each Cyclic Module Record _m_ of _stack_, do", "                1. Assert: _m_.[[Status]] is ~linking~.", "                1. Set _m_.[[Status]] to ~unlinked~.", "                1. Set _m_.[[Environment]] to *undefined*.", "                1. Set _m_.[[DFSIndex]] to *undefined*.", "                1. Set _m_.[[DFSAncestorIndex]] to *undefined*.", "              1. Assert: _module_.[[Status]] is ~unlinked~.", "              1. Return _result_.", "            1. Assert: _module_.[[Status]] is ~linked~ or ~evaluated~.", "            1. Assert: _stack_ is empty.", "            1. Return *undefined*."],
    "head": {
      "name": "Link",
      "params": []
    },
    "ids": "sec-moduledeclarationlinking",
    "rawBody": "{\n  0:assert (! (|| (= module[\"Status\"] CONST_linking) (= module[\"Status\"] CONST_evaluating)))\n  1:let stack = (0) (new [])\n  2:(0) app __x0__ = (InnerModuleLinking module stack 0i)\n  2:let result = __x0__\n  3:(1) app __x1__ = (IsAbruptCompletion result)\n  3:if __x1__ {\n    4:let __x2__ = stack\n    4:let __x3__ = 0i\n    4:while (< __x3__ __x2__[\"length\"]) {\n      let m = __x2__[__x3__]\n      5:assert (= m[\"Status\"] CONST_linking)\n      6:m[\"Status\"] = CONST_unlinked\n      7:m[\"Environment\"] = undefined\n      8:m[\"DFSIndex\"] = undefined\n      9:m[\"DFSAncestorIndex\"] = undefined\n      __x3__ = (+ __x3__ 1i)\n    }\n    10:assert (= module[\"Status\"] CONST_unlinked)\n    11:return result\n  } else 36:{}\n  12:assert (|| (= module[\"Status\"] CONST_linked) (= module[\"Status\"] CONST_evaluated))\n  13:assert (= stack[\"length\"] 0i)\n  14:return undefined\n}"
  }, {
    "code": ["              1. If _module_ is not a Cyclic Module Record, then", "                1. Perform ? _module_.Link().", "                1. Return _index_.", "              1. If _module_.[[Status]] is ~linking~, ~linked~, or ~evaluated~, then", "                1. Return _index_.", "              1. Assert: _module_.[[Status]] is ~unlinked~.", "              1. Set _module_.[[Status]] to ~linking~.", "              1. Set _module_.[[DFSIndex]] to _index_.", "              1. Set _module_.[[DFSAncestorIndex]] to _index_.", "              1. Set _index_ to _index_ + 1.", "              1. Append _module_ to _stack_.", "              1. For each String _required_ of _module_.[[RequestedModules]], do", "                1. Let _requiredModule_ be ? HostResolveImportedModule(_module_, _required_).", "                1. Set _index_ to ? InnerModuleLinking(_requiredModule_, _stack_, _index_).", "                1. If _requiredModule_ is a Cyclic Module Record, then", "                  1. Assert: _requiredModule_.[[Status]] is either ~linking~, ~linked~, or ~evaluated~.", "                  1. Assert: _requiredModule_.[[Status]] is ~linking~ if and only if _requiredModule_ is in _stack_.", "                  1. If _requiredModule_.[[Status]] is ~linking~, then", "                    1. Set _module_.[[DFSAncestorIndex]] to min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]).", "              1. Perform ? _module_.InitializeEnvironment().", "              1. Assert: _module_ occurs exactly once in _stack_.", "              1. Assert: _module_.[[DFSAncestorIndex]] ≤ _module_.[[DFSIndex]].", "              1. If _module_.[[DFSAncestorIndex]] = _module_.[[DFSIndex]], then", "                1. Let _done_ be *false*.", "                1. Repeat, while _done_ is *false*,", "                  1. Let _requiredModule_ be the last element in _stack_.", "                  1. Remove the last element of _stack_.", "                  1. Assert: _requiredModule_ is a Cyclic Module Record.", "                  1. Set _requiredModule_.[[Status]] to ~linked~.", "                  1. If _requiredModule_ and _module_ are the same Module Record, set _done_ to *true*.", "              1. Return _index_."],
    "head": {
      "name": "InnerModuleLinking",
      "params": [{
        "kind": "Normal",
        "name": "module"
      }, {
        "kind": "Normal",
        "name": "stack"
      }, {
        "kind": "Normal",
        "name": "index"
      }]
    },
    "ids": "sec-InnerModuleLinking",
    "rawBody": "{\n  0:if (! (0) (is-instance-of module CyclicModuleRecord)) {\n    1:(0) app __x0__ = (module[\"Link\"] module)\n    1:[? __x0__]\n    2:return index\n  } else 20:{}\n  3:if (|| (|| (= module[\"Status\"] CONST_linking) (= module[\"Status\"] CONST_linked)) (= module[\"Status\"] CONST_evaluated)) return index else 20:{}\n  5:assert (= module[\"Status\"] CONST_unlinked)\n  6:module[\"Status\"] = CONST_linking\n  7:module[\"DFSIndex\"] = index\n  8:module[\"DFSAncestorIndex\"] = index\n  9:index = (+ index 1i)\n  10:append module -> stack\n  11:let __x1__ = module[\"RequestedModules\"]\n  11:let __x2__ = 0i\n  11:while (< __x2__ __x1__[\"length\"]) {\n    let required = __x1__[__x2__]\n    12:(1) app __x3__ = (HostResolveImportedModule module required)\n    12:let requiredModule = [? __x3__]\n    13:(2) app __x4__ = (InnerModuleLinking requiredModule stack index)\n    13:index = [? __x4__]\n    14:if (1) (is-instance-of requiredModule CyclicModuleRecord) {\n      15:assert (|| (|| (= requiredModule[\"Status\"] CONST_linking) (= requiredModule[\"Status\"] CONST_linked)) (= requiredModule[\"Status\"] CONST_evaluated))\n      17:if (= requiredModule[\"Status\"] CONST_linking) {\n        18:(3) app __x5__ = (min module[\"DFSAncestorIndex\"] requiredModule[\"DFSAncestorIndex\"])\n        18:module[\"DFSAncestorIndex\"] = __x5__\n      } else 20:{}\n    } else 20:{}\n    __x2__ = (+ __x2__ 1i)\n  }\n  19:(4) app __x6__ = (module[\"InitializeEnvironment\"] module)\n  19:[? __x6__]\n  21:assert (! (< module[\"DFSIndex\"] module[\"DFSAncestorIndex\"]))\n  22:if (== module[\"DFSAncestorIndex\"] module[\"DFSIndex\"]) {\n    23:let done = false\n    24:while (= done false) {\n      25:let requiredModule = stack[(- stack[\"length\"] 1i)]\n      26:(pop stack (- stack[\"length\"] 1i))\n      27:assert (2) (is-instance-of requiredModule CyclicModuleRecord)\n      28:requiredModule[\"Status\"] = CONST_linked\n      29:if (= requiredModule module) done = true else 20:{}\n    }\n  } else 20:{}\n  30:return index\n}"
  }, {
    "code": ["            1. Assert: This call to Evaluate is not happening at the same time as another call to Evaluate within the surrounding agent.", "            1. Assert: _module_.[[Status]] is ~linked~ or ~evaluated~.", "            1. Let _stack_ be a new empty List.", "            1. Let _result_ be InnerModuleEvaluation(_module_, _stack_, 0).", "            1. If _result_ is an abrupt completion, then", "              1. For each Cyclic Module Record _m_ of _stack_, do", "                1. Assert: _m_.[[Status]] is ~evaluating~.", "                1. Set _m_.[[Status]] to ~evaluated~.", "                1. Set _m_.[[EvaluationError]] to _result_.", "              1. Assert: _module_.[[Status]] is ~evaluated~ and _module_.[[EvaluationError]] is _result_.", "              1. Return _result_.", "            1. Assert: _module_.[[Status]] is ~evaluated~ and _module_.[[EvaluationError]] is *undefined*.", "            1. Assert: _stack_ is empty.", "            1. Return *undefined*."],
    "head": {
      "name": "Evaluate",
      "params": []
    },
    "ids": "sec-moduleevaluation",
    "rawBody": "{\n  1:assert (|| (= module[\"Status\"] CONST_linked) (= module[\"Status\"] CONST_evaluated))\n  2:let stack = (0) (new [])\n  3:(0) app __x0__ = (InnerModuleEvaluation module stack 0i)\n  3:let result = __x0__\n  4:(1) app __x1__ = (IsAbruptCompletion result)\n  4:if __x1__ {\n    5:let __x2__ = stack\n    5:let __x3__ = 0i\n    5:while (< __x3__ __x2__[\"length\"]) {\n      let m = __x2__[__x3__]\n      6:assert (= m[\"Status\"] CONST_evaluating)\n      7:m[\"Status\"] = CONST_evaluated\n      8:m[\"EvaluationError\"] = result\n      __x3__ = (+ __x3__ 1i)\n    }\n    9:assert (&& (= module[\"Status\"] CONST_evaluated) (= module[\"EvaluationError\"] result))\n    10:return result\n  } else 0:{}\n  11:assert (&& (= module[\"Status\"] CONST_evaluated) (= module[\"EvaluationError\"] undefined))\n  12:assert (= stack[\"length\"] 0i)\n  13:return undefined\n}"
  }, {
    "code": ["              1. If _module_ is not a Cyclic Module Record, then", "                1. Perform ? _module_.Evaluate().", "                1. Return _index_.", "              1. If _module_.[[Status]] is ~evaluated~, then", "                1. If _module_.[[EvaluationError]] is *undefined*, return _index_.", "                1. Otherwise, return _module_.[[EvaluationError]].", "              1. If _module_.[[Status]] is ~evaluating~, return _index_.", "              1. Assert: _module_.[[Status]] is ~linked~.", "              1. Set _module_.[[Status]] to ~evaluating~.", "              1. Set _module_.[[DFSIndex]] to _index_.", "              1. Set _module_.[[DFSAncestorIndex]] to _index_.", "              1. Set _index_ to _index_ + 1.", "              1. Append _module_ to _stack_.", "              1. For each String _required_ of _module_.[[RequestedModules]], do", "                1. Let _requiredModule_ be ! HostResolveImportedModule(_module_, _required_).", "                1. NOTE: Link must be completed successfully prior to invoking this method, so every requested module is guaranteed to resolve successfully.", "                1. Set _index_ to ? InnerModuleEvaluation(_requiredModule_, _stack_, _index_).", "                1. If _requiredModule_ is a Cyclic Module Record, then", "                  1. Assert: _requiredModule_.[[Status]] is either ~evaluating~ or ~evaluated~.", "                  1. Assert: _requiredModule_.[[Status]] is ~evaluating~ if and only if _requiredModule_ is in _stack_.", "                  1. If _requiredModule_.[[Status]] is ~evaluating~, then", "                    1. Set _module_.[[DFSAncestorIndex]] to min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]).", "              1. Perform ? _module_.ExecuteModule().", "              1. Assert: _module_ occurs exactly once in _stack_.", "              1. Assert: _module_.[[DFSAncestorIndex]] ≤ _module_.[[DFSIndex]].", "              1. If _module_.[[DFSAncestorIndex]] = _module_.[[DFSIndex]], then", "                1. Let _done_ be *false*.", "                1. Repeat, while _done_ is *false*,", "                  1. Let _requiredModule_ be the last element in _stack_.", "                  1. Remove the last element of _stack_.", "                  1. Assert: _requiredModule_ is a Cyclic Module Record.", "                  1. Set _requiredModule_.[[Status]] to ~evaluated~.", "                  1. If _requiredModule_ and _module_ are the same Module Record, set _done_ to *true*.", "              1. Return _index_."],
    "head": {
      "name": "InnerModuleEvaluation",
      "params": [{
        "kind": "Normal",
        "name": "module"
      }, {
        "kind": "Normal",
        "name": "stack"
      }, {
        "kind": "Normal",
        "name": "index"
      }]
    },
    "ids": "sec-innermoduleevaluation",
    "rawBody": "{\n  0:if (! (0) (is-instance-of module CyclicModuleRecord)) {\n    1:(0) app __x0__ = (module[\"Evaluate\"] module)\n    1:[? __x0__]\n    2:return index\n  } else 23:{}\n  3:if (= module[\"Status\"] CONST_evaluated) if (= module[\"EvaluationError\"] undefined) return index else return module[\"EvaluationError\"] else 23:{}\n  6:if (= module[\"Status\"] CONST_evaluating) return index else 23:{}\n  7:assert (= module[\"Status\"] CONST_linked)\n  8:module[\"Status\"] = CONST_evaluating\n  9:module[\"DFSIndex\"] = index\n  10:module[\"DFSAncestorIndex\"] = index\n  11:index = (+ index 1i)\n  12:append module -> stack\n  13:let __x1__ = module[\"RequestedModules\"]\n  13:let __x2__ = 0i\n  13:while (< __x2__ __x1__[\"length\"]) {\n    let required = __x1__[__x2__]\n    14:(1) app __x3__ = (HostResolveImportedModule module required)\n    14:let requiredModule = [! __x3__]\n    16:(2) app __x4__ = (InnerModuleEvaluation requiredModule stack index)\n    16:index = [? __x4__]\n    17:if (1) (is-instance-of requiredModule CyclicModuleRecord) {\n      18:assert (|| (= requiredModule[\"Status\"] CONST_evaluating) (= requiredModule[\"Status\"] CONST_evaluated))\n      20:if (= requiredModule[\"Status\"] CONST_evaluating) {\n        21:(3) app __x5__ = (min module[\"DFSAncestorIndex\"] requiredModule[\"DFSAncestorIndex\"])\n        21:module[\"DFSAncestorIndex\"] = __x5__\n      } else 23:{}\n    } else 23:{}\n    __x2__ = (+ __x2__ 1i)\n  }\n  22:(4) app __x6__ = (module[\"ExecuteModule\"] module)\n  22:[? __x6__]\n  24:assert (! (< module[\"DFSIndex\"] module[\"DFSAncestorIndex\"]))\n  25:if (== module[\"DFSAncestorIndex\"] module[\"DFSIndex\"]) {\n    26:let done = false\n    27:while (= done false) {\n      28:let requiredModule = stack[(- stack[\"length\"] 1i)]\n      29:(pop stack (- stack[\"length\"] 1i))\n      30:assert (2) (is-instance-of requiredModule CyclicModuleRecord)\n      31:requiredModule[\"Status\"] = CONST_evaluated\n      32:if (= requiredModule module) done = true else 23:{}\n    }\n  } else 23:{}\n  33:return index\n}"
  }, {
    "code": ["            1. Assert: _sourceText_ is an ECMAScript source text (see clause <emu-xref href=\"#sec-ecmascript-language-source-code\"></emu-xref>).", "            1. Let _body_ be ParseText(_sourceText_, |Module|).", "            1. If _body_ is a List of errors, return _body_.", "            1. Let _requestedModules_ be the ModuleRequests of _body_.", "            1. Let _importEntries_ be ImportEntries of _body_.", "            1. Let _importedBoundNames_ be ImportedLocalNames(_importEntries_).", "            1. Let _indirectExportEntries_ be a new empty List.", "            1. Let _localExportEntries_ be a new empty List.", "            1. Let _starExportEntries_ be a new empty List.", "            1. Let _exportEntries_ be ExportEntries of _body_.", "            1. For each ExportEntry Record _ee_ of _exportEntries_, do", "              1. If _ee_.[[ModuleRequest]] is *null*, then", "                1. If _ee_.[[LocalName]] is not an element of _importedBoundNames_, then", "                  1. Append _ee_ to _localExportEntries_.", "                1. Else,", "                  1. Let _ie_ be the element of _importEntries_ whose [[LocalName]] is the same as _ee_.[[LocalName]].", "                  1. If _ie_.[[ImportName]] is *\"\\*\"*, then", "                    1. NOTE: This is a re-export of an imported module namespace object.", "                    1. Append _ee_ to _localExportEntries_.", "                  1. Else,", "                    1. NOTE: This is a re-export of a single name.", "                    1. Append the ExportEntry Record { [[ModuleRequest]]: _ie_.[[ModuleRequest]], [[ImportName]]: _ie_.[[ImportName]], [[LocalName]]: *null*, [[ExportName]]: _ee_.[[ExportName]] } to _indirectExportEntries_.", "              1. Else if _ee_.[[ImportName]] is *\"\\*\"* and _ee_.[[ExportName]] is *null*, then", "                1. Append _ee_ to _starExportEntries_.", "              1. Else,", "                1. Append _ee_ to _indirectExportEntries_.", "            1. Return Source Text Module Record { [[Realm]]: _realm_, [[Environment]]: *undefined*, [[Namespace]]: *undefined*, [[Status]]: ~unlinked~, [[EvaluationError]]: *undefined*, [[HostDefined]]: _hostDefined_, [[ECMAScriptCode]]: _body_, [[Context]]: ~empty~, [[ImportMeta]]: ~empty~, [[RequestedModules]]: _requestedModules_, [[ImportEntries]]: _importEntries_, [[LocalExportEntries]]: _localExportEntries_, [[IndirectExportEntries]]: _indirectExportEntries_, [[StarExportEntries]]: _starExportEntries_, [[DFSIndex]]: *undefined*, [[DFSAncestorIndex]]: *undefined* }."],
    "head": {
      "name": "ParseModule",
      "params": [{
        "kind": "Normal",
        "name": "sourceText"
      }, {
        "kind": "Normal",
        "name": "realm"
      }, {
        "kind": "Normal",
        "name": "hostDefined"
      }]
    },
    "ids": "sec-parsemodule",
    "rawBody": "{\n  1:let body = sourceText\n  3:(0) access __x0__ = (body \"ModuleRequests\")\n  3:let requestedModules = __x0__\n  4:(1) access __x1__ = (body \"ImportEntries\")\n  4:let importEntries = __x1__\n  5:(2) app __x2__ = (ImportedLocalNames importEntries)\n  5:let importedBoundNames = __x2__\n  6:let indirectExportEntries = (0) (new [])\n  7:let localExportEntries = (1) (new [])\n  8:let starExportEntries = (2) (new [])\n  9:(3) access __x3__ = (body \"ExportEntries\")\n  9:let exportEntries = __x3__\n  10:let __x4__ = exportEntries\n  10:let __x5__ = 0i\n  10:while (< __x5__ __x4__[\"length\"]) {\n    let ee = __x4__[__x5__]\n    24:if (= ee[\"ModuleRequest\"] null) if (! (contains importedBoundNames ee[\"LocalName\"])) append ee -> localExportEntries else {\n      15:(3) ??? \"Let id:{ie} be the element of id:{importEntries} whose [ [ LocalName ] ] is the same as id:{ee} . [ [ LocalName ] ] .\"\n      19:if (= ie[\"ImportName\"] \"*\") append ee -> localExportEntries else append (4) (new ExportEntryRecord(\"ModuleRequest\" -> ie[\"ModuleRequest\"], \"ImportName\" -> ie[\"ImportName\"], \"LocalName\" -> null, \"ExportName\" -> ee[\"ExportName\"])) -> indirectExportEntries\n    } else if (&& (= ee[\"ImportName\"] \"*\") (= ee[\"ExportName\"] null)) append ee -> starExportEntries else append ee -> indirectExportEntries\n    __x5__ = (+ __x5__ 1i)\n  }\n  26:return (5) (new SourceTextModuleRecord(\"Realm\" -> realm, \"Environment\" -> undefined, \"Namespace\" -> undefined, \"Status\" -> CONST_unlinked, \"EvaluationError\" -> undefined, \"HostDefined\" -> hostDefined, \"ECMAScriptCode\" -> body, \"Context\" -> CONST_empty, \"ImportMeta\" -> CONST_empty, \"RequestedModules\" -> requestedModules, \"ImportEntries\" -> importEntries, \"LocalExportEntries\" -> localExportEntries, \"IndirectExportEntries\" -> indirectExportEntries, \"StarExportEntries\" -> starExportEntries, \"DFSIndex\" -> undefined, \"DFSAncestorIndex\" -> undefined))\n}"
  }, {
    "code": ["            1. If _exportStarSet_ is not present, set _exportStarSet_ to a new empty List.", "            1. Assert: _exportStarSet_ is a List of Source Text Module Records.", "            1. If _exportStarSet_ contains _module_, then", "              1. Assert: We've reached the starting point of an `export *` circularity.", "              1. Return a new empty List.", "            1. Append _module_ to _exportStarSet_.", "            1. Let _exportedNames_ be a new empty List.", "            1. For each ExportEntry Record _e_ of _module_.[[LocalExportEntries]], do", "              1. Assert: _module_ provides the direct binding for this export.", "              1. Append _e_.[[ExportName]] to _exportedNames_.", "            1. For each ExportEntry Record _e_ of _module_.[[IndirectExportEntries]], do", "              1. Assert: _module_ imports a specific binding for this export.", "              1. Append _e_.[[ExportName]] to _exportedNames_.", "            1. For each ExportEntry Record _e_ of _module_.[[StarExportEntries]], do", "              1. Let _requestedModule_ be ? HostResolveImportedModule(_module_, _e_.[[ModuleRequest]]).", "              1. Let _starNames_ be ? _requestedModule_.GetExportedNames(_exportStarSet_).", "              1. For each element _n_ of _starNames_, do", "                1. If SameValue(_n_, *\"default\"*) is *false*, then", "                  1. If _n_ is not an element of _exportedNames_, then", "                    1. Append _n_ to _exportedNames_.", "            1. Return _exportedNames_."],
    "head": {
      "name": "GetExportedNames",
      "params": [{
        "kind": "Optional",
        "name": "exportStarSet"
      }]
    },
    "ids": "sec-getexportednames",
    "rawBody": "{\n  0:if (= exportStarSet absent) exportStarSet = (0) (new []) else 11:{}\n  2:if (contains exportStarSet module) return (1) (new []) else 11:{}\n  5:append module -> exportStarSet\n  6:let exportedNames = (2) (new [])\n  7:let __x0__ = module[\"LocalExportEntries\"]\n  7:let __x1__ = 0i\n  7:while (< __x1__ __x0__[\"length\"]) {\n    let e = __x0__[__x1__]\n    9:append e[\"ExportName\"] -> exportedNames\n    __x1__ = (+ __x1__ 1i)\n  }\n  10:let __x2__ = module[\"IndirectExportEntries\"]\n  10:let __x3__ = 0i\n  10:while (< __x3__ __x2__[\"length\"]) {\n    let e = __x2__[__x3__]\n    12:append e[\"ExportName\"] -> exportedNames\n    __x3__ = (+ __x3__ 1i)\n  }\n  13:let __x4__ = module[\"StarExportEntries\"]\n  13:let __x5__ = 0i\n  13:while (< __x5__ __x4__[\"length\"]) {\n    let e = __x4__[__x5__]\n    14:(0) app __x6__ = (HostResolveImportedModule module e[\"ModuleRequest\"])\n    14:let requestedModule = [? __x6__]\n    15:(1) app __x7__ = (requestedModule[\"GetExportedNames\"] requestedModule exportStarSet)\n    15:let starNames = [? __x7__]\n    16:let __x8__ = starNames\n    16:let __x9__ = 0i\n    16:while (< __x9__ __x8__[\"length\"]) {\n      let n = __x8__[__x9__]\n      17:(2) app __x10__ = (SameValue n \"default\")\n      17:if (= __x10__ false) if (! (contains exportedNames n)) append n -> exportedNames else 11:{} else 11:{}\n      __x9__ = (+ __x9__ 1i)\n    }\n    __x5__ = (+ __x5__ 1i)\n  }\n  20:return exportedNames\n}"
  }, {
    "code": ["            1. If _resolveSet_ is not present, set _resolveSet_ to a new empty List.", "            1. Assert: _resolveSet_ is a List of Record { [[Module]], [[ExportName]] }.", "            1. For each Record { [[Module]], [[ExportName]] } _r_ of _resolveSet_, do", "              1. If _module_ and _r_.[[Module]] are the same Module Record and SameValue(_exportName_, _r_.[[ExportName]]) is *true*, then", "                1. Assert: This is a circular import request.", "                1. Return *null*.", "            1. Append the Record { [[Module]]: _module_, [[ExportName]]: _exportName_ } to _resolveSet_.", "            1. For each ExportEntry Record _e_ of _module_.[[LocalExportEntries]], do", "              1. If SameValue(_exportName_, _e_.[[ExportName]]) is *true*, then", "                1. Assert: _module_ provides the direct binding for this export.", "                1. Return ResolvedBinding Record { [[Module]]: _module_, [[BindingName]]: _e_.[[LocalName]] }.", "            1. For each ExportEntry Record _e_ of _module_.[[IndirectExportEntries]], do", "              1. If SameValue(_exportName_, _e_.[[ExportName]]) is *true*, then", "                1. Let _importedModule_ be ? HostResolveImportedModule(_module_, _e_.[[ModuleRequest]]).", "                1. If _e_.[[ImportName]] is *\"\\*\"*, then", "                  1. Assert: _module_ does not provide the direct binding for this export.", "                  1. Return ResolvedBinding Record { [[Module]]: _importedModule_, [[BindingName]]: *\"\\*namespace\\*\"* }.", "                1. Else,", "                  1. Assert: _module_ imports a specific binding for this export.", "                  1. Return _importedModule_.ResolveExport(_e_.[[ImportName]], _resolveSet_).", "            1. If SameValue(_exportName_, *\"default\"*) is *true*, then", "              1. Assert: A `default` export was not explicitly defined by this module.", "              1. Return *null*.", "              1. NOTE: A `default` export cannot be provided by an `export *` or `export * from \"mod\"` declaration.", "            1. Let _starResolution_ be *null*.", "            1. For each ExportEntry Record _e_ of _module_.[[StarExportEntries]], do", "              1. Let _importedModule_ be ? HostResolveImportedModule(_module_, _e_.[[ModuleRequest]]).", "              1. Let _resolution_ be ? _importedModule_.ResolveExport(_exportName_, _resolveSet_).", "              1. If _resolution_ is *\"ambiguous\"*, return *\"ambiguous\"*.", "              1. If _resolution_ is not *null*, then", "                1. Assert: _resolution_ is a ResolvedBinding Record.", "                1. If _starResolution_ is *null*, set _starResolution_ to _resolution_.", "                1. Else,", "                  1. Assert: There is more than one `*` import that includes the requested name.", "                  1. If _resolution_.[[Module]] and _starResolution_.[[Module]] are not the same Module Record or SameValue(_resolution_.[[BindingName]], _starResolution_.[[BindingName]]) is *false*, return *\"ambiguous\"*.", "            1. Return _starResolution_."],
    "head": {
      "name": "ResolveExport",
      "params": [{
        "kind": "Normal",
        "name": "exportName"
      }, {
        "kind": "Optional",
        "name": "resolveSet"
      }]
    },
    "ids": "sec-resolveexport",
    "rawBody": "{\n  0:if (= resolveSet absent) resolveSet = (0) (new []) else 33:{}\n  2:let __x0__ = resolveSet\n  2:let __x1__ = 0i\n  2:while (< __x1__ __x0__[\"length\"]) {\n    let r = __x0__[__x1__]\n    3:let __x2__ = true\n    3:__x2__ = (= module r[\"Module\"])\n    3:if __x2__ {\n      (0) app __x3__ = (SameValue exportName r[\"ExportName\"])\n      __x2__ = (= __x3__ true)\n    } else 33:{}\n    3:if __x2__ return null else 33:{}\n    __x1__ = (+ __x1__ 1i)\n  }\n  6:append (1) (new Record(\"Module\" -> module, \"ExportName\" -> exportName)) -> resolveSet\n  7:let __x4__ = module[\"LocalExportEntries\"]\n  7:let __x5__ = 0i\n  7:while (< __x5__ __x4__[\"length\"]) {\n    let e = __x4__[__x5__]\n    8:(1) app __x6__ = (SameValue exportName e[\"ExportName\"])\n    8:if (= __x6__ true) return (2) (new ResolvedBindingRecord(\"Module\" -> module, \"BindingName\" -> e[\"LocalName\"])) else 33:{}\n    __x5__ = (+ __x5__ 1i)\n  }\n  11:let __x7__ = module[\"IndirectExportEntries\"]\n  11:let __x8__ = 0i\n  11:while (< __x8__ __x7__[\"length\"]) {\n    let e = __x7__[__x8__]\n    12:(2) app __x9__ = (SameValue exportName e[\"ExportName\"])\n    12:if (= __x9__ true) {\n      13:(3) app __x10__ = (HostResolveImportedModule module e[\"ModuleRequest\"])\n      13:let importedModule = [? __x10__]\n      17:if (= e[\"ImportName\"] \"*\") return (3) (new ResolvedBindingRecord(\"Module\" -> importedModule, \"BindingName\" -> \"*namespace*\")) else {\n        19:(4) app __x11__ = (importedModule[\"ResolveExport\"] importedModule e[\"ImportName\"] resolveSet)\n        19:return __x11__\n      }\n    } else 33:{}\n    __x8__ = (+ __x8__ 1i)\n  }\n  20:(5) app __x12__ = (SameValue exportName \"default\")\n  20:if (= __x12__ true) return null else 33:{}\n  24:let starResolution = null\n  25:let __x13__ = module[\"StarExportEntries\"]\n  25:let __x14__ = 0i\n  25:while (< __x14__ __x13__[\"length\"]) {\n    let e = __x13__[__x14__]\n    26:(6) app __x15__ = (HostResolveImportedModule module e[\"ModuleRequest\"])\n    26:let importedModule = [? __x15__]\n    27:(7) app __x16__ = (importedModule[\"ResolveExport\"] importedModule exportName resolveSet)\n    27:let resolution = [? __x16__]\n    28:if (= resolution \"ambiguous\") return \"ambiguous\" else 33:{}\n    29:if (! (= resolution null)) {\n      30:assert (4) (is-instance-of resolution ResolvedBindingRecord)\n      32:if (= starResolution null) starResolution = resolution else {\n        34:let __x17__ = true\n        34:__x17__ = (! (= resolution[\"Module\"] starResolution[\"Module\"]))\n        34:if __x17__ 33:{} else {\n          (8) app __x18__ = (SameValue resolution[\"BindingName\"] starResolution[\"BindingName\"])\n          __x17__ = (= __x18__ false)\n        }\n        34:if __x17__ return \"ambiguous\" else 33:{}\n      }\n    } else 33:{}\n    __x14__ = (+ __x14__ 1i)\n  }\n  35:return starResolution\n}"
  }, {
    "code": ["            1. For each ExportEntry Record _e_ of _module_.[[IndirectExportEntries]], do", "              1. Let _resolution_ be ? _module_.ResolveExport(_e_.[[ExportName]]).", "              1. If _resolution_ is *null* or *\"ambiguous\"*, throw a *SyntaxError* exception.", "              1. Assert: _resolution_ is a ResolvedBinding Record.", "            1. Assert: All named exports from _module_ are resolvable.", "            1. Let _realm_ be _module_.[[Realm]].", "            1. Assert: _realm_ is not *undefined*.", "            1. Let _env_ be NewModuleEnvironment(_realm_.[[GlobalEnv]]).", "            1. Set _module_.[[Environment]] to _env_.", "            1. For each ImportEntry Record _in_ of _module_.[[ImportEntries]], do", "              1. Let _importedModule_ be ! HostResolveImportedModule(_module_, _in_.[[ModuleRequest]]).", "              1. NOTE: The above call cannot fail because imported module requests are a subset of _module_.[[RequestedModules]], and these have been resolved earlier in this algorithm.", "              1. If _in_.[[ImportName]] is *\"\\*\"*, then", "                1. Let _namespace_ be ? GetModuleNamespace(_importedModule_).", "                1. Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).", "                1. Call _env_.InitializeBinding(_in_.[[LocalName]], _namespace_).", "              1. Else,", "                1. Let _resolution_ be ? _importedModule_.ResolveExport(_in_.[[ImportName]]).", "                1. If _resolution_ is *null* or *\"ambiguous\"*, throw a *SyntaxError* exception.", "                1. If _resolution_.[[BindingName]] is *\"\\*namespace\\*\"*, then", "                  1. Let _namespace_ be ? GetModuleNamespace(_resolution_.[[Module]]).", "                  1. Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).", "                  1. Call _env_.InitializeBinding(_in_.[[LocalName]], _namespace_).", "                1. Else,", "                  1. Call _env_.CreateImportBinding(_in_.[[LocalName]], _resolution_.[[Module]], _resolution_.[[BindingName]]).", "            1. Let _moduleContext_ be a new ECMAScript code execution context.", "            1. Set the Function of _moduleContext_ to *null*.", "            1. Assert: _module_.[[Realm]] is not *undefined*.", "            1. Set the Realm of _moduleContext_ to _module_.[[Realm]].", "            1. Set the ScriptOrModule of _moduleContext_ to _module_.", "            1. Set the VariableEnvironment of _moduleContext_ to _module_.[[Environment]].", "            1. Set the LexicalEnvironment of _moduleContext_ to _module_.[[Environment]].", "            1. Set _module_.[[Context]] to _moduleContext_.", "            1. Push _moduleContext_ onto the execution context stack; _moduleContext_ is now the running execution context.", "            1. Let _code_ be _module_.[[ECMAScriptCode]].", "            1. Let _varDeclarations_ be the VarScopedDeclarations of _code_.", "            1. Let _declaredVarNames_ be a new empty List.", "            1. For each element _d_ of _varDeclarations_, do", "              1. For each element _dn_ of the BoundNames of _d_, do", "                1. If _dn_ is not an element of _declaredVarNames_, then", "                  1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).", "                  1. Call _env_.InitializeBinding(_dn_, *undefined*).", "                  1. Append _dn_ to _declaredVarNames_.", "            1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _code_.", "            1. For each element _d_ of _lexDeclarations_, do", "              1. For each element _dn_ of the BoundNames of _d_, do", "                1. If IsConstantDeclaration of _d_ is *true*, then", "                  1. Perform ! _env_.CreateImmutableBinding(_dn_, *true*).", "                1. Else,", "                  1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).", "                1. If _d_ is a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|, then", "                  1. Let _fo_ be InstantiateFunctionObject of _d_ with argument _env_.", "                  1. Call _env_.InitializeBinding(_dn_, _fo_).", "            1. Remove _moduleContext_ from the execution context stack.", "            1. Return NormalCompletion(~empty~)."],
    "head": {
      "name": "InitializeEnvironment",
      "params": []
    },
    "ids": "sec-source-text-module-record-initialize-environment",
    "rawBody": "{\n  0:let __x0__ = module[\"IndirectExportEntries\"]\n  0:let __x1__ = 0i\n  0:while (< __x1__ __x0__[\"length\"]) {\n    let e = __x0__[__x1__]\n    1:(0) app __x2__ = (module[\"ResolveExport\"] module e[\"ExportName\"])\n    1:let resolution = [? __x2__]\n    2:if (|| (= resolution null) (= resolution \"ambiguous\")) (0) throw SyntaxError else 11:{}\n    3:assert (1) (is-instance-of resolution ResolvedBindingRecord)\n    __x1__ = (+ __x1__ 1i)\n  }\n  5:let realm = module[\"Realm\"]\n  6:assert (! (= realm undefined))\n  7:(1) app __x3__ = (NewModuleEnvironment realm[\"GlobalEnv\"])\n  7:let env = __x3__\n  8:module[\"Environment\"] = env\n  9:let __x4__ = module[\"ImportEntries\"]\n  9:let __x5__ = 0i\n  9:while (< __x5__ __x4__[\"length\"]) {\n    let in = __x4__[__x5__]\n    10:(2) app __x6__ = (HostResolveImportedModule module in[\"ModuleRequest\"])\n    10:let importedModule = [! __x6__]\n    16:if (= in[\"ImportName\"] \"*\") {\n      13:(3) app __x7__ = (GetModuleNamespace importedModule)\n      13:let namespace = [? __x7__]\n      14:(4) app __x8__ = (env[\"CreateImmutableBinding\"] env in[\"LocalName\"] true)\n      14:[! __x8__]\n      15:(5) app __x9__ = (env[\"InitializeBinding\"] env in[\"LocalName\"] namespace)\n      15:__x9__\n    } else {\n      17:(6) app __x10__ = (importedModule[\"ResolveExport\"] importedModule in[\"ImportName\"])\n      17:let resolution = [? __x10__]\n      18:if (|| (= resolution null) (= resolution \"ambiguous\")) (2) throw SyntaxError else 11:{}\n      23:if (= resolution[\"BindingName\"] \"*namespace*\") {\n        20:(7) app __x11__ = (GetModuleNamespace resolution[\"Module\"])\n        20:let namespace = [? __x11__]\n        21:(8) app __x12__ = (env[\"CreateImmutableBinding\"] env in[\"LocalName\"] true)\n        21:[! __x12__]\n        22:(9) app __x13__ = (env[\"InitializeBinding\"] env in[\"LocalName\"] namespace)\n        22:__x13__\n      } else {\n        24:(10) app __x14__ = (env[\"CreateImportBinding\"] env in[\"LocalName\"] resolution[\"Module\"] resolution[\"BindingName\"])\n        24:__x14__\n      }\n    }\n    __x5__ = (+ __x5__ 1i)\n  }\n  25:let moduleContext = (3) (new ExecutionContext())\n  26:moduleContext[\"Function\"] = null\n  27:assert (! (= module[\"Realm\"] undefined))\n  28:moduleContext[\"Realm\"] = module[\"Realm\"]\n  29:moduleContext[\"ScriptOrModule\"] = module\n  30:moduleContext[\"VariableEnvironment\"] = module[\"Environment\"]\n  31:moduleContext[\"LexicalEnvironment\"] = module[\"Environment\"]\n  32:module[\"Context\"] = moduleContext\n  33:append moduleContext -> EXECUTION_STACK\n  33:CONTEXT = EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)]\n  34:let code = module[\"ECMAScriptCode\"]\n  35:(11) access __x15__ = (code \"VarScopedDeclarations\")\n  35:let varDeclarations = __x15__\n  36:let declaredVarNames = (4) (new [])\n  37:let __x16__ = varDeclarations\n  37:let __x17__ = 0i\n  37:while (< __x17__ __x16__[\"length\"]) {\n    let d = __x16__[__x17__]\n    38:(12) access __x18__ = (d \"BoundNames\")\n    38:let __x19__ = __x18__\n    38:let __x20__ = 0i\n    38:while (< __x20__ __x19__[\"length\"]) {\n      let dn = __x19__[__x20__]\n      39:if (! (contains declaredVarNames dn)) {\n        40:(13) app __x21__ = (env[\"CreateMutableBinding\"] env dn false)\n        40:[! __x21__]\n        41:(14) app __x22__ = (env[\"InitializeBinding\"] env dn undefined)\n        41:__x22__\n        42:append dn -> declaredVarNames\n      } else 11:{}\n      __x20__ = (+ __x20__ 1i)\n    }\n    __x17__ = (+ __x17__ 1i)\n  }\n  43:(15) access __x23__ = (code \"LexicallyScopedDeclarations\")\n  43:let lexDeclarations = __x23__\n  44:let __x24__ = lexDeclarations\n  44:let __x25__ = 0i\n  44:while (< __x25__ __x24__[\"length\"]) {\n    let d = __x24__[__x25__]\n    45:(16) access __x26__ = (d \"BoundNames\")\n    45:let __x27__ = __x26__\n    45:let __x28__ = 0i\n    45:while (< __x28__ __x27__[\"length\"]) {\n      let dn = __x27__[__x28__]\n      48:(17) access __x29__ = (d \"IsConstantDeclaration\")\n      48:if (= __x29__ true) {\n        47:(18) app __x30__ = (env[\"CreateImmutableBinding\"] env dn true)\n        47:[! __x30__]\n      } else {\n        49:(19) app __x31__ = (env[\"CreateMutableBinding\"] env dn false)\n        49:[! __x31__]\n      }\n      50:if (|| (|| (|| (5) (is-instance-of d FunctionDeclaration) (6) (is-instance-of d GeneratorDeclaration)) (7) (is-instance-of d AsyncFunctionDeclaration)) (8) (is-instance-of d AsyncGeneratorDeclaration)) {\n        51:(20) access __x32__ = (d \"InstantiateFunctionObject\" env)\n        51:let fo = __x32__\n        52:(21) app __x33__ = (env[\"InitializeBinding\"] env dn fo)\n        52:__x33__\n      } else 11:{}\n      __x28__ = (+ __x28__ 1i)\n    }\n    __x25__ = (+ __x25__ 1i)\n  }\n  53:(9) ??? \"Remove id:{moduleContext} from the execution context stack .\"\n  54:return CONST_empty\n}"
  }, {
    "code": ["            1. Suspend the currently running execution context.", "            1. Let _moduleContext_ be _module_.[[Context]].", "            1. Push _moduleContext_ onto the execution context stack; _moduleContext_ is now the running execution context.", "            1. Let _result_ be the result of evaluating _module_.[[ECMAScriptCode]].", "            1. Suspend _moduleContext_ and remove it from the execution context stack.", "            1. Resume the context that is now on the top of the execution context stack as the running execution context.", "            1. Return Completion(_result_)."],
    "head": {
      "name": "ExecuteModule",
      "params": []
    },
    "ids": "sec-source-text-module-record-execute-module",
    "rawBody": "{\n  0:CONTEXT = null\n  1:let moduleContext = module[\"Context\"]\n  2:append moduleContext -> EXECUTION_STACK\n  2:CONTEXT = EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)]\n  3:(0) access __x0__ = (module[\"ECMAScriptCode\"] \"Evaluation\")\n  3:let result = __x0__\n  4:CONTEXT = null\n  4:if (= EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)] moduleContext) (pop EXECUTION_STACK (- EXECUTION_STACK[\"length\"] 1i)) else 11:{}\n  5:CONTEXT = EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)]\n  6:return result\n}"
  }, {
    "code": ["          1. If _completion_ is an abrupt completion, perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _completion_.[[Value]] »).", "          1. Else,", "            1. Assert: _completion_ is a normal completion and _completion_.[[Value]] is *undefined*.", "            1. Let _moduleRecord_ be ! HostResolveImportedModule(_referencingScriptOrModule_, _specifier_).", "            1. Assert: Evaluate has already been invoked on _moduleRecord_ and successfully completed.", "            1. Let _namespace_ be GetModuleNamespace(_moduleRecord_).", "            1. If _namespace_ is an abrupt completion, perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _namespace_.[[Value]] »).", "            1. Else, perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _namespace_.[[Value]] »)."],
    "head": {
      "name": "FinishDynamicImport",
      "params": [{
        "kind": "Normal",
        "name": "referencingScriptOrModule"
      }, {
        "kind": "Normal",
        "name": "specifier"
      }, {
        "kind": "Normal",
        "name": "promiseCapability"
      }, {
        "kind": "Normal",
        "name": "completion"
      }]
    },
    "ids": "sec-finishdynamicimport",
    "rawBody": "{\n  1:(0) app __x0__ = (IsAbruptCompletion completion)\n  1:if __x0__ {\n    (1) app __x1__ = (Call promiseCapability[\"Reject\"] undefined (0) (new [completion[\"Value\"]]))\n    [! __x1__]\n  } else {\n    3:(2) app __x2__ = (HostResolveImportedModule referencingScriptOrModule specifier)\n    3:let moduleRecord = [! __x2__]\n    5:(3) app __x3__ = (GetModuleNamespace moduleRecord)\n    5:let namespace = __x3__\n    7:(4) app __x4__ = (IsAbruptCompletion namespace)\n    7:if __x4__ {\n      (5) app __x5__ = (Call promiseCapability[\"Reject\"] undefined (1) (new [namespace[\"Value\"]]))\n      [! __x5__]\n    } else {\n      (6) app __x6__ = (Call promiseCapability[\"Resolve\"] undefined (2) (new [namespace[\"Value\"]]))\n      [! __x6__]\n    }\n  }\n}"
  }, {
    "code": ["          1. Assert: _module_ is an instance of a concrete subclass of Module Record.", "          1. Assert: If _module_ is a Cyclic Module Record, then _module_.[[Status]] is not ~unlinked~.", "          1. Let _namespace_ be _module_.[[Namespace]].", "          1. If _namespace_ is *undefined*, then", "            1. Let _exportedNames_ be ? _module_.GetExportedNames().", "            1. Let _unambiguousNames_ be a new empty List.", "            1. For each element _name_ of _exportedNames_, do", "              1. Let _resolution_ be ? _module_.ResolveExport(_name_).", "              1. If _resolution_ is a ResolvedBinding Record, append _name_ to _unambiguousNames_.", "            1. Set _namespace_ to ModuleNamespaceCreate(_module_, _unambiguousNames_).", "          1. Return _namespace_."],
    "head": {
      "name": "GetModuleNamespace",
      "params": [{
        "kind": "Normal",
        "name": "module"
      }]
    },
    "ids": "sec-getmodulenamespace",
    "rawBody": "{\n  2:let namespace = module[\"Namespace\"]\n  3:if (= namespace undefined) {\n    4:(0) app __x0__ = (module[\"GetExportedNames\"] module)\n    4:let exportedNames = [? __x0__]\n    5:let unambiguousNames = (0) (new [])\n    6:let __x1__ = exportedNames\n    6:let __x2__ = 0i\n    6:while (< __x2__ __x1__[\"length\"]) {\n      let name = __x1__[__x2__]\n      7:(1) app __x3__ = (module[\"ResolveExport\"] module name)\n      7:let resolution = [? __x3__]\n      8:if (1) (is-instance-of resolution ResolvedBindingRecord) append name -> unambiguousNames else 1:{}\n      __x2__ = (+ __x2__ 1i)\n    }\n    9:(2) app __x4__ = (ModuleNamespaceCreate module unambiguousNames)\n    9:namespace = __x4__\n  } else 1:{}\n  10:return namespace\n}"
  }, {
    "code": ["          1. Return NormalCompletion(*undefined*)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "Module",
      "rhs": {
        "tokens": [{
          "empty": null
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-module-semantics-runtime-semantics-evaluation",
    "rawBody": "return undefined"
  }, {
    "code": ["          1. Let _result_ be the result of evaluating |ModuleItemList|.", "          1. If _result_.[[Type]] is ~normal~ and _result_.[[Value]] is ~empty~, then", "            1. Return NormalCompletion(*undefined*).", "          1. Return Completion(_result_)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "ModuleBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ModuleItemList",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-module-semantics-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (ModuleItemList \"Evaluation\")\n  0:let result = __x0__\n  1:if (&& (= result[\"Type\"] CONST_normal) (= result[\"Value\"] CONST_empty)) return undefined else 1:{}\n  3:return result\n}"
  }, {
    "code": ["          1. Let _sl_ be the result of evaluating |ModuleItemList|.", "          1. ReturnIfAbrupt(_sl_).", "          1. Let _s_ be the result of evaluating |ModuleItem|.", "          1. Return Completion(UpdateEmpty(_s_, _sl_))."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "ModuleItemList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ModuleItemList",
          "optional": false
        }, {
          "args": [],
          "name": "ModuleItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-module-semantics-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (ModuleItemList \"Evaluation\")\n  0:let sl = __x0__\n  1:[? sl]\n  2:(1) access __x1__ = (ModuleItem \"Evaluation\")\n  2:let s = __x1__\n  3:(2) app __x2__ = (UpdateEmpty s sl)\n  3:return __x2__\n}"
  }, {
    "code": ["          1. Return NormalCompletion(~empty~)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "ModuleItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ImportDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-module-semantics-runtime-semantics-evaluation",
    "rawBody": "return CONST_empty"
  }, {
    "code": ["          1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "ImportEntries",
      "prod": "Module",
      "rhs": {
        "tokens": [{
          "empty": null
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-importentries",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["          1. Let _entries_ be ImportEntries of |ModuleItemList|.", "          1. Append to _entries_ the elements of the ImportEntries of |ModuleItem|.", "          1. Return _entries_."],
    "head": {
      "idx": 1,
      "methodName": "ImportEntries",
      "prod": "ModuleItemList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ModuleItemList",
          "optional": false
        }, {
          "args": [],
          "name": "ModuleItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-importentries",
    "rawBody": "{\n  0:(0) access __x0__ = (ModuleItemList \"ImportEntries\")\n  0:let entries = __x0__\n  1:(1) access __x1__ = (ModuleItem \"ImportEntries\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> entries\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return entries\n}"
  }, {
    "code": ["          1. Return a new empty List."],
    "head": {
      "idx": 1,
      "methodName": "ImportEntries",
      "prod": "ModuleItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExportDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-importentries",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["          1. Return a new empty List."],
    "head": {
      "idx": 2,
      "methodName": "ImportEntries",
      "prod": "ModuleItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StatementListItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-importentries",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["          1. Let _module_ be the sole element of ModuleRequests of |FromClause|.", "          1. Return ImportEntriesForModule of |ImportClause| with argument _module_."],
    "head": {
      "idx": 0,
      "methodName": "ImportEntries",
      "prod": "ImportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "import"
        }, {
          "args": [],
          "name": "ImportClause",
          "optional": false
        }, {
          "args": [],
          "name": "FromClause",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-importentries",
    "rawBody": "{\n  0:(0) access __x0__ = (FromClause \"ModuleRequests\")\n  0:let module = __x0__[0i]\n  1:(1) access __x1__ = (ImportClause \"ImportEntriesForModule\" module)\n  1:return __x1__\n}"
  }, {
    "code": ["          1. Return a new empty List."],
    "head": {
      "idx": 1,
      "methodName": "ImportEntries",
      "prod": "ImportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "import"
        }, {
          "args": [],
          "name": "ModuleSpecifier",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-importentries",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["          1. Let _entries_ be ImportEntriesForModule of |ImportedDefaultBinding| with argument _module_.", "          1. Append to _entries_ the elements of the ImportEntriesForModule of |NameSpaceImport| with argument _module_.", "          1. Return _entries_."],
    "head": {
      "idx": 3,
      "methodName": "ImportEntriesForModule",
      "prod": "ImportClause",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ImportedDefaultBinding",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "NameSpaceImport",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "module"
      }]
    },
    "ids": "sec-static-semantics-importentriesformodule",
    "rawBody": "{\n  0:(0) access __x0__ = (ImportedDefaultBinding \"ImportEntriesForModule\" module)\n  0:let entries = __x0__\n  1:(1) access __x1__ = (NameSpaceImport \"ImportEntriesForModule\" module)\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> entries\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return entries\n}"
  }, {
    "code": ["          1. Let _entries_ be ImportEntriesForModule of |ImportedDefaultBinding| with argument _module_.", "          1. Append to _entries_ the elements of the ImportEntriesForModule of |NamedImports| with argument _module_.", "          1. Return _entries_."],
    "head": {
      "idx": 4,
      "methodName": "ImportEntriesForModule",
      "prod": "ImportClause",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ImportedDefaultBinding",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "NamedImports",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "module"
      }]
    },
    "ids": "sec-static-semantics-importentriesformodule",
    "rawBody": "{\n  0:(0) access __x0__ = (ImportedDefaultBinding \"ImportEntriesForModule\" module)\n  0:let entries = __x0__\n  1:(1) access __x1__ = (NamedImports \"ImportEntriesForModule\" module)\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> entries\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return entries\n}"
  }, {
    "code": ["          1. Let _localName_ be the sole element of BoundNames of |ImportedBinding|.", "          1. Let _defaultEntry_ be the ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: *\"default\"*, [[LocalName]]: _localName_ }.", "          1. Return a List whose sole element is _defaultEntry_."],
    "head": {
      "idx": 0,
      "methodName": "ImportEntriesForModule",
      "prod": "ImportedDefaultBinding",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ImportedBinding",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "module"
      }]
    },
    "ids": "sec-static-semantics-importentriesformodule",
    "rawBody": "{\n  0:(0) access __x0__ = (ImportedBinding \"BoundNames\")\n  0:let localName = __x0__[0i]\n  1:let defaultEntry = (0) (new ImportEntryRecord(\"ModuleRequest\" -> module, \"ImportName\" -> \"default\", \"LocalName\" -> localName))\n  2:return (1) (new [defaultEntry])\n}"
  }, {
    "code": ["          1. Let _localName_ be the StringValue of |ImportedBinding|.", "          1. Let _entry_ be the ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: *\"\\*\"*, [[LocalName]]: _localName_ }.", "          1. Return a List whose sole element is _entry_."],
    "head": {
      "idx": 0,
      "methodName": "ImportEntriesForModule",
      "prod": "NameSpaceImport",
      "rhs": {
        "tokens": [{
          "term": "*"
        }, {
          "term": "as"
        }, {
          "args": [],
          "name": "ImportedBinding",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "module"
      }]
    },
    "ids": "sec-static-semantics-importentriesformodule",
    "rawBody": "{\n  0:(0) access __x0__ = (ImportedBinding \"StringValue\")\n  0:let localName = __x0__\n  1:let entry = (0) (new ImportEntryRecord(\"ModuleRequest\" -> module, \"ImportName\" -> \"*\", \"LocalName\" -> localName))\n  2:return (1) (new [entry])\n}"
  }, {
    "code": ["          1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "ImportEntriesForModule",
      "prod": "NamedImports",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "module"
      }]
    },
    "ids": "sec-static-semantics-importentriesformodule",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["          1. Let _specs_ be the ImportEntriesForModule of |ImportsList| with argument _module_.", "          1. Append to _specs_ the elements of the ImportEntriesForModule of |ImportSpecifier| with argument _module_.", "          1. Return _specs_."],
    "head": {
      "idx": 1,
      "methodName": "ImportEntriesForModule",
      "prod": "ImportsList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ImportsList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "ImportSpecifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "module"
      }]
    },
    "ids": "sec-static-semantics-importentriesformodule",
    "rawBody": "{\n  0:(0) access __x0__ = (ImportsList \"ImportEntriesForModule\" module)\n  0:let specs = __x0__\n  1:(1) access __x1__ = (ImportSpecifier \"ImportEntriesForModule\" module)\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> specs\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return specs\n}"
  }, {
    "code": ["          1. Let _localName_ be the sole element of BoundNames of |ImportedBinding|.", "          1. Let _entry_ be the ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _localName_, [[LocalName]]: _localName_ }.", "          1. Return a List whose sole element is _entry_."],
    "head": {
      "idx": 0,
      "methodName": "ImportEntriesForModule",
      "prod": "ImportSpecifier",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ImportedBinding",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "module"
      }]
    },
    "ids": "sec-static-semantics-importentriesformodule",
    "rawBody": "{\n  0:(0) access __x0__ = (ImportedBinding \"BoundNames\")\n  0:let localName = __x0__[0i]\n  1:let entry = (0) (new ImportEntryRecord(\"ModuleRequest\" -> module, \"ImportName\" -> localName, \"LocalName\" -> localName))\n  2:return (1) (new [entry])\n}"
  }, {
    "code": ["          1. Let _importName_ be the StringValue of |IdentifierName|.", "          1. Let _localName_ be the StringValue of |ImportedBinding|.", "          1. Let _entry_ be the ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_ }.", "          1. Return a List whose sole element is _entry_."],
    "head": {
      "idx": 1,
      "methodName": "ImportEntriesForModule",
      "prod": "ImportSpecifier",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }, {
          "term": "as"
        }, {
          "args": [],
          "name": "ImportedBinding",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "module"
      }]
    },
    "ids": "sec-static-semantics-importentriesformodule",
    "rawBody": "{\n  0:(0) access __x0__ = (IdentifierName \"StringValue\")\n  0:let importName = __x0__\n  1:(1) access __x1__ = (ImportedBinding \"StringValue\")\n  1:let localName = __x1__\n  2:let entry = (0) (new ImportEntryRecord(\"ModuleRequest\" -> module, \"ImportName\" -> importName, \"LocalName\" -> localName))\n  3:return (1) (new [entry])\n}"
  }, {
    "code": ["          1. Let _names_ be ExportedBindings of |ModuleItemList|.", "          1. Append to _names_ the elements of the ExportedBindings of |ModuleItem|.", "          1. Return _names_."],
    "head": {
      "idx": 1,
      "methodName": "ExportedBindings",
      "prod": "ModuleItemList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ModuleItemList",
          "optional": false
        }, {
          "args": [],
          "name": "ModuleItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportedbindings",
    "rawBody": "{\n  0:(0) access __x0__ = (ModuleItemList \"ExportedBindings\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (ModuleItem \"ExportedBindings\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["          1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "ExportedBindings",
      "prod": "ModuleItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ImportDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportedbindings",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["          1. Return a new empty List."],
    "head": {
      "idx": 2,
      "methodName": "ExportedBindings",
      "prod": "ModuleItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StatementListItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportedbindings",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["          1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "ExportedBindings",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "ExportFromClause",
          "optional": false
        }, {
          "args": [],
          "name": "FromClause",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportedbindings",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["          1. Return the ExportedBindings of |NamedExports|."],
    "head": {
      "idx": 1,
      "methodName": "ExportedBindings",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "NamedExports",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportedbindings",
    "rawBody": "{\n  0:(0) access __x0__ = (NamedExports \"ExportedBindings\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return the BoundNames of |VariableStatement|."],
    "head": {
      "idx": 2,
      "methodName": "ExportedBindings",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "VariableStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportedbindings",
    "rawBody": "{\n  0:(0) access __x0__ = (VariableStatement \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return the BoundNames of |Declaration|."],
    "head": {
      "idx": 3,
      "methodName": "ExportedBindings",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "Declaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportedbindings",
    "rawBody": "{\n  0:(0) access __x0__ = (Declaration \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return the BoundNames of this |ExportDeclaration|."],
    "head": {
      "idx": 4,
      "methodName": "ExportedBindings",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "term": "default"
        }, {
          "args": [],
          "name": "HoistableDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportedbindings",
    "rawBody": "{\n  0:(0) access __x0__ = (this \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return the BoundNames of this |ExportDeclaration|."],
    "head": {
      "idx": 5,
      "methodName": "ExportedBindings",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "term": "default"
        }, {
          "args": [],
          "name": "ClassDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportedbindings",
    "rawBody": "{\n  0:(0) access __x0__ = (this \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return the BoundNames of this |ExportDeclaration|."],
    "head": {
      "idx": 6,
      "methodName": "ExportedBindings",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "term": "default"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportedbindings",
    "rawBody": "{\n  0:(0) access __x0__ = (this \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "ExportedBindings",
      "prod": "NamedExports",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportedbindings",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["          1. Let _names_ be the ExportedBindings of |ExportsList|.", "          1. Append to _names_ the elements of the ExportedBindings of |ExportSpecifier|.", "          1. Return _names_."],
    "head": {
      "idx": 1,
      "methodName": "ExportedBindings",
      "prod": "ExportsList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExportsList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "ExportSpecifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportedbindings",
    "rawBody": "{\n  0:(0) access __x0__ = (ExportsList \"ExportedBindings\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (ExportSpecifier \"ExportedBindings\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["          1. Return a List whose sole element is the StringValue of |IdentifierName|."],
    "head": {
      "idx": 0,
      "methodName": "ExportedBindings",
      "prod": "ExportSpecifier",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportedbindings",
    "rawBody": "{\n  0:(0) access __x0__ = (IdentifierName \"StringValue\")\n  0:return (0) (new [__x0__])\n}"
  }, {
    "code": ["          1. Return a List whose sole element is the StringValue of the first |IdentifierName|."],
    "head": {
      "idx": 1,
      "methodName": "ExportedBindings",
      "prod": "ExportSpecifier",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }, {
          "term": "as"
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportedbindings",
    "rawBody": "{\n  0:(0) access __x0__ = (IdentifierName0 \"StringValue\")\n  0:return (0) (new [__x0__])\n}"
  }, {
    "code": ["          1. Let _names_ be ExportedNames of |ModuleItemList|.", "          1. Append to _names_ the elements of the ExportedNames of |ModuleItem|.", "          1. Return _names_."],
    "head": {
      "idx": 1,
      "methodName": "ExportedNames",
      "prod": "ModuleItemList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ModuleItemList",
          "optional": false
        }, {
          "args": [],
          "name": "ModuleItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportednames",
    "rawBody": "{\n  0:(0) access __x0__ = (ModuleItemList \"ExportedNames\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (ModuleItem \"ExportedNames\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["          1. Return the ExportedNames of |ExportDeclaration|."],
    "head": {
      "idx": 1,
      "methodName": "ExportedNames",
      "prod": "ModuleItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExportDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportednames",
    "rawBody": "{\n  0:(0) access __x0__ = (ExportDeclaration \"ExportedNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "ExportedNames",
      "prod": "ModuleItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ImportDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportednames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["          1. Return a new empty List."],
    "head": {
      "idx": 2,
      "methodName": "ExportedNames",
      "prod": "ModuleItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StatementListItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportednames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["          1. Return the ExportedNames of |ExportFromClause|."],
    "head": {
      "idx": 0,
      "methodName": "ExportedNames",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "ExportFromClause",
          "optional": false
        }, {
          "args": [],
          "name": "FromClause",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportednames",
    "rawBody": "{\n  0:(0) access __x0__ = (ExportFromClause \"ExportedNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "ExportedNames",
      "prod": "ExportFromClause",
      "rhs": {
        "tokens": [{
          "term": "*"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportednames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["          1. Return a List whose sole element is the StringValue of |IdentifierName|."],
    "head": {
      "idx": 1,
      "methodName": "ExportedNames",
      "prod": "ExportFromClause",
      "rhs": {
        "tokens": [{
          "term": "*"
        }, {
          "term": "as"
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportednames",
    "rawBody": "{\n  0:(0) access __x0__ = (IdentifierName \"StringValue\")\n  0:return (0) (new [__x0__])\n}"
  }, {
    "code": ["          1. Return the ExportedNames of |NamedExports|."],
    "head": {
      "idx": 2,
      "methodName": "ExportedNames",
      "prod": "ExportFromClause",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "NamedExports",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportednames",
    "rawBody": "{\n  0:(0) access __x0__ = (NamedExports \"ExportedNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return the BoundNames of |VariableStatement|."],
    "head": {
      "idx": 2,
      "methodName": "ExportedNames",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "VariableStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportednames",
    "rawBody": "{\n  0:(0) access __x0__ = (VariableStatement \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return the BoundNames of |Declaration|."],
    "head": {
      "idx": 3,
      "methodName": "ExportedNames",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "Declaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportednames",
    "rawBody": "{\n  0:(0) access __x0__ = (Declaration \"BoundNames\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return « *\"default\"* »."],
    "head": {
      "idx": 4,
      "methodName": "ExportedNames",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "term": "default"
        }, {
          "args": [],
          "name": "HoistableDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportednames",
    "rawBody": "return (0) (new [\"default\"])"
  }, {
    "code": ["          1. Return « *\"default\"* »."],
    "head": {
      "idx": 5,
      "methodName": "ExportedNames",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "term": "default"
        }, {
          "args": [],
          "name": "ClassDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportednames",
    "rawBody": "return (0) (new [\"default\"])"
  }, {
    "code": ["          1. Return « *\"default\"* »."],
    "head": {
      "idx": 6,
      "methodName": "ExportedNames",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "term": "default"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportednames",
    "rawBody": "return (0) (new [\"default\"])"
  }, {
    "code": ["          1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "ExportedNames",
      "prod": "NamedExports",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportednames",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["          1. Let _names_ be the ExportedNames of |ExportsList|.", "          1. Append to _names_ the elements of the ExportedNames of |ExportSpecifier|.", "          1. Return _names_."],
    "head": {
      "idx": 1,
      "methodName": "ExportedNames",
      "prod": "ExportsList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExportsList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "ExportSpecifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportednames",
    "rawBody": "{\n  0:(0) access __x0__ = (ExportsList \"ExportedNames\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (ExportSpecifier \"ExportedNames\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["          1. Return a List whose sole element is the StringValue of |IdentifierName|."],
    "head": {
      "idx": 0,
      "methodName": "ExportedNames",
      "prod": "ExportSpecifier",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportednames",
    "rawBody": "{\n  0:(0) access __x0__ = (IdentifierName \"StringValue\")\n  0:return (0) (new [__x0__])\n}"
  }, {
    "code": ["          1. Return a List whose sole element is the StringValue of the second |IdentifierName|."],
    "head": {
      "idx": 1,
      "methodName": "ExportedNames",
      "prod": "ExportSpecifier",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }, {
          "term": "as"
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportednames",
    "rawBody": "{\n  0:(0) access __x0__ = (IdentifierName1 \"StringValue\")\n  0:return (0) (new [__x0__])\n}"
  }, {
    "code": ["          1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "ExportEntries",
      "prod": "Module",
      "rhs": {
        "tokens": [{
          "empty": null
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportentries",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["          1. Let _entries_ be ExportEntries of |ModuleItemList|.", "          1. Append to _entries_ the elements of the ExportEntries of |ModuleItem|.", "          1. Return _entries_."],
    "head": {
      "idx": 1,
      "methodName": "ExportEntries",
      "prod": "ModuleItemList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ModuleItemList",
          "optional": false
        }, {
          "args": [],
          "name": "ModuleItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportentries",
    "rawBody": "{\n  0:(0) access __x0__ = (ModuleItemList \"ExportEntries\")\n  0:let entries = __x0__\n  1:(1) access __x1__ = (ModuleItem \"ExportEntries\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> entries\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return entries\n}"
  }, {
    "code": ["          1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "ExportEntries",
      "prod": "ModuleItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ImportDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportentries",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["          1. Return a new empty List."],
    "head": {
      "idx": 2,
      "methodName": "ExportEntries",
      "prod": "ModuleItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StatementListItem",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportentries",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["          1. Let _module_ be the sole element of ModuleRequests of |FromClause|.", "          1. Return ExportEntriesForModule of |ExportFromClause| with argument _module_."],
    "head": {
      "idx": 0,
      "methodName": "ExportEntries",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "ExportFromClause",
          "optional": false
        }, {
          "args": [],
          "name": "FromClause",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportentries",
    "rawBody": "{\n  0:(0) access __x0__ = (FromClause \"ModuleRequests\")\n  0:let module = __x0__[0i]\n  1:(1) access __x1__ = (ExportFromClause \"ExportEntriesForModule\" module)\n  1:return __x1__\n}"
  }, {
    "code": ["          1. Return ExportEntriesForModule of |NamedExports| with argument *null*."],
    "head": {
      "idx": 1,
      "methodName": "ExportEntries",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "NamedExports",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportentries",
    "rawBody": "{\n  0:(0) access __x0__ = (NamedExports \"ExportEntriesForModule\" null)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Let _entries_ be a new empty List.", "          1. Let _names_ be the BoundNames of |VariableStatement|.", "          1. For each element _name_ of _names_, do", "            1. Append the ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _name_, [[ExportName]]: _name_ } to _entries_.", "          1. Return _entries_."],
    "head": {
      "idx": 2,
      "methodName": "ExportEntries",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "VariableStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportentries",
    "rawBody": "{\n  0:let entries = (0) (new [])\n  1:(0) access __x0__ = (VariableStatement \"BoundNames\")\n  1:let names = __x0__\n  2:let __x1__ = names\n  2:let __x2__ = 0i\n  2:while (< __x2__ __x1__[\"length\"]) {\n    let name = __x1__[__x2__]\n    3:append (1) (new ExportEntryRecord(\"ModuleRequest\" -> null, \"ImportName\" -> null, \"LocalName\" -> name, \"ExportName\" -> name)) -> entries\n    __x2__ = (+ __x2__ 1i)\n  }\n  4:return entries\n}"
  }, {
    "code": ["          1. Let _entries_ be a new empty List.", "          1. Let _names_ be the BoundNames of |Declaration|.", "          1. For each element _name_ of _names_, do", "            1. Append the ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _name_, [[ExportName]]: _name_ } to _entries_.", "          1. Return _entries_."],
    "head": {
      "idx": 3,
      "methodName": "ExportEntries",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "Declaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportentries",
    "rawBody": "{\n  0:let entries = (0) (new [])\n  1:(0) access __x0__ = (Declaration \"BoundNames\")\n  1:let names = __x0__\n  2:let __x1__ = names\n  2:let __x2__ = 0i\n  2:while (< __x2__ __x1__[\"length\"]) {\n    let name = __x1__[__x2__]\n    3:append (1) (new ExportEntryRecord(\"ModuleRequest\" -> null, \"ImportName\" -> null, \"LocalName\" -> name, \"ExportName\" -> name)) -> entries\n    __x2__ = (+ __x2__ 1i)\n  }\n  4:return entries\n}"
  }, {
    "code": ["          1. Let _names_ be BoundNames of |HoistableDeclaration|.", "          1. Let _localName_ be the sole element of _names_.", "          1. Return a List whose sole element is the ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _localName_, [[ExportName]]: *\"default\"* }."],
    "head": {
      "idx": 4,
      "methodName": "ExportEntries",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "term": "default"
        }, {
          "args": [],
          "name": "HoistableDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportentries",
    "rawBody": "{\n  0:(0) access __x0__ = (HoistableDeclaration \"BoundNames\")\n  0:let names = __x0__\n  1:let localName = names[0i]\n  2:return (0) (new [(1) (new ExportEntryRecord(\"ModuleRequest\" -> null, \"ImportName\" -> null, \"LocalName\" -> localName, \"ExportName\" -> \"default\"))])\n}"
  }, {
    "code": ["          1. Let _names_ be BoundNames of |ClassDeclaration|.", "          1. Let _localName_ be the sole element of _names_.", "          1. Return a List whose sole element is the ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _localName_, [[ExportName]]: *\"default\"* }."],
    "head": {
      "idx": 5,
      "methodName": "ExportEntries",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "term": "default"
        }, {
          "args": [],
          "name": "ClassDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportentries",
    "rawBody": "{\n  0:(0) access __x0__ = (ClassDeclaration \"BoundNames\")\n  0:let names = __x0__\n  1:let localName = names[0i]\n  2:return (0) (new [(1) (new ExportEntryRecord(\"ModuleRequest\" -> null, \"ImportName\" -> null, \"LocalName\" -> localName, \"ExportName\" -> \"default\"))])\n}"
  }, {
    "code": ["          1. Let _entry_ be the ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: *\"\\*default\\*\"*, [[ExportName]]: *\"default\"* }.", "          1. Return a List whose sole element is _entry_."],
    "head": {
      "idx": 6,
      "methodName": "ExportEntries",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "term": "default"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-exportentries",
    "rawBody": "{\n  0:let entry = (0) (new ExportEntryRecord(\"ModuleRequest\" -> null, \"ImportName\" -> null, \"LocalName\" -> \"*default*\", \"ExportName\" -> \"default\"))\n  1:return (1) (new [entry])\n}"
  }, {
    "code": ["          1. Let _entry_ be the ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: *\"\\*\"*, [[LocalName]]: *null*, [[ExportName]]: *null* }.", "          1. Return a List whose sole element is _entry_."],
    "head": {
      "idx": 0,
      "methodName": "ExportEntriesForModule",
      "prod": "ExportFromClause",
      "rhs": {
        "tokens": [{
          "term": "*"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "module"
      }]
    },
    "ids": "sec-static-semantics-exportentriesformodule",
    "rawBody": "{\n  0:let entry = (0) (new ExportEntryRecord(\"ModuleRequest\" -> module, \"ImportName\" -> \"*\", \"LocalName\" -> null, \"ExportName\" -> null))\n  1:return (1) (new [entry])\n}"
  }, {
    "code": ["          1. Let _exportName_ be the StringValue of |IdentifierName|.", "          1. Let _entry_ be the ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: *\"\\*\"*, [[LocalName]]: *null*, [[ExportName]]: _exportName_ }.", "          1. Return a List whose sole element is _entry_."],
    "head": {
      "idx": 1,
      "methodName": "ExportEntriesForModule",
      "prod": "ExportFromClause",
      "rhs": {
        "tokens": [{
          "term": "*"
        }, {
          "term": "as"
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "module"
      }]
    },
    "ids": "sec-static-semantics-exportentriesformodule",
    "rawBody": "{\n  0:(0) access __x0__ = (IdentifierName \"StringValue\")\n  0:let exportName = __x0__\n  1:let entry = (0) (new ExportEntryRecord(\"ModuleRequest\" -> module, \"ImportName\" -> \"*\", \"LocalName\" -> null, \"ExportName\" -> exportName))\n  2:return (1) (new [entry])\n}"
  }, {
    "code": ["          1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "ExportEntriesForModule",
      "prod": "NamedExports",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "module"
      }]
    },
    "ids": "sec-static-semantics-exportentriesformodule",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["          1. Let _specs_ be the ExportEntriesForModule of |ExportsList| with argument _module_.", "          1. Append to _specs_ the elements of the ExportEntriesForModule of |ExportSpecifier| with argument _module_.", "          1. Return _specs_."],
    "head": {
      "idx": 1,
      "methodName": "ExportEntriesForModule",
      "prod": "ExportsList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExportsList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "ExportSpecifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "module"
      }]
    },
    "ids": "sec-static-semantics-exportentriesformodule",
    "rawBody": "{\n  0:(0) access __x0__ = (ExportsList \"ExportEntriesForModule\" module)\n  0:let specs = __x0__\n  1:(1) access __x1__ = (ExportSpecifier \"ExportEntriesForModule\" module)\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> specs\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return specs\n}"
  }, {
    "code": ["          1. Let _sourceName_ be the StringValue of |IdentifierName|.", "          1. If _module_ is *null*, then", "            1. Let _localName_ be _sourceName_.", "            1. Let _importName_ be *null*.", "          1. Else,", "            1. Let _localName_ be *null*.", "            1. Let _importName_ be _sourceName_.", "          1. Return a List whose sole element is the ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_, [[ExportName]]: _sourceName_ }."],
    "head": {
      "idx": 0,
      "methodName": "ExportEntriesForModule",
      "prod": "ExportSpecifier",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "module"
      }]
    },
    "ids": "sec-static-semantics-exportentriesformodule",
    "rawBody": "{\n  0:(0) access __x0__ = (IdentifierName \"StringValue\")\n  0:let sourceName = __x0__\n  4:if (= module null) {\n    2:let localName = sourceName\n    3:let importName = null\n  } else {\n    5:let localName = null\n    6:let importName = sourceName\n  }\n  7:return (0) (new [(1) (new ExportEntryRecord(\"ModuleRequest\" -> module, \"ImportName\" -> importName, \"LocalName\" -> localName, \"ExportName\" -> sourceName))])\n}"
  }, {
    "code": ["          1. Let _sourceName_ be the StringValue of the first |IdentifierName|.", "          1. Let _exportName_ be the StringValue of the second |IdentifierName|.", "          1. If _module_ is *null*, then", "            1. Let _localName_ be _sourceName_.", "            1. Let _importName_ be *null*.", "          1. Else,", "            1. Let _localName_ be *null*.", "            1. Let _importName_ be _sourceName_.", "          1. Return a List whose sole element is the ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_, [[ExportName]]: _exportName_ }."],
    "head": {
      "idx": 1,
      "methodName": "ExportEntriesForModule",
      "prod": "ExportSpecifier",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }, {
          "term": "as"
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "module"
      }]
    },
    "ids": "sec-static-semantics-exportentriesformodule",
    "rawBody": "{\n  0:(0) access __x0__ = (IdentifierName0 \"StringValue\")\n  0:let sourceName = __x0__\n  1:(1) access __x1__ = (IdentifierName1 \"StringValue\")\n  1:let exportName = __x1__\n  5:if (= module null) {\n    3:let localName = sourceName\n    4:let importName = null\n  } else {\n    6:let localName = null\n    7:let importName = sourceName\n  }\n  8:return (0) (new [(1) (new ExportEntryRecord(\"ModuleRequest\" -> module, \"ImportName\" -> importName, \"LocalName\" -> localName, \"ExportName\" -> exportName))])\n}"
  }, {
    "code": ["          1. Return a new empty List."],
    "head": {
      "idx": 0,
      "methodName": "ReferencedBindings",
      "prod": "NamedExports",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-referencedbindings",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["          1. Let _names_ be the ReferencedBindings of |ExportsList|.", "          1. Append to _names_ the elements of the ReferencedBindings of |ExportSpecifier|.", "          1. Return _names_."],
    "head": {
      "idx": 1,
      "methodName": "ReferencedBindings",
      "prod": "ExportsList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ExportsList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "ExportSpecifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-referencedbindings",
    "rawBody": "{\n  0:(0) access __x0__ = (ExportsList \"ReferencedBindings\")\n  0:let names = __x0__\n  1:(1) access __x1__ = (ExportSpecifier \"ReferencedBindings\")\n  1:let __x2__ = __x1__\n  1:let __x3__ = 0i\n  1:while (< __x3__ __x2__[\"length\"]) {\n    let __x4__ = __x2__[__x3__]\n    append __x4__ -> names\n    __x3__ = (+ __x3__ 1i)\n  }\n  2:return names\n}"
  }, {
    "code": ["          1. Return a List whose sole element is the |IdentifierName|."],
    "head": {
      "idx": 0,
      "methodName": "ReferencedBindings",
      "prod": "ExportSpecifier",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-referencedbindings",
    "rawBody": "return (0) (new [IdentifierName])"
  }, {
    "code": ["          1. Return a List whose sole element is the first |IdentifierName|."],
    "head": {
      "idx": 1,
      "methodName": "ReferencedBindings",
      "prod": "ExportSpecifier",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }, {
          "term": "as"
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-referencedbindings",
    "rawBody": "return (0) (new [IdentifierName0])"
  }, {
    "code": ["          1. Return NormalCompletion(~empty~)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "ExportFromClause",
          "optional": false
        }, {
          "args": [],
          "name": "FromClause",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-exports-runtime-semantics-evaluation",
    "rawBody": "return CONST_empty"
  }, {
    "code": ["          1. Return NormalCompletion(~empty~)."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "NamedExports",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-exports-runtime-semantics-evaluation",
    "rawBody": "return CONST_empty"
  }, {
    "code": ["          1. Return the result of evaluating |VariableStatement|."],
    "head": {
      "idx": 2,
      "methodName": "Evaluation",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "VariableStatement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-exports-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (VariableStatement \"Evaluation\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return the result of evaluating |Declaration|."],
    "head": {
      "idx": 3,
      "methodName": "Evaluation",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "Declaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-exports-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (Declaration \"Evaluation\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return the result of evaluating |HoistableDeclaration|."],
    "head": {
      "idx": 4,
      "methodName": "Evaluation",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "term": "default"
        }, {
          "args": [],
          "name": "HoistableDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-exports-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (HoistableDeclaration \"Evaluation\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Let _value_ be ? BindingClassDeclarationEvaluation of |ClassDeclaration|.", "          1. Let _className_ be the sole element of BoundNames of |ClassDeclaration|.", "          1. If _className_ is *\"\\*default\\*\"*, then", "            1. Let _env_ be the running execution context's LexicalEnvironment.", "            1. Perform ? InitializeBoundName(*\"\\*default\\*\"*, _value_, _env_).", "          1. Return NormalCompletion(~empty~)."],
    "head": {
      "idx": 5,
      "methodName": "Evaluation",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "term": "default"
        }, {
          "args": [],
          "name": "ClassDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-exports-runtime-semantics-evaluation",
    "rawBody": "{\n  0:(0) access __x0__ = (ClassDeclaration \"BindingClassDeclarationEvaluation\")\n  0:let value = [? __x0__]\n  1:(1) access __x1__ = (ClassDeclaration \"BoundNames\")\n  1:let className = __x1__[0i]\n  2:if (= className \"*default*\") {\n    3:let env = CONTEXT[\"LexicalEnvironment\"]\n    4:(2) app __x2__ = (InitializeBoundName \"*default*\" value env)\n    4:[? __x2__]\n  } else 1:{}\n  5:return CONST_empty\n}"
  }, {
    "code": ["          1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true*, then", "            1. Let _value_ be ? NamedEvaluation of |AssignmentExpression| with argument *\"default\"*.", "          1. Else,", "            1. Let _rhs_ be the result of evaluating |AssignmentExpression|.", "            1. Let _value_ be ? GetValue(_rhs_).", "          1. Let _env_ be the running execution context's LexicalEnvironment.", "          1. Perform ? InitializeBoundName(*\"\\*default\\*\"*, _value_, _env_).", "          1. Return NormalCompletion(~empty~)."],
    "head": {
      "idx": 6,
      "methodName": "Evaluation",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "term": "default"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-exports-runtime-semantics-evaluation",
    "rawBody": "{\n  2:(0) app __x0__ = (IsAnonymousFunctionDefinition AssignmentExpression)\n  2:if (= __x0__ true) {\n    1:(1) access __x1__ = (AssignmentExpression \"NamedEvaluation\" \"default\")\n    1:let value = [? __x1__]\n  } else {\n    3:(2) access __x2__ = (AssignmentExpression \"Evaluation\")\n    3:let rhs = __x2__\n    4:(3) app __x3__ = (GetValue rhs)\n    4:let value = [? __x3__]\n  }\n  5:let env = CONTEXT[\"LexicalEnvironment\"]\n  6:(4) app __x4__ = (InitializeBoundName \"*default*\" value env)\n  6:[? __x4__]\n  7:return CONST_empty\n}"
  }, {
    "code": ["        1. Assert: The execution context stack has at least two elements.", "        1. Let _callerContext_ be the second to top element of the execution context stack.", "        1. Let _callerRealm_ be _callerContext_'s Realm.", "        1. Return ? PerformEval(_x_, _callerRealm_, *false*, *false*)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "x"
      }],
      "ref": "eval"
    },
    "ids": "sec-eval-x",
    "rawBody": "{\n  1:let callerContext = EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 2i)]\n  2:let callerRealm = callerContext[\"Realm\"]\n  3:(0) app __x0__ = (PerformEval x callerRealm false false)\n  3:return [? __x0__]\n}"
  }, {
    "code": ["          1. Assert: If _direct_ is *false*, then _strictCaller_ is also *false*.", "          1. If Type(_x_) is not String, return _x_.", "          1. Let _evalRealm_ be the current Realm Record.", "          1. Perform ? HostEnsureCanCompileStrings(_callerRealm_, _evalRealm_).", "          1. Let _inFunction_ be *false*.", "          1. Let _inMethod_ be *false*.", "          1. Let _inDerivedConstructor_ be *false*.", "          1. If _direct_ is *true*, then", "            1. Let _thisEnvRec_ be ! GetThisEnvironment().", "            1. If _thisEnvRec_ is a function Environment Record, then", "              1. Let _F_ be _thisEnvRec_.[[FunctionObject]].", "              1. Set _inFunction_ to *true*.", "              1. Set _inMethod_ to _thisEnvRec_.HasSuperBinding().", "              1. If _F_.[[ConstructorKind]] is ~derived~, set _inDerivedConstructor_ to *true*.", "          1. Perform the following substeps in an implementation-defined order, possibly interleaving parsing and error detection:", "            1. Let _script_ be ParseText(! StringToCodePoints(_x_), |Script|).", "            1. If _script_ is a List of errors, throw a *SyntaxError* exception.", "            1. If _script_ Contains |ScriptBody| is *false*, return *undefined*.", "            1. Let _body_ be the |ScriptBody| of _script_.", "            1. If _inFunction_ is *false*, and _body_ Contains |NewTarget|, throw a *SyntaxError* exception.", "            1. If _inMethod_ is *false*, and _body_ Contains |SuperProperty|, throw a *SyntaxError* exception.", "            1. If _inDerivedConstructor_ is *false*, and _body_ Contains |SuperCall|, throw a *SyntaxError* exception.", "          1. If _strictCaller_ is *true*, let _strictEval_ be *true*.", "          1. Else, let _strictEval_ be IsStrict of _script_.", "          1. Let _runningContext_ be the running execution context.", "          1. NOTE: If _direct_ is *true*, _runningContext_ will be the execution context that performed the direct eval. If _direct_ is *false*, _runningContext_ will be the execution context for the invocation of the `eval` function.", "          1. If _direct_ is *true*, then", "            1. Let _lexEnv_ be NewDeclarativeEnvironment(_runningContext_'s LexicalEnvironment).", "            1. Let _varEnv_ be _runningContext_'s VariableEnvironment.", "          1. Else,", "            1. Let _lexEnv_ be NewDeclarativeEnvironment(_evalRealm_.[[GlobalEnv]]).", "            1. Let _varEnv_ be _evalRealm_.[[GlobalEnv]].", "          1. If _strictEval_ is *true*, set _varEnv_ to _lexEnv_.", "          1. If _runningContext_ is not already suspended, suspend _runningContext_.", "          1. Let _evalContext_ be a new ECMAScript code execution context.", "          1. Set _evalContext_'s Function to *null*.", "          1. Set _evalContext_'s Realm to _evalRealm_.", "          1. Set _evalContext_'s ScriptOrModule to _runningContext_'s ScriptOrModule.", "          1. Set _evalContext_'s VariableEnvironment to _varEnv_.", "          1. Set _evalContext_'s LexicalEnvironment to _lexEnv_.", "          1. Push _evalContext_ onto the execution context stack; _evalContext_ is now the running execution context.", "          1. Let _result_ be EvalDeclarationInstantiation(_body_, _varEnv_, _lexEnv_, _strictEval_).", "          1. If _result_.[[Type]] is ~normal~, then", "            1. Set _result_ to the result of evaluating _body_.", "          1. If _result_.[[Type]] is ~normal~ and _result_.[[Value]] is ~empty~, then", "            1. Set _result_ to NormalCompletion(*undefined*).", "          1. Suspend _evalContext_ and remove it from the execution context stack.", "          1. Resume the context that is now on the top of the execution context stack as the running execution context.", "          1. Return Completion(_result_)."],
    "head": {
      "name": "PerformEval",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "callerRealm"
      }, {
        "kind": "Normal",
        "name": "strictCaller"
      }, {
        "kind": "Normal",
        "name": "direct"
      }]
    },
    "ids": "sec-performeval",
    "rawBody": "{\n  1:if (! (= (typeof x) String)) return x else 25:{}\n  2:let evalRealm = REALM\n  3:(0) app __x0__ = (HostEnsureCanCompileStrings callerRealm evalRealm)\n  3:[? __x0__]\n  4:let inFunction = false\n  5:let inMethod = false\n  6:let inDerivedConstructor = false\n  7:if (= direct true) {\n    8:(1) app __x1__ = (GetThisEnvironment)\n    8:let thisEnvRec = [! __x1__]\n    9:if (0) (is-instance-of thisEnvRec FunctionEnvironmentRecord) {\n      10:let F = thisEnvRec[\"FunctionObject\"]\n      11:inFunction = true\n      12:(2) app __x2__ = (thisEnvRec[\"HasSuperBinding\"] thisEnvRec)\n      12:inMethod = __x2__\n      13:if (= F[\"ConstructorKind\"] CONST_derived) inDerivedConstructor = true else 25:{}\n    } else 25:{}\n  } else 25:{}\n  14:let parameterGoal = AST_FormalParameters\n  14:let script = AST_Script\n  14:let body = AST_ScriptBody\n  23:if (= strictCaller true) let strictEval = true else {\n    (3) access __x3__ = (script \"IsStrict\")\n    let strictEval = __x3__\n  }\n  24:let runningContext = CONTEXT\n  29:if (= direct true) {\n    27:(4) app __x4__ = (NewDeclarativeEnvironment runningContext[\"LexicalEnvironment\"])\n    27:let lexEnv = __x4__\n    28:let varEnv = runningContext[\"VariableEnvironment\"]\n  } else {\n    30:(5) app __x5__ = (NewDeclarativeEnvironment evalRealm[\"GlobalEnv\"])\n    30:let lexEnv = __x5__\n    31:let varEnv = evalRealm[\"GlobalEnv\"]\n  }\n  32:if (= strictEval true) varEnv = lexEnv else 25:{}\n  33:if (= runningContext null) CONTEXT = null else 25:{}\n  34:let evalContext = (1) (new ExecutionContext())\n  35:evalContext[\"Function\"] = null\n  36:evalContext[\"Realm\"] = evalRealm\n  37:evalContext[\"ScriptOrModule\"] = runningContext[\"ScriptOrModule\"]\n  38:evalContext[\"VariableEnvironment\"] = varEnv\n  39:evalContext[\"LexicalEnvironment\"] = lexEnv\n  40:append evalContext -> EXECUTION_STACK\n  40:CONTEXT = EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)]\n  41:(6) app __x6__ = (EvalDeclarationInstantiation body varEnv lexEnv strictEval)\n  41:let result = __x6__\n  42:if (= result[\"Type\"] CONST_normal) {\n    43:(7) access __x7__ = (body \"Evaluation\")\n    43:result = __x7__\n  } else 25:{}\n  44:if (&& (= result[\"Type\"] CONST_normal) (= result[\"Value\"] CONST_empty)) {\n    45:(8) app __x8__ = (NormalCompletion undefined)\n    45:result = __x8__\n  } else 25:{}\n  46:CONTEXT = null\n  46:if (= EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)] evalContext) (pop EXECUTION_STACK (- EXECUTION_STACK[\"length\"] 1i)) else 25:{}\n  47:CONTEXT = EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)]\n  48:return result\n}"
  }, {
    "code": ["          1. Let _varNames_ be the VarDeclaredNames of _body_.", "          1. Let _varDeclarations_ be the VarScopedDeclarations of _body_.", "          1. If _strict_ is *false*, then", "            1. If _varEnv_ is a global Environment Record, then", "              1. For each element _name_ of _varNames_, do", "                1. If _varEnv_.HasLexicalDeclaration(_name_) is *true*, throw a *SyntaxError* exception.", "                1. NOTE: `eval` will not create a global var declaration that would be shadowed by a global lexical declaration.", "            1. Let _thisEnv_ be _lexEnv_.", "            1. Assert: The following loop will terminate.", "            1. Repeat, while _thisEnv_ is not the same as _varEnv_,", "              1. If _thisEnv_ is not an object Environment Record, then", "                1. NOTE: The environment of with statements cannot contain any lexical declaration so it doesn't need to be checked for var/let hoisting conflicts.", "                1. For each element _name_ of _varNames_, do", "                  1. If _thisEnv_.HasBinding(_name_) is *true*, then", "                    1. [id=\"step-evaldeclarationinstantiation-throw-duplicate-binding\"] Throw a *SyntaxError* exception.", "                    1. NOTE: Annex <emu-xref href=\"#sec-variablestatements-in-catch-blocks\"></emu-xref> defines alternate semantics for the above step.", "                  1. NOTE: A direct eval will not hoist var declaration over a like-named lexical declaration.", "              1. Set _thisEnv_ to _thisEnv_.[[OuterEnv]].", "          1. Let _functionsToInitialize_ be a new empty List.", "          1. Let _declaredFunctionNames_ be a new empty List.", "          1. For each element _d_ of _varDeclarations_, in reverse List order, do", "            1. If _d_ is neither a |VariableDeclaration| nor a |ForBinding| nor a |BindingIdentifier|, then", "              1. Assert: _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|.", "              1. NOTE: If there are multiple function declarations for the same name, the last declaration is used.", "              1. Let _fn_ be the sole element of the BoundNames of _d_.", "              1. If _fn_ is not an element of _declaredFunctionNames_, then", "                1. If _varEnv_ is a global Environment Record, then", "                  1. Let _fnDefinable_ be ? _varEnv_.CanDeclareGlobalFunction(_fn_).", "                  1. If _fnDefinable_ is *false*, throw a *TypeError* exception.", "                1. Append _fn_ to _declaredFunctionNames_.", "                1. Insert _d_ as the first element of _functionsToInitialize_.", "          1. [id=\"step-evaldeclarationinstantiation-web-compat-insertion-point\"] NOTE: Annex <emu-xref href=\"#sec-web-compat-evaldeclarationinstantiation\"></emu-xref> adds additional steps at this point.", "          1. Let _declaredVarNames_ be a new empty List.", "          1. For each element _d_ of _varDeclarations_, do", "            1. If _d_ is a |VariableDeclaration|, a |ForBinding|, or a |BindingIdentifier|, then", "              1. For each String _vn_ of the BoundNames of _d_, do", "                1. If _vn_ is not an element of _declaredFunctionNames_, then", "                  1. If _varEnv_ is a global Environment Record, then", "                    1. Let _vnDefinable_ be ? _varEnv_.CanDeclareGlobalVar(_vn_).", "                    1. If _vnDefinable_ is *false*, throw a *TypeError* exception.", "                  1. If _vn_ is not an element of _declaredVarNames_, then", "                    1. Append _vn_ to _declaredVarNames_.", "          1. [id=\"step-evaldeclarationinstantiation-post-validation\"] NOTE: No abnormal terminations occur after this algorithm step unless _varEnv_ is a global Environment Record and the global object is a Proxy exotic object.", "          1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _body_.", "          1. For each element _d_ of _lexDeclarations_, do", "            1. NOTE: Lexically declared names are only instantiated here but not initialized.", "            1. For each element _dn_ of the BoundNames of _d_, do", "              1. If IsConstantDeclaration of _d_ is *true*, then", "                1. Perform ? _lexEnv_.CreateImmutableBinding(_dn_, *true*).", "              1. Else,", "                1. Perform ? _lexEnv_.CreateMutableBinding(_dn_, *false*).", "          1. For each Parse Node _f_ of _functionsToInitialize_, do", "            1. Let _fn_ be the sole element of the BoundNames of _f_.", "            1. Let _fo_ be InstantiateFunctionObject of _f_ with argument _lexEnv_.", "            1. If _varEnv_ is a global Environment Record, then", "              1. Perform ? _varEnv_.CreateGlobalFunctionBinding(_fn_, _fo_, *true*).", "            1. Else,", "              1. Let _bindingExists_ be _varEnv_.HasBinding(_fn_).", "              1. If _bindingExists_ is *false*, then", "                1. Let _status_ be ! _varEnv_.CreateMutableBinding(_fn_, *true*).", "                1. Assert: _status_ is not an abrupt completion because of validation preceding step <emu-xref href=\"#step-evaldeclarationinstantiation-post-validation\"></emu-xref>.", "                1. Perform ! _varEnv_.InitializeBinding(_fn_, _fo_).", "              1. Else,", "                1. Perform ! _varEnv_.SetMutableBinding(_fn_, _fo_, *false*).", "          1. For each String _vn_ of _declaredVarNames_, do", "            1. If _varEnv_ is a global Environment Record, then", "              1. Perform ? _varEnv_.CreateGlobalVarBinding(_vn_, *true*).", "            1. Else,", "              1. Let _bindingExists_ be _varEnv_.HasBinding(_vn_).", "              1. If _bindingExists_ is *false*, then", "                1. Let _status_ be ! _varEnv_.CreateMutableBinding(_vn_, *true*).", "                1. Assert: _status_ is not an abrupt completion because of validation preceding step <emu-xref href=\"#step-evaldeclarationinstantiation-post-validation\"></emu-xref>.", "                1. Perform ! _varEnv_.InitializeBinding(_vn_, *undefined*).", "          1. Return NormalCompletion(~empty~)."],
    "head": {
      "name": "EvalDeclarationInstantiation",
      "params": [{
        "kind": "Normal",
        "name": "body"
      }, {
        "kind": "Normal",
        "name": "varEnv"
      }, {
        "kind": "Normal",
        "name": "lexEnv"
      }, {
        "kind": "Normal",
        "name": "strict"
      }]
    },
    "ids": "sec-evaldeclarationinstantiation",
    "rawBody": "{\n  0:(0) access __x0__ = (body \"VarDeclaredNames\")\n  0:let varNames = __x0__\n  1:(1) access __x1__ = (body \"VarScopedDeclarations\")\n  1:let varDeclarations = __x1__\n  2:if (= strict false) {\n    3:if (0) (is-instance-of varEnv GlobalEnvironmentRecord) {\n      4:let __x2__ = varNames\n      4:let __x3__ = 0i\n      4:while (< __x3__ __x2__[\"length\"]) {\n        let name = __x2__[__x3__]\n        5:(2) app __x4__ = (varEnv[\"HasLexicalDeclaration\"] varEnv name)\n        5:if (= __x4__ true) (1) throw SyntaxError else 71:{}\n        __x3__ = (+ __x3__ 1i)\n      }\n    } else 71:{}\n    7:let thisEnv = lexEnv\n    9:while (! (= thisEnv varEnv)) {\n      10:if (! (2) (is-instance-of thisEnv ObjectEnvironmentRecord)) {\n        12:let __x5__ = varNames\n        12:let __x6__ = 0i\n        12:while (< __x6__ __x5__[\"length\"]) {\n          let name = __x5__[__x6__]\n          13:(3) app __x7__ = (thisEnv[\"HasBinding\"] thisEnv name)\n          13:if (= __x7__ true) (3) throw SyntaxError else 71:{}\n          __x6__ = (+ __x6__ 1i)\n        }\n      } else 71:{}\n      17:thisEnv = thisEnv[\"OuterEnv\"]\n    }\n  } else 71:{}\n  18:let functionsToInitialize = (4) (new [])\n  19:let declaredFunctionNames = (5) (new [])\n  20:let __x8__ = varDeclarations\n  20:let __x9__ = __x8__[\"length\"]\n  20:while (< 0i __x9__) {\n    __x9__ = (- __x9__ 1i)\n    let d = __x8__[__x9__]\n    21:if (! (|| (|| (6) (is-instance-of d VariableDeclaration) (7) (is-instance-of d ForBinding)) (8) (is-instance-of d BindingIdentifier))) {\n      22:assert (|| (|| (|| (9) (is-instance-of d FunctionDeclaration) (10) (is-instance-of d GeneratorDeclaration)) (11) (is-instance-of d AsyncFunctionDeclaration)) (12) (is-instance-of d AsyncGeneratorDeclaration))\n      24:(4) access __x10__ = (d \"BoundNames\")\n      24:let fn = __x10__[0i]\n      25:if (! (contains declaredFunctionNames fn)) {\n        26:if (13) (is-instance-of varEnv GlobalEnvironmentRecord) {\n          27:(5) app __x11__ = (varEnv[\"CanDeclareGlobalFunction\"] varEnv fn)\n          27:let fnDefinable = [? __x11__]\n          28:if (= fnDefinable false) (14) throw TypeError else 71:{}\n        } else 71:{}\n        29:append fn -> declaredFunctionNames\n        30:prepend d -> functionsToInitialize\n      } else 71:{}\n    } else 71:{}\n  }\n  32:let declaredVarNames = (15) (new [])\n  33:let __x12__ = varDeclarations\n  33:let __x13__ = 0i\n  33:while (< __x13__ __x12__[\"length\"]) {\n    let d = __x12__[__x13__]\n    34:if (|| (|| (16) (is-instance-of d VariableDeclaration) (17) (is-instance-of d ForBinding)) (18) (is-instance-of d BindingIdentifier)) {\n      35:(6) access __x14__ = (d \"BoundNames\")\n      35:let __x15__ = __x14__\n      35:let __x16__ = 0i\n      35:while (< __x16__ __x15__[\"length\"]) {\n        let vn = __x15__[__x16__]\n        36:if (! (contains declaredFunctionNames vn)) {\n          37:if (19) (is-instance-of varEnv GlobalEnvironmentRecord) {\n            38:(7) app __x17__ = (varEnv[\"CanDeclareGlobalVar\"] varEnv vn)\n            38:let vnDefinable = [? __x17__]\n            39:if (= vnDefinable false) (20) throw TypeError else 71:{}\n          } else 71:{}\n          40:if (! (contains declaredVarNames vn)) append vn -> declaredVarNames else 71:{}\n        } else 71:{}\n        __x16__ = (+ __x16__ 1i)\n      }\n    } else 71:{}\n    __x13__ = (+ __x13__ 1i)\n  }\n  43:(8) access __x18__ = (body \"LexicallyScopedDeclarations\")\n  43:let lexDeclarations = __x18__\n  44:let __x19__ = lexDeclarations\n  44:let __x20__ = 0i\n  44:while (< __x20__ __x19__[\"length\"]) {\n    let d = __x19__[__x20__]\n    46:(9) access __x21__ = (d \"BoundNames\")\n    46:let __x22__ = __x21__\n    46:let __x23__ = 0i\n    46:while (< __x23__ __x22__[\"length\"]) {\n      let dn = __x22__[__x23__]\n      49:(10) access __x24__ = (d \"IsConstantDeclaration\")\n      49:if (= __x24__ true) {\n        48:(11) app __x25__ = (lexEnv[\"CreateImmutableBinding\"] lexEnv dn true)\n        48:[? __x25__]\n      } else {\n        50:(12) app __x26__ = (lexEnv[\"CreateMutableBinding\"] lexEnv dn false)\n        50:[? __x26__]\n      }\n      __x23__ = (+ __x23__ 1i)\n    }\n    __x20__ = (+ __x20__ 1i)\n  }\n  51:let __x27__ = functionsToInitialize\n  51:let __x28__ = 0i\n  51:while (< __x28__ __x27__[\"length\"]) {\n    let f = __x27__[__x28__]\n    52:(13) access __x29__ = (f \"BoundNames\")\n    52:let fn = __x29__[0i]\n    53:(14) access __x30__ = (f \"InstantiateFunctionObject\" lexEnv)\n    53:let fo = __x30__\n    56:if (21) (is-instance-of varEnv GlobalEnvironmentRecord) {\n      55:(15) app __x31__ = (varEnv[\"CreateGlobalFunctionBinding\"] varEnv fn fo true)\n      55:[? __x31__]\n    } else {\n      57:(16) app __x32__ = (varEnv[\"HasBinding\"] varEnv fn)\n      57:let bindingExists = __x32__\n      62:if (= bindingExists false) {\n        59:(17) app __x33__ = (varEnv[\"CreateMutableBinding\"] varEnv fn true)\n        59:let status = [! __x33__]\n        61:(18) app __x34__ = (varEnv[\"InitializeBinding\"] varEnv fn fo)\n        61:[! __x34__]\n      } else {\n        63:(19) app __x35__ = (varEnv[\"SetMutableBinding\"] varEnv fn fo false)\n        63:[! __x35__]\n      }\n    }\n    __x28__ = (+ __x28__ 1i)\n  }\n  64:let __x36__ = declaredVarNames\n  64:let __x37__ = 0i\n  64:while (< __x37__ __x36__[\"length\"]) {\n    let vn = __x36__[__x37__]\n    67:if (22) (is-instance-of varEnv GlobalEnvironmentRecord) {\n      66:(20) app __x38__ = (varEnv[\"CreateGlobalVarBinding\"] varEnv vn true)\n      66:[? __x38__]\n    } else {\n      68:(21) app __x39__ = (varEnv[\"HasBinding\"] varEnv vn)\n      68:let bindingExists = __x39__\n      69:if (= bindingExists false) {\n        70:(22) app __x40__ = (varEnv[\"CreateMutableBinding\"] varEnv vn true)\n        70:let status = [! __x40__]\n        72:(23) app __x41__ = (varEnv[\"InitializeBinding\"] varEnv vn undefined)\n        72:[! __x41__]\n      } else 71:{}\n    }\n    __x37__ = (+ __x37__ 1i)\n  }\n  73:return CONST_empty\n}"
  }, {
    "code": ["        1. Let _num_ be ? ToNumber(_number_).", "        1. If _num_ is *NaN*, *+∞*<sub>𝔽</sub>, or *-∞*<sub>𝔽</sub>, return *false*.", "        1. Otherwise, return *true*."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "number"
      }],
      "ref": "isFinite"
    },
    "ids": "sec-isfinite-number",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber number)\n  0:let num = [? __x0__]\n  2:if (|| (|| (= num NaN) (= num Infinity)) (= num -Infinity)) return false else return true\n}"
  }, {
    "code": ["        1. Let _num_ be ? ToNumber(_number_).", "        1. If _num_ is *NaN*, return *true*.", "        1. Otherwise, return *false*."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "number"
      }],
      "ref": "isNaN"
    },
    "ids": "sec-isnan-number",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber number)\n  0:let num = [? __x0__]\n  2:if (= num NaN) return true else return false\n}"
  }, {
    "code": ["        1. Let _inputString_ be ? ToString(_string_).", "        1. Let _trimmedString_ be ! TrimString(_inputString_, ~start~).", "        1. If neither _trimmedString_ nor any prefix of _trimmedString_ satisfies the syntax of a |StrDecimalLiteral| (see <emu-xref href=\"#sec-tonumber-applied-to-the-string-type\"></emu-xref>), return *NaN*.", "        1. Let _numberString_ be the longest prefix of _trimmedString_, which might be _trimmedString_ itself, that satisfies the syntax of a |StrDecimalLiteral|.", "        1. Let _mathFloat_ be MV of _numberString_.", "        1. If _mathFloat_ = 0, then", "          1. If the first code unit of _trimmedString_ is the code unit 0x002D (HYPHEN-MINUS), return *-0*<sub>𝔽</sub>.", "          1. Return *+0*<sub>𝔽</sub>.", "        1. Return 𝔽(_mathFloat_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "string"
      }],
      "ref": "parseFloat"
    },
    "ids": "sec-parsefloat-string",
    "rawBody": "{\n  0:(0) app __x0__ = (ToString string)\n  0:let inputString = [? __x0__]\n  1:(1) app __x1__ = (TrimString inputString CONST_start)\n  1:let trimmedString = [! __x1__]\n  2:(0) ??? \"If neither id:{trimmedString} nor any prefix of id:{trimmedString} satisfies the syntax of a nt:{StrDecimalLiteral} ( see link:{sec-tonumber-applied-to-the-string-type} ) , return value:{NaN} .\"\n  3:(1) ??? \"Let id:{numberString} be the longest prefix of id:{trimmedString} , which might be id:{trimmedString} itself , that satisfies the syntax of a nt:{StrDecimalLiteral} .\"\n  4:(2) access __x2__ = (numberString \"MV\")\n  4:let mathFloat = __x2__\n  5:if (== mathFloat 0i) {\n    6:(2) ??? \"If the first code unit of id:{trimmedString} is the code unit 0x002D ( HYPHEN - MINUS ) , return value:{-0} .\"\n    7:return 0i\n  } else 71:{}\n  8:return mathFloat\n}"
  }, {
    "code": ["        1. Let _inputString_ be ? ToString(_string_).", "        1. Let _S_ be ! TrimString(_inputString_, ~start~).", "        1. Let _sign_ be 1.", "        1. If _S_ is not empty and the first code unit of _S_ is the code unit 0x002D (HYPHEN-MINUS), set _sign_ to -1.", "        1. If _S_ is not empty and the first code unit of _S_ is the code unit 0x002B (PLUS SIGN) or the code unit 0x002D (HYPHEN-MINUS), remove the first code unit from _S_.", "        1. Let _R_ be ℝ(? ToInt32(_radix_)).", "        1. Let _stripPrefix_ be *true*.", "        1. If _R_ ≠ 0, then", "          1. If _R_ < 2 or _R_ > 36, return *NaN*.", "          1. If _R_ ≠ 16, set _stripPrefix_ to *false*.", "        1. Else,", "          1. Set _R_ to 10.", "        1. If _stripPrefix_ is *true*, then", "          1. If the length of _S_ is at least 2 and the first two code units of _S_ are either *\"0x\"* or *\"0X\"*, then", "            1. Remove the first two code units from _S_.", "            1. Set _R_ to 16.", "        1. If _S_ contains a code unit that is not a radix-_R_ digit, let _end_ be the index within _S_ of the first such code unit; otherwise, let _end_ be the length of _S_.", "        1. Let _Z_ be the substring of _S_ from 0 to _end_.", "        1. If _Z_ is empty, return *NaN*.", "        1. Let _mathInt_ be the integer value that is represented by _Z_ in radix-_R_ notation, using the letters <b>A</b>-<b>Z</b> and <b>a</b>-<b>z</b> for digits with values 10 through 35. (However, if _R_ is 10 and _Z_ contains more than 20 significant digits, every significant digit after the 20th may be replaced by a 0 digit, at the option of the implementation; and if _R_ is not 2, 4, 8, 10, 16, or 32, then _mathInt_ may be an implementation-approximated value representing the integer value that is represented by _Z_ in radix-_R_ notation.)", "        1. If _mathInt_ = 0, then", "          1. If _sign_ = -1, return *-0*<sub>𝔽</sub>.", "          1. Return *+0*<sub>𝔽</sub>.", "        1. Return 𝔽(_sign_ × _mathInt_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "string"
      }, {
        "kind": "Normal",
        "name": "radix"
      }],
      "ref": "parseInt"
    },
    "ids": "sec-parseint-string-radix",
    "rawBody": "{\n  0:(0) app __x0__ = (ToString string)\n  0:let inputString = [? __x0__]\n  1:(1) app __x1__ = (TrimString inputString CONST_start)\n  1:let S = [! __x1__]\n  2:let sign = 1i\n  3:(0) ??? \"If id:{S} is not empty and the first code unit of id:{S} is the code unit 0x002D ( HYPHEN - MINUS ) , set id:{sign} to - 1 .\"\n  4:(1) ??? \"If id:{S} is not empty and the first code unit of id:{S} is the code unit 0x002B ( PLUS SIGN ) or the code unit 0x002D ( HYPHEN - MINUS ) , remove the first code unit from id:{S} .\"\n  5:(2) app __x2__ = (ToInt32 radix)\n  5:let R = [? __x2__]\n  6:let stripPrefix = true\n  10:if (! (== R 0i)) {\n    8:if (|| (< R 2i) (< 36i R)) return NaN else 71:{}\n    9:if (! (== R 16i)) stripPrefix = false else 71:{}\n  } else R = 10i\n  12:if (= stripPrefix true) (2) ??? \"If the length of id:{S} is at least 2 and the first two code units of id:{S} are either value:{\\\"0x\\\"} or value:{\\\"0X\\\"} , then in:{} out:{}\" else 71:{}\n  16:(3) ??? \"If id:{S} contains a code unit that is not a radix - id:{R} digit , let id:{end} be the index within id:{S} of the first such code unit ; otherwise , let id:{end} be the length of id:{S} .\"\n  17:let __x3__ = \"\"\n  17:let __x4__ = 0i\n  17:while (< __x4__ (+ end 1i)) {\n    (3) access __x5__ = (S __x4__)\n    __x3__ = (+ __x3__ __x5__)\n    __x4__ = (+ __x4__ 1i)\n  }\n  17:let Z = __x3__\n  18:if (= Z[\"length\"] 0i) return NaN else 71:{}\n  19:(4) ??? \"Let id:{mathInt} be the integer value that is represented by id:{Z} in radix - id:{R} notation , using the letters < b > A < / b > - < b > Z < / b > and < b > a < / b > - < b > z < / b > for digits with values 10 through 35 . ( However , if id:{R} is 10 and id:{Z} contains more than 20 significant digits , every significant digit after the 20th may be replaced by a 0 digit , at the option of the implementation ; and if id:{R} is not 2 , 4 , 8 , 10 , 16 , or 32 , then id:{mathInt} may be an implementation - approximated value representing the integer value that is represented by id:{Z} in radix - id:{R} notation . )\"\n  20:if (== mathInt 0i) {\n    21:if (== sign -1i) return -0.0 else 71:{}\n    22:return 0i\n  } else 71:{}\n  23:return (* sign mathInt)\n}"
  }, {
    "code": ["            1. Let _strLen_ be the number of code units in _string_.", "            1. Let _R_ be the empty String.", "            1. Let _k_ be 0.", "            1. Repeat,", "              1. If _k_ = _strLen_, return _R_.", "              1. Let _C_ be the code unit at index _k_ within _string_.", "              1. If _C_ is in _unescapedSet_, then", "                1. Set _k_ to _k_ + 1.", "                1. Set _R_ to the string-concatenation of _R_ and _C_.", "              1. Else,", "                1. Let _cp_ be ! CodePointAt(_string_, _k_).", "                1. If _cp_.[[IsUnpairedSurrogate]] is *true*, throw a *URIError* exception.", "                1. Set _k_ to _k_ + _cp_.[[CodeUnitCount]].", "                1. Let _Octets_ be the List of octets resulting by applying the UTF-8 transformation to _cp_.[[CodePoint]].", "                1. For each element _octet_ of _Octets_, do", "                  1. Set _R_ to the string-concatenation of:", "                    * _R_", "                    * *\"%\"*", "                    * the String representation of _octet_, formatted as a two-digit uppercase hexadecimal number, padded to the left with a zero if necessary"],
    "head": {
      "name": "Encode",
      "params": [{
        "kind": "Normal",
        "name": "string"
      }, {
        "kind": "Normal",
        "name": "unescapedSet"
      }]
    },
    "ids": "sec-encode",
    "rawBody": "{\n  0:let strLen = string[\"length\"]\n  1:let R = \"\"\n  2:let k = 0i\n  3:while true {\n    4:if (== k strLen) return R else 71:{}\n    5:let C = string[k]\n    9:if (contains unescapedSet C) {\n      7:k = (+ k 1i)\n      8:R = (+ R C)\n    } else {\n      10:(0) app __x0__ = (CodePointAt string k)\n      10:let cp = [! __x0__]\n      11:if (= cp[\"IsUnpairedSurrogate\"] true) (0) throw URIError else 71:{}\n      12:k = (+ k cp[\"CodeUnitCount\"])\n      13:(1) ??? \"Let id:{Octets} be the List of octets resulting by applying the UTF - 8 transformation to id:{cp} . [ [ CodePoint ] ] .\"\n      14:let __x1__ = Octets\n      14:let __x2__ = 0i\n      14:while (< __x2__ __x1__[\"length\"]) {\n        let octet = __x1__[__x2__]\n        15:R = (+ (+ R \"%\") (2) ??? \"StringOp\")\n        __x2__ = (+ __x2__ 1i)\n      }\n    }\n  }\n}"
  }, {
    "code": ["            1. Let _strLen_ be the length of _string_.", "            1. Let _R_ be the empty String.", "            1. Let _k_ be 0.", "            1. Repeat,", "              1. If _k_ = _strLen_, return _R_.", "              1. Let _C_ be the code unit at index _k_ within _string_.", "              1. If _C_ is not the code unit 0x0025 (PERCENT SIGN), then", "                1. Let _S_ be the String value containing only the code unit _C_.", "              1. Else,", "                1. Let _start_ be _k_.", "                1. If _k_ + 2 ≥ _strLen_, throw a *URIError* exception.", "                1. If the code units at index (_k_ + 1) and (_k_ + 2) within _string_ do not represent hexadecimal digits, throw a *URIError* exception.", "                1. Let _B_ be the 8-bit value represented by the two hexadecimal digits at index (_k_ + 1) and (_k_ + 2).", "                1. Set _k_ to _k_ + 2.", "                1. Let _n_ be the number of leading 1 bits in _B_.", "                1. If _n_ = 0, then", "                  1. Let _C_ be the code unit whose value is _B_.", "                  1. If _C_ is not in _reservedSet_, then", "                    1. Let _S_ be the String value containing only the code unit _C_.", "                  1. Else,", "                    1. Let _S_ be the substring of _string_ from _start_ to _k_ + 1.", "                1. Else,", "                  1. If _n_ = 1 or _n_ > 4, throw a *URIError* exception.", "                  1. If _k_ + (3 × (_n_ - 1)) ≥ _strLen_, throw a *URIError* exception.", "                  1. Let _Octets_ be a List whose sole element is _B_.", "                  1. Let _j_ be 1.", "                  1. Repeat, while _j_ < _n_,", "                    1. Set _k_ to _k_ + 1.", "                    1. If the code unit at index _k_ within _string_ is not the code unit 0x0025 (PERCENT SIGN), throw a *URIError* exception.", "                    1. If the code units at index (_k_ + 1) and (_k_ + 2) within _string_ do not represent hexadecimal digits, throw a *URIError* exception.", "                    1. Let _B_ be the 8-bit value represented by the two hexadecimal digits at index (_k_ + 1) and (_k_ + 2).", "                    1. Set _k_ to _k_ + 2.", "                    1. Append _B_ to _Octets_.", "                    1. Set _j_ to _j_ + 1.", "                  1. Assert: The length of _Octets_ is _n_.", "                  1. If _Octets_ does not contain a valid UTF-8 encoding of a Unicode code point, throw a *URIError* exception.", "                  1. Let _V_ be the code point obtained by applying the UTF-8 transformation to _Octets_, that is, from a List of octets into a 21-bit value.", "                  1. Let _S_ be UTF16EncodeCodePoint(_V_).", "              1. Set _R_ to the string-concatenation of _R_ and _S_.", "              1. Set _k_ to _k_ + 1."],
    "head": {
      "name": "Decode",
      "params": [{
        "kind": "Normal",
        "name": "string"
      }, {
        "kind": "Normal",
        "name": "reservedSet"
      }]
    },
    "ids": "sec-decode",
    "rawBody": "{\n  0:let strLen = string[\"length\"]\n  1:let R = \"\"\n  2:let k = 0i\n  3:while true {\n    4:if (== k strLen) return R else 71:{}\n    5:let C = string[k]\n    8:if (! (= C \"%\")) let S = C else {\n      9:let start = k\n      10:if (! (< (+ k 2i) strLen)) (0) throw URIError else 71:{}\n      11:(1) ??? \"If the code units at index ( id:{k} + 1 ) and ( id:{k} + 2 ) within id:{string} do not represent hexadecimal digits , throw a value:{URIError} exception .\"\n      12:(2) ??? \"Let id:{B} be the 8 - bit value represented by the two hexadecimal digits at index ( id:{k} + 1 ) and ( id:{k} + 2 ) .\"\n      13:k = (+ k 2i)\n      14:(3) ??? \"Let id:{n} be the number of leading 1 bits in id:{B} .\"\n      21:if (== n 0i) {\n        16:let C = B\n        19:if (! (contains reservedSet C)) let S = C else {\n          20:let __x0__ = \"\"\n          20:let __x1__ = start\n          20:while (< __x1__ (+ (+ k 1i) 1i)) {\n            (0) access __x2__ = (string __x1__)\n            __x0__ = (+ __x0__ __x2__)\n            __x1__ = (+ __x1__ 1i)\n          }\n          20:let S = __x0__\n        }\n      } else {\n        22:if (|| (== n 1i) (< 4i n)) (4) throw URIError else 71:{}\n        23:if (! (< (+ k (* 3i (- n 1i))) strLen)) (5) throw URIError else 71:{}\n        24:let Octets = (6) (new [B])\n        25:let j = 1i\n        26:while (< j n) {\n          27:k = (+ k 1i)\n          28:if (! (= string[k] \"%\")) (7) throw URIError else 71:{}\n          29:(8) ??? \"If the code units at index ( id:{k} + 1 ) and ( id:{k} + 2 ) within id:{string} do not represent hexadecimal digits , throw a value:{URIError} exception .\"\n          30:(9) ??? \"Let id:{B} be the 8 - bit value represented by the two hexadecimal digits at index ( id:{k} + 1 ) and ( id:{k} + 2 ) .\"\n          31:k = (+ k 2i)\n          32:append B -> Octets\n          33:j = (+ j 1i)\n        }\n        34:assert (= Octets[\"length\"] n)\n        35:(10) ??? \"If id:{Octets} does not contain a valid UTF - 8 encoding of a Unicode code point , throw a value:{URIError} exception .\"\n        36:(11) ??? \"Let id:{V} be the code point obtained by applying the UTF - 8 transformation to id:{Octets} , that is , from a List of octets into a 21 - bit value .\"\n        37:(1) app __x3__ = (UTF16EncodeCodePoint V)\n        37:let S = __x3__\n      }\n    }\n    38:R = (+ R S)\n    39:k = (+ k 1i)\n  }\n}"
  }, {
    "code": ["          1. Let _uriString_ be ? ToString(_encodedURI_).", "          1. Let _reservedURISet_ be a String containing one instance of each code unit valid in |uriReserved| plus *\"#\"*.", "          1. Return ? Decode(_uriString_, _reservedURISet_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "encodedURI"
      }],
      "ref": "decodeURI"
    },
    "ids": "sec-decodeuri-encodeduri",
    "rawBody": "{\n  0:(0) app __x0__ = (ToString encodedURI)\n  0:let uriString = [? __x0__]\n  1:(0) ??? \"Let id:{reservedURISet} be a String containing one instance of each code unit valid in nt:{uriReserved} plus value:{\\\"#\\\"} .\"\n  2:(1) app __x1__ = (Decode uriString reservedURISet)\n  2:return [? __x1__]\n}"
  }, {
    "code": ["          1. Let _componentString_ be ? ToString(_encodedURIComponent_).", "          1. Let _reservedURIComponentSet_ be the empty String.", "          1. Return ? Decode(_componentString_, _reservedURIComponentSet_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "encodedURIComponent"
      }],
      "ref": "decodeURIComponent"
    },
    "ids": "sec-decodeuricomponent-encodeduricomponent",
    "rawBody": "{\n  0:(0) app __x0__ = (ToString encodedURIComponent)\n  0:let componentString = [? __x0__]\n  1:let reservedURIComponentSet = \"\"\n  2:(1) app __x1__ = (Decode componentString reservedURIComponentSet)\n  2:return [? __x1__]\n}"
  }, {
    "code": ["          1. Let _uriString_ be ? ToString(_uri_).", "          1. Let _unescapedURISet_ be a String containing one instance of each code unit valid in |uriReserved| and |uriUnescaped| plus *\"#\"*.", "          1. Return ? Encode(_uriString_, _unescapedURISet_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "uri"
      }],
      "ref": "encodeURI"
    },
    "ids": "sec-encodeuri-uri",
    "rawBody": "{\n  0:(0) app __x0__ = (ToString uri)\n  0:let uriString = [? __x0__]\n  1:(0) ??? \"Let id:{unescapedURISet} be a String containing one instance of each code unit valid in nt:{uriReserved} and nt:{uriUnescaped} plus value:{\\\"#\\\"} .\"\n  2:(1) app __x1__ = (Encode uriString unescapedURISet)\n  2:return [? __x1__]\n}"
  }, {
    "code": ["          1. Let _componentString_ be ? ToString(_uriComponent_).", "          1. Let _unescapedURIComponentSet_ be a String containing one instance of each code unit valid in |uriUnescaped|.", "          1. Return ? Encode(_componentString_, _unescapedURIComponentSet_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "uriComponent"
      }],
      "ref": "encodeURIComponent"
    },
    "ids": "sec-encodeuricomponent-uricomponent",
    "rawBody": "{\n  0:(0) app __x0__ = (ToString uriComponent)\n  0:let componentString = [? __x0__]\n  1:(0) ??? \"Let id:{unescapedURIComponentSet} be a String containing one instance of each code unit valid in nt:{uriUnescaped} .\"\n  2:(1) app __x1__ = (Encode componentString unescapedURIComponentSet)\n  2:return [? __x1__]\n}"
  }, {
    "code": ["          1. If NewTarget is neither *undefined* nor the active function, then", "            1. Return ? OrdinaryCreateFromConstructor(NewTarget, *\"%Object.prototype%\"*).", "          1. If _value_ is *undefined* or *null*, return ! OrdinaryObjectCreate(%Object.prototype%).", "          1. Return ! ToObject(_value_)."],
    "head": {
      "origParams": [{
        "kind": "Optional",
        "name": "value"
      }],
      "ref": "Object"
    },
    "ids": "sec-object-value",
    "rawBody": "{\n  0:if (! (|| (= NewTarget undefined) (= NewTarget CONTEXT[\"Function\"]))) {\n    1:(0) app __x0__ = (OrdinaryCreateFromConstructor NewTarget \"%Object.prototype%\")\n    1:return [? __x0__]\n  } else 71:{}\n  2:if (|| (= value undefined) (= value null)) {\n    (1) app __x1__ = (OrdinaryObjectCreate INTRINSIC_Object_prototype)\n    return [! __x1__]\n  } else 71:{}\n  3:(2) app __x2__ = (ToObject value)\n  3:return [! __x2__]\n}"
  }, {
    "code": ["          1. Let _to_ be ? ToObject(_target_).", "          1. If only one argument was passed, return _to_.", "          1. For each element _nextSource_ of _sources_, do", "            1. If _nextSource_ is neither *undefined* nor *null*, then", "              1. Let _from_ be ! ToObject(_nextSource_).", "              1. Let _keys_ be ? _from_.[[OwnPropertyKeys]]().", "              1. For each element _nextKey_ of _keys_, do", "                1. Let _desc_ be ? _from_.[[GetOwnProperty]](_nextKey_).", "                1. If _desc_ is not *undefined* and _desc_.[[Enumerable]] is *true*, then", "                  1. Let _propValue_ be ? Get(_from_, _nextKey_).", "                  1. Perform ? Set(_to_, _nextKey_, _propValue_, *true*).", "          1. Return _to_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "target"
      }, {
        "kind": "Variadic",
        "name": "sources"
      }],
      "ref": "Object[\"assign\"]"
    },
    "ids": "sec-object.assign",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject target)\n  0:let to = [? __x0__]\n  1:if (= argumentsList[\"length\"] 1i) return to else 71:{}\n  2:let __x1__ = sources\n  2:let __x2__ = 0i\n  2:while (< __x2__ __x1__[\"length\"]) {\n    let nextSource = __x1__[__x2__]\n    3:if (! (|| (= nextSource undefined) (= nextSource null))) {\n      4:(1) app __x3__ = (ToObject nextSource)\n      4:let from = [! __x3__]\n      5:(2) app __x4__ = (from[\"OwnPropertyKeys\"] from)\n      5:let keys = [? __x4__]\n      6:let __x5__ = keys\n      6:let __x6__ = 0i\n      6:while (< __x6__ __x5__[\"length\"]) {\n        let nextKey = __x5__[__x6__]\n        7:(3) app __x7__ = (from[\"GetOwnProperty\"] from nextKey)\n        7:let desc = [? __x7__]\n        8:if (&& (! (= desc undefined)) (= desc[\"Enumerable\"] true)) {\n          9:(4) app __x8__ = (Get from nextKey)\n          9:let propValue = [? __x8__]\n          10:(5) app __x9__ = (Set to nextKey propValue true)\n          10:[? __x9__]\n        } else 71:{}\n        __x6__ = (+ __x6__ 1i)\n      }\n    } else 71:{}\n    __x2__ = (+ __x2__ 1i)\n  }\n  11:return to\n}"
  }, {
    "code": ["          1. If Type(_O_) is neither Object nor Null, throw a *TypeError* exception.", "          1. Let _obj_ be ! OrdinaryObjectCreate(_O_).", "          1. If _Properties_ is not *undefined*, then", "            1. Return ? ObjectDefineProperties(_obj_, _Properties_).", "          1. Return _obj_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "Properties"
      }],
      "ref": "Object[\"create\"]"
    },
    "ids": "sec-object.create",
    "rawBody": "{\n  0:if (! (|| (= (typeof O) Object) (= (typeof O) Null))) (0) throw TypeError else 71:{}\n  1:(0) app __x0__ = (OrdinaryObjectCreate O)\n  1:let obj = [! __x0__]\n  2:if (! (= Properties undefined)) {\n    3:(1) app __x1__ = (ObjectDefineProperties obj Properties)\n    3:return [? __x1__]\n  } else 71:{}\n  4:return obj\n}"
  }, {
    "code": ["          1. If Type(_O_) is not Object, throw a *TypeError* exception.", "          1. Return ? ObjectDefineProperties(_O_, _Properties_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "Properties"
      }],
      "ref": "Object[\"defineProperties\"]"
    },
    "ids": "sec-object.defineproperties",
    "rawBody": "{\n  0:if (! (= (typeof O) Object)) (0) throw TypeError else 71:{}\n  1:(0) app __x0__ = (ObjectDefineProperties O Properties)\n  1:return [? __x0__]\n}"
  }, {
    "code": ["            1. Assert: Type(_O_) is Object.", "            1. Let _props_ be ? ToObject(_Properties_).", "            1. Let _keys_ be ? _props_.[[OwnPropertyKeys]]().", "            1. Let _descriptors_ be a new empty List.", "            1. For each element _nextKey_ of _keys_, do", "              1. Let _propDesc_ be ? _props_.[[GetOwnProperty]](_nextKey_).", "              1. If _propDesc_ is not *undefined* and _propDesc_.[[Enumerable]] is *true*, then", "                1. Let _descObj_ be ? Get(_props_, _nextKey_).", "                1. Let _desc_ be ? ToPropertyDescriptor(_descObj_).", "                1. Append the pair (a two element List) consisting of _nextKey_ and _desc_ to the end of _descriptors_.", "            1. For each element _pair_ of _descriptors_, do", "              1. Let _P_ be the first element of _pair_.", "              1. Let _desc_ be the second element of _pair_.", "              1. Perform ? DefinePropertyOrThrow(_O_, _P_, _desc_).", "            1. Return _O_."],
    "head": {
      "name": "ObjectDefineProperties",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "Properties"
      }]
    },
    "ids": "sec-objectdefineproperties",
    "rawBody": "{\n  0:assert (= (typeof O) Object)\n  1:(0) app __x0__ = (ToObject Properties)\n  1:let props = [? __x0__]\n  2:(1) app __x1__ = (props[\"OwnPropertyKeys\"] props)\n  2:let keys = [? __x1__]\n  3:let descriptors = (0) (new [])\n  4:let __x2__ = keys\n  4:let __x3__ = 0i\n  4:while (< __x3__ __x2__[\"length\"]) {\n    let nextKey = __x2__[__x3__]\n    5:(2) app __x4__ = (props[\"GetOwnProperty\"] props nextKey)\n    5:let propDesc = [? __x4__]\n    6:if (&& (! (= propDesc undefined)) (= propDesc[\"Enumerable\"] true)) {\n      7:(3) app __x5__ = (Get props nextKey)\n      7:let descObj = [? __x5__]\n      8:(4) app __x6__ = (ToPropertyDescriptor descObj)\n      8:let desc = [? __x6__]\n      9:append (1) (new [nextKey, desc]) -> descriptors\n    } else 71:{}\n    __x3__ = (+ __x3__ 1i)\n  }\n  10:let __x7__ = descriptors\n  10:let __x8__ = 0i\n  10:while (< __x8__ __x7__[\"length\"]) {\n    let pair = __x7__[__x8__]\n    11:let P = pair[0i]\n    12:let desc = pair[1i]\n    13:(5) app __x9__ = (DefinePropertyOrThrow O P desc)\n    13:[? __x9__]\n    __x8__ = (+ __x8__ 1i)\n  }\n  14:return O\n}"
  }, {
    "code": ["          1. If Type(_O_) is not Object, throw a *TypeError* exception.", "          1. Let _key_ be ? ToPropertyKey(_P_).", "          1. Let _desc_ be ? ToPropertyDescriptor(_Attributes_).", "          1. Perform ? DefinePropertyOrThrow(_O_, _key_, _desc_).", "          1. Return _O_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Normal",
        "name": "Attributes"
      }],
      "ref": "Object[\"defineProperty\"]"
    },
    "ids": "sec-object.defineproperty",
    "rawBody": "{\n  0:if (! (= (typeof O) Object)) (0) throw TypeError else 71:{}\n  1:(0) app __x0__ = (ToPropertyKey P)\n  1:let key = [? __x0__]\n  2:(1) app __x1__ = (ToPropertyDescriptor Attributes)\n  2:let desc = [? __x1__]\n  3:(2) app __x2__ = (DefinePropertyOrThrow O key desc)\n  3:[? __x2__]\n  4:return O\n}"
  }, {
    "code": ["          1. Let _obj_ be ? ToObject(_O_).", "          1. Let _nameList_ be ? EnumerableOwnPropertyNames(_obj_, ~key+value~).", "          1. Return CreateArrayFromList(_nameList_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "O"
      }],
      "ref": "Object[\"entries\"]"
    },
    "ids": "sec-object.entries",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject O)\n  0:let obj = [? __x0__]\n  1:(1) app __x1__ = (EnumerableOwnPropertyNames obj CONST_keyPLUSvalue)\n  1:let nameList = [? __x1__]\n  2:(2) app __x2__ = (CreateArrayFromList nameList)\n  2:return __x2__\n}"
  }, {
    "code": ["          1. If Type(_O_) is not Object, return _O_.", "          1. Let _status_ be ? SetIntegrityLevel(_O_, ~frozen~).", "          1. If _status_ is *false*, throw a *TypeError* exception.", "          1. Return _O_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "O"
      }],
      "ref": "Object[\"freeze\"]"
    },
    "ids": "sec-object.freeze",
    "rawBody": "{\n  0:if (! (= (typeof O) Object)) return O else 71:{}\n  1:(0) app __x0__ = (SetIntegrityLevel O CONST_frozen)\n  1:let status = [? __x0__]\n  2:if (= status false) (0) throw TypeError else 71:{}\n  3:return O\n}"
  }, {
    "code": ["          1. Perform ? RequireObjectCoercible(_iterable_).", "          1. Let _obj_ be ! OrdinaryObjectCreate(%Object.prototype%).", "          1. Assert: _obj_ is an extensible ordinary object with no own properties.", "          1. Let _stepsDefine_ be the algorithm steps defined in <emu-xref href=\"#sec-create-data-property-on-object-functions\" title></emu-xref>.", "          1. Let _lengthDefine_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#sec-create-data-property-on-object-functions\" title></emu-xref>.", "          1. Let _adder_ be ! CreateBuiltinFunction(_stepsDefine_, _lengthDefine_, *\"\"*, « »).", "          1. Return ? AddEntriesFromIterable(_obj_, _iterable_, _adder_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "iterable"
      }],
      "ref": "Object[\"fromEntries\"]"
    },
    "ids": "sec-object.fromentries",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible iterable)\n  0:[? __x0__]\n  1:(1) app __x1__ = (OrdinaryObjectCreate INTRINSIC_Object_prototype)\n  1:let obj = [! __x1__]\n  3:(0) ??? \"Let id:{stepsDefine} be the algorithm steps defined in link:{sec-create-data-property-on-object-functions} .\"\n  4:(1) ??? \"Let id:{lengthDefine} be the number of non - optional parameters of the function definition in link:{sec-create-data-property-on-object-functions} .\"\n  5:(2) app __x2__ = (CreateBuiltinFunction stepsDefine lengthDefine \"\" (2) (new []))\n  5:let adder = [! __x2__]\n  6:(3) app __x3__ = (AddEntriesFromIterable obj iterable adder)\n  6:return [? __x3__]\n}"
  }, {
    "code": ["            1. Let _O_ be the *this* value.", "            1. Assert: Type(_O_) is Object.", "            1. Assert: _O_ is an extensible ordinary object.", "            1. Let _propertyKey_ be ? ToPropertyKey(_key_).", "            1. Perform ! CreateDataPropertyOrThrow(_O_, _propertyKey_, _value_).", "            1. Return *undefined*."],
    "head": {
      "name": "CreateDataPropertyOnObjectFunctions",
      "params": []
    },
    "ids": "sec-create-data-property-on-object-functions",
    "rawBody": "{\n  0:let O = this\n  1:assert (= (typeof O) Object)\n  3:(0) app __x0__ = (ToPropertyKey key)\n  3:let propertyKey = [? __x0__]\n  4:(1) app __x1__ = (CreateDataPropertyOrThrow O propertyKey value)\n  4:[! __x1__]\n  5:return undefined\n}"
  }, {
    "code": ["          1. Let _obj_ be ? ToObject(_O_).", "          1. Let _key_ be ? ToPropertyKey(_P_).", "          1. Let _desc_ be ? _obj_.[[GetOwnProperty]](_key_).", "          1. Return FromPropertyDescriptor(_desc_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "P"
      }],
      "ref": "Object[\"getOwnPropertyDescriptor\"]"
    },
    "ids": "sec-object.getownpropertydescriptor",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject O)\n  0:let obj = [? __x0__]\n  1:(1) app __x1__ = (ToPropertyKey P)\n  1:let key = [? __x1__]\n  2:(2) app __x2__ = (obj[\"GetOwnProperty\"] obj key)\n  2:let desc = [? __x2__]\n  3:(3) app __x3__ = (FromPropertyDescriptor desc)\n  3:return __x3__\n}"
  }, {
    "code": ["          1. Let _obj_ be ? ToObject(_O_).", "          1. Let _ownKeys_ be ? _obj_.[[OwnPropertyKeys]]().", "          1. Let _descriptors_ be ! OrdinaryObjectCreate(%Object.prototype%).", "          1. For each element _key_ of _ownKeys_, do", "            1. Let _desc_ be ? _obj_.[[GetOwnProperty]](_key_).", "            1. Let _descriptor_ be ! FromPropertyDescriptor(_desc_).", "            1. If _descriptor_ is not *undefined*, perform ! CreateDataPropertyOrThrow(_descriptors_, _key_, _descriptor_).", "          1. Return _descriptors_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "O"
      }],
      "ref": "Object[\"getOwnPropertyDescriptors\"]"
    },
    "ids": "sec-object.getownpropertydescriptors",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject O)\n  0:let obj = [? __x0__]\n  1:(1) app __x1__ = (obj[\"OwnPropertyKeys\"] obj)\n  1:let ownKeys = [? __x1__]\n  2:(2) app __x2__ = (OrdinaryObjectCreate INTRINSIC_Object_prototype)\n  2:let descriptors = [! __x2__]\n  3:let __x3__ = ownKeys\n  3:let __x4__ = 0i\n  3:while (< __x4__ __x3__[\"length\"]) {\n    let key = __x3__[__x4__]\n    4:(3) app __x5__ = (obj[\"GetOwnProperty\"] obj key)\n    4:let desc = [? __x5__]\n    5:(4) app __x6__ = (FromPropertyDescriptor desc)\n    5:let descriptor = [! __x6__]\n    6:if (! (= descriptor undefined)) {\n      (5) app __x7__ = (CreateDataPropertyOrThrow descriptors key descriptor)\n      [! __x7__]\n    } else 2:{}\n    __x4__ = (+ __x4__ 1i)\n  }\n  7:return descriptors\n}"
  }, {
    "code": ["          1. Return ? GetOwnPropertyKeys(_O_, ~string~)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "O"
      }],
      "ref": "Object[\"getOwnPropertyNames\"]"
    },
    "ids": "sec-object.getownpropertynames",
    "rawBody": "{\n  0:(0) app __x0__ = (GetOwnPropertyKeys O CONST_string)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Return ? GetOwnPropertyKeys(_O_, ~symbol~)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "O"
      }],
      "ref": "Object[\"getOwnPropertySymbols\"]"
    },
    "ids": "sec-object.getownpropertysymbols",
    "rawBody": "{\n  0:(0) app __x0__ = (GetOwnPropertyKeys O CONST_symbol)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["            1. Let _obj_ be ? ToObject(_O_).", "            1. Let _keys_ be ? _obj_.[[OwnPropertyKeys]]().", "            1. Let _nameList_ be a new empty List.", "            1. For each element _nextKey_ of _keys_, do", "              1. If Type(_nextKey_) is Symbol and _type_ is ~symbol~ or Type(_nextKey_) is String and _type_ is ~string~, then", "                1. Append _nextKey_ as the last element of _nameList_.", "            1. Return CreateArrayFromList(_nameList_)."],
    "head": {
      "name": "GetOwnPropertyKeys",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "type"
      }]
    },
    "ids": "sec-getownpropertykeys",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject O)\n  0:let obj = [? __x0__]\n  1:(1) app __x1__ = (obj[\"OwnPropertyKeys\"] obj)\n  1:let keys = [? __x1__]\n  2:let nameList = (0) (new [])\n  3:let __x2__ = keys\n  3:let __x3__ = 0i\n  3:while (< __x3__ __x2__[\"length\"]) {\n    let nextKey = __x2__[__x3__]\n    4:if (&& (= (typeof nextKey) Symbol) (|| (= type CONST_symbol) (&& (= (typeof nextKey) String) (= type CONST_string)))) append nextKey -> nameList else 2:{}\n    __x3__ = (+ __x3__ 1i)\n  }\n  6:(2) app __x4__ = (CreateArrayFromList nameList)\n  6:return __x4__\n}"
  }, {
    "code": ["          1. Let _obj_ be ? ToObject(_O_).", "          1. Return ? _obj_.[[GetPrototypeOf]]()."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "O"
      }],
      "ref": "Object[\"getPrototypeOf\"]"
    },
    "ids": "sec-object.getprototypeof",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject O)\n  0:let obj = [? __x0__]\n  1:(1) app __x1__ = (obj[\"GetPrototypeOf\"] obj)\n  1:return [? __x1__]\n}"
  }, {
    "code": ["          1. Return SameValue(_value1_, _value2_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "value1"
      }, {
        "kind": "Normal",
        "name": "value2"
      }],
      "ref": "Object[\"is\"]"
    },
    "ids": "sec-object.is",
    "rawBody": "{\n  0:(0) app __x0__ = (SameValue value1 value2)\n  0:return __x0__\n}"
  }, {
    "code": ["          1. If Type(_O_) is not Object, return *false*.", "          1. Return ? IsExtensible(_O_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "O"
      }],
      "ref": "Object[\"isExtensible\"]"
    },
    "ids": "sec-object.isextensible",
    "rawBody": "{\n  0:if (! (= (typeof O) Object)) return false else 2:{}\n  1:(0) app __x0__ = (IsExtensible O)\n  1:return [? __x0__]\n}"
  }, {
    "code": ["          1. If Type(_O_) is not Object, return *true*.", "          1. Return ? TestIntegrityLevel(_O_, ~frozen~)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "O"
      }],
      "ref": "Object[\"isFrozen\"]"
    },
    "ids": "sec-object.isfrozen",
    "rawBody": "{\n  0:if (! (= (typeof O) Object)) return true else 2:{}\n  1:(0) app __x0__ = (TestIntegrityLevel O CONST_frozen)\n  1:return [? __x0__]\n}"
  }, {
    "code": ["          1. If Type(_O_) is not Object, return *true*.", "          1. Return ? TestIntegrityLevel(_O_, ~sealed~)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "O"
      }],
      "ref": "Object[\"isSealed\"]"
    },
    "ids": "sec-object.issealed",
    "rawBody": "{\n  0:if (! (= (typeof O) Object)) return true else 2:{}\n  1:(0) app __x0__ = (TestIntegrityLevel O CONST_sealed)\n  1:return [? __x0__]\n}"
  }, {
    "code": ["          1. Let _obj_ be ? ToObject(_O_).", "          1. Let _nameList_ be ? EnumerableOwnPropertyNames(_obj_, ~key~).", "          1. Return CreateArrayFromList(_nameList_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "O"
      }],
      "ref": "Object[\"keys\"]"
    },
    "ids": "sec-object.keys",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject O)\n  0:let obj = [? __x0__]\n  1:(1) app __x1__ = (EnumerableOwnPropertyNames obj CONST_key)\n  1:let nameList = [? __x1__]\n  2:(2) app __x2__ = (CreateArrayFromList nameList)\n  2:return __x2__\n}"
  }, {
    "code": ["          1. If Type(_O_) is not Object, return _O_.", "          1. Let _status_ be ? _O_.[[PreventExtensions]]().", "          1. If _status_ is *false*, throw a *TypeError* exception.", "          1. Return _O_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "O"
      }],
      "ref": "Object[\"preventExtensions\"]"
    },
    "ids": "sec-object.preventextensions",
    "rawBody": "{\n  0:if (! (= (typeof O) Object)) return O else 2:{}\n  1:(0) app __x0__ = (O[\"PreventExtensions\"] O)\n  1:let status = [? __x0__]\n  2:if (= status false) (0) throw TypeError else 2:{}\n  3:return O\n}"
  }, {
    "code": ["          1. If Type(_O_) is not Object, return _O_.", "          1. Let _status_ be ? SetIntegrityLevel(_O_, ~sealed~).", "          1. If _status_ is *false*, throw a *TypeError* exception.", "          1. Return _O_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "O"
      }],
      "ref": "Object[\"seal\"]"
    },
    "ids": "sec-object.seal",
    "rawBody": "{\n  0:if (! (= (typeof O) Object)) return O else 2:{}\n  1:(0) app __x0__ = (SetIntegrityLevel O CONST_sealed)\n  1:let status = [? __x0__]\n  2:if (= status false) (0) throw TypeError else 2:{}\n  3:return O\n}"
  }, {
    "code": ["          1. Set _O_ to ? RequireObjectCoercible(_O_).", "          1. If Type(_proto_) is neither Object nor Null, throw a *TypeError* exception.", "          1. If Type(_O_) is not Object, return _O_.", "          1. Let _status_ be ? _O_.[[SetPrototypeOf]](_proto_).", "          1. If _status_ is *false*, throw a *TypeError* exception.", "          1. Return _O_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "proto"
      }],
      "ref": "Object[\"setPrototypeOf\"]"
    },
    "ids": "sec-object.setprototypeof",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible O)\n  0:O = [? __x0__]\n  1:if (! (|| (= (typeof proto) Object) (= (typeof proto) Null))) (0) throw TypeError else 2:{}\n  2:if (! (= (typeof O) Object)) return O else 2:{}\n  3:(1) app __x1__ = (O[\"SetPrototypeOf\"] O proto)\n  3:let status = [? __x1__]\n  4:if (= status false) (1) throw TypeError else 2:{}\n  5:return O\n}"
  }, {
    "code": ["          1. Let _obj_ be ? ToObject(_O_).", "          1. Let _nameList_ be ? EnumerableOwnPropertyNames(_obj_, ~value~).", "          1. Return CreateArrayFromList(_nameList_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "O"
      }],
      "ref": "Object[\"values\"]"
    },
    "ids": "sec-object.values",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject O)\n  0:let obj = [? __x0__]\n  1:(1) app __x1__ = (EnumerableOwnPropertyNames obj CONST_value)\n  1:let nameList = [? __x1__]\n  2:(2) app __x2__ = (CreateArrayFromList nameList)\n  2:return __x2__\n}"
  }, {
    "code": ["          1. [id=\"step-hasownproperty-topropertykey\"] Let _P_ be ? ToPropertyKey(_V_).", "          1. [id=\"step-hasownproperty-toobject\"] Let _O_ be ? ToObject(*this* value).", "          1. Return ? HasOwnProperty(_O_, _P_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "V"
      }],
      "ref": "Object[\"prototype\"][\"hasOwnProperty\"]"
    },
    "ids": "sec-object.prototype.hasownproperty",
    "rawBody": "{\n  0:(0) app __x0__ = (ToPropertyKey V)\n  0:let P = [? __x0__]\n  1:(1) app __x1__ = (ToObject this)\n  1:let O = [? __x1__]\n  2:(2) app __x2__ = (HasOwnProperty O P)\n  2:return [? __x2__]\n}"
  }, {
    "code": ["          1. [id=\"step-isprototypeof-check-object\"] If Type(_V_) is not Object, return *false*.", "          1. [id=\"step-isprototypeof-toobject\"] Let _O_ be ? ToObject(*this* value).", "          1. Repeat,", "            1. Set _V_ to ? _V_.[[GetPrototypeOf]]().", "            1. If _V_ is *null*, return *false*.", "            1. If SameValue(_O_, _V_) is *true*, return *true*."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "V"
      }],
      "ref": "Object[\"prototype\"][\"isPrototypeOf\"]"
    },
    "ids": "sec-object.prototype.isprototypeof",
    "rawBody": "{\n  0:if (! (= (typeof V) Object)) return false else 2:{}\n  1:(0) app __x0__ = (ToObject this)\n  1:let O = [? __x0__]\n  2:while true {\n    3:(1) app __x1__ = (V[\"GetPrototypeOf\"] V)\n    3:V = [? __x1__]\n    4:if (= V null) return false else 2:{}\n    5:(2) app __x2__ = (SameValue O V)\n    5:if (= __x2__ true) return true else 2:{}\n  }\n}"
  }, {
    "code": ["          1. [id=\"step-propertyisenumerable-topropertykey\"] Let _P_ be ? ToPropertyKey(_V_).", "          1. [id=\"step-propertyisenumerable-toobject\"] Let _O_ be ? ToObject(*this* value).", "          1. Let _desc_ be ? _O_.[[GetOwnProperty]](_P_).", "          1. If _desc_ is *undefined*, return *false*.", "          1. Return _desc_.[[Enumerable]]."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "V"
      }],
      "ref": "Object[\"prototype\"][\"propertyIsEnumerable\"]"
    },
    "ids": "sec-object.prototype.propertyisenumerable",
    "rawBody": "{\n  0:(0) app __x0__ = (ToPropertyKey V)\n  0:let P = [? __x0__]\n  1:(1) app __x1__ = (ToObject this)\n  1:let O = [? __x1__]\n  2:(2) app __x2__ = (O[\"GetOwnProperty\"] O P)\n  2:let desc = [? __x2__]\n  3:if (= desc undefined) return false else 2:{}\n  4:return desc[\"Enumerable\"]\n}"
  }, {
    "code": ["          1. Let _O_ be the *this* value.", "          1. Return ? Invoke(_O_, *\"toString\"*)."],
    "head": {
      "origParams": [{
        "kind": "Optional",
        "name": "reserved1"
      }, {
        "kind": "Optional",
        "name": "reserved2"
      }],
      "ref": "Object[\"prototype\"][\"toLocaleString\"]"
    },
    "ids": "sec-object.prototype.tolocalestring",
    "rawBody": "{\n  0:let O = this\n  1:(0) app __x0__ = (Invoke O \"toString\")\n  1:return [? __x0__]\n}"
  }, {
    "code": ["          1. If the *this* value is *undefined*, return *\"[object Undefined]\"*.", "          1. If the *this* value is *null*, return *\"[object Null]\"*.", "          1. Let _O_ be ! ToObject(*this* value).", "          1. Let _isArray_ be ? IsArray(_O_).", "          1. If _isArray_ is *true*, let _builtinTag_ be *\"Array\"*.", "          1. Else if _O_ has a [[ParameterMap]] internal slot, let _builtinTag_ be *\"Arguments\"*.", "          1. Else if _O_ has a [[Call]] internal method, let _builtinTag_ be *\"Function\"*.", "          1. Else if _O_ has an [[ErrorData]] internal slot, let _builtinTag_ be *\"Error\"*.", "          1. Else if _O_ has a [[BooleanData]] internal slot, let _builtinTag_ be *\"Boolean\"*.", "          1. Else if _O_ has a [[NumberData]] internal slot, let _builtinTag_ be *\"Number\"*.", "          1. Else if _O_ has a [[StringData]] internal slot, let _builtinTag_ be *\"String\"*.", "          1. Else if _O_ has a [[DateValue]] internal slot, let _builtinTag_ be *\"Date\"*.", "          1. Else if _O_ has a [[RegExpMatcher]] internal slot, let _builtinTag_ be *\"RegExp\"*.", "          1. Else, let _builtinTag_ be *\"Object\"*.", "          1. Let _tag_ be ? Get(_O_, @@toStringTag).", "          1. If Type(_tag_) is not String, set _tag_ to _builtinTag_.", "          1. Return the string-concatenation of *\"[object \"*, _tag_, and *\"]\"*."],
    "head": {
      "origParams": [],
      "ref": "Object[\"prototype\"][\"toString\"]"
    },
    "ids": "sec-object.prototype.tostring",
    "rawBody": "{\n  0:if (= this undefined) return \"[object Undefined]\" else 2:{}\n  1:if (= this null) return \"[object Null]\" else 2:{}\n  2:(0) app __x0__ = (ToObject this)\n  2:let O = [! __x0__]\n  3:(1) app __x1__ = (IsArray O)\n  3:let isArray = [? __x1__]\n  13:if (= isArray true) let builtinTag = \"Array\" else if (! (= O[\"ParameterMap\"] absent)) let builtinTag = \"Arguments\" else if (! (= O[\"Call\"] absent)) let builtinTag = \"Function\" else if (! (= O[\"ErrorData\"] absent)) let builtinTag = \"Error\" else if (! (= O[\"BooleanData\"] absent)) let builtinTag = \"Boolean\" else if (! (= O[\"NumberData\"] absent)) let builtinTag = \"Number\" else if (! (= O[\"StringData\"] absent)) let builtinTag = \"String\" else if (! (= O[\"DateValue\"] absent)) let builtinTag = \"Date\" else if (! (= O[\"RegExpMatcher\"] absent)) let builtinTag = \"RegExp\" else let builtinTag = \"Object\"\n  14:(2) app __x2__ = (Get O SYMBOL_toStringTag)\n  14:let tag = [? __x2__]\n  15:if (! (= (typeof tag) String)) tag = builtinTag else 2:{}\n  16:return (+ (+ \"[object \" tag) \"]\")\n}"
  }, {
    "code": ["          1. Return ? ToObject(*this* value)."],
    "head": {
      "origParams": [],
      "ref": "Object[\"prototype\"][\"valueOf\"]"
    },
    "ids": "sec-object.prototype.valueof",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Let _C_ be the active function object.", "          1. Let _args_ be the _argumentsList_ that was passed to this function by [[Call]] or [[Construct]].", "          1. Return ? CreateDynamicFunction(_C_, NewTarget, ~normal~, _args_)."],
    "head": {
      "origParams": [],
      "ref": "Function"
    },
    "ids": "sec-function-p1-p2-pn-body",
    "rawBody": "{\n  0:let C = CONTEXT[\"Function\"]\n  1:let args = argumentsList\n  2:(0) app __x0__ = (CreateDynamicFunction C NewTarget CONST_normal args)\n  2:return [? __x0__]\n}"
  }, {
    "code": ["            1. Assert: The execution context stack has at least two elements.", "            1. Let _callerContext_ be the second to top element of the execution context stack.", "            1. Let _callerRealm_ be _callerContext_'s Realm.", "            1. Let _calleeRealm_ be the current Realm Record.", "            1. Perform ? HostEnsureCanCompileStrings(_callerRealm_, _calleeRealm_).", "            1. If _newTarget_ is *undefined*, set _newTarget_ to _constructor_.", "            1. If _kind_ is ~normal~, then", "              1. Let _goal_ be the grammar symbol |FunctionBody[~Yield, ~Await]|.", "              1. Let _parameterGoal_ be the grammar symbol |FormalParameters[~Yield, ~Await]|.", "              1. Let _fallbackProto_ be *\"%Function.prototype%\"*.", "            1. Else if _kind_ is ~generator~, then", "              1. Let _goal_ be the grammar symbol |GeneratorBody|.", "              1. Let _parameterGoal_ be the grammar symbol |FormalParameters[+Yield, ~Await]|.", "              1. Let _fallbackProto_ be *\"%GeneratorFunction.prototype%\"*.", "            1. Else if _kind_ is ~async~, then", "              1. Let _goal_ be the grammar symbol |AsyncFunctionBody|.", "              1. Let _parameterGoal_ be the grammar symbol |FormalParameters[~Yield, +Await]|.", "              1. Let _fallbackProto_ be *\"%AsyncFunction.prototype%\"*.", "            1. Else,", "              1. Assert: _kind_ is ~asyncGenerator~.", "              1. Let _goal_ be the grammar symbol |AsyncGeneratorBody|.", "              1. Let _parameterGoal_ be the grammar symbol |FormalParameters[+Yield, +Await]|.", "              1. Let _fallbackProto_ be *\"%AsyncGeneratorFunction.prototype%\"*.", "            1. Let _argCount_ be the number of elements in _args_.", "            1. Let _P_ be the empty String.", "            1. If _argCount_ = 0, let _bodyArg_ be the empty String.", "            1. Else if _argCount_ = 1, let _bodyArg_ be _args_[0].", "            1. Else,", "              1. Assert: _argCount_ > 1.", "              1. Let _firstArg_ be _args_[0].", "              1. Set _P_ to ? ToString(_firstArg_).", "              1. Let _k_ be 1.", "              1. Repeat, while _k_ < _argCount_ - 1,", "                1. Let _nextArg_ be _args_[_k_].", "                1. Let _nextArgString_ be ? ToString(_nextArg_).", "                1. Set _P_ to the string-concatenation of _P_, *\",\"* (a comma), and _nextArgString_.", "                1. Set _k_ to _k_ + 1.", "              1. Let _bodyArg_ be _args_[_k_].", "            1. Let _bodyString_ be the string-concatenation of 0x000A (LINE FEED), ? ToString(_bodyArg_), and 0x000A (LINE FEED).", "            1. Let _prefix_ be the prefix associated with _kind_ in <emu-xref href=\"#table-dynamic-function-sourcetext-prefixes\"></emu-xref>.", "            1. Let _sourceString_ be the string-concatenation of _prefix_, *\" anonymous(\"*, _P_, 0x000A (LINE FEED), *\") {\"*, _bodyString_, and *\"}\"*.", "            1. Let _sourceText_ be ! StringToCodePoints(_sourceString_).", "            1. Perform the following substeps in an implementation-defined order, possibly interleaving parsing and error detection:", "              1. Let _parameters_ be ParseText(! StringToCodePoints(_P_), _parameterGoal_).", "              1. If _parameters_ is a List of errors, throw a *SyntaxError* exception.", "              1. Let _body_ be ParseText(! StringToCodePoints(_bodyString_), _goal_).", "              1. If _body_ is a List of errors, throw a *SyntaxError* exception.", "              1. Let _strict_ be FunctionBodyContainsUseStrict of _body_.", "              1. If _strict_ is *true*, apply the early error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> to _parameters_.", "              1. If _strict_ is *true* and IsSimpleParameterList of _parameters_ is *false*, throw a *SyntaxError* exception.", "              1. If any element of the BoundNames of _parameters_ also occurs in the LexicallyDeclaredNames of _body_, throw a *SyntaxError* exception.", "              1. If _body_ Contains |SuperCall| is *true*, throw a *SyntaxError* exception.", "              1. If _parameters_ Contains |SuperCall| is *true*, throw a *SyntaxError* exception.", "              1. If _body_ Contains |SuperProperty| is *true*, throw a *SyntaxError* exception.", "              1. If _parameters_ Contains |SuperProperty| is *true*, throw a *SyntaxError* exception.", "              1. If _kind_ is ~generator~ or ~asyncGenerator~, then", "                1. If _parameters_ Contains |YieldExpression| is *true*, throw a *SyntaxError* exception.", "              1. If _kind_ is ~async~ or ~asyncGenerator~, then", "                1. If _parameters_ Contains |AwaitExpression| is *true*, throw a *SyntaxError* exception.", "              1. If _strict_ is *true*, then", "                1. If BoundNames of _parameters_ contains any duplicate elements, throw a *SyntaxError* exception.", "            1. Let _proto_ be ? GetPrototypeFromConstructor(_newTarget_, _fallbackProto_).", "            1. Let _realmF_ be the current Realm Record.", "            1. Let _scope_ be _realmF_.[[GlobalEnv]].", "            1. Let _F_ be ! OrdinaryFunctionCreate(_proto_, _sourceText_, _parameters_, _body_, ~non-lexical-this~, _scope_).", "            1. Perform SetFunctionName(_F_, *\"anonymous\"*).", "            1. If _kind_ is ~generator~, then", "              1. Let _prototype_ be ! OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).", "              1. Perform DefinePropertyOrThrow(_F_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).", "            1. Else if _kind_ is ~asyncGenerator~, then", "              1. Let _prototype_ be ! OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).", "              1. Perform DefinePropertyOrThrow(_F_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).", "            1. Else if _kind_ is ~normal~, perform MakeConstructor(_F_).", "            1. NOTE: Functions whose _kind_ is ~async~ are not constructible and do not have a [[Construct]] internal method or a *\"prototype\"* property.", "            1. Return _F_."],
    "head": {
      "name": "CreateDynamicFunction",
      "params": [{
        "kind": "Normal",
        "name": "constructor"
      }, {
        "kind": "Normal",
        "name": "newTarget"
      }, {
        "kind": "Normal",
        "name": "kind"
      }, {
        "kind": "Normal",
        "name": "args"
      }]
    },
    "ids": "sec-createdynamicfunction",
    "rawBody": "{\n  1:let callerContext = EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 2i)]\n  2:let callerRealm = callerContext[\"Realm\"]\n  3:let calleeRealm = REALM\n  4:(0) app __x0__ = (HostEnsureCanCompileStrings callerRealm calleeRealm)\n  4:[? __x0__]\n  5:if (= newTarget undefined) newTarget = constructor else 73:{}\n  18:if (= kind CONST_normal) {\n    7:(0) ??? \"Let id:{goal} be the grammar symbol | FunctionBody [ ~ Yield , ~ Await ] | .\"\n    8:(1) ??? \"Let id:{parameterGoal} be the grammar symbol | FormalParameters [ ~ Yield , ~ Await ] | .\"\n    9:let fallbackProto = \"%Function.prototype%\"\n  } else if (= kind CONST_generator) {\n    11:let goal = \"GeneratorBody\"\n    12:(2) ??? \"Let id:{parameterGoal} be the grammar symbol | FormalParameters [ + Yield , ~ Await ] | .\"\n    13:let fallbackProto = \"%GeneratorFunction.prototype%\"\n  } else if (= kind CONST_async) {\n    15:let goal = \"AsyncFunctionBody\"\n    16:(3) ??? \"Let id:{parameterGoal} be the grammar symbol | FormalParameters [ ~ Yield , + Await ] | .\"\n    17:let fallbackProto = \"%AsyncFunction.prototype%\"\n  } else {\n    19:assert (= kind CONST_asyncGenerator)\n    20:let goal = \"AsyncGeneratorBody\"\n    21:(4) ??? \"Let id:{parameterGoal} be the grammar symbol | FormalParameters [ + Yield , + Await ] | .\"\n    22:let fallbackProto = \"%AsyncGeneratorFunction.prototype%\"\n  }\n  23:let argCount = args[\"length\"]\n  24:let P = \"\"\n  27:if (== argCount 0i) let bodyArg = \"\" else if (== argCount 1i) let bodyArg = args[0i] else {\n    28:assert (< 1i argCount)\n    29:let firstArg = args[0i]\n    30:(1) app __x1__ = (ToString firstArg)\n    30:P = [? __x1__]\n    31:let k = 1i\n    32:while (< k (- argCount 1i)) {\n      33:let nextArg = args[k]\n      34:(2) app __x2__ = (ToString nextArg)\n      34:let nextArgString = [? __x2__]\n      35:(5) ??? \"Set id:{P} to the string - concatenation of id:{P} , value:{\\\",\\\"} ( a comma ) , and id:{nextArgString} .\"\n      36:k = (+ k 1i)\n    }\n    37:let bodyArg = args[k]\n  }\n  38:(3) app __x3__ = (ToString bodyArg)\n  38:let bodyString = (+ (+ \"\\n\" [? __x3__]) \"\\n\")\n  39:(6) ??? \"Let id:{prefix} be the prefix associated with id:{kind} in link:{table-dynamic-function-sourcetext-prefixes} .\"\n  40:let sourceString = (+ (+ (+ (+ (+ (+ prefix \"anonymous(\") P) \"\\n\") \") {\") bodyString) \"}\")\n  41:(4) app __x4__ = (StringToCodePoints sourceString)\n  41:let sourceText = [! __x4__]\n  42:let parameterGoal = AST_FormalParameters\n  42:let script = AST_Script\n  42:let body = AST_ScriptBody\n  61:(5) app __x5__ = (GetPrototypeFromConstructor newTarget fallbackProto)\n  61:let proto = [? __x5__]\n  62:let realmF = REALM\n  63:let scope = realmF[\"GlobalEnv\"]\n  64:(6) app __x6__ = (OrdinaryFunctionCreate proto sourceText parameters body CONST_nonDASHlexicalDASHthis scope)\n  64:let F = [! __x6__]\n  65:(7) app __x7__ = (SetFunctionName F \"anonymous\")\n  65:__x7__\n  72:if (= kind CONST_generator) {\n    67:(8) app __x8__ = (OrdinaryObjectCreate INTRINSIC_GeneratorFunction_prototype_prototype)\n    67:let prototype = [! __x8__]\n    68:(9) app __x9__ = (DefinePropertyOrThrow F \"prototype\" (7) (new PropertyDescriptor(\"Value\" -> prototype, \"Writable\" -> true, \"Enumerable\" -> false, \"Configurable\" -> false)))\n    68:__x9__\n  } else if (= kind CONST_asyncGenerator) {\n    70:(10) app __x10__ = (OrdinaryObjectCreate INTRINSIC_AsyncGeneratorFunction_prototype_prototype)\n    70:let prototype = [! __x10__]\n    71:(11) app __x11__ = (DefinePropertyOrThrow F \"prototype\" (8) (new PropertyDescriptor(\"Value\" -> prototype, \"Writable\" -> true, \"Enumerable\" -> false, \"Configurable\" -> false)))\n    71:__x11__\n  } else if (= kind CONST_normal) {\n    (12) app __x12__ = (MakeConstructor F)\n    __x12__\n  } else 73:{}\n  74:return F\n}"
  }, {
    "code": ["          1. Let _func_ be the *this* value.", "          1. If IsCallable(_func_) is *false*, throw a *TypeError* exception.", "          1. If _argArray_ is *undefined* or *null*, then", "            1. Perform PrepareForTailCall().", "            1. Return ? Call(_func_, _thisArg_).", "          1. Let _argList_ be ? CreateListFromArrayLike(_argArray_).", "          1. Perform PrepareForTailCall().", "          1. [id=\"step-function-proto-apply-call\"] Return ? Call(_func_, _thisArg_, _argList_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "thisArg"
      }, {
        "kind": "Normal",
        "name": "argArray"
      }],
      "ref": "Function[\"prototype\"][\"apply\"]"
    },
    "ids": "sec-function.prototype.apply",
    "rawBody": "{\n  0:let func = this\n  1:(0) app __x0__ = (IsCallable func)\n  1:if (= __x0__ false) (0) throw TypeError else 73:{}\n  2:if (|| (= argArray undefined) (= argArray null)) {\n    3:(1) app __x1__ = (PrepareForTailCall)\n    3:__x1__\n    4:(2) app __x2__ = (Call func thisArg)\n    4:return [? __x2__]\n  } else 73:{}\n  5:(3) app __x3__ = (CreateListFromArrayLike argArray)\n  5:let argList = [? __x3__]\n  6:(4) app __x4__ = (PrepareForTailCall)\n  6:__x4__\n  7:(5) app __x5__ = (Call func thisArg argList)\n  7:return [? __x5__]\n}"
  }, {
    "code": ["          1. Let _Target_ be the *this* value.", "          1. If IsCallable(_Target_) is *false*, throw a *TypeError* exception.", "          1. Let _F_ be ? BoundFunctionCreate(_Target_, _thisArg_, _args_).", "          1. Let _L_ be 0.", "          1. Let _targetHasLength_ be ? HasOwnProperty(_Target_, *\"length\"*).", "          1. If _targetHasLength_ is *true*, then", "            1. Let _targetLen_ be ? Get(_Target_, *\"length\"*).", "            1. If Type(_targetLen_) is Number, then", "              1. If _targetLen_ is *+∞*<sub>𝔽</sub>, set _L_ to +∞.", "              1. Else if _targetLen_ is *-∞*<sub>𝔽</sub>, set _L_ to 0.", "              1. Else,", "                1. Let _targetLenAsInt_ be ! ToIntegerOrInfinity(_targetLen_).", "                1. Assert: _targetLenAsInt_ is finite.", "                1. Let _argCount_ be the number of elements in _args_.", "                1. Set _L_ to max(_targetLenAsInt_ - _argCount_, 0).", "          1. Perform ! SetFunctionLength(_F_, _L_).", "          1. Let _targetName_ be ? Get(_Target_, *\"name\"*).", "          1. If Type(_targetName_) is not String, set _targetName_ to the empty String.", "          1. Perform SetFunctionName(_F_, _targetName_, *\"bound\"*).", "          1. Return _F_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "thisArg"
      }, {
        "kind": "Variadic",
        "name": "args"
      }],
      "ref": "Function[\"prototype\"][\"bind\"]"
    },
    "ids": "sec-function.prototype.bind",
    "rawBody": "{\n  0:let Target = this\n  1:(0) app __x0__ = (IsCallable Target)\n  1:if (= __x0__ false) (0) throw TypeError else 73:{}\n  2:(1) app __x1__ = (BoundFunctionCreate Target thisArg args)\n  2:let F = [? __x1__]\n  3:let L = 0i\n  4:(2) app __x2__ = (HasOwnProperty Target \"length\")\n  4:let targetHasLength = [? __x2__]\n  5:if (= targetHasLength true) {\n    6:(3) app __x3__ = (Get Target \"length\")\n    6:let targetLen = [? __x3__]\n    7:if (= (typeof targetLen) Number) if (= targetLen Infinity) L = Infinity else if (= targetLen -Infinity) L = 0i else {\n      11:(4) app __x4__ = (ToIntegerOrInfinity targetLen)\n      11:let targetLenAsInt = [! __x4__]\n      12:assert (! (|| (= targetLenAsInt Infinity) (= targetLenAsInt -Infinity)))\n      13:let argCount = args[\"length\"]\n      14:(5) app __x5__ = (max (- targetLenAsInt argCount) 0i)\n      14:L = __x5__\n    } else 73:{}\n  } else 73:{}\n  15:(6) app __x6__ = (SetFunctionLength F L)\n  15:[! __x6__]\n  16:(7) app __x7__ = (Get Target \"name\")\n  16:let targetName = [? __x7__]\n  17:if (! (= (typeof targetName) String)) targetName = \"\" else 73:{}\n  18:(8) app __x8__ = (SetFunctionName F targetName \"bound\")\n  18:__x8__\n  19:return F\n}"
  }, {
    "code": ["          1. Let _func_ be the *this* value.", "          1. If IsCallable(_func_) is *false*, throw a *TypeError* exception.", "          1. Perform PrepareForTailCall().", "          1. [id=\"step-function-proto-call-call\"] Return ? Call(_func_, _thisArg_, _args_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "thisArg"
      }, {
        "kind": "Variadic",
        "name": "args"
      }],
      "ref": "Function[\"prototype\"][\"call\"]"
    },
    "ids": "sec-function.prototype.call",
    "rawBody": "{\n  0:let func = this\n  1:(0) app __x0__ = (IsCallable func)\n  1:if (= __x0__ false) (0) throw TypeError else 73:{}\n  2:(1) app __x1__ = (PrepareForTailCall)\n  2:__x1__\n  3:(2) app __x2__ = (Call func thisArg args)\n  3:return [? __x2__]\n}"
  }, {
    "code": ["          1. Let _func_ be the *this* value.", "          1. If Type(_func_) is Object and _func_ has a [[SourceText]] internal slot and _func_.[[SourceText]] is a sequence of Unicode code points and ! HostHasSourceTextAvailable(_func_) is *true*, then", "            1. Return ! CodePointsToString(_func_.[[SourceText]]).", "          1. If _func_ is a <emu-xref href=\"#sec-built-in-function-objects\">built-in function object</emu-xref>, return an implementation-defined String source code representation of _func_. The representation must have the syntax of a |NativeFunction|. Additionally, if _func_ has an [[InitialName]] internal slot and _func_.[[InitialName]] is a String, the portion of the returned String that would be matched by |NativeFunctionAccessor?| |PropertyName| must be the value of _func_.[[InitialName]].", "          1. If Type(_func_) is Object and IsCallable(_func_) is *true*, return an implementation-defined String source code representation of _func_. The representation must have the syntax of a |NativeFunction|.", "          1. Throw a *TypeError* exception."],
    "head": {
      "origParams": [],
      "ref": "Function[\"prototype\"][\"toString\"]"
    },
    "ids": "sec-function.prototype.tostring",
    "rawBody": "{\n  0:let func = this\n  1:(0) ??? \"If Type ( id:{func} ) is Object and id:{func} has a [ [ SourceText ] ] internal slot and id:{func} . [ [ SourceText ] ] is a sequence of Unicode code points and ! HostHasSourceTextAvailable ( id:{func} ) is value:{true} , then in:{} out:{}\"\n  3:(1) ??? \"If id:{func} is a < emu - xref href = \\\" # sec - built - in - function - objects \\\" > built - in function object < / emu - xref > , return an implementation - defined String source code representation of id:{func} . The representation must have the syntax of a nt:{NativeFunction} . Additionally , if id:{func} has an [ [ InitialName ] ] internal slot and id:{func} . [ [ InitialName ] ] is a String , the portion of the returned String that would be matched by nt:{NativeFunctionAccessor?} nt:{PropertyName} must be the value of id:{func} . [ [ InitialName ] ] .\"\n  4:(2) ??? \"If Type ( id:{func} ) is Object and IsCallable ( id:{func} ) is value:{true} , return an implementation - defined String source code representation of id:{func} . The representation must have the syntax of a nt:{NativeFunction} .\"\n  5:(3) throw TypeError\n}"
  }, {
    "code": ["          1. Let _F_ be the *this* value.", "          1. Return ? OrdinaryHasInstance(_F_, _V_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "V"
      }],
      "ref": "Function[\"prototype\"][SYMBOL_hasInstance]"
    },
    "ids": "sec-function.prototype-@@hasinstance",
    "rawBody": "{\n  0:let F = this\n  1:(0) app __x0__ = (OrdinaryHasInstance F V)\n  1:return [? __x0__]\n}"
  }, {
    "code": ["          1. Let _b_ be ! ToBoolean(_value_).", "          1. If NewTarget is *undefined*, return _b_.", "          1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Boolean.prototype%\"*, « [[BooleanData]] »).", "          1. Set _O_.[[BooleanData]] to _b_.", "          1. Return _O_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "value"
      }],
      "ref": "Boolean"
    },
    "ids": "sec-boolean-constructor-boolean-value",
    "rawBody": "{\n  0:(0) app __x0__ = (ToBoolean value)\n  0:let b = [! __x0__]\n  1:if (= NewTarget undefined) return b else 73:{}\n  2:(1) app __x1__ = (OrdinaryCreateFromConstructor NewTarget \"%Boolean.prototype%\" (0) (new [\"BooleanData\"]))\n  2:let O = [? __x1__]\n  3:O[\"BooleanData\"] = b\n  4:return O\n}"
  }, {
    "code": ["        1. If Type(_value_) is Boolean, return _value_.", "        1. If Type(_value_) is Object and _value_ has a [[BooleanData]] internal slot, then", "          1. Let _b_ be _value_.[[BooleanData]].", "          1. Assert: Type(_b_) is Boolean.", "          1. Return _b_.", "        1. Throw a *TypeError* exception."],
    "head": {
      "name": "thisBooleanValue",
      "params": [{
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "sec-properties-of-the-boolean-prototype-object",
    "rawBody": "{\n  0:if (= (typeof value) Boolean) return value else 73:{}\n  1:if (&& (= (typeof value) Object) (! (= value[\"BooleanData\"] absent))) {\n    2:let b = value[\"BooleanData\"]\n    3:assert (= (typeof b) Boolean)\n    4:return b\n  } else 73:{}\n  5:(0) throw TypeError\n}"
  }, {
    "code": ["          1. Let _b_ be ? thisBooleanValue(*this* value).", "          1. If _b_ is *true*, return *\"true\"*; else return *\"false\"*."],
    "head": {
      "origParams": [],
      "ref": "Boolean[\"prototype\"][\"toString\"]"
    },
    "ids": "sec-boolean.prototype.tostring",
    "rawBody": "{\n  0:(0) app __x0__ = (thisBooleanValue this)\n  0:let b = [? __x0__]\n  1:if (= b true) return \"true\" else return \"false\"\n}"
  }, {
    "code": ["          1. Return ? thisBooleanValue(*this* value)."],
    "head": {
      "origParams": [],
      "ref": "Boolean[\"prototype\"][\"valueOf\"]"
    },
    "ids": "sec-boolean.prototype.valueof",
    "rawBody": "{\n  0:(0) app __x0__ = (thisBooleanValue this)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. If NewTarget is not *undefined*, throw a *TypeError* exception.", "          1. If _description_ is *undefined*, let _descString_ be *undefined*.", "          1. Else, let _descString_ be ? ToString(_description_).", "          1. Return a new unique Symbol value whose [[Description]] value is _descString_."],
    "head": {
      "origParams": [{
        "kind": "Optional",
        "name": "description"
      }],
      "ref": "Symbol"
    },
    "ids": "sec-symbol-description",
    "rawBody": "{\n  0:if (! (= NewTarget undefined)) (0) throw TypeError else 73:{}\n  2:if (= description undefined) let descString = undefined else {\n    (0) app __x0__ = (ToString description)\n    let descString = [? __x0__]\n  }\n  3:(1) ??? \"Return a new unique Symbol value whose [ [ Description ] ] value is id:{descString} .\"\n}"
  }, {
    "code": ["          1. Let _stringKey_ be ? ToString(_key_).", "          1. For each element _e_ of the GlobalSymbolRegistry List, do", "            1. If SameValue(_e_.[[Key]], _stringKey_) is *true*, return _e_.[[Symbol]].", "          1. Assert: GlobalSymbolRegistry does not currently contain an entry for _stringKey_.", "          1. Let _newSymbol_ be a new unique Symbol value whose [[Description]] value is _stringKey_.", "          1. Append the Record { [[Key]]: _stringKey_, [[Symbol]]: _newSymbol_ } to the GlobalSymbolRegistry List.", "          1. Return _newSymbol_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "key"
      }],
      "ref": "Symbol[\"for\"]"
    },
    "ids": "sec-symbol.for",
    "rawBody": "{\n  0:(0) app __x0__ = (ToString key)\n  0:let stringKey = [? __x0__]\n  1:let __x1__ = SYMBOL_REGISTRY\n  1:let __x2__ = 0i\n  1:while (< __x2__ __x1__[\"length\"]) {\n    let e = __x1__[__x2__]\n    2:(1) app __x3__ = (SameValue e[\"Key\"] stringKey)\n    2:if (= __x3__ true) return e[\"Symbol\"] else 3:{}\n    __x2__ = (+ __x2__ 1i)\n  }\n  4:(0) ??? \"Let id:{newSymbol} be a new unique Symbol value whose [ [ Description ] ] value is id:{stringKey} .\"\n  5:append (1) (new Record(\"Key\" -> stringKey, \"Symbol\" -> newSymbol)) -> SYMBOL_REGISTRY\n  6:return newSymbol\n}"
  }, {
    "code": ["          1. If Type(_sym_) is not Symbol, throw a *TypeError* exception.", "          1. For each element _e_ of the GlobalSymbolRegistry List (see <emu-xref href=\"#sec-symbol.for\"></emu-xref>), do", "            1. If SameValue(_e_.[[Symbol]], _sym_) is *true*, return _e_.[[Key]].", "          1. Assert: GlobalSymbolRegistry does not currently contain an entry for _sym_.", "          1. Return *undefined*."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "sym"
      }],
      "ref": "Symbol[\"keyFor\"]"
    },
    "ids": "sec-symbol.keyfor",
    "rawBody": "{\n  0:if (! (= (typeof sym) Symbol)) (0) throw TypeError else 3:{}\n  1:let __x0__ = SYMBOL_REGISTRY\n  1:let __x1__ = 0i\n  1:while (< __x1__ __x0__[\"length\"]) {\n    let e = __x0__[__x1__]\n    2:(0) app __x2__ = (SameValue e[\"Symbol\"] sym)\n    2:if (= __x2__ true) return e[\"Key\"] else 3:{}\n    __x1__ = (+ __x1__ 1i)\n  }\n  4:return undefined\n}"
  }, {
    "code": ["        1. If Type(_value_) is Symbol, return _value_.", "        1. If Type(_value_) is Object and _value_ has a [[SymbolData]] internal slot, then", "          1. Let _s_ be _value_.[[SymbolData]].", "          1. Assert: Type(_s_) is Symbol.", "          1. Return _s_.", "        1. Throw a *TypeError* exception."],
    "head": {
      "name": "thisSymbolValue",
      "params": [{
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "sec-properties-of-the-symbol-prototype-object",
    "rawBody": "{\n  0:if (= (typeof value) Symbol) return value else 3:{}\n  1:if (&& (= (typeof value) Object) (! (= value[\"SymbolData\"] absent))) {\n    2:let s = value[\"SymbolData\"]\n    3:assert (= (typeof s) Symbol)\n    4:return s\n  } else 3:{}\n  5:(0) throw TypeError\n}"
  }, {
    "code": ["          1. Let _s_ be the *this* value.", "          1. Let _sym_ be ? thisSymbolValue(_s_).", "          1. Return _sym_.[[Description]]."],
    "head": {
      "origParams": [],
      "ref": "getSymbol[\"prototype\"][\"description\"]"
    },
    "ids": "sec-symbol.prototype.description",
    "rawBody": "{\n  0:let s = this\n  1:(0) app __x0__ = (thisSymbolValue s)\n  1:let sym = [? __x0__]\n  2:return sym[\"Description\"]\n}"
  }, {
    "code": ["          1. Let _sym_ be ? thisSymbolValue(*this* value).", "          1. Return SymbolDescriptiveString(_sym_)."],
    "head": {
      "origParams": [],
      "ref": "Symbol[\"prototype\"][\"toString\"]"
    },
    "ids": "sec-symbol.prototype.tostring",
    "rawBody": "{\n  0:(0) app __x0__ = (thisSymbolValue this)\n  0:let sym = [? __x0__]\n  1:(1) app __x1__ = (SymbolDescriptiveString sym)\n  1:return __x1__\n}"
  }, {
    "code": ["            1. Assert: Type(_sym_) is Symbol.", "            1. Let _desc_ be _sym_'s [[Description]] value.", "            1. If _desc_ is *undefined*, set _desc_ to the empty String.", "            1. Assert: Type(_desc_) is String.", "            1. Return the string-concatenation of *\"Symbol(\"*, _desc_, and *\")\"*."],
    "head": {
      "name": "SymbolDescriptiveString",
      "params": [{
        "kind": "Normal",
        "name": "sym"
      }]
    },
    "ids": "sec-symboldescriptivestring",
    "rawBody": "{\n  0:assert (= (typeof sym) Symbol)\n  1:let desc = sym[\"Description\"]\n  2:if (= desc undefined) desc = \"\" else 3:{}\n  3:assert (= (typeof desc) String)\n  4:return (+ (+ \"Symbol(\" desc) \")\")\n}"
  }, {
    "code": ["          1. Return ? thisSymbolValue(*this* value)."],
    "head": {
      "origParams": [],
      "ref": "Symbol[\"prototype\"][\"valueOf\"]"
    },
    "ids": "sec-symbol.prototype.valueof",
    "rawBody": "{\n  0:(0) app __x0__ = (thisSymbolValue this)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Return ? thisSymbolValue(*this* value)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "hint"
      }],
      "ref": "Symbol[\"prototype\"][SYMBOL_toPrimitive]"
    },
    "ids": "sec-symbol.prototype-@@toprimitive",
    "rawBody": "{\n  0:(0) app __x0__ = (thisSymbolValue this)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. If NewTarget is *undefined*, let _newTarget_ be the active function object; else let _newTarget_ be NewTarget.", "          1. Let _O_ be ? OrdinaryCreateFromConstructor(_newTarget_, *\"%Error.prototype%\"*, « [[ErrorData]] »).", "          1. If _message_ is not *undefined*, then", "            1. Let _msg_ be ? ToString(_message_).", "            1. Let _msgDesc_ be the PropertyDescriptor { [[Value]]: _msg_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.", "            1. Perform ! DefinePropertyOrThrow(_O_, *\"message\"*, _msgDesc_).", "          1. Return _O_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "message"
      }],
      "ref": "Error"
    },
    "ids": "sec-error-message",
    "rawBody": "{\n  0:if (= NewTarget undefined) let newTarget = CONTEXT[\"Function\"] else let newTarget = NewTarget\n  1:(0) app __x0__ = (OrdinaryCreateFromConstructor newTarget \"%Error.prototype%\" (0) (new [\"ErrorData\"]))\n  1:let O = [? __x0__]\n  2:if (! (= message undefined)) {\n    3:(1) app __x1__ = (ToString message)\n    3:let msg = [? __x1__]\n    4:let msgDesc = (1) (new PropertyDescriptor(\"Value\" -> msg, \"Writable\" -> true, \"Enumerable\" -> false, \"Configurable\" -> true))\n    5:(2) app __x2__ = (DefinePropertyOrThrow O \"message\" msgDesc)\n    5:[! __x2__]\n  } else 3:{}\n  6:return O\n}"
  }, {
    "code": ["          1. Let _O_ be the *this* value.", "          1. If Type(_O_) is not Object, throw a *TypeError* exception.", "          1. Let _name_ be ? Get(_O_, *\"name\"*).", "          1. If _name_ is *undefined*, set _name_ to *\"Error\"*; otherwise set _name_ to ? ToString(_name_).", "          1. Let _msg_ be ? Get(_O_, *\"message\"*).", "          1. If _msg_ is *undefined*, set _msg_ to the empty String; otherwise set _msg_ to ? ToString(_msg_).", "          1. If _name_ is the empty String, return _msg_.", "          1. If _msg_ is the empty String, return _name_.", "          1. Return the string-concatenation of _name_, the code unit 0x003A (COLON), the code unit 0x0020 (SPACE), and _msg_."],
    "head": {
      "origParams": [],
      "ref": "Error[\"prototype\"][\"toString\"]"
    },
    "ids": "sec-error.prototype.tostring",
    "rawBody": "{\n  0:let O = this\n  1:if (! (= (typeof O) Object)) (0) throw TypeError else 3:{}\n  2:(0) app __x0__ = (Get O \"name\")\n  2:let name = [? __x0__]\n  3:if (= name undefined) name = \"Error\" else {\n    (1) app __x1__ = (ToString name)\n    name = [? __x1__]\n  }\n  4:(2) app __x2__ = (Get O \"message\")\n  4:let msg = [? __x2__]\n  5:if (= msg undefined) msg = \"\" else {\n    (3) app __x3__ = (ToString msg)\n    msg = [? __x3__]\n  }\n  6:if (= name \"\") return msg else 3:{}\n  7:if (= msg \"\") return name else 3:{}\n  8:return (+ (+ (+ name \":\") \" \") msg)\n}"
  }, {
    "code": ["            1. If NewTarget is *undefined*, let _newTarget_ be the active function object; else let _newTarget_ be NewTarget.", "            1. Let _O_ be ? OrdinaryCreateFromConstructor(_newTarget_, *\"%AggregateError.prototype%\"*, « [[ErrorData]] »).", "            1. If _message_ is not *undefined*, then", "              1. Let _msg_ be ? ToString(_message_).", "              1. Let _msgDesc_ be the PropertyDescriptor { [[Value]]: _msg_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.", "              1. Perform ! DefinePropertyOrThrow(_O_, *\"message\"*, _msgDesc_).", "            1. Let _errorsList_ be ? IterableToList(_errors_).", "            1. Perform ! DefinePropertyOrThrow(_O_, *\"errors\"*, PropertyDescriptor { [[Configurable]]: *true*, [[Enumerable]]: *false*, [[Writable]]: *true*, [[Value]]: ! CreateArrayFromList(_errorsList_) }).", "            1. Return _O_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "errors"
      }, {
        "kind": "Normal",
        "name": "message"
      }],
      "ref": "AggregateError"
    },
    "ids": "sec-aggregate-error",
    "rawBody": "{\n  0:if (= NewTarget undefined) let newTarget = CONTEXT[\"Function\"] else let newTarget = NewTarget\n  1:(0) app __x0__ = (OrdinaryCreateFromConstructor newTarget \"%AggregateError.prototype%\" (0) (new [\"ErrorData\"]))\n  1:let O = [? __x0__]\n  2:if (! (= message undefined)) {\n    3:(1) app __x1__ = (ToString message)\n    3:let msg = [? __x1__]\n    4:let msgDesc = (1) (new PropertyDescriptor(\"Value\" -> msg, \"Writable\" -> true, \"Enumerable\" -> false, \"Configurable\" -> true))\n    5:(2) app __x2__ = (DefinePropertyOrThrow O \"message\" msgDesc)\n    5:[! __x2__]\n  } else 3:{}\n  6:(3) app __x3__ = (IterableToList errors)\n  6:let errorsList = [? __x3__]\n  7:(4) app __x4__ = (CreateArrayFromList errorsList)\n  7:(5) app __x5__ = (DefinePropertyOrThrow O \"errors\" (2) (new PropertyDescriptor(\"Configurable\" -> true, \"Enumerable\" -> false, \"Writable\" -> true, \"Value\" -> [! __x4__])))\n  7:[! __x5__]\n  8:return O\n}"
  }, {
    "code": ["          1. If _value_ is present, then", "            1. Let _prim_ be ? ToNumeric(_value_).", "            1. If Type(_prim_) is BigInt, let _n_ be 𝔽(ℝ(_prim_)).", "            1. Otherwise, let _n_ be _prim_.", "          1. Else,", "            1. Let _n_ be *+0*<sub>𝔽</sub>.", "          1. If NewTarget is *undefined*, return _n_.", "          1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Number.prototype%\"*, « [[NumberData]] »).", "          1. Set _O_.[[NumberData]] to _n_.", "          1. Return _O_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "value"
      }],
      "ref": "Number"
    },
    "ids": "sec-number-constructor-number-value",
    "rawBody": "{\n  4:if (! (= value absent)) {\n    1:(0) app __x0__ = (ToNumeric value)\n    1:let prim = [? __x0__]\n    3:if (= (typeof prim) BigInt) let n = prim else let n = prim\n  } else let n = 0i\n  6:if (= NewTarget undefined) return n else 3:{}\n  7:(1) app __x1__ = (OrdinaryCreateFromConstructor NewTarget \"%Number.prototype%\" (0) (new [\"NumberData\"]))\n  7:let O = [? __x1__]\n  8:O[\"NumberData\"] = n\n  9:return O\n}"
  }, {
    "code": ["          1. If Type(_number_) is not Number, return *false*.", "          1. If _number_ is *NaN*, *+∞*<sub>𝔽</sub>, or *-∞*<sub>𝔽</sub>, return *false*.", "          1. Otherwise, return *true*."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "number"
      }],
      "ref": "Number[\"isFinite\"]"
    },
    "ids": "sec-number.isfinite",
    "rawBody": "{\n  0:if (! (= (typeof number) Number)) return false else 3:{}\n  2:if (|| (|| (= number NaN) (= number Infinity)) (= number -Infinity)) return false else return true\n}"
  }, {
    "code": ["          1. Return ! IsIntegralNumber(_number_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "number"
      }],
      "ref": "Number[\"isInteger\"]"
    },
    "ids": "sec-number.isinteger",
    "rawBody": "{\n  0:(0) app __x0__ = (IsIntegralNumber number)\n  0:return [! __x0__]\n}"
  }, {
    "code": ["          1. If Type(_number_) is not Number, return *false*.", "          1. If _number_ is *NaN*, return *true*.", "          1. Otherwise, return *false*."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "number"
      }],
      "ref": "Number[\"isNaN\"]"
    },
    "ids": "sec-number.isnan",
    "rawBody": "{\n  0:if (! (= (typeof number) Number)) return false else 3:{}\n  2:if (= number NaN) return true else return false\n}"
  }, {
    "code": ["          1. If ! IsIntegralNumber(_number_) is *true*, then", "            1. If abs(ℝ(_number_)) ≤ 2<sup>53</sup> - 1, return *true*.", "          1. Return *false*."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "number"
      }],
      "ref": "Number[\"isSafeInteger\"]"
    },
    "ids": "sec-number.issafeinteger",
    "rawBody": "{\n  0:(0) app __x0__ = (IsIntegralNumber number)\n  0:if (= [! __x0__] true) {\n    1:(1) app __x1__ = (abs number)\n    1:if (! (< (- (** 2.0 53i) 1i) __x1__)) return true else 3:{}\n  } else 3:{}\n  2:return false\n}"
  }, {
    "code": ["        1. If Type(_value_) is Number, return _value_.", "        1. If Type(_value_) is Object and _value_ has a [[NumberData]] internal slot, then", "          1. Let _n_ be _value_.[[NumberData]].", "          1. Assert: Type(_n_) is Number.", "          1. Return _n_.", "        1. Throw a *TypeError* exception."],
    "head": {
      "name": "thisNumberValue",
      "params": [{
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "sec-properties-of-the-number-prototype-object",
    "rawBody": "{\n  0:if (= (typeof value) Number) return value else 3:{}\n  1:if (&& (= (typeof value) Object) (! (= value[\"NumberData\"] absent))) {\n    2:let n = value[\"NumberData\"]\n    3:assert (= (typeof n) Number)\n    4:return n\n  } else 3:{}\n  5:(0) throw TypeError\n}"
  }, {
    "code": ["          1. Let _x_ be ? thisNumberValue(*this* value).", "          1. Let _f_ be ? ToIntegerOrInfinity(_fractionDigits_).", "          1. Assert: If _fractionDigits_ is *undefined*, then _f_ is 0.", "          1. If _x_ is not finite, return ! Number::toString(_x_).", "          1. If _f_ < 0 or _f_ > 100, throw a *RangeError* exception.", "          1. Set _x_ to ℝ(_x_).", "          1. Let _s_ be the empty String.", "          1. If _x_ < 0, then", "            1. Set _s_ to *\"-\"*.", "            1. Set _x_ to -_x_.", "          1. If _x_ = 0, then", "            1. Let _m_ be the String value consisting of _f_ + 1 occurrences of the code unit 0x0030 (DIGIT ZERO).", "            1. Let _e_ be 0.", "          1. Else,", "            1. If _fractionDigits_ is not *undefined*, then", "              1. Let _e_ and _n_ be integers such that 10<sup>_f_</sup> ≤ _n_ < 10<sup>_f_ + 1</sup> and for which _n_ × 10<sup>_e_ - _n_</sup> - _x_ is as close to zero as possible. If there are two such sets of _e_ and _n_, pick the _e_ and _n_ for which _n_ × 10<sup>_e_ - _f_</sup> is larger.", "            1. Else,", "              1. [id=\"step-number-proto-toexponential-intermediate-values\"] Let _e_, _n_, and _f_ be integers such that _f_ ≥ 0, 10<sup>_f_</sup> ≤ _n_ < 10<sup>_f_ + 1</sup>, _n_ × 10<sup>_e_ - _f_</sup> is _x_, and _f_ is as small as possible. Note that the decimal representation of _n_ has _f_ + 1 digits, _n_ is not divisible by 10, and the least significant digit of _n_ is not necessarily uniquely determined by these criteria.", "            1. Let _m_ be the String value consisting of the digits of the decimal representation of _n_ (in order, with no leading zeroes).", "          1. If _f_ ≠ 0, then", "            1. Let _a_ be the first code unit of _m_.", "            1. Let _b_ be the other _f_ code units of _m_.", "            1. Set _m_ to the string-concatenation of _a_, *\".\"*, and _b_.", "          1. If _e_ = 0, then", "            1. Let _c_ be *\"+\"*.", "            1. Let _d_ be *\"0\"*.", "          1. Else,", "            1. If _e_ > 0, let _c_ be *\"+\"*.", "            1. Else,", "              1. Assert: _e_ < 0.", "              1. Let _c_ be *\"-\"*.", "              1. Set _e_ to -_e_.", "            1. Let _d_ be the String value consisting of the digits of the decimal representation of _e_ (in order, with no leading zeroes).", "          1. Set _m_ to the string-concatenation of _m_, *\"e\"*, _c_, and _d_.", "          1. Return the string-concatenation of _s_ and _m_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "fractionDigits"
      }],
      "ref": "Number[\"prototype\"][\"toExponential\"]"
    },
    "ids": "sec-number.prototype.toexponential",
    "rawBody": "{\n  0:(0) app __x0__ = (thisNumberValue this)\n  0:let x = [? __x0__]\n  1:(1) app __x1__ = (ToIntegerOrInfinity fractionDigits)\n  1:let f = [? __x1__]\n  3:if (|| (= x Infinity) (= x -Infinity)) {\n    (2) app __x2__ = (PRIMITIVE[Number][\"toString\"] x)\n    return [! __x2__]\n  } else 2:{}\n  4:if (|| (< f 0i) (< 100i f)) (0) throw RangeError else 2:{}\n  5:x = x\n  6:let s = \"\"\n  7:if (< x 0i) {\n    8:s = \"-\"\n    9:x = (- x)\n  } else 2:{}\n  13:if (== x 0i) {\n    11:(1) ??? \"Let id:{m} be the String value consisting of id:{f} + 1 occurrences of the code unit 0x0030 ( DIGIT ZERO ) .\"\n    12:let e = 0i\n  } else {\n    16:if (! (= fractionDigits undefined)) (2) ??? \"Let id:{e} and id:{n} be integers such that 10 sup:{id:{f}} ≤ id:{n} < 10 sup:{id:{f} + 1} and for which id:{n} × 10 sup:{id:{e} - id:{n}} - id:{x} is as close to zero as possible . If there are two such sets of id:{e} and id:{n} , pick the id:{e} and id:{n} for which id:{n} × 10 sup:{id:{e} - id:{f}} is larger .\" else (3) ??? \"Let id:{e} , id:{n} , and id:{f} be integers such that id:{f} ≥ 0 , 10 sup:{id:{f}} ≤ id:{n} < 10 sup:{id:{f} + 1} , id:{n} × 10 sup:{id:{e} - id:{f}} is id:{x} , and id:{f} is as small as possible . Note that the decimal representation of id:{n} has id:{f} + 1 digits , id:{n} is not divisible by 10 , and the least significant digit of id:{n} is not necessarily uniquely determined by these criteria .\"\n    18:(4) ??? \"Let id:{m} be the String value consisting of the digits of the decimal representation of id:{n} ( in order , with no leading zeroes ) .\"\n  }\n  19:if (! (== f 0i)) {\n    20:(5) ??? \"Let id:{a} be the first code unit of id:{m} .\"\n    21:(6) ??? \"Let id:{b} be the other id:{f} code units of id:{m} .\"\n    22:m = (+ (+ a \".\") b)\n  } else 2:{}\n  26:if (== e 0i) {\n    24:let c = \"+\"\n    25:let d = \"0\"\n  } else {\n    28:if (< 0i e) let c = \"+\" else {\n      29:assert (< e 0i)\n      30:let c = \"-\"\n      31:e = (- e)\n    }\n    32:(7) ??? \"Let id:{d} be the String value consisting of the digits of the decimal representation of id:{e} ( in order , with no leading zeroes ) .\"\n  }\n  33:m = (+ (+ (+ m \"e\") c) d)\n  34:return (+ s m)\n}"
  }, {
    "code": ["          1. Let _x_ be ? thisNumberValue(*this* value).", "          1. Let _f_ be ? ToIntegerOrInfinity(_fractionDigits_).", "          1. Assert: If _fractionDigits_ is *undefined*, then _f_ is 0.", "          1. If _f_ is not finite, throw a *RangeError* exception.", "          1. If _f_ < 0 or _f_ > 100, throw a *RangeError* exception.", "          1. If _x_ is not finite, return ! Number::toString(_x_).", "          1. Set _x_ to ℝ(_x_).", "          1. Let _s_ be the empty String.", "          1. If _x_ < 0, then", "            1. Set _s_ to *\"-\"*.", "            1. Set _x_ to -_x_.", "          1. If _x_ ≥ 10<sup>21</sup>, then", "            1. Let _m_ be ! ToString(𝔽(_x_)).", "          1. Else,", "            1. Let _n_ be an integer for which _n_ / 10<sup>_f_</sup> - _x_ is as close to zero as possible. If there are two such _n_, pick the larger _n_.", "            1. If _n_ = 0, let _m_ be the String *\"0\"*. Otherwise, let _m_ be the String value consisting of the digits of the decimal representation of _n_ (in order, with no leading zeroes).", "            1. If _f_ ≠ 0, then", "              1. Let _k_ be the length of _m_.", "              1. If _k_ ≤ _f_, then", "                1. Let _z_ be the String value consisting of _f_ + 1 - _k_ occurrences of the code unit 0x0030 (DIGIT ZERO).", "                1. Set _m_ to the string-concatenation of _z_ and _m_.", "                1. Set _k_ to _f_ + 1.", "              1. Let _a_ be the first _k_ - _f_ code units of _m_.", "              1. Let _b_ be the other _f_ code units of _m_.", "              1. Set _m_ to the string-concatenation of _a_, *\".\"*, and _b_.", "          1. Return the string-concatenation of _s_ and _m_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "fractionDigits"
      }],
      "ref": "Number[\"prototype\"][\"toFixed\"]"
    },
    "ids": "sec-number.prototype.tofixed",
    "rawBody": "{\n  0:(0) app __x0__ = (thisNumberValue this)\n  0:let x = [? __x0__]\n  1:(1) app __x1__ = (ToIntegerOrInfinity fractionDigits)\n  1:let f = [? __x1__]\n  3:if (|| (= f Infinity) (= f -Infinity)) (0) throw RangeError else 2:{}\n  4:if (|| (< f 0i) (< 100i f)) (1) throw RangeError else 2:{}\n  5:if (|| (= x Infinity) (= x -Infinity)) {\n    (2) app __x2__ = (PRIMITIVE[Number][\"toString\"] x)\n    return [! __x2__]\n  } else 2:{}\n  6:x = x\n  7:let s = \"\"\n  8:if (< x 0i) {\n    9:s = \"-\"\n    10:x = (- x)\n  } else 2:{}\n  13:if (! (< x (** 10.0 21i))) {\n    12:(3) app __x3__ = (ToString x)\n    12:let m = [! __x3__]\n  } else {\n    14:(2) ??? \"Let id:{n} be an integer for which id:{n} / 10 sup:{id:{f}} - id:{x} is as close to zero as possible . If there are two such id:{n} , pick the larger id:{n} .\"\n    15:(3) ??? \"If id:{n} = 0 , let id:{m} be the String value:{\\\"0\\\"} . Otherwise , let id:{m} be the String value consisting of the digits of the decimal representation of id:{n} ( in order , with no leading zeroes ) .\"\n    16:if (! (== f 0i)) {\n      17:let k = m[\"length\"]\n      18:if (! (< f k)) {\n        19:(4) ??? \"Let id:{z} be the String value consisting of id:{f} + 1 - id:{k} occurrences of the code unit 0x0030 ( DIGIT ZERO ) .\"\n        20:m = (+ z m)\n        21:k = (+ f 1i)\n      } else 2:{}\n      22:(5) ??? \"Let id:{a} be the first id:{k} - id:{f} code units of id:{m} .\"\n      23:(6) ??? \"Let id:{b} be the other id:{f} code units of id:{m} .\"\n      24:m = (+ (+ a \".\") b)\n    } else 2:{}\n  }\n  25:return (+ s m)\n}"
  }, {
    "code": ["          1. Let _x_ be ? thisNumberValue(*this* value).", "          1. If _precision_ is *undefined*, return ! ToString(_x_).", "          1. Let _p_ be ? ToIntegerOrInfinity(_precision_).", "          1. If _x_ is not finite, return ! Number::toString(_x_).", "          1. If _p_ < 1 or _p_ > 100, throw a *RangeError* exception.", "          1. Set _x_ to ℝ(_x_).", "          1. Let _s_ be the empty String.", "          1. If _x_ < 0, then", "            1. Set _s_ to the code unit 0x002D (HYPHEN-MINUS).", "            1. Set _x_ to -_x_.", "          1. If _x_ = 0, then", "            1. Let _m_ be the String value consisting of _p_ occurrences of the code unit 0x0030 (DIGIT ZERO).", "            1. Let _e_ be 0.", "          1. Else,", "            1. Let _e_ and _n_ be integers such that 10<sup>_p_ - 1</sup> ≤ _n_ < 10<sup>_p_</sup> and for which _n_ × 10<sup>_e_ - _p_ + 1</sup> - _x_ is as close to zero as possible. If there are two such sets of _e_ and _n_, pick the _e_ and _n_ for which _n_ × 10<sup>_e_ - _p_ + 1</sup> is larger.", "            1. Let _m_ be the String value consisting of the digits of the decimal representation of _n_ (in order, with no leading zeroes).", "            1. If _e_ < -6 or _e_ ≥ _p_, then", "              1. Assert: _e_ ≠ 0.", "              1. If _p_ ≠ 1, then", "                1. Let _a_ be the first code unit of _m_.", "                1. Let _b_ be the other _p_ - 1 code units of _m_.", "                1. Set _m_ to the string-concatenation of _a_, *\".\"*, and _b_.", "              1. If _e_ > 0, then", "                1. Let _c_ be the code unit 0x002B (PLUS SIGN).", "              1. Else,", "                1. Assert: _e_ < 0.", "                1. Let _c_ be the code unit 0x002D (HYPHEN-MINUS).", "                1. Set _e_ to -_e_.", "              1. Let _d_ be the String value consisting of the digits of the decimal representation of _e_ (in order, with no leading zeroes).", "              1. Return the string-concatenation of _s_, _m_, the code unit 0x0065 (LATIN SMALL LETTER E), _c_, and _d_.", "          1. If _e_ = _p_ - 1, return the string-concatenation of _s_ and _m_.", "          1. If _e_ ≥ 0, then", "            1. Set _m_ to the string-concatenation of the first _e_ + 1 code units of _m_, the code unit 0x002E (FULL STOP), and the remaining _p_ - (_e_ + 1) code units of _m_.", "          1. Else,", "            1. Set _m_ to the string-concatenation of the code unit 0x0030 (DIGIT ZERO), the code unit 0x002E (FULL STOP), -(_e_ + 1) occurrences of the code unit 0x0030 (DIGIT ZERO), and the String _m_.", "          1. Return the string-concatenation of _s_ and _m_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "precision"
      }],
      "ref": "Number[\"prototype\"][\"toPrecision\"]"
    },
    "ids": "sec-number.prototype.toprecision",
    "rawBody": "{\n  0:(0) app __x0__ = (thisNumberValue this)\n  0:let x = [? __x0__]\n  1:if (= precision undefined) {\n    (1) app __x1__ = (ToString x)\n    return [! __x1__]\n  } else 2:{}\n  2:(2) app __x2__ = (ToIntegerOrInfinity precision)\n  2:let p = [? __x2__]\n  3:if (|| (= x Infinity) (= x -Infinity)) {\n    (3) app __x3__ = (PRIMITIVE[Number][\"toString\"] x)\n    return [! __x3__]\n  } else 2:{}\n  4:if (|| (< p 1i) (< 100i p)) (0) throw RangeError else 2:{}\n  5:x = x\n  6:let s = \"\"\n  7:if (< x 0i) {\n    8:s = \"-\"\n    9:x = (- x)\n  } else 2:{}\n  13:if (== x 0i) {\n    11:(1) ??? \"Let id:{m} be the String value consisting of id:{p} occurrences of the code unit 0x0030 ( DIGIT ZERO ) .\"\n    12:let e = 0i\n  } else {\n    14:(2) ??? \"Let id:{e} and id:{n} be integers such that 10 sup:{id:{p} - 1} ≤ id:{n} < 10 sup:{id:{p}} and for which id:{n} × 10 sup:{id:{e} - id:{p} + 1} - id:{x} is as close to zero as possible . If there are two such sets of id:{e} and id:{n} , pick the id:{e} and id:{n} for which id:{n} × 10 sup:{id:{e} - id:{p} + 1} is larger .\"\n    15:(3) ??? \"Let id:{m} be the String value consisting of the digits of the decimal representation of id:{n} ( in order , with no leading zeroes ) .\"\n    16:if (|| (< e -6i) (! (< e p))) {\n      17:assert (! (== e 0i))\n      18:if (! (== p 1i)) {\n        19:(4) ??? \"Let id:{a} be the first code unit of id:{m} .\"\n        20:(5) ??? \"Let id:{b} be the other id:{p} - 1 code units of id:{m} .\"\n        21:m = (+ (+ a \".\") b)\n      } else 2:{}\n      24:if (< 0i e) let c = \"+\" else {\n        25:assert (< e 0i)\n        26:let c = \"-\"\n        27:e = (- e)\n      }\n      28:(6) ??? \"Let id:{d} be the String value consisting of the digits of the decimal representation of id:{e} ( in order , with no leading zeroes ) .\"\n      29:return (+ (+ (+ (+ s m) \"e\") c) d)\n    } else 2:{}\n  }\n  30:if (== e (- p 1i)) return (+ s m) else 2:{}\n  33:if (! (< e 0i)) (7) ??? \"Set id:{m} to the string - concatenation of the first id:{e} + 1 code units of id:{m} , the code unit 0x002E ( FULL STOP ) , and the remaining id:{p} - ( id:{e} + 1 ) code units of id:{m} .\" else (8) ??? \"Set id:{m} to the string - concatenation of the code unit 0x0030 ( DIGIT ZERO ) , the code unit 0x002E ( FULL STOP ) , - ( id:{e} + 1 ) occurrences of the code unit 0x0030 ( DIGIT ZERO ) , and the String id:{m} .\"\n  35:return (+ s m)\n}"
  }, {
    "code": ["          1. Let _x_ be ? thisNumberValue(*this* value).", "          1. If _radix_ is *undefined*, let _radixMV_ be 10.", "          1. Else, let _radixMV_ be ? ToIntegerOrInfinity(_radix_).", "          1. If _radixMV_ < 2 or _radixMV_ > 36, throw a *RangeError* exception.", "          1. If _radixMV_ = 10, return ! ToString(_x_).", "          1. Return the String representation of this Number value using the radix specified by _radixMV_. Letters `a`-`z` are used for digits with values 10 through 35. The precise algorithm is implementation-defined, however the algorithm should be a generalization of that specified in <emu-xref href=\"#sec-numeric-types-number-tostring\"></emu-xref>."],
    "head": {
      "origParams": [{
        "kind": "Optional",
        "name": "radix"
      }],
      "ref": "Number[\"prototype\"][\"toString\"]"
    },
    "ids": "sec-number.prototype.tostring",
    "rawBody": "{\n  0:(0) app __x0__ = (thisNumberValue this)\n  0:let x = [? __x0__]\n  2:if (= radix undefined) let radixMV = 10i else {\n    (1) app __x1__ = (ToIntegerOrInfinity radix)\n    let radixMV = [? __x1__]\n  }\n  3:if (|| (< radixMV 2i) (< 36i radixMV)) (0) throw RangeError else 2:{}\n  4:if (== radixMV 10i) {\n    (2) app __x2__ = (ToString x)\n    return [! __x2__]\n  } else 2:{}\n  5:return (convert x num2str radixMV)\n}"
  }, {
    "code": ["          1. Return ? thisNumberValue(*this* value)."],
    "head": {
      "origParams": [],
      "ref": "Number[\"prototype\"][\"valueOf\"]"
    },
    "ids": "sec-number.prototype.valueof",
    "rawBody": "{\n  0:(0) app __x0__ = (thisNumberValue this)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. If NewTarget is not *undefined*, throw a *TypeError* exception.", "          1. Let _prim_ be ? ToPrimitive(_value_, ~number~).", "          1. If Type(_prim_) is Number, return ? NumberToBigInt(_prim_).", "          1. Otherwise, return ? ToBigInt(_value_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "value"
      }],
      "ref": "BigInt"
    },
    "ids": "sec-bigint-constructor-number-value",
    "rawBody": "{\n  0:if (! (= NewTarget undefined)) (0) throw TypeError else 2:{}\n  1:(0) app __x0__ = (ToPrimitive value CONST_number)\n  1:let prim = [? __x0__]\n  3:if (= (typeof prim) Number) {\n    (1) app __x1__ = (NumberToBigInt prim)\n    return [? __x1__]\n  } else {\n    (2) app __x2__ = (ToBigInt value)\n    return [? __x2__]\n  }\n}"
  }, {
    "code": ["            1. If IsIntegralNumber(_number_) is *false*, throw a *RangeError* exception.", "            1. Return the BigInt value that represents ℝ(_number_)."],
    "head": {
      "name": "NumberToBigInt",
      "params": [{
        "kind": "Normal",
        "name": "number"
      }]
    },
    "ids": "sec-numbertobigint",
    "rawBody": "{\n  0:(0) app __x0__ = (IsIntegralNumber number)\n  0:if (= __x0__ false) (0) throw RangeError else 2:{}\n  1:return (convert number num2bigint )\n}"
  }, {
    "code": ["          1. Set _bits_ to ? ToIndex(_bits_).", "          1. Set _bigint_ to ? ToBigInt(_bigint_).", "          1. Let _mod_ be ℝ(_bigint_) modulo 2<sup>_bits_</sup>.", "          1. If _mod_ ≥ 2<sup>_bits_ - 1</sup>, return ℤ(_mod_ - 2<sup>_bits_</sup>); otherwise, return ℤ(_mod_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "bits"
      }, {
        "kind": "Normal",
        "name": "bigint"
      }],
      "ref": "BigInt[\"asIntN\"]"
    },
    "ids": "sec-bigint.asintn",
    "rawBody": "{\n  0:(0) app __x0__ = (ToIndex bits)\n  0:bits = [? __x0__]\n  1:(1) app __x1__ = (ToBigInt bigint)\n  1:bigint = [? __x1__]\n  2:let mod = (%% bigint (** 2.0 bits))\n  3:if (! (< mod (** 2.0 (- bits 1i)))) return (convert (- mod (** 2.0 bits)) num2bigint ) else return (convert mod num2bigint )\n}"
  }, {
    "code": ["          1. Set _bits_ to ? ToIndex(_bits_).", "          1. Set _bigint_ to ? ToBigInt(_bigint_).", "          1. Return the BigInt value that represents ℝ(_bigint_) modulo 2<sup>_bits_</sup>."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "bits"
      }, {
        "kind": "Normal",
        "name": "bigint"
      }],
      "ref": "BigInt[\"asUintN\"]"
    },
    "ids": "sec-bigint.asuintn",
    "rawBody": "{\n  0:(0) app __x0__ = (ToIndex bits)\n  0:bits = [? __x0__]\n  1:(1) app __x1__ = (ToBigInt bigint)\n  1:bigint = [? __x1__]\n  2:return (convert (%% bigint (** 2.0 bits)) num2bigint )\n}"
  }, {
    "code": ["        1. If Type(_value_) is BigInt, return _value_.", "        1. If Type(_value_) is Object and _value_ has a [[BigIntData]] internal slot, then", "          1. Assert: Type(_value_.[[BigIntData]]) is BigInt.", "          1. Return _value_.[[BigIntData]].", "        1. Throw a *TypeError* exception."],
    "head": {
      "name": "thisBigIntValue",
      "params": [{
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "sec-properties-of-the-bigint-prototype-object",
    "rawBody": "{\n  0:if (= (typeof value) BigInt) return value else 2:{}\n  1:if (&& (= (typeof value) Object) (! (= value[\"BigIntData\"] absent))) {\n    2:assert (= (typeof value[\"BigIntData\"]) BigInt)\n    3:return value[\"BigIntData\"]\n  } else 2:{}\n  4:(0) throw TypeError\n}"
  }, {
    "code": ["          1. Let _x_ be ? thisBigIntValue(*this* value).", "          1. If _radix_ is *undefined*, let _radixMV_ be 10.", "          1. Else, let _radixMV_ be ? ToIntegerOrInfinity(_radix_).", "          1. If _radixMV_ < 2 or _radixMV_ > 36, throw a *RangeError* exception.", "          1. If _radixMV_ = 10, return ! ToString(_x_).", "          1. Return the String representation of this Number value using the radix specified by _radixMV_. Letters `a`-`z` are used for digits with values 10 through 35. The precise algorithm is implementation-defined, however the algorithm should be a generalization of that specified in <emu-xref href=\"#sec-numeric-types-bigint-tostring\"></emu-xref>."],
    "head": {
      "origParams": [{
        "kind": "Optional",
        "name": "radix"
      }],
      "ref": "BigInt[\"prototype\"][\"toString\"]"
    },
    "ids": "sec-bigint.prototype.tostring",
    "rawBody": "{\n  0:(0) app __x0__ = (thisBigIntValue this)\n  0:let x = [? __x0__]\n  2:if (= radix undefined) let radixMV = 10i else {\n    (1) app __x1__ = (ToIntegerOrInfinity radix)\n    let radixMV = [? __x1__]\n  }\n  3:if (|| (< radixMV 2i) (< 36i radixMV)) (0) throw RangeError else 2:{}\n  4:if (== radixMV 10i) {\n    (2) app __x2__ = (ToString x)\n    return [! __x2__]\n  } else 2:{}\n  5:(1) ??? \"Return the String representation of this Number value using the radix specified by id:{radixMV} . Letters code:{a} - code:{z} are used for digits with values 10 through 35 . The precise algorithm is implementation - defined , however the algorithm should be a generalization of that specified in link:{sec-numeric-types-bigint-tostring} .\"\n}"
  }, {
    "code": ["          1. Return ? thisBigIntValue(*this* value)."],
    "head": {
      "origParams": [],
      "ref": "BigInt[\"prototype\"][\"valueOf\"]"
    },
    "ids": "sec-bigint.prototype.valueof",
    "rawBody": "{\n  0:(0) app __x0__ = (thisBigIntValue this)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Let _n_ be ? ToNumber(_x_).", "          1. If _n_ is *NaN*, return *NaN*.", "          1. If _n_ is *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.", "          1. If _n_ is *-∞*<sub>𝔽</sub>, return *+∞*<sub>𝔽</sub>.", "          1. If _n_ < *+0*<sub>𝔽</sub>, return -_n_.", "          1. Return _n_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "x"
      }],
      "ref": "Math[\"abs\"]"
    },
    "ids": "sec-math.abs",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber x)\n  0:let n = [? __x0__]\n  1:if (= n NaN) return NaN else 2:{}\n  2:if (= n -0.0) return 0i else 2:{}\n  3:if (= n -Infinity) return Infinity else 2:{}\n  4:if (< n 0i) return (- n) else 2:{}\n  5:return n\n}"
  }, {
    "code": ["          1. Let _n_ be ? ToNumber(_x_).", "          1. If _n_ is *NaN*, _n_ > *1*<sub>𝔽</sub>, or _n_ < *-1*<sub>𝔽</sub>, return *NaN*.", "          1. If _n_ is *1*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.", "          1. Return an implementation-approximated value representing the result of the inverse cosine of ℝ(_n_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "x"
      }],
      "ref": "Math[\"acos\"]"
    },
    "ids": "sec-math.acos",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber x)\n  0:let n = [? __x0__]\n  1:if (|| (|| (= n NaN) (< 1i n)) (< n -1i)) return NaN else 2:{}\n  2:if (= n 1i) return 0i else 2:{}\n  3:(0) ??? \"Return an implementation - approximated value representing the result of the inverse cosine of ℝ ( id:{n} ) .\"\n}"
  }, {
    "code": ["          1. Let _n_ be ? ToNumber(_x_).", "          1. If _n_ is *NaN* or _n_ is *+∞*<sub>𝔽</sub>, return _n_.", "          1. If _n_ is *1*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.", "          1. If _n_ < *1*<sub>𝔽</sub>, return *NaN*.", "          1. Return an implementation-approximated value representing the result of the inverse hyperbolic cosine of ℝ(_n_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "x"
      }],
      "ref": "Math[\"acosh\"]"
    },
    "ids": "sec-math.acosh",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber x)\n  0:let n = [? __x0__]\n  1:if (|| (= n NaN) (= n Infinity)) return n else 2:{}\n  2:if (= n 1i) return 0i else 2:{}\n  3:if (< n 1i) return NaN else 2:{}\n  4:(0) ??? \"Return an implementation - approximated value representing the result of the inverse hyperbolic cosine of ℝ ( id:{n} ) .\"\n}"
  }, {
    "code": ["          1. Let _n_ be ? ToNumber(_x_).", "          1. If _n_ is *NaN*, _n_ is *+0*<sub>𝔽</sub>, or _n_ is *-0*<sub>𝔽</sub>, return _n_.", "          1. If _n_ > *1*<sub>𝔽</sub> or _n_ < *-1*<sub>𝔽</sub>, return *NaN*.", "          1. Return an implementation-approximated value representing the result of the inverse sine of ℝ(_n_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "x"
      }],
      "ref": "Math[\"asin\"]"
    },
    "ids": "sec-math.asin",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber x)\n  0:let n = [? __x0__]\n  1:if (|| (|| (= n NaN) (= n 0i)) (= n -0.0)) return n else 2:{}\n  2:if (|| (< 1i n) (< n -1i)) return NaN else 2:{}\n  3:(0) ??? \"Return an implementation - approximated value representing the result of the inverse sine of ℝ ( id:{n} ) .\"\n}"
  }, {
    "code": ["          1. Let _n_ be ? ToNumber(_x_).", "          1. If _n_ is *NaN*, _n_ is *+0*<sub>𝔽</sub>, _n_ is *-0*<sub>𝔽</sub>, _n_ is *+∞*<sub>𝔽</sub>, or _n_ is *-∞*<sub>𝔽</sub>, return _n_.", "          1. Return an implementation-approximated value representing the result of the inverse hyperbolic sine of ℝ(_n_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "x"
      }],
      "ref": "Math[\"asinh\"]"
    },
    "ids": "sec-math.asinh",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber x)\n  0:let n = [? __x0__]\n  1:if (|| (|| (|| (|| (= n NaN) (= n 0i)) (= n -0.0)) (= n Infinity)) (= n -Infinity)) return n else 2:{}\n  2:(0) ??? \"Return an implementation - approximated value representing the result of the inverse hyperbolic sine of ℝ ( id:{n} ) .\"\n}"
  }, {
    "code": ["          1. Let _n_ be ? ToNumber(_x_).", "          1. If _n_ is *NaN*, _n_ is *+0*<sub>𝔽</sub>, or _n_ is *-0*<sub>𝔽</sub>, return _n_.", "          1. If _n_ is *+∞*<sub>𝔽</sub>, return an implementation-approximated value representing π / 2.", "          1. If _n_ is *-∞*<sub>𝔽</sub>, return an implementation-approximated value representing -π / 2.", "          1. Return an implementation-approximated value representing the result of the inverse tangent of ℝ(_n_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "x"
      }],
      "ref": "Math[\"atan\"]"
    },
    "ids": "sec-math.atan",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber x)\n  0:let n = [? __x0__]\n  1:if (|| (|| (= n NaN) (= n 0i)) (= n -0.0)) return n else 2:{}\n  2:(0) ??? \"If id:{n} is value:{+∞} , return an implementation - approximated value representing π / 2 .\"\n  3:(1) ??? \"If id:{n} is value:{-∞} , return an implementation - approximated value representing - π / 2 .\"\n  4:(2) ??? \"Return an implementation - approximated value representing the result of the inverse tangent of ℝ ( id:{n} ) .\"\n}"
  }, {
    "code": ["          1. Let _n_ be ? ToNumber(_x_).", "          1. If _n_ is *NaN*, _n_ is *+0*<sub>𝔽</sub>, or _n_ is *-0*<sub>𝔽</sub>, return _n_.", "          1. If _n_ > *1*<sub>𝔽</sub> or _n_ < *-1*<sub>𝔽</sub>, return *NaN*.", "          1. If _n_ is *1*<sub>𝔽</sub>, return *+∞*<sub>𝔽</sub>.", "          1. If _n_ is *-1*<sub>𝔽</sub>, return *-∞*<sub>𝔽</sub>.", "          1. Return an implementation-approximated value representing the result of the inverse hyperbolic tangent of ℝ(_n_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "x"
      }],
      "ref": "Math[\"atanh\"]"
    },
    "ids": "sec-math.atanh",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber x)\n  0:let n = [? __x0__]\n  1:if (|| (|| (= n NaN) (= n 0i)) (= n -0.0)) return n else 2:{}\n  2:if (|| (< 1i n) (< n -1i)) return NaN else 2:{}\n  3:if (= n 1i) return Infinity else 2:{}\n  4:if (= n -1i) return -Infinity else 2:{}\n  5:(0) ??? \"Return an implementation - approximated value representing the result of the inverse hyperbolic tangent of ℝ ( id:{n} ) .\"\n}"
  }, {
    "code": ["          1. Let _n_ be ? ToNumber(_x_).", "          1. If _n_ is *NaN*, _n_ is *+0*<sub>𝔽</sub>, _n_ is *-0*<sub>𝔽</sub>, _n_ is *+∞*<sub>𝔽</sub>, or _n_ is *-∞*<sub>𝔽</sub>, return _n_.", "          1. Return an implementation-approximated value representing the result of the cube root of ℝ(_n_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "x"
      }],
      "ref": "Math[\"cbrt\"]"
    },
    "ids": "sec-math.cbrt",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber x)\n  0:let n = [? __x0__]\n  1:if (|| (|| (|| (|| (= n NaN) (= n 0i)) (= n -0.0)) (= n Infinity)) (= n -Infinity)) return n else 2:{}\n  2:(0) ??? \"Return an implementation - approximated value representing the result of the cube root of ℝ ( id:{n} ) .\"\n}"
  }, {
    "code": ["          1. Let _n_ be ? ToNumber(_x_).", "          1. If _n_ is *NaN*, _n_ is *+0*<sub>𝔽</sub>, _n_ is *-0*<sub>𝔽</sub>, _n_ is *+∞*<sub>𝔽</sub>, or _n_ is *-∞*<sub>𝔽</sub>, return _n_.", "          1. If _n_ < *+0*<sub>𝔽</sub> and _n_ > *-1*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.", "          1. If _n_ is an integral Number, return _n_.", "          1. Return the smallest (closest to -∞) integral Number value that is not less than _n_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "x"
      }],
      "ref": "Math[\"ceil\"]"
    },
    "ids": "sec-math.ceil",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber x)\n  0:let n = [? __x0__]\n  1:if (|| (|| (|| (|| (= n NaN) (= n 0i)) (= n -0.0)) (= n Infinity)) (= n -Infinity)) return n else 2:{}\n  2:if (&& (< n 0i) (< -1i n)) return -0.0 else 2:{}\n  3:(0) ??? \"If id:{n} is an integral Number , return id:{n} .\"\n  4:(1) ??? \"Return the smallest ( closest to - ∞ ) integral Number value that is not less than id:{n} .\"\n}"
  }, {
    "code": ["          1. Let _n_ be ? ToNumber(_x_).", "          1. If _n_ is *NaN*, _n_ is *+0*<sub>𝔽</sub>, or _n_ is *-0*<sub>𝔽</sub>, return _n_.", "          1. If _n_ is *+∞*<sub>𝔽</sub> or _n_ is *-∞*<sub>𝔽</sub>, return *NaN*.", "          1. Return an implementation-approximated value representing the result of the cosine of ℝ(_n_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "x"
      }],
      "ref": "Math[\"cos\"]"
    },
    "ids": "sec-math.cos",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber x)\n  0:let n = [? __x0__]\n  1:if (|| (|| (= n NaN) (= n 0i)) (= n -0.0)) return n else 2:{}\n  2:if (|| (= n Infinity) (= n -Infinity)) return NaN else 2:{}\n  3:(0) ??? \"Return an implementation - approximated value representing the result of the cosine of ℝ ( id:{n} ) .\"\n}"
  }, {
    "code": ["          1. Let _n_ be ? ToNumber(_x_).", "          1. If _n_ is *NaN*, _n_ is *+∞*<sub>𝔽</sub>, or _n_ is *-∞*<sub>𝔽</sub>, return _n_.", "          1. If _n_ is *+0*<sub>𝔽</sub> or _n_ is *-0*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>.", "          1. Return an implementation-approximated value representing the result of the hyperbolic cosine of ℝ(_n_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "x"
      }],
      "ref": "Math[\"cosh\"]"
    },
    "ids": "sec-math.cosh",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber x)\n  0:let n = [? __x0__]\n  1:if (|| (|| (= n NaN) (= n Infinity)) (= n -Infinity)) return n else 2:{}\n  2:if (|| (= n 0i) (= n -0.0)) return 1i else 2:{}\n  3:(0) ??? \"Return an implementation - approximated value representing the result of the hyperbolic cosine of ℝ ( id:{n} ) .\"\n}"
  }, {
    "code": ["          1. Let _n_ be ? ToNumber(_x_).", "          1. If _n_ is *NaN* or _n_ is *+∞*<sub>𝔽</sub>, return _n_.", "          1. If _n_ is *+0*<sub>𝔽</sub> or _n_ is *-0*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>.", "          1. If _n_ is *-∞*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.", "          1. Return an implementation-approximated value representing the result of the exponential function of ℝ(_n_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "x"
      }],
      "ref": "Math[\"exp\"]"
    },
    "ids": "sec-math.exp",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber x)\n  0:let n = [? __x0__]\n  1:if (|| (= n NaN) (= n Infinity)) return n else 2:{}\n  2:if (|| (= n 0i) (= n -0.0)) return 1i else 2:{}\n  3:if (= n -Infinity) return 0i else 2:{}\n  4:(0) ??? \"Return an implementation - approximated value representing the result of the exponential function of ℝ ( id:{n} ) .\"\n}"
  }, {
    "code": ["          1. Let _n_ be ? ToNumber(_x_).", "          1. If _n_ is *NaN*, _n_ is *+0*<sub>𝔽</sub>, _n_ is *-0*<sub>𝔽</sub>, _n_ is *+∞*<sub>𝔽</sub>, or _n_ is *-∞*<sub>𝔽</sub>, return _n_.", "          1. If _n_ < *1*<sub>𝔽</sub> and _n_ > *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.", "          1. If _n_ is an integral Number, return _n_.", "          1. Return the greatest (closest to +∞) integral Number value that is not greater than _n_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "x"
      }],
      "ref": "Math[\"floor\"]"
    },
    "ids": "sec-math.floor",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber x)\n  0:let n = [? __x0__]\n  1:if (|| (|| (|| (|| (= n NaN) (= n 0i)) (= n -0.0)) (= n Infinity)) (= n -Infinity)) return n else 2:{}\n  2:if (&& (< n 1i) (< 0i n)) return 0i else 2:{}\n  3:(0) ??? \"If id:{n} is an integral Number , return id:{n} .\"\n  4:(1) ??? \"Return the greatest ( closest to + ∞ ) integral Number value that is not greater than id:{n} .\"\n}"
  }, {
    "code": ["          1. Let _n_ be ? ToNumber(_x_).", "          1. If _n_ is *NaN*, return *NaN*.", "          1. If _n_ is one of *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, *+∞*<sub>𝔽</sub>, or *-∞*<sub>𝔽</sub>, return _n_.", "          1. Let _n32_ be the result of converting _n_ to a value in IEEE 754-2019 binary32 format using roundTiesToEven mode.", "          1. Let _n64_ be the result of converting _n32_ to a value in IEEE 754-2019 binary64 format.", "          1. Return the ECMAScript Number value corresponding to _n64_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "x"
      }],
      "ref": "Math[\"fround\"]"
    },
    "ids": "sec-math.fround",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber x)\n  0:let n = [? __x0__]\n  1:if (= n NaN) return NaN else 2:{}\n  2:(0) ??? \"If id:{n} is one of value:{+0} , value:{-0} , value:{+∞} , or value:{-∞} , return id:{n} .\"\n  3:(1) ??? \"Let id:{n32} be the result of converting id:{n} to a value in IEEE 754 - 2019 binary32 format using roundTiesToEven mode .\"\n  4:(2) ??? \"Let id:{n64} be the result of converting id:{n32} to a value in IEEE 754 - 2019 binary64 format .\"\n  5:return n64\n}"
  }, {
    "code": ["          1. Let _coerced_ be a new empty List.", "          1. For each element _arg_ of _args_, do", "            1. Let _n_ be ? ToNumber(_arg_).", "            1. Append _n_ to _coerced_.", "          1. For each element _number_ of _coerced_, do", "            1. If _number_ is *+∞*<sub>𝔽</sub> or _number_ is *-∞*<sub>𝔽</sub>, return *+∞*<sub>𝔽</sub>.", "          1. Let _onlyZero_ be *true*.", "          1. For each element _number_ of _coerced_, do", "            1. If _number_ is *NaN*, return *NaN*.", "            1. If _number_ is neither *+0*<sub>𝔽</sub> nor *-0*<sub>𝔽</sub>, set _onlyZero_ to *false*.", "          1. If _onlyZero_ is *true*, return *+0*<sub>𝔽</sub>.", "          1. Return an implementation-approximated value representing the square root of the sum of squares of the mathematical values of the elements of _coerced_."],
    "head": {
      "origParams": [{
        "kind": "Variadic",
        "name": "args"
      }],
      "ref": "Math[\"hypot\"]"
    },
    "ids": "sec-math.hypot",
    "rawBody": "{\n  0:let coerced = (0) (new [])\n  1:let __x0__ = args\n  1:let __x1__ = 0i\n  1:while (< __x1__ __x0__[\"length\"]) {\n    let arg = __x0__[__x1__]\n    2:(0) app __x2__ = (ToNumber arg)\n    2:let n = [? __x2__]\n    3:append n -> coerced\n    __x1__ = (+ __x1__ 1i)\n  }\n  4:let __x3__ = coerced\n  4:let __x4__ = 0i\n  4:while (< __x4__ __x3__[\"length\"]) {\n    let number = __x3__[__x4__]\n    5:if (|| (= number Infinity) (= number -Infinity)) return Infinity else 2:{}\n    __x4__ = (+ __x4__ 1i)\n  }\n  6:let onlyZero = true\n  7:let __x5__ = coerced\n  7:let __x6__ = 0i\n  7:while (< __x6__ __x5__[\"length\"]) {\n    let number = __x5__[__x6__]\n    8:if (= number NaN) return NaN else 2:{}\n    9:if (! (|| (= number 0i) (= number -0.0))) onlyZero = false else 2:{}\n    __x6__ = (+ __x6__ 1i)\n  }\n  10:if (= onlyZero true) return 0i else 2:{}\n  11:(1) ??? \"Return an implementation - approximated value representing the square root of the sum of squares of the mathematical values of the elements of id:{coerced} .\"\n}"
  }, {
    "code": ["          1. Let _a_ be ℝ(? ToUint32(_x_)).", "          1. Let _b_ be ℝ(? ToUint32(_y_)).", "          1. Let _product_ be (_a_ × _b_) modulo 2<sup>32</sup>.", "          1. If _product_ ≥ 2<sup>31</sup>, return 𝔽(_product_ - 2<sup>32</sup>); otherwise return 𝔽(_product_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }],
      "ref": "Math[\"imul\"]"
    },
    "ids": "sec-math.imul",
    "rawBody": "{\n  0:(0) app __x0__ = (ToUint32 x)\n  0:let a = [? __x0__]\n  1:(1) app __x1__ = (ToUint32 y)\n  1:let b = [? __x1__]\n  2:let product = (%% (* a b) (** 2.0 32i))\n  3:if (! (< product (** 2.0 31i))) return (- product (** 2.0 32i)) else return product\n}"
  }, {
    "code": ["          1. Let _n_ be ? ToNumber(_x_).", "          1. If _n_ is *NaN* or _n_ is *+∞*<sub>𝔽</sub>, return _n_.", "          1. If _n_ is *1*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.", "          1. If _n_ is *+0*<sub>𝔽</sub> or _n_ is *-0*<sub>𝔽</sub>, return *-∞*<sub>𝔽</sub>.", "          1. If _n_ < *+0*<sub>𝔽</sub>, return *NaN*.", "          1. Return an implementation-approximated value representing the result of the natural logarithm of ℝ(_n_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "x"
      }],
      "ref": "Math[\"log\"]"
    },
    "ids": "sec-math.log",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber x)\n  0:let n = [? __x0__]\n  1:if (|| (= n NaN) (= n Infinity)) return n else 2:{}\n  2:if (= n 1i) return 0i else 2:{}\n  3:if (|| (= n 0i) (= n -0.0)) return -Infinity else 2:{}\n  4:if (< n 0i) return NaN else 2:{}\n  5:(0) ??? \"Return an implementation - approximated value representing the result of the natural logarithm of ℝ ( id:{n} ) .\"\n}"
  }, {
    "code": ["          1. Let _coerced_ be a new empty List.", "          1. For each element _arg_ of _args_, do", "            1. Let _n_ be ? ToNumber(_arg_).", "            1. Append _n_ to _coerced_.", "          1. Let _highest_ be *-∞*<sub>𝔽</sub>.", "          1. For each element _number_ of _coerced_, do", "            1. If _number_ is *NaN*, return *NaN*.", "            1. If _number_ is *+0*<sub>𝔽</sub> and _highest_ is *-0*<sub>𝔽</sub>, set _highest_ to *+0*<sub>𝔽</sub>.", "            1. If _number_ > _highest_, set _highest_ to _number_.", "          1. Return _highest_."],
    "head": {
      "origParams": [{
        "kind": "Variadic",
        "name": "args"
      }],
      "ref": "Math[\"max\"]"
    },
    "ids": "sec-math.max",
    "rawBody": "{\n  0:let coerced = (0) (new [])\n  1:let __x0__ = args\n  1:let __x1__ = 0i\n  1:while (< __x1__ __x0__[\"length\"]) {\n    let arg = __x0__[__x1__]\n    2:(0) app __x2__ = (ToNumber arg)\n    2:let n = [? __x2__]\n    3:append n -> coerced\n    __x1__ = (+ __x1__ 1i)\n  }\n  4:let highest = -Infinity\n  5:let __x3__ = coerced\n  5:let __x4__ = 0i\n  5:while (< __x4__ __x3__[\"length\"]) {\n    let number = __x3__[__x4__]\n    6:if (= number NaN) return NaN else 2:{}\n    7:if (&& (= number 0i) (= highest -0.0)) highest = 0i else 2:{}\n    8:if (< highest number) highest = number else 2:{}\n    __x4__ = (+ __x4__ 1i)\n  }\n  9:return highest\n}"
  }, {
    "code": ["          1. Let _coerced_ be a new empty List.", "          1. For each element _arg_ of _args_, do", "            1. Let _n_ be ? ToNumber(_arg_).", "            1. Append _n_ to _coerced_.", "          1. Let _lowest_ be *+∞*<sub>𝔽</sub>.", "          1. For each element _number_ of _coerced_, do", "            1. If _number_ is *NaN*, return *NaN*.", "            1. If _number_ is *-0*<sub>𝔽</sub> and _lowest_ is *+0*<sub>𝔽</sub>, set _lowest_ to *-0*<sub>𝔽</sub>.", "            1. If _number_ < _lowest_, set _lowest_ to _number_.", "          1. Return _lowest_."],
    "head": {
      "origParams": [{
        "kind": "Variadic",
        "name": "args"
      }],
      "ref": "Math[\"min\"]"
    },
    "ids": "sec-math.min",
    "rawBody": "{\n  0:let coerced = (0) (new [])\n  1:let __x0__ = args\n  1:let __x1__ = 0i\n  1:while (< __x1__ __x0__[\"length\"]) {\n    let arg = __x0__[__x1__]\n    2:(0) app __x2__ = (ToNumber arg)\n    2:let n = [? __x2__]\n    3:append n -> coerced\n    __x1__ = (+ __x1__ 1i)\n  }\n  4:let lowest = Infinity\n  5:let __x3__ = coerced\n  5:let __x4__ = 0i\n  5:while (< __x4__ __x3__[\"length\"]) {\n    let number = __x3__[__x4__]\n    6:if (= number NaN) return NaN else 2:{}\n    7:if (&& (= number -0.0) (= lowest 0i)) lowest = -0.0 else 2:{}\n    8:if (< number lowest) lowest = number else 2:{}\n    __x4__ = (+ __x4__ 1i)\n  }\n  9:return lowest\n}"
  }, {
    "code": ["          1. Set _base_ to ? ToNumber(_base_).", "          1. Set _exponent_ to ? ToNumber(_exponent_).", "          1. Return ! Number::exponentiate(_base_, _exponent_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "base"
      }, {
        "kind": "Normal",
        "name": "exponent"
      }],
      "ref": "Math[\"pow\"]"
    },
    "ids": "sec-math.pow",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber base)\n  0:base = [? __x0__]\n  1:(1) app __x1__ = (ToNumber exponent)\n  1:exponent = [? __x1__]\n  2:(2) app __x2__ = (PRIMITIVE[Number][\"exponentiate\"] base exponent)\n  2:return [! __x2__]\n}"
  }, {
    "code": ["          1. Let _n_ be ? ToNumber(_x_).", "          1. If _n_ is *NaN*, *+∞*<sub>𝔽</sub>, *-∞*<sub>𝔽</sub>, or an integral Number, return _n_.", "          1. If _n_ < *0.5*<sub>𝔽</sub> and _n_ > *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.", "          1. If _n_ < *+0*<sub>𝔽</sub> and _n_ ≥ *-0.5*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.", "          1. Return the integral Number closest to _n_, preferring the Number closer to +∞ in the case of a tie."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "x"
      }],
      "ref": "Math[\"round\"]"
    },
    "ids": "sec-math.round",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber x)\n  0:let n = [? __x0__]\n  1:(0) ??? \"If id:{n} is value:{NaN} , value:{+∞} , value:{-∞} , or an integral Number , return id:{n} .\"\n  2:if (&& (< n 0.5) (< 0i n)) return 0i else 2:{}\n  3:if (&& (< n 0i) (! (< n -0.5))) return -0.0 else 2:{}\n  4:(1) ??? \"Return the integral Number closest to id:{n} , preferring the Number closer to + ∞ in the case of a tie .\"\n}"
  }, {
    "code": ["          1. Let _n_ be ? ToNumber(_x_).", "          1. If _n_ is *NaN*, _n_ is *+0*<sub>𝔽</sub>, or _n_ is *-0*<sub>𝔽</sub>, return _n_.", "          1. If _n_ < *+0*<sub>𝔽</sub>, return *-1*<sub>𝔽</sub>.", "          1. Return *1*<sub>𝔽</sub>."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "x"
      }],
      "ref": "Math[\"sign\"]"
    },
    "ids": "sec-math.sign",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber x)\n  0:let n = [? __x0__]\n  1:if (|| (|| (= n NaN) (= n 0i)) (= n -0.0)) return n else 2:{}\n  2:if (< n 0i) return -1i else 2:{}\n  3:return 1i\n}"
  }, {
    "code": ["          1. Let _n_ be ? ToNumber(_x_).", "          1. If _n_ is *NaN*, _n_ is *+0*<sub>𝔽</sub>, or _n_ is *-0*<sub>𝔽</sub>, return _n_.", "          1. If _n_ is *+∞*<sub>𝔽</sub> or _n_ is *-∞*<sub>𝔽</sub>, return *NaN*.", "          1. Return an implementation-approximated value representing the result of the sine of ℝ(_n_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "x"
      }],
      "ref": "Math[\"sin\"]"
    },
    "ids": "sec-math.sin",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber x)\n  0:let n = [? __x0__]\n  1:if (|| (|| (= n NaN) (= n 0i)) (= n -0.0)) return n else 2:{}\n  2:if (|| (= n Infinity) (= n -Infinity)) return NaN else 2:{}\n  3:(0) ??? \"Return an implementation - approximated value representing the result of the sine of ℝ ( id:{n} ) .\"\n}"
  }, {
    "code": ["          1. Let _n_ be ? ToNumber(_x_).", "          1. If _n_ is *NaN*, _n_ is *+0*<sub>𝔽</sub>, _n_ is *-0*<sub>𝔽</sub>, _n_ is *+∞*<sub>𝔽</sub>, or _n_ is *-∞*<sub>𝔽</sub>, return _n_.", "          1. Return an implementation-approximated value representing the result of the hyperbolic sine of ℝ(_n_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "x"
      }],
      "ref": "Math[\"sinh\"]"
    },
    "ids": "sec-math.sinh",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber x)\n  0:let n = [? __x0__]\n  1:if (|| (|| (|| (|| (= n NaN) (= n 0i)) (= n -0.0)) (= n Infinity)) (= n -Infinity)) return n else 2:{}\n  2:(0) ??? \"Return an implementation - approximated value representing the result of the hyperbolic sine of ℝ ( id:{n} ) .\"\n}"
  }, {
    "code": ["          1. Let _n_ be ? ToNumber(_x_).", "          1. If _n_ is *NaN*, _n_ is *+0*<sub>𝔽</sub>, _n_ is *-0*<sub>𝔽</sub>, or _n_ is *+∞*<sub>𝔽</sub>, return _n_.", "          1. If _n_ < *+0*<sub>𝔽</sub>, return *NaN*.", "          1. Return an implementation-approximated value representing the result of the square root of ℝ(_n_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "x"
      }],
      "ref": "Math[\"sqrt\"]"
    },
    "ids": "sec-math.sqrt",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber x)\n  0:let n = [? __x0__]\n  1:if (|| (|| (|| (= n NaN) (= n 0i)) (= n -0.0)) (= n Infinity)) return n else 2:{}\n  2:if (< n 0i) return NaN else 2:{}\n  3:(0) ??? \"Return an implementation - approximated value representing the result of the square root of ℝ ( id:{n} ) .\"\n}"
  }, {
    "code": ["          1. Let _n_ be ? ToNumber(_x_).", "          1. If _n_ is *NaN*, _n_ is *+0*<sub>𝔽</sub>, or _n_ is *-0*<sub>𝔽</sub>, return _n_.", "          1. If _n_ is *+∞*<sub>𝔽</sub>, or _n_ is *-∞*<sub>𝔽</sub>, return *NaN*.", "          1. Return an implementation-approximated value representing the result of the tangent of ℝ(_n_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "x"
      }],
      "ref": "Math[\"tan\"]"
    },
    "ids": "sec-math.tan",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber x)\n  0:let n = [? __x0__]\n  1:if (|| (|| (= n NaN) (= n 0i)) (= n -0.0)) return n else 2:{}\n  2:if (|| (= n Infinity) (= n -Infinity)) return NaN else 2:{}\n  3:(0) ??? \"Return an implementation - approximated value representing the result of the tangent of ℝ ( id:{n} ) .\"\n}"
  }, {
    "code": ["          1. Let _n_ be ? ToNumber(_x_).", "          1. If _n_ is *NaN*, _n_ is *+0*<sub>𝔽</sub>, or _n_ is *-0*<sub>𝔽</sub>, return _n_.", "          1. If _n_ is *+∞*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>.", "          1. If _n_ is *-∞*<sub>𝔽</sub>, return *-1*<sub>𝔽</sub>.", "          1. Return an implementation-approximated value representing the result of the hyperbolic tangent of ℝ(_n_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "x"
      }],
      "ref": "Math[\"tanh\"]"
    },
    "ids": "sec-math.tanh",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber x)\n  0:let n = [? __x0__]\n  1:if (|| (|| (= n NaN) (= n 0i)) (= n -0.0)) return n else 2:{}\n  2:if (= n Infinity) return 1i else 2:{}\n  3:if (= n -Infinity) return -1i else 2:{}\n  4:(0) ??? \"Return an implementation - approximated value representing the result of the hyperbolic tangent of ℝ ( id:{n} ) .\"\n}"
  }, {
    "code": ["          1. Let _n_ be ? ToNumber(_x_).", "          1. If _n_ is *NaN*, _n_ is *+0*<sub>𝔽</sub>, _n_ is *-0*<sub>𝔽</sub>, _n_ is *+∞*<sub>𝔽</sub>, or _n_ is *-∞*<sub>𝔽</sub>, return _n_.", "          1. If _n_ < *1*<sub>𝔽</sub> and _n_ > *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.", "          1. If _n_ < *+0*<sub>𝔽</sub> and _n_ > *-1*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.", "          1. Return the integral Number nearest _n_ in the direction of *+0*<sub>𝔽</sub>."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "x"
      }],
      "ref": "Math[\"trunc\"]"
    },
    "ids": "sec-math.trunc",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber x)\n  0:let n = [? __x0__]\n  1:if (|| (|| (|| (|| (= n NaN) (= n 0i)) (= n -0.0)) (= n Infinity)) (= n -Infinity)) return n else 2:{}\n  2:if (&& (< n 1i) (< 0i n)) return 0i else 2:{}\n  3:if (&& (< n 0i) (< -1i n)) return -0.0 else 2:{}\n  4:(0) ??? \"Return the integral Number nearest id:{n} in the direction of value:{+0} .\"\n}"
  }, {
    "code": ["          1. Return _t_ + LocalTZA(_t_, *true*)."],
    "head": {
      "name": "LocalTime",
      "params": [{
        "kind": "Normal",
        "name": "t"
      }]
    },
    "ids": "sec-localtime",
    "rawBody": "{\n  0:(0) app __x0__ = (LocalTZA t true)\n  0:return (+ t __x0__)\n}"
  }, {
    "code": ["          1. Return _t_ - LocalTZA(_t_, *false*)."],
    "head": {
      "name": "UTC",
      "params": [{
        "kind": "Normal",
        "name": "t"
      }]
    },
    "ids": "sec-utc-t",
    "rawBody": "{\n  0:(0) app __x0__ = (LocalTZA t false)\n  0:return (- t __x0__)\n}"
  }, {
    "code": ["          1. If _hour_ is not finite or _min_ is not finite or _sec_ is not finite or _ms_ is not finite, return *NaN*.", "          1. Let _h_ be 𝔽(! ToIntegerOrInfinity(_hour_)).", "          1. Let _m_ be 𝔽(! ToIntegerOrInfinity(_min_)).", "          1. Let _s_ be 𝔽(! ToIntegerOrInfinity(_sec_)).", "          1. Let _milli_ be 𝔽(! ToIntegerOrInfinity(_ms_)).", "          1. Let _t_ be ((_h_ `*` msPerHour `+` _m_ `*` msPerMinute) `+` _s_ `*` msPerSecond) `+` _milli_, performing the arithmetic according to IEEE 754-2019 rules (that is, as if using the ECMAScript operators `*` and `+`).", "          1. Return _t_."],
    "head": {
      "name": "MakeTime",
      "params": [{
        "kind": "Normal",
        "name": "hour"
      }, {
        "kind": "Normal",
        "name": "min"
      }, {
        "kind": "Normal",
        "name": "sec"
      }, {
        "kind": "Normal",
        "name": "ms"
      }]
    },
    "ids": "sec-maketime",
    "rawBody": "{\n  0:if (|| (|| (= hour Infinity) (= hour -Infinity)) (|| (|| (= min Infinity) (= min -Infinity)) (|| (|| (= sec Infinity) (= sec -Infinity)) (|| (= ms Infinity) (= ms -Infinity))))) return NaN else 2:{}\n  1:(0) app __x0__ = (ToIntegerOrInfinity hour)\n  1:let h = [! __x0__]\n  2:(1) app __x1__ = (ToIntegerOrInfinity min)\n  2:let m = [! __x1__]\n  3:(2) app __x2__ = (ToIntegerOrInfinity sec)\n  3:let s = [! __x2__]\n  4:(3) app __x3__ = (ToIntegerOrInfinity ms)\n  4:let milli = [! __x3__]\n  5:(0) ??? \"Let id:{t} be ( ( id:{h} code:{*} msPerHour code:{+} id:{m} code:{*} msPerMinute ) code:{+} id:{s} code:{*} msPerSecond ) code:{+} id:{milli} , performing the arithmetic according to IEEE 754 - 2019 rules ( that is , as if using the ECMAScript operators code:{*} and code:{+} ) .\"\n  6:return t\n}"
  }, {
    "code": ["          1. If _year_ is not finite or _month_ is not finite or _date_ is not finite, return *NaN*.", "          1. Let _y_ be 𝔽(! ToIntegerOrInfinity(_year_)).", "          1. Let _m_ be 𝔽(! ToIntegerOrInfinity(_month_)).", "          1. Let _dt_ be 𝔽(! ToIntegerOrInfinity(_date_)).", "          1. Let _ym_ be _y_ + 𝔽(floor(ℝ(_m_) / 12)).", "          1. If _ym_ is not finite, return *NaN*.", "          1. Let _mn_ be 𝔽(ℝ(_m_) modulo 12).", "          1. Find a finite time value _t_ such that YearFromTime(_t_) is _ym_ and MonthFromTime(_t_) is _mn_ and DateFromTime(_t_) is *1*<sub>𝔽</sub>; but if this is not possible (because some argument is out of range), return *NaN*.", "          1. Return Day(_t_) + _dt_ - *1*<sub>𝔽</sub>."],
    "head": {
      "name": "MakeDay",
      "params": [{
        "kind": "Normal",
        "name": "year"
      }, {
        "kind": "Normal",
        "name": "month"
      }, {
        "kind": "Normal",
        "name": "date"
      }]
    },
    "ids": "sec-makeday",
    "rawBody": "{\n  0:if (|| (|| (= year Infinity) (= year -Infinity)) (|| (|| (= month Infinity) (= month -Infinity)) (|| (= date Infinity) (= date -Infinity)))) return NaN else 2:{}\n  1:(0) app __x0__ = (ToIntegerOrInfinity year)\n  1:let y = [! __x0__]\n  2:(1) app __x1__ = (ToIntegerOrInfinity month)\n  2:let m = [! __x1__]\n  3:(2) app __x2__ = (ToIntegerOrInfinity date)\n  3:let dt = [! __x2__]\n  4:(3) app __x3__ = (floor (/ m 12i))\n  4:let ym = (+ y __x3__)\n  5:if (|| (= ym Infinity) (= ym -Infinity)) return NaN else 2:{}\n  6:let mn = (%% m 12i)\n  7:(0) ??? \"Find a finite time value id:{t} such that YearFromTime ( id:{t} ) is id:{ym} and MonthFromTime ( id:{t} ) is id:{mn} and DateFromTime ( id:{t} ) is value:{1} ; but if this is not possible ( because some argument is out of range ) , return value:{NaN} .\"\n  8:(4) app __x4__ = (Day t)\n  8:return (- (+ __x4__ dt) 1i)\n}"
  }, {
    "code": ["          1. If _day_ is not finite or _time_ is not finite, return *NaN*.", "          1. Let _tv_ be _day_ × msPerDay + _time_.", "          1. If _tv_ is not finite, return *NaN*.", "          1. Return _tv_."],
    "head": {
      "name": "MakeDate",
      "params": [{
        "kind": "Normal",
        "name": "day"
      }, {
        "kind": "Normal",
        "name": "time"
      }]
    },
    "ids": "sec-makedate",
    "rawBody": "{\n  0:if (|| (|| (= day Infinity) (= day -Infinity)) (|| (= time Infinity) (= time -Infinity))) return NaN else 2:{}\n  1:let tv = (+ (* day 8.64E7) time)\n  2:if (|| (= tv Infinity) (= tv -Infinity)) return NaN else 2:{}\n  3:return tv\n}"
  }, {
    "code": ["          1. If _time_ is not finite, return *NaN*.", "          1. If abs(ℝ(_time_)) > 8.64 × 10<sup>15</sup>, return *NaN*.", "          1. Return 𝔽(! ToIntegerOrInfinity(_time_))."],
    "head": {
      "name": "TimeClip",
      "params": [{
        "kind": "Normal",
        "name": "time"
      }]
    },
    "ids": "sec-timeclip",
    "rawBody": "{\n  0:if (|| (= time Infinity) (= time -Infinity)) return NaN else 2:{}\n  1:(0) app __x0__ = (abs time)\n  1:if (< (* 8.64 (** 10.0 15i)) __x0__) return NaN else 2:{}\n  2:(1) app __x1__ = (ToIntegerOrInfinity time)\n  2:return [! __x1__]\n}"
  }, {
    "code": ["          1. If NewTarget is *undefined*, then", "            1. Let _now_ be the time value (UTC) identifying the current time.", "            1. Return ToDateString(_now_).", "          1. Let _numberOfArgs_ be the number of elements in _values_.", "          1. If _numberOfArgs_ = 0, then", "            1. Let _dv_ be the time value (UTC) identifying the current time.", "          1. Else if _numberOfArgs_ = 1, then", "            1. Let _value_ be _values_[0].", "            1. If Type(_value_) is Object and _value_ has a [[DateValue]] internal slot, then", "              1. Let _tv_ be ! thisTimeValue(_value_).", "            1. Else,", "              1. Let _v_ be ? ToPrimitive(_value_).", "              1. If Type(_v_) is String, then", "                1. Assert: The next step never returns an abrupt completion because Type(_v_) is String.", "                1. Let _tv_ be the result of parsing _v_ as a date, in exactly the same manner as for the `parse` method (<emu-xref href=\"#sec-date.parse\"></emu-xref>).", "              1. Else,", "                1. Let _tv_ be ? ToNumber(_v_).", "            1. Let _dv_ be TimeClip(_tv_).", "          1. Else,", "            1. Assert: _numberOfArgs_ ≥ 2.", "            1. Let _y_ be ? ToNumber(_values_[0]).", "            1. Let _m_ be ? ToNumber(_values_[1]).", "            1. If _numberOfArgs_ > 2, let _dt_ be ? ToNumber(_values_[2]); else let _dt_ be *1*<sub>𝔽</sub>.", "            1. If _numberOfArgs_ > 3, let _h_ be ? ToNumber(_values_[3]); else let _h_ be *+0*<sub>𝔽</sub>.", "            1. If _numberOfArgs_ > 4, let _min_ be ? ToNumber(_values_[4]); else let _min_ be *+0*<sub>𝔽</sub>.", "            1. If _numberOfArgs_ > 5, let _s_ be ? ToNumber(_values_[5]); else let _s_ be *+0*<sub>𝔽</sub>.", "            1. If _numberOfArgs_ > 6, let _milli_ be ? ToNumber(_values_[6]); else let _milli_ be *+0*<sub>𝔽</sub>.", "            1. If _y_ is *NaN*, let _yr_ be *NaN*.", "            1. Else,", "              1. Let _yi_ be ! ToIntegerOrInfinity(_y_).", "              1. If 0 ≤ _yi_ ≤ 99, let _yr_ be *1900*<sub>𝔽</sub> + 𝔽(_yi_); otherwise, let _yr_ be _y_.", "            1. Let _finalDate_ be MakeDate(MakeDay(_yr_, _m_, _dt_), MakeTime(_h_, _min_, _s_, _milli_)).", "            1. Let _dv_ be TimeClip(UTC(_finalDate_)).", "          1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Date.prototype%\"*, « [[DateValue]] »).", "          1. Set _O_.[[DateValue]] to _dv_.", "          1. Return _O_."],
    "head": {
      "origParams": [{
        "kind": "Variadic",
        "name": "values"
      }],
      "ref": "Date"
    },
    "ids": "sec-date",
    "rawBody": "{\n  0:if (= NewTarget undefined) {\n    1:(0) ??? \"Let id:{now} be the time value ( UTC ) identifying the current time .\"\n    2:(0) app __x0__ = (ToDateString now)\n    2:return __x0__\n  } else 13:{}\n  3:let numberOfArgs = values[\"length\"]\n  18:if (== numberOfArgs 0i) (1) ??? \"Let id:{dv} be the time value ( UTC ) identifying the current time .\" else if (== numberOfArgs 1i) {\n    7:let value = values[0i]\n    10:if (&& (= (typeof value) Object) (! (= value[\"DateValue\"] absent))) {\n      9:(1) app __x1__ = (thisTimeValue value)\n      9:let tv = [! __x1__]\n    } else {\n      11:(2) app __x2__ = (ToPrimitive value)\n      11:let v = [? __x2__]\n      15:if (= (typeof v) String) (2) ??? \"Let id:{tv} be the result of parsing id:{v} as a date , in exactly the same manner as for the code:{parse} method ( link:{sec-date.parse} ) .\" else {\n        16:(3) app __x3__ = (ToNumber v)\n        16:let tv = [? __x3__]\n      }\n    }\n    17:(4) app __x4__ = (TimeClip tv)\n    17:let dv = __x4__\n  } else {\n    19:assert (! (< numberOfArgs 2i))\n    20:(5) app __x5__ = (ToNumber values[0i])\n    20:let y = [? __x5__]\n    21:(6) app __x6__ = (ToNumber values[1i])\n    21:let m = [? __x6__]\n    22:if (< 2i numberOfArgs) {\n      (7) app __x7__ = (ToNumber values[2i])\n      let dt = [? __x7__]\n    } else let dt = 1i\n    23:if (< 3i numberOfArgs) {\n      (8) app __x8__ = (ToNumber values[3i])\n      let h = [? __x8__]\n    } else let h = 0i\n    24:if (< 4i numberOfArgs) {\n      (9) app __x9__ = (ToNumber values[4i])\n      let min = [? __x9__]\n    } else let min = 0i\n    25:if (< 5i numberOfArgs) {\n      (10) app __x10__ = (ToNumber values[5i])\n      let s = [? __x10__]\n    } else let s = 0i\n    26:if (< 6i numberOfArgs) {\n      (11) app __x11__ = (ToNumber values[6i])\n      let milli = [? __x11__]\n    } else let milli = 0i\n    28:if (= y NaN) let yr = NaN else {\n      29:(12) app __x12__ = (ToIntegerOrInfinity y)\n      29:let yi = [! __x12__]\n      30:if (&& (! (< yi 0i)) (! (< 99i yi))) let yr = (+ 1900i yi) else let yr = y\n    }\n    31:(13) app __x13__ = (MakeDay yr m dt)\n    31:(14) app __x14__ = (MakeTime h min s milli)\n    31:(15) app __x15__ = (MakeDate __x13__ __x14__)\n    31:let finalDate = __x15__\n    32:(16) app __x16__ = (UTC finalDate)\n    32:(17) app __x17__ = (TimeClip __x16__)\n    32:let dv = __x17__\n  }\n  33:(18) app __x18__ = (OrdinaryCreateFromConstructor NewTarget \"%Date.prototype%\" (3) (new [\"DateValue\"]))\n  33:let O = [? __x18__]\n  34:O[\"DateValue\"] = dv\n  35:return O\n}"
  }, {
    "code": ["          1. Let _y_ be ? ToNumber(_year_).", "          1. If _month_ is present, let _m_ be ? ToNumber(_month_); else let _m_ be *+0*<sub>𝔽</sub>.", "          1. If _date_ is present, let _dt_ be ? ToNumber(_date_); else let _dt_ be *1*<sub>𝔽</sub>.", "          1. If _hours_ is present, let _h_ be ? ToNumber(_hours_); else let _h_ be *+0*<sub>𝔽</sub>.", "          1. If _minutes_ is present, let _min_ be ? ToNumber(_minutes_); else let _min_ be *+0*<sub>𝔽</sub>.", "          1. If _seconds_ is present, let _s_ be ? ToNumber(_seconds_); else let _s_ be *+0*<sub>𝔽</sub>.", "          1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_); else let _milli_ be *+0*<sub>𝔽</sub>.", "          1. If _y_ is *NaN*, let _yr_ be *NaN*.", "          1. Else,", "            1. Let _yi_ be ! ToIntegerOrInfinity(_y_).", "            1. If 0 ≤ _yi_ ≤ 99, let _yr_ be *1900*<sub>𝔽</sub> + 𝔽(_yi_); otherwise, let _yr_ be _y_.", "          1. Return TimeClip(MakeDate(MakeDay(_yr_, _m_, _dt_), MakeTime(_h_, _min_, _s_, _milli_)))."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "year"
      }, {
        "kind": "Optional",
        "name": "month"
      }, {
        "kind": "Optional",
        "name": "date"
      }, {
        "kind": "Optional",
        "name": "hours"
      }, {
        "kind": "Optional",
        "name": "minutes"
      }, {
        "kind": "Optional",
        "name": "seconds"
      }, {
        "kind": "Optional",
        "name": "ms"
      }],
      "ref": "Date[\"UTC\"]"
    },
    "ids": "sec-date.utc",
    "rawBody": "{\n  0:(0) app __x0__ = (ToNumber year)\n  0:let y = [? __x0__]\n  1:if (! (= month absent)) {\n    (1) app __x1__ = (ToNumber month)\n    let m = [? __x1__]\n  } else let m = 0i\n  2:if (! (= date absent)) {\n    (2) app __x2__ = (ToNumber date)\n    let dt = [? __x2__]\n  } else let dt = 1i\n  3:if (! (= hours absent)) {\n    (3) app __x3__ = (ToNumber hours)\n    let h = [? __x3__]\n  } else let h = 0i\n  4:if (! (= minutes absent)) {\n    (4) app __x4__ = (ToNumber minutes)\n    let min = [? __x4__]\n  } else let min = 0i\n  5:if (! (= seconds absent)) {\n    (5) app __x5__ = (ToNumber seconds)\n    let s = [? __x5__]\n  } else let s = 0i\n  6:if (! (= ms absent)) {\n    (6) app __x6__ = (ToNumber ms)\n    let milli = [? __x6__]\n  } else let milli = 0i\n  8:if (= y NaN) let yr = NaN else {\n    9:(7) app __x7__ = (ToIntegerOrInfinity y)\n    9:let yi = [! __x7__]\n    10:if (&& (! (< yi 0i)) (! (< 99i yi))) let yr = (+ 1900i yi) else let yr = y\n  }\n  11:(8) app __x8__ = (MakeDay yr m dt)\n  11:(9) app __x9__ = (MakeTime h min s milli)\n  11:(10) app __x10__ = (MakeDate __x8__ __x9__)\n  11:(11) app __x11__ = (TimeClip __x10__)\n  11:return __x11__\n}"
  }, {
    "code": ["        1. If Type(_value_) is Object and _value_ has a [[DateValue]] internal slot, then", "          1. Return _value_.[[DateValue]].", "        1. Throw a *TypeError* exception."],
    "head": {
      "name": "thisTimeValue",
      "params": [{
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "sec-properties-of-the-date-prototype-object",
    "rawBody": "{\n  0:if (&& (= (typeof value) Object) (! (= value[\"DateValue\"] absent))) return value[\"DateValue\"] else 13:{}\n  2:(0) throw TypeError\n}"
  }, {
    "code": ["          1. Let _t_ be ? thisTimeValue(*this* value).", "          1. If _t_ is *NaN*, return *NaN*.", "          1. Return DateFromTime(LocalTime(_t_))."],
    "head": {
      "origParams": [],
      "ref": "Date[\"prototype\"][\"getDate\"]"
    },
    "ids": "sec-date.prototype.getdate",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:let t = [? __x0__]\n  1:if (= t NaN) return NaN else 13:{}\n  2:(1) app __x1__ = (LocalTime t)\n  2:(2) app __x2__ = (DateFromTime __x1__)\n  2:return __x2__\n}"
  }, {
    "code": ["          1. Let _t_ be ? thisTimeValue(*this* value).", "          1. If _t_ is *NaN*, return *NaN*.", "          1. Return WeekDay(LocalTime(_t_))."],
    "head": {
      "origParams": [],
      "ref": "Date[\"prototype\"][\"getDay\"]"
    },
    "ids": "sec-date.prototype.getday",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:let t = [? __x0__]\n  1:if (= t NaN) return NaN else 13:{}\n  2:(1) app __x1__ = (LocalTime t)\n  2:(2) app __x2__ = (WeekDay __x1__)\n  2:return __x2__\n}"
  }, {
    "code": ["          1. Let _t_ be ? thisTimeValue(*this* value).", "          1. If _t_ is *NaN*, return *NaN*.", "          1. Return YearFromTime(LocalTime(_t_))."],
    "head": {
      "origParams": [],
      "ref": "Date[\"prototype\"][\"getFullYear\"]"
    },
    "ids": "sec-date.prototype.getfullyear",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:let t = [? __x0__]\n  1:if (= t NaN) return NaN else 13:{}\n  2:(1) app __x1__ = (LocalTime t)\n  2:(2) app __x2__ = (YearFromTime __x1__)\n  2:return __x2__\n}"
  }, {
    "code": ["          1. Let _t_ be ? thisTimeValue(*this* value).", "          1. If _t_ is *NaN*, return *NaN*.", "          1. Return HourFromTime(LocalTime(_t_))."],
    "head": {
      "origParams": [],
      "ref": "Date[\"prototype\"][\"getHours\"]"
    },
    "ids": "sec-date.prototype.gethours",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:let t = [? __x0__]\n  1:if (= t NaN) return NaN else 13:{}\n  2:(1) app __x1__ = (LocalTime t)\n  2:(2) app __x2__ = (HourFromTime __x1__)\n  2:return __x2__\n}"
  }, {
    "code": ["          1. Let _t_ be ? thisTimeValue(*this* value).", "          1. If _t_ is *NaN*, return *NaN*.", "          1. Return msFromTime(LocalTime(_t_))."],
    "head": {
      "origParams": [],
      "ref": "Date[\"prototype\"][\"getMilliseconds\"]"
    },
    "ids": "sec-date.prototype.getmilliseconds",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:let t = [? __x0__]\n  1:if (= t NaN) return NaN else 13:{}\n  2:(1) app __x1__ = (LocalTime t)\n  2:(2) app __x2__ = (msFromTime __x1__)\n  2:return __x2__\n}"
  }, {
    "code": ["          1. Let _t_ be ? thisTimeValue(*this* value).", "          1. If _t_ is *NaN*, return *NaN*.", "          1. Return MinFromTime(LocalTime(_t_))."],
    "head": {
      "origParams": [],
      "ref": "Date[\"prototype\"][\"getMinutes\"]"
    },
    "ids": "sec-date.prototype.getminutes",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:let t = [? __x0__]\n  1:if (= t NaN) return NaN else 13:{}\n  2:(1) app __x1__ = (LocalTime t)\n  2:(2) app __x2__ = (MinFromTime __x1__)\n  2:return __x2__\n}"
  }, {
    "code": ["          1. Let _t_ be ? thisTimeValue(*this* value).", "          1. If _t_ is *NaN*, return *NaN*.", "          1. Return MonthFromTime(LocalTime(_t_))."],
    "head": {
      "origParams": [],
      "ref": "Date[\"prototype\"][\"getMonth\"]"
    },
    "ids": "sec-date.prototype.getmonth",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:let t = [? __x0__]\n  1:if (= t NaN) return NaN else 13:{}\n  2:(1) app __x1__ = (LocalTime t)\n  2:(2) app __x2__ = (MonthFromTime __x1__)\n  2:return __x2__\n}"
  }, {
    "code": ["          1. Let _t_ be ? thisTimeValue(*this* value).", "          1. If _t_ is *NaN*, return *NaN*.", "          1. Return SecFromTime(LocalTime(_t_))."],
    "head": {
      "origParams": [],
      "ref": "Date[\"prototype\"][\"getSeconds\"]"
    },
    "ids": "sec-date.prototype.getseconds",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:let t = [? __x0__]\n  1:if (= t NaN) return NaN else 13:{}\n  2:(1) app __x1__ = (LocalTime t)\n  2:(2) app __x2__ = (SecFromTime __x1__)\n  2:return __x2__\n}"
  }, {
    "code": ["          1. Return ? thisTimeValue(*this* value)."],
    "head": {
      "origParams": [],
      "ref": "Date[\"prototype\"][\"getTime\"]"
    },
    "ids": "sec-date.prototype.gettime",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Let _t_ be ? thisTimeValue(*this* value).", "          1. If _t_ is *NaN*, return *NaN*.", "          1. Return (_t_ - LocalTime(_t_)) / msPerMinute."],
    "head": {
      "origParams": [],
      "ref": "Date[\"prototype\"][\"getTimezoneOffset\"]"
    },
    "ids": "sec-date.prototype.gettimezoneoffset",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:let t = [? __x0__]\n  1:if (= t NaN) return NaN else 13:{}\n  2:(1) app __x1__ = (LocalTime t)\n  2:return (/ (- t __x1__) 60000.0)\n}"
  }, {
    "code": ["          1. Let _t_ be ? thisTimeValue(*this* value).", "          1. If _t_ is *NaN*, return *NaN*.", "          1. Return DateFromTime(_t_)."],
    "head": {
      "origParams": [],
      "ref": "Date[\"prototype\"][\"getUTCDate\"]"
    },
    "ids": "sec-date.prototype.getutcdate",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:let t = [? __x0__]\n  1:if (= t NaN) return NaN else 13:{}\n  2:(1) app __x1__ = (DateFromTime t)\n  2:return __x1__\n}"
  }, {
    "code": ["          1. Let _t_ be ? thisTimeValue(*this* value).", "          1. If _t_ is *NaN*, return *NaN*.", "          1. Return WeekDay(_t_)."],
    "head": {
      "origParams": [],
      "ref": "Date[\"prototype\"][\"getUTCDay\"]"
    },
    "ids": "sec-date.prototype.getutcday",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:let t = [? __x0__]\n  1:if (= t NaN) return NaN else 13:{}\n  2:(1) app __x1__ = (WeekDay t)\n  2:return __x1__\n}"
  }, {
    "code": ["          1. Let _t_ be ? thisTimeValue(*this* value).", "          1. If _t_ is *NaN*, return *NaN*.", "          1. Return YearFromTime(_t_)."],
    "head": {
      "origParams": [],
      "ref": "Date[\"prototype\"][\"getUTCFullYear\"]"
    },
    "ids": "sec-date.prototype.getutcfullyear",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:let t = [? __x0__]\n  1:if (= t NaN) return NaN else 13:{}\n  2:(1) app __x1__ = (YearFromTime t)\n  2:return __x1__\n}"
  }, {
    "code": ["          1. Let _t_ be ? thisTimeValue(*this* value).", "          1. If _t_ is *NaN*, return *NaN*.", "          1. Return HourFromTime(_t_)."],
    "head": {
      "origParams": [],
      "ref": "Date[\"prototype\"][\"getUTCHours\"]"
    },
    "ids": "sec-date.prototype.getutchours",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:let t = [? __x0__]\n  1:if (= t NaN) return NaN else 13:{}\n  2:(1) app __x1__ = (HourFromTime t)\n  2:return __x1__\n}"
  }, {
    "code": ["          1. Let _t_ be ? thisTimeValue(*this* value).", "          1. If _t_ is *NaN*, return *NaN*.", "          1. Return msFromTime(_t_)."],
    "head": {
      "origParams": [],
      "ref": "Date[\"prototype\"][\"getUTCMilliseconds\"]"
    },
    "ids": "sec-date.prototype.getutcmilliseconds",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:let t = [? __x0__]\n  1:if (= t NaN) return NaN else 13:{}\n  2:(1) app __x1__ = (msFromTime t)\n  2:return __x1__\n}"
  }, {
    "code": ["          1. Let _t_ be ? thisTimeValue(*this* value).", "          1. If _t_ is *NaN*, return *NaN*.", "          1. Return MinFromTime(_t_)."],
    "head": {
      "origParams": [],
      "ref": "Date[\"prototype\"][\"getUTCMinutes\"]"
    },
    "ids": "sec-date.prototype.getutcminutes",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:let t = [? __x0__]\n  1:if (= t NaN) return NaN else 13:{}\n  2:(1) app __x1__ = (MinFromTime t)\n  2:return __x1__\n}"
  }, {
    "code": ["          1. Let _t_ be ? thisTimeValue(*this* value).", "          1. If _t_ is *NaN*, return *NaN*.", "          1. Return MonthFromTime(_t_)."],
    "head": {
      "origParams": [],
      "ref": "Date[\"prototype\"][\"getUTCMonth\"]"
    },
    "ids": "sec-date.prototype.getutcmonth",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:let t = [? __x0__]\n  1:if (= t NaN) return NaN else 13:{}\n  2:(1) app __x1__ = (MonthFromTime t)\n  2:return __x1__\n}"
  }, {
    "code": ["          1. Let _t_ be ? thisTimeValue(*this* value).", "          1. If _t_ is *NaN*, return *NaN*.", "          1. Return SecFromTime(_t_)."],
    "head": {
      "origParams": [],
      "ref": "Date[\"prototype\"][\"getUTCSeconds\"]"
    },
    "ids": "sec-date.prototype.getutcseconds",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:let t = [? __x0__]\n  1:if (= t NaN) return NaN else 13:{}\n  2:(1) app __x1__ = (SecFromTime t)\n  2:return __x1__\n}"
  }, {
    "code": ["          1. Let _t_ be LocalTime(? thisTimeValue(*this* value)).", "          1. Let _dt_ be ? ToNumber(_date_).", "          1. Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), MonthFromTime(_t_), _dt_), TimeWithinDay(_t_)).", "          1. Let _u_ be TimeClip(UTC(_newDate_)).", "          1. Set the [[DateValue]] internal slot of this Date object to _u_.", "          1. Return _u_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "date"
      }],
      "ref": "Date[\"prototype\"][\"setDate\"]"
    },
    "ids": "sec-date.prototype.setdate",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:(1) app __x1__ = (LocalTime [? __x0__])\n  0:let t = __x1__\n  1:(2) app __x2__ = (ToNumber date)\n  1:let dt = [? __x2__]\n  2:(3) app __x3__ = (YearFromTime t)\n  2:(4) app __x4__ = (MonthFromTime t)\n  2:(5) app __x5__ = (MakeDay __x3__ __x4__ dt)\n  2:(6) app __x6__ = (TimeWithinDay t)\n  2:(7) app __x7__ = (MakeDate __x5__ __x6__)\n  2:let newDate = __x7__\n  3:(8) app __x8__ = (UTC newDate)\n  3:(9) app __x9__ = (TimeClip __x8__)\n  3:let u = __x9__\n  4:this[\"DateValue\"] = u\n  5:return u\n}"
  }, {
    "code": ["          1. Let _t_ be ? thisTimeValue(*this* value).", "          1. If _t_ is *NaN*, set _t_ to *+0*<sub>𝔽</sub>; otherwise, set _t_ to LocalTime(_t_).", "          1. Let _y_ be ? ToNumber(_year_).", "          1. If _month_ is not present, let _m_ be MonthFromTime(_t_); otherwise, let _m_ be ? ToNumber(_month_).", "          1. If _date_ is not present, let _dt_ be DateFromTime(_t_); otherwise, let _dt_ be ? ToNumber(_date_).", "          1. Let _newDate_ be MakeDate(MakeDay(_y_, _m_, _dt_), TimeWithinDay(_t_)).", "          1. Let _u_ be TimeClip(UTC(_newDate_)).", "          1. Set the [[DateValue]] internal slot of this Date object to _u_.", "          1. Return _u_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "year"
      }, {
        "kind": "Optional",
        "name": "month"
      }, {
        "kind": "Optional",
        "name": "date"
      }],
      "ref": "Date[\"prototype\"][\"setFullYear\"]"
    },
    "ids": "sec-date.prototype.setfullyear",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:let t = [? __x0__]\n  1:if (= t NaN) t = 0i else {\n    (1) app __x1__ = (LocalTime t)\n    t = __x1__\n  }\n  2:(2) app __x2__ = (ToNumber year)\n  2:let y = [? __x2__]\n  3:if (= month absent) {\n    (3) app __x3__ = (MonthFromTime t)\n    let m = __x3__\n  } else {\n    (4) app __x4__ = (ToNumber month)\n    let m = [? __x4__]\n  }\n  4:if (= date absent) {\n    (5) app __x5__ = (DateFromTime t)\n    let dt = __x5__\n  } else {\n    (6) app __x6__ = (ToNumber date)\n    let dt = [? __x6__]\n  }\n  5:(7) app __x7__ = (MakeDay y m dt)\n  5:(8) app __x8__ = (TimeWithinDay t)\n  5:(9) app __x9__ = (MakeDate __x7__ __x8__)\n  5:let newDate = __x9__\n  6:(10) app __x10__ = (UTC newDate)\n  6:(11) app __x11__ = (TimeClip __x10__)\n  6:let u = __x11__\n  7:this[\"DateValue\"] = u\n  8:return u\n}"
  }, {
    "code": ["          1. Let _t_ be LocalTime(? thisTimeValue(*this* value)).", "          1. Let _h_ be ? ToNumber(_hour_).", "          1. If _min_ is not present, let _m_ be MinFromTime(_t_); otherwise, let _m_ be ? ToNumber(_min_).", "          1. If _sec_ is not present, let _s_ be SecFromTime(_t_); otherwise, let _s_ be ? ToNumber(_sec_).", "          1. If _ms_ is not present, let _milli_ be msFromTime(_t_); otherwise, let _milli_ be ? ToNumber(_ms_).", "          1. Let _date_ be MakeDate(Day(_t_), MakeTime(_h_, _m_, _s_, _milli_)).", "          1. Let _u_ be TimeClip(UTC(_date_)).", "          1. Set the [[DateValue]] internal slot of this Date object to _u_.", "          1. Return _u_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "hour"
      }, {
        "kind": "Optional",
        "name": "min"
      }, {
        "kind": "Optional",
        "name": "sec"
      }, {
        "kind": "Optional",
        "name": "ms"
      }],
      "ref": "Date[\"prototype\"][\"setHours\"]"
    },
    "ids": "sec-date.prototype.sethours",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:(1) app __x1__ = (LocalTime [? __x0__])\n  0:let t = __x1__\n  1:(2) app __x2__ = (ToNumber hour)\n  1:let h = [? __x2__]\n  2:if (= min absent) {\n    (3) app __x3__ = (MinFromTime t)\n    let m = __x3__\n  } else {\n    (4) app __x4__ = (ToNumber min)\n    let m = [? __x4__]\n  }\n  3:if (= sec absent) {\n    (5) app __x5__ = (SecFromTime t)\n    let s = __x5__\n  } else {\n    (6) app __x6__ = (ToNumber sec)\n    let s = [? __x6__]\n  }\n  4:if (= ms absent) {\n    (7) app __x7__ = (msFromTime t)\n    let milli = __x7__\n  } else {\n    (8) app __x8__ = (ToNumber ms)\n    let milli = [? __x8__]\n  }\n  5:(9) app __x9__ = (Day t)\n  5:(10) app __x10__ = (MakeTime h m s milli)\n  5:(11) app __x11__ = (MakeDate __x9__ __x10__)\n  5:let date = __x11__\n  6:(12) app __x12__ = (UTC date)\n  6:(13) app __x13__ = (TimeClip __x12__)\n  6:let u = __x13__\n  7:this[\"DateValue\"] = u\n  8:return u\n}"
  }, {
    "code": ["          1. Let _t_ be LocalTime(? thisTimeValue(*this* value)).", "          1. Set _ms_ to ? ToNumber(_ms_).", "          1. Let _time_ be MakeTime(HourFromTime(_t_), MinFromTime(_t_), SecFromTime(_t_), _ms_).", "          1. Let _u_ be TimeClip(UTC(MakeDate(Day(_t_), _time_))).", "          1. Set the [[DateValue]] internal slot of this Date object to _u_.", "          1. Return _u_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "ms"
      }],
      "ref": "Date[\"prototype\"][\"setMilliseconds\"]"
    },
    "ids": "sec-date.prototype.setmilliseconds",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:(1) app __x1__ = (LocalTime [? __x0__])\n  0:let t = __x1__\n  1:(2) app __x2__ = (ToNumber ms)\n  1:ms = [? __x2__]\n  2:(3) app __x3__ = (HourFromTime t)\n  2:(4) app __x4__ = (MinFromTime t)\n  2:(5) app __x5__ = (SecFromTime t)\n  2:(6) app __x6__ = (MakeTime __x3__ __x4__ __x5__ ms)\n  2:let time = __x6__\n  3:(7) app __x7__ = (Day t)\n  3:(8) app __x8__ = (MakeDate __x7__ time)\n  3:(9) app __x9__ = (UTC __x8__)\n  3:(10) app __x10__ = (TimeClip __x9__)\n  3:let u = __x10__\n  4:this[\"DateValue\"] = u\n  5:return u\n}"
  }, {
    "code": ["          1. Let _t_ be LocalTime(? thisTimeValue(*this* value)).", "          1. Let _m_ be ? ToNumber(_min_).", "          1. If _sec_ is not present, let _s_ be SecFromTime(_t_); otherwise, let _s_ be ? ToNumber(_sec_).", "          1. If _ms_ is not present, let _milli_ be msFromTime(_t_); otherwise, let _milli_ be ? ToNumber(_ms_).", "          1. Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), _m_, _s_, _milli_)).", "          1. Let _u_ be TimeClip(UTC(_date_)).", "          1. Set the [[DateValue]] internal slot of this Date object to _u_.", "          1. Return _u_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "min"
      }, {
        "kind": "Optional",
        "name": "sec"
      }, {
        "kind": "Optional",
        "name": "ms"
      }],
      "ref": "Date[\"prototype\"][\"setMinutes\"]"
    },
    "ids": "sec-date.prototype.setminutes",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:(1) app __x1__ = (LocalTime [? __x0__])\n  0:let t = __x1__\n  1:(2) app __x2__ = (ToNumber min)\n  1:let m = [? __x2__]\n  2:if (= sec absent) {\n    (3) app __x3__ = (SecFromTime t)\n    let s = __x3__\n  } else {\n    (4) app __x4__ = (ToNumber sec)\n    let s = [? __x4__]\n  }\n  3:if (= ms absent) {\n    (5) app __x5__ = (msFromTime t)\n    let milli = __x5__\n  } else {\n    (6) app __x6__ = (ToNumber ms)\n    let milli = [? __x6__]\n  }\n  4:(7) app __x7__ = (Day t)\n  4:(8) app __x8__ = (HourFromTime t)\n  4:(9) app __x9__ = (MakeTime __x8__ m s milli)\n  4:(10) app __x10__ = (MakeDate __x7__ __x9__)\n  4:let date = __x10__\n  5:(11) app __x11__ = (UTC date)\n  5:(12) app __x12__ = (TimeClip __x11__)\n  5:let u = __x12__\n  6:this[\"DateValue\"] = u\n  7:return u\n}"
  }, {
    "code": ["          1. Let _t_ be LocalTime(? thisTimeValue(*this* value)).", "          1. Let _m_ be ? ToNumber(_month_).", "          1. If _date_ is not present, let _dt_ be DateFromTime(_t_); otherwise, let _dt_ be ? ToNumber(_date_).", "          1. Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), _m_, _dt_), TimeWithinDay(_t_)).", "          1. Let _u_ be TimeClip(UTC(_newDate_)).", "          1. Set the [[DateValue]] internal slot of this Date object to _u_.", "          1. Return _u_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "month"
      }, {
        "kind": "Optional",
        "name": "date"
      }],
      "ref": "Date[\"prototype\"][\"setMonth\"]"
    },
    "ids": "sec-date.prototype.setmonth",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:(1) app __x1__ = (LocalTime [? __x0__])\n  0:let t = __x1__\n  1:(2) app __x2__ = (ToNumber month)\n  1:let m = [? __x2__]\n  2:if (= date absent) {\n    (3) app __x3__ = (DateFromTime t)\n    let dt = __x3__\n  } else {\n    (4) app __x4__ = (ToNumber date)\n    let dt = [? __x4__]\n  }\n  3:(5) app __x5__ = (YearFromTime t)\n  3:(6) app __x6__ = (MakeDay __x5__ m dt)\n  3:(7) app __x7__ = (TimeWithinDay t)\n  3:(8) app __x8__ = (MakeDate __x6__ __x7__)\n  3:let newDate = __x8__\n  4:(9) app __x9__ = (UTC newDate)\n  4:(10) app __x10__ = (TimeClip __x9__)\n  4:let u = __x10__\n  5:this[\"DateValue\"] = u\n  6:return u\n}"
  }, {
    "code": ["          1. Let _t_ be LocalTime(? thisTimeValue(*this* value)).", "          1. Let _s_ be ? ToNumber(_sec_).", "          1. If _ms_ is not present, let _milli_ be msFromTime(_t_); otherwise, let _milli_ be ? ToNumber(_ms_).", "          1. Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), MinFromTime(_t_), _s_, _milli_)).", "          1. Let _u_ be TimeClip(UTC(_date_)).", "          1. Set the [[DateValue]] internal slot of this Date object to _u_.", "          1. Return _u_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "sec"
      }, {
        "kind": "Optional",
        "name": "ms"
      }],
      "ref": "Date[\"prototype\"][\"setSeconds\"]"
    },
    "ids": "sec-date.prototype.setseconds",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:(1) app __x1__ = (LocalTime [? __x0__])\n  0:let t = __x1__\n  1:(2) app __x2__ = (ToNumber sec)\n  1:let s = [? __x2__]\n  2:if (= ms absent) {\n    (3) app __x3__ = (msFromTime t)\n    let milli = __x3__\n  } else {\n    (4) app __x4__ = (ToNumber ms)\n    let milli = [? __x4__]\n  }\n  3:(5) app __x5__ = (Day t)\n  3:(6) app __x6__ = (HourFromTime t)\n  3:(7) app __x7__ = (MinFromTime t)\n  3:(8) app __x8__ = (MakeTime __x6__ __x7__ s milli)\n  3:(9) app __x9__ = (MakeDate __x5__ __x8__)\n  3:let date = __x9__\n  4:(10) app __x10__ = (UTC date)\n  4:(11) app __x11__ = (TimeClip __x10__)\n  4:let u = __x11__\n  5:this[\"DateValue\"] = u\n  6:return u\n}"
  }, {
    "code": ["          1. Perform ? thisTimeValue(*this* value).", "          1. Let _t_ be ? ToNumber(_time_).", "          1. Let _v_ be TimeClip(_t_).", "          1. Set the [[DateValue]] internal slot of this Date object to _v_.", "          1. Return _v_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "time"
      }],
      "ref": "Date[\"prototype\"][\"setTime\"]"
    },
    "ids": "sec-date.prototype.settime",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:[? __x0__]\n  1:(1) app __x1__ = (ToNumber time)\n  1:let t = [? __x1__]\n  2:(2) app __x2__ = (TimeClip t)\n  2:let v = __x2__\n  3:this[\"DateValue\"] = v\n  4:return v\n}"
  }, {
    "code": ["          1. Let _t_ be ? thisTimeValue(*this* value).", "          1. Let _dt_ be ? ToNumber(_date_).", "          1. Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), MonthFromTime(_t_), _dt_), TimeWithinDay(_t_)).", "          1. Let _v_ be TimeClip(_newDate_).", "          1. Set the [[DateValue]] internal slot of this Date object to _v_.", "          1. Return _v_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "date"
      }],
      "ref": "Date[\"prototype\"][\"setUTCDate\"]"
    },
    "ids": "sec-date.prototype.setutcdate",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:let t = [? __x0__]\n  1:(1) app __x1__ = (ToNumber date)\n  1:let dt = [? __x1__]\n  2:(2) app __x2__ = (YearFromTime t)\n  2:(3) app __x3__ = (MonthFromTime t)\n  2:(4) app __x4__ = (MakeDay __x2__ __x3__ dt)\n  2:(5) app __x5__ = (TimeWithinDay t)\n  2:(6) app __x6__ = (MakeDate __x4__ __x5__)\n  2:let newDate = __x6__\n  3:(7) app __x7__ = (TimeClip newDate)\n  3:let v = __x7__\n  4:this[\"DateValue\"] = v\n  5:return v\n}"
  }, {
    "code": ["          1. Let _t_ be ? thisTimeValue(*this* value).", "          1. If _t_ is *NaN*, set _t_ to *+0*<sub>𝔽</sub>.", "          1. Let _y_ be ? ToNumber(_year_).", "          1. If _month_ is not present, let _m_ be MonthFromTime(_t_); otherwise, let _m_ be ? ToNumber(_month_).", "          1. If _date_ is not present, let _dt_ be DateFromTime(_t_); otherwise, let _dt_ be ? ToNumber(_date_).", "          1. Let _newDate_ be MakeDate(MakeDay(_y_, _m_, _dt_), TimeWithinDay(_t_)).", "          1. Let _v_ be TimeClip(_newDate_).", "          1. Set the [[DateValue]] internal slot of this Date object to _v_.", "          1. Return _v_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "year"
      }, {
        "kind": "Optional",
        "name": "month"
      }, {
        "kind": "Optional",
        "name": "date"
      }],
      "ref": "Date[\"prototype\"][\"setUTCFullYear\"]"
    },
    "ids": "sec-date.prototype.setutcfullyear",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:let t = [? __x0__]\n  1:if (= t NaN) t = 0i else 13:{}\n  2:(1) app __x1__ = (ToNumber year)\n  2:let y = [? __x1__]\n  3:if (= month absent) {\n    (2) app __x2__ = (MonthFromTime t)\n    let m = __x2__\n  } else {\n    (3) app __x3__ = (ToNumber month)\n    let m = [? __x3__]\n  }\n  4:if (= date absent) {\n    (4) app __x4__ = (DateFromTime t)\n    let dt = __x4__\n  } else {\n    (5) app __x5__ = (ToNumber date)\n    let dt = [? __x5__]\n  }\n  5:(6) app __x6__ = (MakeDay y m dt)\n  5:(7) app __x7__ = (TimeWithinDay t)\n  5:(8) app __x8__ = (MakeDate __x6__ __x7__)\n  5:let newDate = __x8__\n  6:(9) app __x9__ = (TimeClip newDate)\n  6:let v = __x9__\n  7:this[\"DateValue\"] = v\n  8:return v\n}"
  }, {
    "code": ["          1. Let _t_ be ? thisTimeValue(*this* value).", "          1. Let _h_ be ? ToNumber(_hour_).", "          1. If _min_ is not present, let _m_ be MinFromTime(_t_); otherwise, let _m_ be ? ToNumber(_min_).", "          1. If _sec_ is not present, let _s_ be SecFromTime(_t_); otherwise, let _s_ be ? ToNumber(_sec_).", "          1. If _ms_ is not present, let _milli_ be msFromTime(_t_); otherwise, let _milli_ be ? ToNumber(_ms_).", "          1. Let _newDate_ be MakeDate(Day(_t_), MakeTime(_h_, _m_, _s_, _milli_)).", "          1. Let _v_ be TimeClip(_newDate_).", "          1. Set the [[DateValue]] internal slot of this Date object to _v_.", "          1. Return _v_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "hour"
      }, {
        "kind": "Optional",
        "name": "min"
      }, {
        "kind": "Optional",
        "name": "sec"
      }, {
        "kind": "Optional",
        "name": "ms"
      }],
      "ref": "Date[\"prototype\"][\"setUTCHours\"]"
    },
    "ids": "sec-date.prototype.setutchours",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:let t = [? __x0__]\n  1:(1) app __x1__ = (ToNumber hour)\n  1:let h = [? __x1__]\n  2:if (= min absent) {\n    (2) app __x2__ = (MinFromTime t)\n    let m = __x2__\n  } else {\n    (3) app __x3__ = (ToNumber min)\n    let m = [? __x3__]\n  }\n  3:if (= sec absent) {\n    (4) app __x4__ = (SecFromTime t)\n    let s = __x4__\n  } else {\n    (5) app __x5__ = (ToNumber sec)\n    let s = [? __x5__]\n  }\n  4:if (= ms absent) {\n    (6) app __x6__ = (msFromTime t)\n    let milli = __x6__\n  } else {\n    (7) app __x7__ = (ToNumber ms)\n    let milli = [? __x7__]\n  }\n  5:(8) app __x8__ = (Day t)\n  5:(9) app __x9__ = (MakeTime h m s milli)\n  5:(10) app __x10__ = (MakeDate __x8__ __x9__)\n  5:let newDate = __x10__\n  6:(11) app __x11__ = (TimeClip newDate)\n  6:let v = __x11__\n  7:this[\"DateValue\"] = v\n  8:return v\n}"
  }, {
    "code": ["          1. Let _t_ be ? thisTimeValue(*this* value).", "          1. Let _milli_ be ? ToNumber(_ms_).", "          1. Let _time_ be MakeTime(HourFromTime(_t_), MinFromTime(_t_), SecFromTime(_t_), _milli_).", "          1. Let _v_ be TimeClip(MakeDate(Day(_t_), _time_)).", "          1. Set the [[DateValue]] internal slot of this Date object to _v_.", "          1. Return _v_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "ms"
      }],
      "ref": "Date[\"prototype\"][\"setUTCMilliseconds\"]"
    },
    "ids": "sec-date.prototype.setutcmilliseconds",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:let t = [? __x0__]\n  1:(1) app __x1__ = (ToNumber ms)\n  1:let milli = [? __x1__]\n  2:(2) app __x2__ = (HourFromTime t)\n  2:(3) app __x3__ = (MinFromTime t)\n  2:(4) app __x4__ = (SecFromTime t)\n  2:(5) app __x5__ = (MakeTime __x2__ __x3__ __x4__ milli)\n  2:let time = __x5__\n  3:(6) app __x6__ = (Day t)\n  3:(7) app __x7__ = (MakeDate __x6__ time)\n  3:(8) app __x8__ = (TimeClip __x7__)\n  3:let v = __x8__\n  4:this[\"DateValue\"] = v\n  5:return v\n}"
  }, {
    "code": ["          1. Let _t_ be ? thisTimeValue(*this* value).", "          1. Let _m_ be ? ToNumber(_min_).", "          1. If _sec_ is not present, let _s_ be SecFromTime(_t_).", "          1. Else,", "            1. Let _s_ be ? ToNumber(_sec_).", "          1. If _ms_ is not present, let _milli_ be msFromTime(_t_).", "          1. Else,", "            1. Let _milli_ be ? ToNumber(_ms_).", "          1. Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), _m_, _s_, _milli_)).", "          1. Let _v_ be TimeClip(_date_).", "          1. Set the [[DateValue]] internal slot of this Date object to _v_.", "          1. Return _v_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "min"
      }, {
        "kind": "Optional",
        "name": "sec"
      }, {
        "kind": "Optional",
        "name": "ms"
      }],
      "ref": "Date[\"prototype\"][\"setUTCMinutes\"]"
    },
    "ids": "sec-date.prototype.setutcminutes",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:let t = [? __x0__]\n  1:(1) app __x1__ = (ToNumber min)\n  1:let m = [? __x1__]\n  3:if (= sec absent) {\n    (2) app __x2__ = (SecFromTime t)\n    let s = __x2__\n  } else {\n    4:(3) app __x3__ = (ToNumber sec)\n    4:let s = [? __x3__]\n  }\n  6:if (= ms absent) {\n    (4) app __x4__ = (msFromTime t)\n    let milli = __x4__\n  } else {\n    7:(5) app __x5__ = (ToNumber ms)\n    7:let milli = [? __x5__]\n  }\n  8:(6) app __x6__ = (Day t)\n  8:(7) app __x7__ = (HourFromTime t)\n  8:(8) app __x8__ = (MakeTime __x7__ m s milli)\n  8:(9) app __x9__ = (MakeDate __x6__ __x8__)\n  8:let date = __x9__\n  9:(10) app __x10__ = (TimeClip date)\n  9:let v = __x10__\n  10:this[\"DateValue\"] = v\n  11:return v\n}"
  }, {
    "code": ["          1. Let _t_ be ? thisTimeValue(*this* value).", "          1. Let _m_ be ? ToNumber(_month_).", "          1. If _date_ is not present, let _dt_ be DateFromTime(_t_).", "          1. Else,", "            1. Let _dt_ be ? ToNumber(_date_).", "          1. Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), _m_, _dt_), TimeWithinDay(_t_)).", "          1. Let _v_ be TimeClip(_newDate_).", "          1. Set the [[DateValue]] internal slot of this Date object to _v_.", "          1. Return _v_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "month"
      }, {
        "kind": "Optional",
        "name": "date"
      }],
      "ref": "Date[\"prototype\"][\"setUTCMonth\"]"
    },
    "ids": "sec-date.prototype.setutcmonth",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:let t = [? __x0__]\n  1:(1) app __x1__ = (ToNumber month)\n  1:let m = [? __x1__]\n  3:if (= date absent) {\n    (2) app __x2__ = (DateFromTime t)\n    let dt = __x2__\n  } else {\n    4:(3) app __x3__ = (ToNumber date)\n    4:let dt = [? __x3__]\n  }\n  5:(4) app __x4__ = (YearFromTime t)\n  5:(5) app __x5__ = (MakeDay __x4__ m dt)\n  5:(6) app __x6__ = (TimeWithinDay t)\n  5:(7) app __x7__ = (MakeDate __x5__ __x6__)\n  5:let newDate = __x7__\n  6:(8) app __x8__ = (TimeClip newDate)\n  6:let v = __x8__\n  7:this[\"DateValue\"] = v\n  8:return v\n}"
  }, {
    "code": ["          1. Let _t_ be ? thisTimeValue(*this* value).", "          1. Let _s_ be ? ToNumber(_sec_).", "          1. If _ms_ is not present, let _milli_ be msFromTime(_t_).", "          1. Else,", "            1. Let _milli_ be ? ToNumber(_ms_).", "          1. Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), MinFromTime(_t_), _s_, _milli_)).", "          1. Let _v_ be TimeClip(_date_).", "          1. Set the [[DateValue]] internal slot of this Date object to _v_.", "          1. Return _v_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "sec"
      }, {
        "kind": "Optional",
        "name": "ms"
      }],
      "ref": "Date[\"prototype\"][\"setUTCSeconds\"]"
    },
    "ids": "sec-date.prototype.setutcseconds",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:let t = [? __x0__]\n  1:(1) app __x1__ = (ToNumber sec)\n  1:let s = [? __x1__]\n  3:if (= ms absent) {\n    (2) app __x2__ = (msFromTime t)\n    let milli = __x2__\n  } else {\n    4:(3) app __x3__ = (ToNumber ms)\n    4:let milli = [? __x3__]\n  }\n  5:(4) app __x4__ = (Day t)\n  5:(5) app __x5__ = (HourFromTime t)\n  5:(6) app __x6__ = (MinFromTime t)\n  5:(7) app __x7__ = (MakeTime __x5__ __x6__ s milli)\n  5:(8) app __x8__ = (MakeDate __x4__ __x7__)\n  5:let date = __x8__\n  6:(9) app __x9__ = (TimeClip date)\n  6:let v = __x9__\n  7:this[\"DateValue\"] = v\n  8:return v\n}"
  }, {
    "code": ["          1. Let _O_ be this Date object.", "          1. Let _tv_ be ? thisTimeValue(_O_).", "          1. If _tv_ is *NaN*, return *\"Invalid Date\"*.", "          1. Let _t_ be LocalTime(_tv_).", "          1. Return DateString(_t_)."],
    "head": {
      "origParams": [],
      "ref": "Date[\"prototype\"][\"toDateString\"]"
    },
    "ids": "sec-date.prototype.todatestring",
    "rawBody": "{\n  0:let O = this\n  1:(0) app __x0__ = (thisTimeValue O)\n  1:let tv = [? __x0__]\n  2:if (= tv NaN) return \"Invalid Date\" else 13:{}\n  3:(1) app __x1__ = (LocalTime tv)\n  3:let t = __x1__\n  4:(2) app __x2__ = (DateString t)\n  4:return __x2__\n}"
  }, {
    "code": ["          1. Let _O_ be ? ToObject(*this* value).", "          1. Let _tv_ be ? ToPrimitive(_O_, ~number~).", "          1. If Type(_tv_) is Number and _tv_ is not finite, return *null*.", "          1. Return ? Invoke(_O_, *\"toISOString\"*)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "key"
      }],
      "ref": "Date[\"prototype\"][\"toJSON\"]"
    },
    "ids": "sec-date.prototype.tojson",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (ToPrimitive O CONST_number)\n  1:let tv = [? __x1__]\n  2:if (&& (= (typeof tv) Number) (|| (= tv Infinity) (= tv -Infinity))) return null else 13:{}\n  3:(2) app __x2__ = (Invoke O \"toISOString\")\n  3:return [? __x2__]\n}"
  }, {
    "code": ["          1. Let _tv_ be ? thisTimeValue(*this* value).", "          1. Return ToDateString(_tv_)."],
    "head": {
      "origParams": [],
      "ref": "Date[\"prototype\"][\"toString\"]"
    },
    "ids": "sec-date.prototype.tostring",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:let tv = [? __x0__]\n  1:(1) app __x1__ = (ToDateString tv)\n  1:return __x1__\n}"
  }, {
    "code": ["            1. Assert: Type(_tv_) is Number.", "            1. Assert: _tv_ is not *NaN*.", "            1. Let _hour_ be the String representation of HourFromTime(_tv_), formatted as a two-digit decimal number, padded to the left with the code unit 0x0030 (DIGIT ZERO) if necessary.", "            1. Let _minute_ be the String representation of MinFromTime(_tv_), formatted as a two-digit decimal number, padded to the left with the code unit 0x0030 (DIGIT ZERO) if necessary.", "            1. Let _second_ be the String representation of SecFromTime(_tv_), formatted as a two-digit decimal number, padded to the left with the code unit 0x0030 (DIGIT ZERO) if necessary.", "            1. Return the string-concatenation of _hour_, *\":\"*, _minute_, *\":\"*, _second_, the code unit 0x0020 (SPACE), and *\"GMT\"*."],
    "head": {
      "name": "TimeString",
      "params": [{
        "kind": "Normal",
        "name": "tv"
      }]
    },
    "ids": "sec-timestring",
    "rawBody": "{\n  0:assert (= (typeof tv) Number)\n  1:assert (! (= tv NaN))\n  2:(0) ??? \"Let id:{hour} be the String representation of HourFromTime ( id:{tv} ) , formatted as a two - digit decimal number , padded to the left with the code unit 0x0030 ( DIGIT ZERO ) if necessary .\"\n  3:(1) ??? \"Let id:{minute} be the String representation of MinFromTime ( id:{tv} ) , formatted as a two - digit decimal number , padded to the left with the code unit 0x0030 ( DIGIT ZERO ) if necessary .\"\n  4:(2) ??? \"Let id:{second} be the String representation of SecFromTime ( id:{tv} ) , formatted as a two - digit decimal number , padded to the left with the code unit 0x0030 ( DIGIT ZERO ) if necessary .\"\n  5:return (+ (+ (+ (+ (+ (+ hour \":\") minute) \":\") second) \" \") \"GMT\")\n}"
  }, {
    "code": ["            1. Assert: Type(_tv_) is Number.", "            1. Assert: _tv_ is not *NaN*.", "            1. Let _weekday_ be the Name of the entry in <emu-xref href=\"#sec-todatestring-day-names\"></emu-xref> with the Number WeekDay(_tv_).", "            1. Let _month_ be the Name of the entry in <emu-xref href=\"#sec-todatestring-month-names\"></emu-xref> with the Number MonthFromTime(_tv_).", "            1. Let _day_ be the String representation of DateFromTime(_tv_), formatted as a two-digit decimal number, padded to the left with the code unit 0x0030 (DIGIT ZERO) if necessary.", "            1. Let _yv_ be YearFromTime(_tv_).", "            1. If _yv_ ≥ *+0*<sub>𝔽</sub>, let _yearSign_ be the empty String; otherwise, let _yearSign_ be *\"-\"*.", "            1. Let _year_ be the String representation of abs(ℝ(_yv_)), formatted as a decimal number.", "            1. Let _paddedYear_ be ! StringPad(_year_, *4*<sub>𝔽</sub>, *\"0\"*, ~start~).", "            1. Return the string-concatenation of _weekday_, the code unit 0x0020 (SPACE), _month_, the code unit 0x0020 (SPACE), _day_, the code unit 0x0020 (SPACE), _yearSign_, and _paddedYear_."],
    "head": {
      "name": "DateString",
      "params": [{
        "kind": "Normal",
        "name": "tv"
      }]
    },
    "ids": "sec-datestring",
    "rawBody": "{\n  0:assert (= (typeof tv) Number)\n  1:assert (! (= tv NaN))\n  2:(0) ??? \"Let id:{weekday} be the Name of the entry in link:{sec-todatestring-day-names} with the Number WeekDay ( id:{tv} ) .\"\n  3:(1) ??? \"Let id:{month} be the Name of the entry in link:{sec-todatestring-month-names} with the Number MonthFromTime ( id:{tv} ) .\"\n  4:(2) ??? \"Let id:{day} be the String representation of DateFromTime ( id:{tv} ) , formatted as a two - digit decimal number , padded to the left with the code unit 0x0030 ( DIGIT ZERO ) if necessary .\"\n  5:(0) app __x0__ = (YearFromTime tv)\n  5:let yv = __x0__\n  6:if (! (< yv 0i)) let yearSign = \"\" else let yearSign = \"-\"\n  7:(3) ??? \"Let id:{year} be the String representation of abs ( ℝ ( id:{yv} ) ) , formatted as a decimal number .\"\n  8:(1) app __x1__ = (StringPad year 4i \"0\" CONST_start)\n  8:let paddedYear = [! __x1__]\n  9:return (+ (+ (+ (+ (+ (+ (+ weekday \" \") month) \" \") day) \" \") yearSign) paddedYear)\n}"
  }, {
    "code": ["            1. Assert: Type(_tv_) is Number.", "            1. Assert: _tv_ is not *NaN*.", "            1. Let _offset_ be LocalTZA(_tv_, *true*).", "            1. If _offset_ ≥ *+0*<sub>𝔽</sub>, then", "              1. Let _offsetSign_ be *\"+\"*.", "              1. Let _absOffset_ be _offset_.", "            1. Else,", "              1. Let _offsetSign_ be *\"-\"*.", "              1. Let _absOffset_ be -_offset_.", "            1. Let _offsetMin_ be the String representation of MinFromTime(_absOffset_), formatted as a two-digit decimal number, padded to the left with the code unit 0x0030 (DIGIT ZERO) if necessary.", "            1. Let _offsetHour_ be the String representation of HourFromTime(_absOffset_), formatted as a two-digit decimal number, padded to the left with the code unit 0x0030 (DIGIT ZERO) if necessary.", "            1. Let _tzName_ be an implementation-defined string that is either the empty String or the string-concatenation of the code unit 0x0020 (SPACE), the code unit 0x0028 (LEFT PARENTHESIS), an implementation-defined timezone name, and the code unit 0x0029 (RIGHT PARENTHESIS).", "            1. Return the string-concatenation of _offsetSign_, _offsetHour_, _offsetMin_, and _tzName_."],
    "head": {
      "name": "TimeZoneString",
      "params": [{
        "kind": "Normal",
        "name": "tv"
      }]
    },
    "ids": "sec-timezoneestring",
    "rawBody": "{\n  0:assert (= (typeof tv) Number)\n  1:assert (! (= tv NaN))\n  2:(0) app __x0__ = (LocalTZA tv true)\n  2:let offset = __x0__\n  6:if (! (< offset 0i)) {\n    4:let offsetSign = \"+\"\n    5:let absOffset = offset\n  } else {\n    7:let offsetSign = \"-\"\n    8:let absOffset = (- offset)\n  }\n  9:(0) ??? \"Let id:{offsetMin} be the String representation of MinFromTime ( id:{absOffset} ) , formatted as a two - digit decimal number , padded to the left with the code unit 0x0030 ( DIGIT ZERO ) if necessary .\"\n  10:(1) ??? \"Let id:{offsetHour} be the String representation of HourFromTime ( id:{absOffset} ) , formatted as a two - digit decimal number , padded to the left with the code unit 0x0030 ( DIGIT ZERO ) if necessary .\"\n  11:(2) ??? \"Let id:{tzName} be an implementation - defined string that is either the empty String or the string - concatenation of the code unit 0x0020 ( SPACE ) , the code unit 0x0028 ( LEFT PARENTHESIS ) , an implementation - defined timezone name , and the code unit 0x0029 ( RIGHT PARENTHESIS ) .\"\n  12:return (+ (+ (+ offsetSign offsetHour) offsetMin) tzName)\n}"
  }, {
    "code": ["            1. Assert: Type(_tv_) is Number.", "            1. If _tv_ is *NaN*, return *\"Invalid Date\"*.", "            1. Let _t_ be LocalTime(_tv_).", "            1. Return the string-concatenation of DateString(_t_), the code unit 0x0020 (SPACE), TimeString(_t_), and TimeZoneString(_tv_)."],
    "head": {
      "name": "ToDateString",
      "params": [{
        "kind": "Normal",
        "name": "tv"
      }]
    },
    "ids": "sec-todatestring",
    "rawBody": "{\n  0:assert (= (typeof tv) Number)\n  1:if (= tv NaN) return \"Invalid Date\" else 13:{}\n  2:(0) app __x0__ = (LocalTime tv)\n  2:let t = __x0__\n  3:(1) app __x1__ = (DateString t)\n  3:(2) app __x2__ = (TimeString t)\n  3:(3) app __x3__ = (TimeZoneString tv)\n  3:return (+ (+ (+ __x1__ \" \") __x2__) __x3__)\n}"
  }, {
    "code": ["          1. Let _O_ be this Date object.", "          1. Let _tv_ be ? thisTimeValue(_O_).", "          1. If _tv_ is *NaN*, return *\"Invalid Date\"*.", "          1. Let _t_ be LocalTime(_tv_).", "          1. Return the string-concatenation of TimeString(_t_) and TimeZoneString(_tv_)."],
    "head": {
      "origParams": [],
      "ref": "Date[\"prototype\"][\"toTimeString\"]"
    },
    "ids": "sec-date.prototype.totimestring",
    "rawBody": "{\n  0:let O = this\n  1:(0) app __x0__ = (thisTimeValue O)\n  1:let tv = [? __x0__]\n  2:if (= tv NaN) return \"Invalid Date\" else 13:{}\n  3:(1) app __x1__ = (LocalTime tv)\n  3:let t = __x1__\n  4:(2) app __x2__ = (TimeString t)\n  4:(3) app __x3__ = (TimeZoneString tv)\n  4:return (+ __x2__ __x3__)\n}"
  }, {
    "code": ["          1. Let _O_ be this Date object.", "          1. Let _tv_ be ? thisTimeValue(_O_).", "          1. If _tv_ is *NaN*, return *\"Invalid Date\"*.", "          1. Let _weekday_ be the Name of the entry in <emu-xref href=\"#sec-todatestring-day-names\"></emu-xref> with the Number WeekDay(_tv_).", "          1. Let _month_ be the Name of the entry in <emu-xref href=\"#sec-todatestring-month-names\"></emu-xref> with the Number MonthFromTime(_tv_).", "          1. Let _day_ be the String representation of DateFromTime(_tv_), formatted as a two-digit decimal number, padded to the left with the code unit 0x0030 (DIGIT ZERO) if necessary.", "          1. Let _yv_ be YearFromTime(_tv_).", "          1. If _yv_ ≥ *+0*<sub>𝔽</sub>, let _yearSign_ be the empty String; otherwise, let _yearSign_ be *\"-\"*.", "          1. Let _year_ be the String representation of abs(ℝ(_yv_)), formatted as a decimal number.", "          1. Let _paddedYear_ be ! StringPad(_year_, *4*<sub>𝔽</sub>, *\"0\"*, ~start~).", "          1. Return the string-concatenation of _weekday_, *\",\"*, the code unit 0x0020 (SPACE), _day_, the code unit 0x0020 (SPACE), _month_, the code unit 0x0020 (SPACE), _yearSign_, _paddedYear_, the code unit 0x0020 (SPACE), and TimeString(_tv_)."],
    "head": {
      "origParams": [],
      "ref": "Date[\"prototype\"][\"toUTCString\"]"
    },
    "ids": "sec-date.prototype.toutcstring",
    "rawBody": "{\n  0:let O = this\n  1:(0) app __x0__ = (thisTimeValue O)\n  1:let tv = [? __x0__]\n  2:if (= tv NaN) return \"Invalid Date\" else 13:{}\n  3:(0) ??? \"Let id:{weekday} be the Name of the entry in link:{sec-todatestring-day-names} with the Number WeekDay ( id:{tv} ) .\"\n  4:(1) ??? \"Let id:{month} be the Name of the entry in link:{sec-todatestring-month-names} with the Number MonthFromTime ( id:{tv} ) .\"\n  5:(2) ??? \"Let id:{day} be the String representation of DateFromTime ( id:{tv} ) , formatted as a two - digit decimal number , padded to the left with the code unit 0x0030 ( DIGIT ZERO ) if necessary .\"\n  6:(1) app __x1__ = (YearFromTime tv)\n  6:let yv = __x1__\n  7:if (! (< yv 0i)) let yearSign = \"\" else let yearSign = \"-\"\n  8:(3) ??? \"Let id:{year} be the String representation of abs ( ℝ ( id:{yv} ) ) , formatted as a decimal number .\"\n  9:(2) app __x2__ = (StringPad year 4i \"0\" CONST_start)\n  9:let paddedYear = [! __x2__]\n  10:(3) app __x3__ = (TimeString tv)\n  10:return (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ weekday \",\") \" \") day) \" \") month) \" \") yearSign) paddedYear) \" \") __x3__)\n}"
  }, {
    "code": ["          1. Return ? thisTimeValue(*this* value)."],
    "head": {
      "origParams": [],
      "ref": "Date[\"prototype\"][\"valueOf\"]"
    },
    "ids": "sec-date.prototype.valueof",
    "rawBody": "{\n  0:(0) app __x0__ = (thisTimeValue this)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Let _O_ be the *this* value.", "          1. If Type(_O_) is not Object, throw a *TypeError* exception.", "          1. If _hint_ is *\"string\"* or *\"default\"*, then", "            1. Let _tryFirst_ be ~string~.", "          1. Else if _hint_ is *\"number\"*, then", "            1. Let _tryFirst_ be ~number~.", "          1. Else, throw a *TypeError* exception.", "          1. Return ? OrdinaryToPrimitive(_O_, _tryFirst_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "hint"
      }],
      "ref": "Date[\"prototype\"][SYMBOL_toPrimitive]"
    },
    "ids": "sec-date.prototype-@@toprimitive",
    "rawBody": "{\n  0:let O = this\n  1:if (! (= (typeof O) Object)) (0) throw TypeError else 13:{}\n  6:if (|| (= hint \"string\") (= hint \"default\")) let tryFirst = CONST_string else if (= hint \"number\") let tryFirst = CONST_number else (1) throw TypeError\n  7:(0) app __x0__ = (OrdinaryToPrimitive O tryFirst)\n  7:return [? __x0__]\n}"
  }, {
    "code": ["          1. If _value_ is not present, let _s_ be the empty String.", "          1. Else,", "            1. If NewTarget is *undefined* and Type(_value_) is Symbol, return SymbolDescriptiveString(_value_).", "            1. Let _s_ be ? ToString(_value_).", "          1. If NewTarget is *undefined*, return _s_.", "          1. Return ! StringCreate(_s_, ? GetPrototypeFromConstructor(NewTarget, *\"%String.prototype%\"*))."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "value"
      }],
      "ref": "String"
    },
    "ids": "sec-string-constructor-string-value",
    "rawBody": "{\n  1:if (= value absent) let s = \"\" else {\n    2:if (&& (= NewTarget undefined) (= (typeof value) Symbol)) {\n      (0) app __x0__ = (SymbolDescriptiveString value)\n      return __x0__\n    } else 13:{}\n    3:(1) app __x1__ = (ToString value)\n    3:let s = [? __x1__]\n  }\n  4:if (= NewTarget undefined) return s else 13:{}\n  5:(2) app __x2__ = (GetPrototypeFromConstructor NewTarget \"%String.prototype%\")\n  5:(3) app __x3__ = (StringCreate s [? __x2__])\n  5:return [! __x3__]\n}"
  }, {
    "code": ["          1. Let _length_ be the number of elements in _codeUnits_.", "          1. Let _elements_ be a new empty List.", "          1. For each element _next_ of _codeUnits_, do", "            1. Let _nextCU_ be ℝ(? ToUint16(_next_)).", "            1. Append _nextCU_ to the end of _elements_.", "          1. Return the String value whose code units are the elements in the List _elements_. If _codeUnits_ is empty, the empty String is returned."],
    "head": {
      "origParams": [{
        "kind": "Variadic",
        "name": "codeUnits"
      }],
      "ref": "String[\"fromCharCode\"]"
    },
    "ids": "sec-string.fromcharcode",
    "rawBody": "{\n  0:let length = codeUnits[\"length\"]\n  1:let elements = (0) (new [])\n  2:let __x0__ = codeUnits\n  2:let __x1__ = 0i\n  2:while (< __x1__ __x0__[\"length\"]) {\n    let next = __x0__[__x1__]\n    3:(0) app __x2__ = (ToUint16 next)\n    3:let nextCU = [? __x2__]\n    4:append nextCU -> elements\n    __x1__ = (+ __x1__ 1i)\n  }\n  5:(1) ??? \"Return the String value whose code units are the elements in the List id:{elements} . If id:{codeUnits} is empty , the empty String is returned .\"\n}"
  }, {
    "code": ["          1. Let _result_ be the empty String.", "          1. For each element _next_ of _codePoints_, do", "            1. Let _nextCP_ be ? ToNumber(_next_).", "            1. If ! IsIntegralNumber(_nextCP_) is *false*, throw a *RangeError* exception.", "            1. If ℝ(_nextCP_) < 0 or ℝ(_nextCP_) > 0x10FFFF, throw a *RangeError* exception.", "            1. Set _result_ to the string-concatenation of _result_ and ! UTF16EncodeCodePoint(ℝ(_nextCP_)).", "          1. Assert: If _codePoints_ is empty, then _result_ is the empty String.", "          1. Return _result_."],
    "head": {
      "origParams": [{
        "kind": "Variadic",
        "name": "codePoints"
      }],
      "ref": "String[\"fromCodePoint\"]"
    },
    "ids": "sec-string.fromcodepoint",
    "rawBody": "{\n  0:let result = \"\"\n  1:let __x0__ = codePoints\n  1:let __x1__ = 0i\n  1:while (< __x1__ __x0__[\"length\"]) {\n    let next = __x0__[__x1__]\n    2:(0) app __x2__ = (ToNumber next)\n    2:let nextCP = [? __x2__]\n    3:(1) app __x3__ = (IsIntegralNumber nextCP)\n    3:if (= [! __x3__] false) (0) throw RangeError else 6:{}\n    4:if (|| (< nextCP 0i) (< 1114111i nextCP)) (1) throw RangeError else 6:{}\n    5:(2) app __x4__ = (UTF16EncodeCodePoint nextCP)\n    5:result = (+ result [! __x4__])\n    __x1__ = (+ __x1__ 1i)\n  }\n  7:return result\n}"
  }, {
    "code": ["          1. Let _numberOfSubstitutions_ be the number of elements in _substitutions_.", "          1. Let _cooked_ be ? ToObject(_template_).", "          1. Let _raw_ be ? ToObject(? Get(_cooked_, *\"raw\"*)).", "          1. Let _literalSegments_ be ? LengthOfArrayLike(_raw_).", "          1. If _literalSegments_ ≤ 0, return the empty String.", "          1. Let _stringElements_ be a new empty List.", "          1. Let _nextIndex_ be 0.", "          1. Repeat,", "            1. Let _nextKey_ be ! ToString(𝔽(_nextIndex_)).", "            1. Let _nextSeg_ be ? ToString(? Get(_raw_, _nextKey_)).", "            1. Append the code unit elements of _nextSeg_ to the end of _stringElements_.", "            1. If _nextIndex_ + 1 = _literalSegments_, then", "              1. Return the String value whose code units are the elements in the List _stringElements_. If _stringElements_ has no elements, the empty String is returned.", "            1. If _nextIndex_ < _numberOfSubstitutions_, let _next_ be _substitutions_[_nextIndex_].", "            1. Else, let _next_ be the empty String.", "            1. Let _nextSub_ be ? ToString(_next_).", "            1. Append the code unit elements of _nextSub_ to the end of _stringElements_.", "            1. Set _nextIndex_ to _nextIndex_ + 1."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "template"
      }, {
        "kind": "Variadic",
        "name": "substitutions"
      }],
      "ref": "String[\"raw\"]"
    },
    "ids": "sec-string.raw",
    "rawBody": "{\n  0:let numberOfSubstitutions = substitutions[\"length\"]\n  1:(0) app __x0__ = (ToObject template)\n  1:let cooked = [? __x0__]\n  2:(1) app __x1__ = (Get cooked \"raw\")\n  2:(2) app __x2__ = (ToObject [? __x1__])\n  2:let raw = [? __x2__]\n  3:(3) app __x3__ = (LengthOfArrayLike raw)\n  3:let literalSegments = [? __x3__]\n  4:if (! (< 0i literalSegments)) return \"\" else 6:{}\n  5:let stringElements = (0) (new [])\n  6:let nextIndex = 0i\n  7:while true {\n    8:(4) app __x4__ = (ToString nextIndex)\n    8:let nextKey = [! __x4__]\n    9:(5) app __x5__ = (Get raw nextKey)\n    9:(6) app __x6__ = (ToString [? __x5__])\n    9:let nextSeg = [? __x6__]\n    10:let __x7__ = nextSeg\n    10:let __x8__ = 0i\n    10:while (< __x8__ __x7__[\"length\"]) {\n      let __x9__ = __x7__[__x8__]\n      append __x9__ -> stringElements\n      __x8__ = (+ __x8__ 1i)\n    }\n    11:if (== (+ nextIndex 1i) literalSegments) (1) ??? \"Return the String value whose code units are the elements in the List id:{stringElements} . If id:{stringElements} has no elements , the empty String is returned .\" else 6:{}\n    14:if (< nextIndex numberOfSubstitutions) let next = substitutions[nextIndex] else let next = \"\"\n    15:(7) app __x10__ = (ToString next)\n    15:let nextSub = [? __x10__]\n    16:let __x11__ = nextSub\n    16:let __x12__ = 0i\n    16:while (< __x12__ __x11__[\"length\"]) {\n      let __x13__ = __x11__[__x12__]\n      append __x13__ -> stringElements\n      __x12__ = (+ __x12__ 1i)\n    }\n    17:nextIndex = (+ nextIndex 1i)\n  }\n}"
  }, {
    "code": ["        1. If Type(_value_) is String, return _value_.", "        1. If Type(_value_) is Object and _value_ has a [[StringData]] internal slot, then", "          1. Let _s_ be _value_.[[StringData]].", "          1. Assert: Type(_s_) is String.", "          1. Return _s_.", "        1. Throw a *TypeError* exception."],
    "head": {
      "name": "thisStringValue",
      "params": [{
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "sec-properties-of-the-string-prototype-object",
    "rawBody": "{\n  0:if (= (typeof value) String) return value else 6:{}\n  1:if (&& (= (typeof value) Object) (! (= value[\"StringData\"] absent))) {\n    2:let s = value[\"StringData\"]\n    3:assert (= (typeof s) String)\n    4:return s\n  } else 6:{}\n  5:(0) throw TypeError\n}"
  }, {
    "code": ["          1. Let _O_ be ? RequireObjectCoercible(*this* value).", "          1. Let _S_ be ? ToString(_O_).", "          1. Let _position_ be ? ToIntegerOrInfinity(_pos_).", "          1. Let _size_ be the length of _S_.", "          1. If _position_ < 0 or _position_ ≥ _size_, return the empty String.", "          1. Return the String value of length 1, containing one code unit from _S_, namely the code unit at index _position_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "pos"
      }],
      "ref": "String[\"prototype\"][\"charAt\"]"
    },
    "ids": "sec-string.prototype.charat",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (ToString O)\n  1:let S = [? __x1__]\n  2:(2) app __x2__ = (ToIntegerOrInfinity pos)\n  2:let position = [? __x2__]\n  3:let size = S[\"length\"]\n  4:if (|| (< position 0i) (! (< position size))) return \"\" else 6:{}\n  5:(0) ??? \"Return the String value of length 1 , containing one code unit from id:{S} , namely the code unit at index id:{position} .\"\n}"
  }, {
    "code": ["          1. Let _O_ be ? RequireObjectCoercible(*this* value).", "          1. Let _S_ be ? ToString(_O_).", "          1. Let _position_ be ? ToIntegerOrInfinity(_pos_).", "          1. Let _size_ be the length of _S_.", "          1. If _position_ < 0 or _position_ ≥ _size_, return *NaN*.", "          1. Return the Number value for the numeric value of the code unit at index _position_ within the String _S_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "pos"
      }],
      "ref": "String[\"prototype\"][\"charCodeAt\"]"
    },
    "ids": "sec-string.prototype.charcodeat",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (ToString O)\n  1:let S = [? __x1__]\n  2:(2) app __x2__ = (ToIntegerOrInfinity pos)\n  2:let position = [? __x2__]\n  3:let size = S[\"length\"]\n  4:if (|| (< position 0i) (! (< position size))) return NaN else 6:{}\n  5:(0) ??? \"Return the Number value for the numeric value of the code unit at index id:{position} within the String id:{S} .\"\n}"
  }, {
    "code": ["          1. Let _O_ be ? RequireObjectCoercible(*this* value).", "          1. Let _S_ be ? ToString(_O_).", "          1. Let _position_ be ? ToIntegerOrInfinity(_pos_).", "          1. Let _size_ be the length of _S_.", "          1. If _position_ < 0 or _position_ ≥ _size_, return *undefined*.", "          1. Let _cp_ be ! CodePointAt(_S_, _position_).", "          1. Return 𝔽(_cp_.[[CodePoint]])."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "pos"
      }],
      "ref": "String[\"prototype\"][\"codePointAt\"]"
    },
    "ids": "sec-string.prototype.codepointat",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (ToString O)\n  1:let S = [? __x1__]\n  2:(2) app __x2__ = (ToIntegerOrInfinity pos)\n  2:let position = [? __x2__]\n  3:let size = S[\"length\"]\n  4:if (|| (< position 0i) (! (< position size))) return undefined else 6:{}\n  5:(3) app __x3__ = (CodePointAt S position)\n  5:let cp = [! __x3__]\n  6:return cp[\"CodePoint\"]\n}"
  }, {
    "code": ["          1. Let _O_ be ? RequireObjectCoercible(*this* value).", "          1. Let _S_ be ? ToString(_O_).", "          1. Let _R_ be _S_.", "          1. For each element _next_ of _args_, do", "            1. Let _nextString_ be ? ToString(_next_).", "            1. Set _R_ to the string-concatenation of _R_ and _nextString_.", "          1. Return _R_."],
    "head": {
      "origParams": [{
        "kind": "Variadic",
        "name": "args"
      }],
      "ref": "String[\"prototype\"][\"concat\"]"
    },
    "ids": "sec-string.prototype.concat",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (ToString O)\n  1:let S = [? __x1__]\n  2:let R = S\n  3:let __x2__ = args\n  3:let __x3__ = 0i\n  3:while (< __x3__ __x2__[\"length\"]) {\n    let next = __x2__[__x3__]\n    4:(2) app __x4__ = (ToString next)\n    4:let nextString = [? __x4__]\n    5:R = (+ R nextString)\n    __x3__ = (+ __x3__ 1i)\n  }\n  6:return R\n}"
  }, {
    "code": ["          1. Let _O_ be ? RequireObjectCoercible(*this* value).", "          1. Let _S_ be ? ToString(_O_).", "          1. Let _isRegExp_ be ? IsRegExp(_searchString_).", "          1. If _isRegExp_ is *true*, throw a *TypeError* exception.", "          1. Let _searchStr_ be ? ToString(_searchString_).", "          1. Let _len_ be the length of _S_.", "          1. If _endPosition_ is *undefined*, let _pos_ be _len_; else let _pos_ be ? ToIntegerOrInfinity(_endPosition_).", "          1. Let _end_ be the result of clamping _pos_ between 0 and _len_.", "          1. Let _searchLength_ be the length of _searchStr_.", "          1. If _searchLength_ = 0, return *true*.", "          1. Let _start_ be _end_ - _searchLength_.", "          1. If _start_ < 0, return *false*.", "          1. Let _substring_ be the substring of _S_ from _start_ to _end_.", "          1. Return ! SameValueNonNumeric(_substring_, _searchStr_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "searchString"
      }, {
        "kind": "Optional",
        "name": "endPosition"
      }],
      "ref": "String[\"prototype\"][\"endsWith\"]"
    },
    "ids": "sec-string.prototype.endswith",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (ToString O)\n  1:let S = [? __x1__]\n  2:(2) app __x2__ = (IsRegExp searchString)\n  2:let isRegExp = [? __x2__]\n  3:if (= isRegExp true) (0) throw TypeError else 6:{}\n  4:(3) app __x3__ = (ToString searchString)\n  4:let searchStr = [? __x3__]\n  5:let len = S[\"length\"]\n  6:if (= endPosition undefined) let pos = len else {\n    (4) app __x4__ = (ToIntegerOrInfinity endPosition)\n    let pos = [? __x4__]\n  }\n  7:(1) ??? \"Let id:{end} be the result of clamping id:{pos} between 0 and id:{len} .\"\n  8:let searchLength = searchStr[\"length\"]\n  9:if (== searchLength 0i) return true else 6:{}\n  10:let start = (- end searchLength)\n  11:if (< start 0i) return false else 6:{}\n  12:let __x5__ = \"\"\n  12:let __x6__ = start\n  12:while (< __x6__ (+ end 1i)) {\n    (5) access __x7__ = (S __x6__)\n    __x5__ = (+ __x5__ __x7__)\n    __x6__ = (+ __x6__ 1i)\n  }\n  12:let substring = __x5__\n  13:(6) app __x8__ = (SameValueNonNumeric substring searchStr)\n  13:return [! __x8__]\n}"
  }, {
    "code": ["          1. Let _O_ be ? RequireObjectCoercible(*this* value).", "          1. Let _S_ be ? ToString(_O_).", "          1. Let _isRegExp_ be ? IsRegExp(_searchString_).", "          1. If _isRegExp_ is *true*, throw a *TypeError* exception.", "          1. Let _searchStr_ be ? ToString(_searchString_).", "          1. Let _pos_ be ? ToIntegerOrInfinity(_position_).", "          1. Assert: If _position_ is *undefined*, then _pos_ is 0.", "          1. Let _len_ be the length of _S_.", "          1. Let _start_ be the result of clamping _pos_ between 0 and _len_.", "          1. Let _index_ be ! StringIndexOf(_S_, _searchStr_, _start_).", "          1. If _index_ is not -1, return *true*.", "          1. Return *false*."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "searchString"
      }, {
        "kind": "Optional",
        "name": "position"
      }],
      "ref": "String[\"prototype\"][\"includes\"]"
    },
    "ids": "sec-string.prototype.includes",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (ToString O)\n  1:let S = [? __x1__]\n  2:(2) app __x2__ = (IsRegExp searchString)\n  2:let isRegExp = [? __x2__]\n  3:if (= isRegExp true) (0) throw TypeError else 6:{}\n  4:(3) app __x3__ = (ToString searchString)\n  4:let searchStr = [? __x3__]\n  5:(4) app __x4__ = (ToIntegerOrInfinity position)\n  5:let pos = [? __x4__]\n  7:let len = S[\"length\"]\n  8:(1) ??? \"Let id:{start} be the result of clamping id:{pos} between 0 and id:{len} .\"\n  9:(5) app __x5__ = (StringIndexOf S searchStr start)\n  9:let index = [! __x5__]\n  10:if (! (= index -1i)) return true else 6:{}\n  11:return false\n}"
  }, {
    "code": ["          1. Let _O_ be ? RequireObjectCoercible(*this* value).", "          1. Let _S_ be ? ToString(_O_).", "          1. Let _searchStr_ be ? ToString(_searchString_).", "          1. Let _pos_ be ? ToIntegerOrInfinity(_position_).", "          1. Assert: If _position_ is *undefined*, then _pos_ is 0.", "          1. Let _len_ be the length of _S_.", "          1. Let _start_ be the result of clamping _pos_ between 0 and _len_.", "          1. Return 𝔽(! StringIndexOf(_S_, _searchStr_, _start_))."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "searchString"
      }, {
        "kind": "Optional",
        "name": "position"
      }],
      "ref": "String[\"prototype\"][\"indexOf\"]"
    },
    "ids": "sec-string.prototype.indexof",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (ToString O)\n  1:let S = [? __x1__]\n  2:(2) app __x2__ = (ToString searchString)\n  2:let searchStr = [? __x2__]\n  3:(3) app __x3__ = (ToIntegerOrInfinity position)\n  3:let pos = [? __x3__]\n  5:let len = S[\"length\"]\n  6:(0) ??? \"Let id:{start} be the result of clamping id:{pos} between 0 and id:{len} .\"\n  7:(4) app __x4__ = (StringIndexOf S searchStr start)\n  7:return [! __x4__]\n}"
  }, {
    "code": ["          1. Let _O_ be ? RequireObjectCoercible(*this* value).", "          1. Let _S_ be ? ToString(_O_).", "          1. Let _searchStr_ be ? ToString(_searchString_).", "          1. Let _numPos_ be ? ToNumber(_position_).", "          1. Assert: If _position_ is *undefined*, then _numPos_ is *NaN*.", "          1. If _numPos_ is *NaN*, let _pos_ be +∞; otherwise, let _pos_ be ! ToIntegerOrInfinity(_numPos_).", "          1. Let _len_ be the length of _S_.", "          1. Let _start_ be the result of clamping _pos_ between 0 and _len_.", "          1. Let _searchLen_ be the length of _searchStr_.", "          1. Let _k_ be the largest possible non-negative integer not larger than _start_ such that _k_ + _searchLen_ ≤ _len_, and for all non-negative integers _j_ such that _j_ < _searchLen_, the code unit at index _k_ + _j_ within _S_ is the same as the code unit at index _j_ within _searchStr_; but if there is no such integer, let _k_ be -1.", "          1. Return 𝔽(_k_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "searchString"
      }, {
        "kind": "Optional",
        "name": "position"
      }],
      "ref": "String[\"prototype\"][\"lastIndexOf\"]"
    },
    "ids": "sec-string.prototype.lastindexof",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (ToString O)\n  1:let S = [? __x1__]\n  2:(2) app __x2__ = (ToString searchString)\n  2:let searchStr = [? __x2__]\n  3:(3) app __x3__ = (ToNumber position)\n  3:let numPos = [? __x3__]\n  5:if (= numPos NaN) let pos = Infinity else {\n    (4) app __x4__ = (ToIntegerOrInfinity numPos)\n    let pos = [! __x4__]\n  }\n  6:let len = S[\"length\"]\n  7:(0) ??? \"Let id:{start} be the result of clamping id:{pos} between 0 and id:{len} .\"\n  8:let searchLen = searchStr[\"length\"]\n  9:(1) ??? \"Let id:{k} be the largest possible non - negative integer not larger than id:{start} such that id:{k} + id:{searchLen} ≤ id:{len} , and for all non - negative integers id:{j} such that id:{j} < id:{searchLen} , the code unit at index id:{k} + id:{j} within id:{S} is the same as the code unit at index id:{j} within id:{searchStr} ; but if there is no such integer , let id:{k} be - 1 .\"\n  10:return k\n}"
  }, {
    "code": ["          1. Let _O_ be ? RequireObjectCoercible(*this* value).", "          1. Let _S_ be ? ToString(_O_).", "          1. Let _That_ be ? ToString(_that_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "that"
      }, {
        "kind": "Optional",
        "name": "reserved1"
      }, {
        "kind": "Optional",
        "name": "reserved2"
      }],
      "ref": "String[\"prototype\"][\"localeCompare\"]"
    },
    "ids": "sec-string.prototype.localecompare",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (ToString O)\n  1:let S = [? __x1__]\n  2:(2) app __x2__ = (ToString that)\n  2:let That = [? __x2__]\n}"
  }, {
    "code": ["          1. Let _O_ be ? RequireObjectCoercible(*this* value).", "          1. If _regexp_ is neither *undefined* nor *null*, then", "            1. Let _matcher_ be ? GetMethod(_regexp_, @@match).", "            1. If _matcher_ is not *undefined*, then", "              1. Return ? Call(_matcher_, _regexp_, « _O_ »).", "          1. Let _S_ be ? ToString(_O_).", "          1. Let _rx_ be ? RegExpCreate(_regexp_, *undefined*).", "          1. Return ? Invoke(_rx_, @@match, « _S_ »)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "regexp"
      }],
      "ref": "String[\"prototype\"][\"match\"]"
    },
    "ids": "sec-string.prototype.match",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible this)\n  0:let O = [? __x0__]\n  1:if (! (|| (= regexp undefined) (= regexp null))) {\n    2:(1) app __x1__ = (GetMethod regexp SYMBOL_match)\n    2:let matcher = [? __x1__]\n    3:if (! (= matcher undefined)) {\n      4:(2) app __x2__ = (Call matcher regexp (0) (new [O]))\n      4:return [? __x2__]\n    } else 4:{}\n  } else 4:{}\n  5:(3) app __x3__ = (ToString O)\n  5:let S = [? __x3__]\n  6:(4) app __x4__ = (RegExpCreate regexp undefined)\n  6:let rx = [? __x4__]\n  7:(5) app __x5__ = (Invoke rx SYMBOL_match (1) (new [S]))\n  7:return [? __x5__]\n}"
  }, {
    "code": ["          1. Let _O_ be ? RequireObjectCoercible(*this* value).", "          1. If _regexp_ is neither *undefined* nor *null*, then", "            1. Let _isRegExp_ be ? IsRegExp(_regexp_).", "            1. If _isRegExp_ is *true*, then", "              1. Let _flags_ be ? Get(_regexp_, *\"flags\"*).", "              1. Perform ? RequireObjectCoercible(_flags_).", "              1. If ? ToString(_flags_) does not contain *\"g\"*, throw a *TypeError* exception.", "            1. Let _matcher_ be ? GetMethod(_regexp_, @@matchAll).", "            1. If _matcher_ is not *undefined*, then", "              1. Return ? Call(_matcher_, _regexp_, « _O_ »).", "          1. Let _S_ be ? ToString(_O_).", "          1. Let _rx_ be ? RegExpCreate(_regexp_, *\"g\"*).", "          1. Return ? Invoke(_rx_, @@matchAll, « _S_ »)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "regexp"
      }],
      "ref": "String[\"prototype\"][\"matchAll\"]"
    },
    "ids": "sec-string.prototype.matchall",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible this)\n  0:let O = [? __x0__]\n  1:if (! (|| (= regexp undefined) (= regexp null))) {\n    2:(1) app __x1__ = (IsRegExp regexp)\n    2:let isRegExp = [? __x1__]\n    3:if (= isRegExp true) {\n      4:(2) app __x2__ = (Get regexp \"flags\")\n      4:let flags = [? __x2__]\n      5:(3) app __x3__ = (RequireObjectCoercible flags)\n      5:[? __x3__]\n      6:(4) app __x4__ = (ToString flags)\n      6:if (! (contains [? __x4__] \"g\")) (0) throw TypeError else 4:{}\n    } else 4:{}\n    7:(5) app __x5__ = (GetMethod regexp SYMBOL_matchAll)\n    7:let matcher = [? __x5__]\n    8:if (! (= matcher undefined)) {\n      9:(6) app __x6__ = (Call matcher regexp (1) (new [O]))\n      9:return [? __x6__]\n    } else 4:{}\n  } else 4:{}\n  10:(7) app __x7__ = (ToString O)\n  10:let S = [? __x7__]\n  11:(8) app __x8__ = (RegExpCreate regexp \"g\")\n  11:let rx = [? __x8__]\n  12:(9) app __x9__ = (Invoke rx SYMBOL_matchAll (2) (new [S]))\n  12:return [? __x9__]\n}"
  }, {
    "code": ["          1. Let _O_ be ? RequireObjectCoercible(*this* value).", "          1. Let _S_ be ? ToString(_O_).", "          1. If _form_ is *undefined*, let _f_ be *\"NFC\"*.", "          1. Else, let _f_ be ? ToString(_form_).", "          1. If _f_ is not one of *\"NFC\"*, *\"NFD\"*, *\"NFKC\"*, or *\"NFKD\"*, throw a *RangeError* exception.", "          1. Let _ns_ be the String value that is the result of normalizing _S_ into the normalization form named by _f_ as specified in <a href=\"https://unicode.org/reports/tr15/\">https://unicode.org/reports/tr15/</a>.", "          1. Return _ns_."],
    "head": {
      "origParams": [{
        "kind": "Optional",
        "name": "form"
      }],
      "ref": "String[\"prototype\"][\"normalize\"]"
    },
    "ids": "sec-string.prototype.normalize",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (ToString O)\n  1:let S = [? __x1__]\n  3:if (= form undefined) let f = \"NFC\" else {\n    (2) app __x2__ = (ToString form)\n    let f = [? __x2__]\n  }\n  4:if (! (|| (|| (|| (= f \"NFC\") (= f \"NFD\")) (= f \"NFKC\")) (= f \"NFKD\"))) (0) throw RangeError else 4:{}\n  5:(1) ??? \"Let id:{ns} be the String value that is the result of normalizing id:{S} into the normalization form named by id:{f} as specified in < a href = \\\" https : / / unicode . org / reports / tr15 / \\\" > https : / / unicode . org / reports / tr15 / < / a > .\"\n  6:return ns\n}"
  }, {
    "code": ["          1. Let _O_ be ? RequireObjectCoercible(*this* value).", "          1. Return ? StringPad(_O_, _maxLength_, _fillString_, ~end~)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "maxLength"
      }, {
        "kind": "Optional",
        "name": "fillString"
      }],
      "ref": "String[\"prototype\"][\"padEnd\"]"
    },
    "ids": "sec-string.prototype.padend",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (StringPad O maxLength fillString CONST_end)\n  1:return [? __x1__]\n}"
  }, {
    "code": ["          1. Let _O_ be ? RequireObjectCoercible(*this* value).", "          1. Return ? StringPad(_O_, _maxLength_, _fillString_, ~start~)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "maxLength"
      }, {
        "kind": "Optional",
        "name": "fillString"
      }],
      "ref": "String[\"prototype\"][\"padStart\"]"
    },
    "ids": "sec-string.prototype.padstart",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (StringPad O maxLength fillString CONST_start)\n  1:return [? __x1__]\n}"
  }, {
    "code": ["            1. Assert: _placement_ is ~start~ or ~end~.", "            1. Let _S_ be ? ToString(_O_).", "            1. Let _intMaxLength_ be ℝ(? ToLength(_maxLength_)).", "            1. Let _stringLength_ be the length of _S_.", "            1. If _intMaxLength_ ≤ _stringLength_, return _S_.", "            1. If _fillString_ is *undefined*, let _filler_ be the String value consisting solely of the code unit 0x0020 (SPACE).", "            1. Else, let _filler_ be ? ToString(_fillString_).", "            1. If _filler_ is the empty String, return _S_.", "            1. Let _fillLen_ be _intMaxLength_ - _stringLength_.", "            1. Let _truncatedStringFiller_ be the String value consisting of repeated concatenations of _filler_ truncated to length _fillLen_.", "            1. If _placement_ is ~start~, return the string-concatenation of _truncatedStringFiller_ and _S_.", "            1. Else, return the string-concatenation of _S_ and _truncatedStringFiller_."],
    "head": {
      "name": "StringPad",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "maxLength"
      }, {
        "kind": "Normal",
        "name": "fillString"
      }, {
        "kind": "Normal",
        "name": "placement"
      }]
    },
    "ids": "sec-stringpad",
    "rawBody": "{\n  0:assert (|| (= placement CONST_start) (= placement CONST_end))\n  1:(0) app __x0__ = (ToString O)\n  1:let S = [? __x0__]\n  2:(1) app __x1__ = (ToLength maxLength)\n  2:let intMaxLength = [? __x1__]\n  3:let stringLength = S[\"length\"]\n  4:if (! (< stringLength intMaxLength)) return S else 4:{}\n  6:if (= fillString undefined) let filler = \" \" else {\n    (2) app __x2__ = (ToString fillString)\n    let filler = [? __x2__]\n  }\n  7:if (= filler \"\") return S else 4:{}\n  8:let fillLen = (- intMaxLength stringLength)\n  9:(0) ??? \"Let id:{truncatedStringFiller} be the String value consisting of repeated concatenations of id:{filler} truncated to length id:{fillLen} .\"\n  11:if (= placement CONST_start) return (+ truncatedStringFiller S) else return (+ S truncatedStringFiller)\n}"
  }, {
    "code": ["          1. Let _O_ be ? RequireObjectCoercible(*this* value).", "          1. Let _S_ be ? ToString(_O_).", "          1. Let _n_ be ? ToIntegerOrInfinity(_count_).", "          1. If _n_ < 0 or _n_ is +∞, throw a *RangeError* exception.", "          1. If _n_ is 0, return the empty String.", "          1. Return the String value that is made from _n_ copies of _S_ appended together."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "count"
      }],
      "ref": "String[\"prototype\"][\"repeat\"]"
    },
    "ids": "sec-string.prototype.repeat",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (ToString O)\n  1:let S = [? __x1__]\n  2:(2) app __x2__ = (ToIntegerOrInfinity count)\n  2:let n = [? __x2__]\n  3:if (|| (< n 0i) (= n Infinity)) (0) throw RangeError else 4:{}\n  4:if (= n 0i) return \"\" else 4:{}\n  5:(1) ??? \"Return the String value that is made from id:{n} copies of id:{S} appended together .\"\n}"
  }, {
    "code": ["          1. Let _O_ be ? RequireObjectCoercible(*this* value).", "          1. If _searchValue_ is neither *undefined* nor *null*, then", "            1. Let _replacer_ be ? GetMethod(_searchValue_, @@replace).", "            1. If _replacer_ is not *undefined*, then", "              1. Return ? Call(_replacer_, _searchValue_, « _O_, _replaceValue_ »).", "          1. Let _string_ be ? ToString(_O_).", "          1. Let _searchString_ be ? ToString(_searchValue_).", "          1. Let _functionalReplace_ be IsCallable(_replaceValue_).", "          1. If _functionalReplace_ is *false*, then", "            1. Set _replaceValue_ to ? ToString(_replaceValue_).", "          1. Let _searchLength_ be the length of _searchString_.", "          1. Let _position_ be ! StringIndexOf(_string_, _searchString_, 0).", "          1. If _position_ is -1, return _string_.", "          1. Let _preserved_ be the substring of _string_ from 0 to _position_.", "          1. If _functionalReplace_ is *true*, then", "            1. Let _replacement_ be ? ToString(? Call(_replaceValue_, *undefined*, « _searchString_, 𝔽(_position_), _string_ »)).", "          1. Else,", "            1. Assert: Type(_replaceValue_) is String.", "            1. Let _captures_ be a new empty List.", "            1. Let _replacement_ be ! GetSubstitution(_searchString_, _string_, _position_, _captures_, *undefined*, _replaceValue_).", "          1. Return the string-concatenation of _preserved_, _replacement_, and the substring of _string_ from _position_ + _searchLength_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "searchValue"
      }, {
        "kind": "Normal",
        "name": "replaceValue"
      }],
      "ref": "String[\"prototype\"][\"replace\"]"
    },
    "ids": "sec-string.prototype.replace",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible this)\n  0:let O = [? __x0__]\n  1:if (! (|| (= searchValue undefined) (= searchValue null))) {\n    2:(1) app __x1__ = (GetMethod searchValue SYMBOL_replace)\n    2:let replacer = [? __x1__]\n    3:if (! (= replacer undefined)) {\n      4:(2) app __x2__ = (Call replacer searchValue (0) (new [O, replaceValue]))\n      4:return [? __x2__]\n    } else 4:{}\n  } else 4:{}\n  5:(3) app __x3__ = (ToString O)\n  5:let string = [? __x3__]\n  6:(4) app __x4__ = (ToString searchValue)\n  6:let searchString = [? __x4__]\n  7:(5) app __x5__ = (IsCallable replaceValue)\n  7:let functionalReplace = __x5__\n  8:if (= functionalReplace false) {\n    9:(6) app __x6__ = (ToString replaceValue)\n    9:replaceValue = [? __x6__]\n  } else 4:{}\n  10:let searchLength = searchString[\"length\"]\n  11:(7) app __x7__ = (StringIndexOf string searchString 0i)\n  11:let position = [! __x7__]\n  12:if (= position -1i) return string else 4:{}\n  13:let __x8__ = \"\"\n  13:let __x9__ = 0i\n  13:while (< __x9__ (+ position 1i)) {\n    (8) access __x10__ = (string __x9__)\n    __x8__ = (+ __x8__ __x10__)\n    __x9__ = (+ __x9__ 1i)\n  }\n  13:let preserved = __x8__\n  16:if (= functionalReplace true) {\n    15:(9) app __x11__ = (Call replaceValue undefined (1) (new [searchString, position, string]))\n    15:(10) app __x12__ = (ToString [? __x11__])\n    15:let replacement = [? __x12__]\n  } else {\n    17:assert (= (typeof replaceValue) String)\n    18:let captures = (2) (new [])\n    19:(11) app __x13__ = (GetSubstitution searchString string position captures undefined replaceValue)\n    19:let replacement = [! __x13__]\n  }\n  20:(3) ??? \"Return the string - concatenation of id:{preserved} , id:{replacement} , and the substring of id:{string} from id:{position} + id:{searchLength} .\"\n}"
  }, {
    "code": ["            1. Assert: Type(_matched_) is String.", "            1. Let _matchLength_ be the number of code units in _matched_.", "            1. Assert: Type(_str_) is String.", "            1. Let _stringLength_ be the number of code units in _str_.", "            1. Assert: _position_ ≤ _stringLength_.", "            1. Assert: _captures_ is a possibly empty List of Strings.", "            1. Assert: Type(_replacement_) is String.", "            1. Let _tailPos_ be _position_ + _matchLength_.", "            1. Let _m_ be the number of elements in _captures_.", "            1. Let _result_ be the String value derived from _replacement_ by copying code unit elements from _replacement_ to _result_ while performing replacements as specified in <emu-xref href=\"#table-replacement-text-symbol-substitutions\"></emu-xref>. These `$` replacements are done left-to-right, and, once such a replacement is performed, the new replacement text is not subject to further replacements.", "            1. Return _result_."],
    "head": {
      "name": "GetSubstitution",
      "params": [{
        "kind": "Normal",
        "name": "matched"
      }, {
        "kind": "Normal",
        "name": "str"
      }, {
        "kind": "Normal",
        "name": "position"
      }, {
        "kind": "Normal",
        "name": "captures"
      }, {
        "kind": "Normal",
        "name": "namedCaptures"
      }, {
        "kind": "Normal",
        "name": "replacement"
      }]
    },
    "ids": "sec-getsubstitution",
    "rawBody": "{\n  0:assert (= (typeof matched) String)\n  1:let matchLength = matched[\"length\"]\n  2:assert (= (typeof str) String)\n  3:let stringLength = str[\"length\"]\n  4:assert (! (< stringLength position))\n  6:assert (= (typeof replacement) String)\n  7:let tailPos = (+ position matchLength)\n  8:let m = captures[\"length\"]\n  9:(0) ??? \"Let id:{result} be the String value derived from id:{replacement} by copying code unit elements from id:{replacement} to id:{result} while performing replacements as specified in link:{table-replacement-text-symbol-substitutions} . These code:{$} replacements are done left - to - right , and , once such a replacement is performed , the new replacement text is not subject to further replacements .\"\n  10:return result\n}"
  }, {
    "code": ["          1. Let _O_ be ? RequireObjectCoercible(*this* value).", "          1. If _searchValue_ is neither *undefined* nor *null*, then", "            1. Let _isRegExp_ be ? IsRegExp(_searchValue_).", "            1. If _isRegExp_ is *true*, then", "              1. Let _flags_ be ? Get(_searchValue_, *\"flags\"*).", "              1. Perform ? RequireObjectCoercible(_flags_).", "              1. If ? ToString(_flags_) does not contain *\"g\"*, throw a *TypeError* exception.", "            1. Let _replacer_ be ? GetMethod(_searchValue_, @@replace).", "            1. If _replacer_ is not *undefined*, then", "              1. Return ? Call(_replacer_, _searchValue_, « _O_, _replaceValue_ »).", "          1. Let _string_ be ? ToString(_O_).", "          1. Let _searchString_ be ? ToString(_searchValue_).", "          1. Let _functionalReplace_ be IsCallable(_replaceValue_).", "          1. If _functionalReplace_ is *false*, then", "            1. Set _replaceValue_ to ? ToString(_replaceValue_).", "          1. Let _searchLength_ be the length of _searchString_.", "          1. Let _advanceBy_ be max(1, _searchLength_).", "          1. Let _matchPositions_ be a new empty List.", "          1. Let _position_ be ! StringIndexOf(_string_, _searchString_, 0).", "          1. Repeat, while _position_ is not -1,", "            1. Append _position_ to the end of _matchPositions_.", "            1. Set _position_ to ! StringIndexOf(_string_, _searchString_, _position_ + _advanceBy_).", "          1. Let _endOfLastMatch_ be 0.", "          1. Let _result_ be the empty String.", "          1. For each element _p_ of _matchPositions_, do", "            1. Let _preserved_ be the substring of _string_ from _endOfLastMatch_ to _p_.", "            1. If _functionalReplace_ is *true*, then", "              1. Let _replacement_ be ? ToString(? Call(_replaceValue_, *undefined*, « _searchString_, 𝔽(_p_), _string_ »)).", "            1. Else,", "              1. Assert: Type(_replaceValue_) is String.", "              1. Let _captures_ be a new empty List.", "              1. Let _replacement_ be ! GetSubstitution(_searchString_, _string_, _p_, _captures_, *undefined*, _replaceValue_).", "            1. Set _result_ to the string-concatenation of _result_, _preserved_, and _replacement_.", "            1. Set _endOfLastMatch_ to _p_ + _searchLength_.", "          1. If _endOfLastMatch_ < the length of _string_, then", "            1. Set _result_ to the string-concatenation of _result_ and the substring of _string_ from _endOfLastMatch_.", "          1. Return _result_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "searchValue"
      }, {
        "kind": "Normal",
        "name": "replaceValue"
      }],
      "ref": "String[\"prototype\"][\"replaceAll\"]"
    },
    "ids": "sec-string.prototype.replaceall",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible this)\n  0:let O = [? __x0__]\n  1:if (! (|| (= searchValue undefined) (= searchValue null))) {\n    2:(1) app __x1__ = (IsRegExp searchValue)\n    2:let isRegExp = [? __x1__]\n    3:if (= isRegExp true) {\n      4:(2) app __x2__ = (Get searchValue \"flags\")\n      4:let flags = [? __x2__]\n      5:(3) app __x3__ = (RequireObjectCoercible flags)\n      5:[? __x3__]\n      6:(4) app __x4__ = (ToString flags)\n      6:if (! (contains [? __x4__] \"g\")) (0) throw TypeError else 5:{}\n    } else 5:{}\n    7:(5) app __x5__ = (GetMethod searchValue SYMBOL_replace)\n    7:let replacer = [? __x5__]\n    8:if (! (= replacer undefined)) {\n      9:(6) app __x6__ = (Call replacer searchValue (1) (new [O, replaceValue]))\n      9:return [? __x6__]\n    } else 5:{}\n  } else 5:{}\n  10:(7) app __x7__ = (ToString O)\n  10:let string = [? __x7__]\n  11:(8) app __x8__ = (ToString searchValue)\n  11:let searchString = [? __x8__]\n  12:(9) app __x9__ = (IsCallable replaceValue)\n  12:let functionalReplace = __x9__\n  13:if (= functionalReplace false) {\n    14:(10) app __x10__ = (ToString replaceValue)\n    14:replaceValue = [? __x10__]\n  } else 5:{}\n  15:let searchLength = searchString[\"length\"]\n  16:(11) app __x11__ = (max 1i searchLength)\n  16:let advanceBy = __x11__\n  17:let matchPositions = (2) (new [])\n  18:(12) app __x12__ = (StringIndexOf string searchString 0i)\n  18:let position = [! __x12__]\n  19:while (! (= position -1i)) {\n    20:append position -> matchPositions\n    21:(13) app __x13__ = (StringIndexOf string searchString (+ position advanceBy))\n    21:position = [! __x13__]\n  }\n  22:let endOfLastMatch = 0i\n  23:let result = \"\"\n  24:let __x14__ = matchPositions\n  24:let __x15__ = 0i\n  24:while (< __x15__ __x14__[\"length\"]) {\n    let p = __x14__[__x15__]\n    25:let __x16__ = \"\"\n    25:let __x17__ = endOfLastMatch\n    25:while (< __x17__ (+ p 1i)) {\n      (14) access __x18__ = (string __x17__)\n      __x16__ = (+ __x16__ __x18__)\n      __x17__ = (+ __x17__ 1i)\n    }\n    25:let preserved = __x16__\n    28:if (= functionalReplace true) {\n      27:(15) app __x19__ = (Call replaceValue undefined (3) (new [searchString, p, string]))\n      27:(16) app __x20__ = (ToString [? __x19__])\n      27:let replacement = [? __x20__]\n    } else {\n      29:assert (= (typeof replaceValue) String)\n      30:let captures = (4) (new [])\n      31:(17) app __x21__ = (GetSubstitution searchString string p captures undefined replaceValue)\n      31:let replacement = [! __x21__]\n    }\n    32:result = (+ (+ result preserved) replacement)\n    33:endOfLastMatch = (+ p searchLength)\n    __x15__ = (+ __x15__ 1i)\n  }\n  34:if (< endOfLastMatch string[\"length\"]) (5) ??? \"Set id:{result} to the string - concatenation of id:{result} and the substring of id:{string} from id:{endOfLastMatch} .\" else 5:{}\n  36:return result\n}"
  }, {
    "code": ["          1. Let _O_ be ? RequireObjectCoercible(*this* value).", "          1. If _regexp_ is neither *undefined* nor *null*, then", "            1. Let _searcher_ be ? GetMethod(_regexp_, @@search).", "            1. If _searcher_ is not *undefined*, then", "              1. Return ? Call(_searcher_, _regexp_, « _O_ »).", "          1. Let _string_ be ? ToString(_O_).", "          1. Let _rx_ be ? RegExpCreate(_regexp_, *undefined*).", "          1. Return ? Invoke(_rx_, @@search, « _string_ »)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "regexp"
      }],
      "ref": "String[\"prototype\"][\"search\"]"
    },
    "ids": "sec-string.prototype.search",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible this)\n  0:let O = [? __x0__]\n  1:if (! (|| (= regexp undefined) (= regexp null))) {\n    2:(1) app __x1__ = (GetMethod regexp SYMBOL_search)\n    2:let searcher = [? __x1__]\n    3:if (! (= searcher undefined)) {\n      4:(2) app __x2__ = (Call searcher regexp (0) (new [O]))\n      4:return [? __x2__]\n    } else 5:{}\n  } else 5:{}\n  5:(3) app __x3__ = (ToString O)\n  5:let string = [? __x3__]\n  6:(4) app __x4__ = (RegExpCreate regexp undefined)\n  6:let rx = [? __x4__]\n  7:(5) app __x5__ = (Invoke rx SYMBOL_search (1) (new [string]))\n  7:return [? __x5__]\n}"
  }, {
    "code": ["          1. Let _O_ be ? RequireObjectCoercible(*this* value).", "          1. Let _S_ be ? ToString(_O_).", "          1. Let _len_ be the length of _S_.", "          1. Let _intStart_ be ? ToIntegerOrInfinity(_start_).", "          1. If _intStart_ is -∞, let _from_ be 0.", "          1. Else if _intStart_ < 0, let _from_ be max(_len_ + _intStart_, 0).", "          1. Else, let _from_ be min(_intStart_, _len_).", "          1. If _end_ is *undefined*, let _intEnd_ be _len_; else let _intEnd_ be ? ToIntegerOrInfinity(_end_).", "          1. If _intEnd_ is -∞, let _to_ be 0.", "          1. Else if _intEnd_ < 0, let _to_ be max(_len_ + _intEnd_, 0).", "          1. Else, let _to_ be min(_intEnd_, _len_).", "          1. If _from_ ≥ _to_, return the empty String.", "          1. Return the substring of _S_ from _from_ to _to_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "start"
      }, {
        "kind": "Normal",
        "name": "end"
      }],
      "ref": "String[\"prototype\"][\"slice\"]"
    },
    "ids": "sec-string.prototype.slice",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (ToString O)\n  1:let S = [? __x1__]\n  2:let len = S[\"length\"]\n  3:(2) app __x2__ = (ToIntegerOrInfinity start)\n  3:let intStart = [? __x2__]\n  6:if (= intStart -Infinity) let from = 0i else if (< intStart 0i) {\n    (3) app __x3__ = (max (+ len intStart) 0i)\n    let from = __x3__\n  } else {\n    (4) app __x4__ = (min intStart len)\n    let from = __x4__\n  }\n  7:if (= end undefined) let intEnd = len else {\n    (5) app __x5__ = (ToIntegerOrInfinity end)\n    let intEnd = [? __x5__]\n  }\n  10:if (= intEnd -Infinity) let to = 0i else if (< intEnd 0i) {\n    (6) app __x6__ = (max (+ len intEnd) 0i)\n    let to = __x6__\n  } else {\n    (7) app __x7__ = (min intEnd len)\n    let to = __x7__\n  }\n  11:if (! (< from to)) return \"\" else 5:{}\n  12:let __x8__ = \"\"\n  12:let __x9__ = from\n  12:while (< __x9__ (+ to 1i)) {\n    (8) access __x10__ = (S __x9__)\n    __x8__ = (+ __x8__ __x10__)\n    __x9__ = (+ __x9__ 1i)\n  }\n  12:return __x8__\n}"
  }, {
    "code": ["          1. Let _O_ be ? RequireObjectCoercible(*this* value).", "          1. If _separator_ is neither *undefined* nor *null*, then", "            1. Let _splitter_ be ? GetMethod(_separator_, @@split).", "            1. If _splitter_ is not *undefined*, then", "              1. Return ? Call(_splitter_, _separator_, « _O_, _limit_ »).", "          1. Let _S_ be ? ToString(_O_).", "          1. Let _A_ be ! ArrayCreate(0).", "          1. Let _lengthA_ be 0.", "          1. If _limit_ is *undefined*, let _lim_ be 2<sup>32</sup> - 1; else let _lim_ be ℝ(? ToUint32(_limit_)).", "          1. Let _R_ be ? ToString(_separator_).", "          1. If _lim_ = 0, return _A_.", "          1. If _separator_ is *undefined*, then", "            1. Perform ! CreateDataPropertyOrThrow(_A_, *\"0\"*, _S_).", "            1. Return _A_.", "          1. Let _s_ be the length of _S_.", "          1. If _s_ = 0, then", "            1. If _R_ is not the empty String, then", "              1. Perform ! CreateDataPropertyOrThrow(_A_, *\"0\"*, _S_).", "            1. Return _A_.", "          1. Let _p_ be 0.", "          1. Let _q_ be _p_.", "          1. Repeat, while _q_ ≠ _s_,", "            1. Let _e_ be SplitMatch(_S_, _q_, _R_).", "            1. If _e_ is ~not-matched~, set _q_ to _q_ + 1.", "            1. Else,", "              1. Assert: _e_ is a non-negative integer ≤ _s_.", "              1. If _e_ = _p_, set _q_ to _q_ + 1.", "              1. Else,", "                1. Let _T_ be the substring of _S_ from _p_ to _q_.", "                1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_lengthA_)), _T_).", "                1. Set _lengthA_ to _lengthA_ + 1.", "                1. If _lengthA_ = _lim_, return _A_.", "                1. Set _p_ to _e_.", "                1. Set _q_ to _p_.", "          1. Let _T_ be the substring of _S_ from _p_ to _s_.", "          1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_lengthA_)), _T_).", "          1. Return _A_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "separator"
      }, {
        "kind": "Normal",
        "name": "limit"
      }],
      "ref": "String[\"prototype\"][\"split\"]"
    },
    "ids": "sec-string.prototype.split",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible this)\n  0:let O = [? __x0__]\n  1:if (! (|| (= separator undefined) (= separator null))) {\n    2:(1) app __x1__ = (GetMethod separator SYMBOL_split)\n    2:let splitter = [? __x1__]\n    3:if (! (= splitter undefined)) {\n      4:(2) app __x2__ = (Call splitter separator (0) (new [O, limit]))\n      4:return [? __x2__]\n    } else 25:{}\n  } else 25:{}\n  5:(3) app __x3__ = (ToString O)\n  5:let S = [? __x3__]\n  6:(4) app __x4__ = (ArrayCreate 0i)\n  6:let A = [! __x4__]\n  7:let lengthA = 0i\n  8:if (= limit undefined) let lim = (- (** 2.0 32i) 1i) else {\n    (5) app __x5__ = (ToUint32 limit)\n    let lim = [? __x5__]\n  }\n  9:(6) app __x6__ = (ToString separator)\n  9:let R = [? __x6__]\n  10:if (== lim 0i) return A else 25:{}\n  11:if (= separator undefined) {\n    12:(7) app __x7__ = (CreateDataPropertyOrThrow A \"0\" S)\n    12:[! __x7__]\n    13:return A\n  } else 25:{}\n  14:let s = S[\"length\"]\n  15:if (== s 0i) {\n    16:if (! (= R \"\")) {\n      17:(8) app __x8__ = (CreateDataPropertyOrThrow A \"0\" S)\n      17:[! __x8__]\n    } else 25:{}\n    18:return A\n  } else 25:{}\n  19:let p = 0i\n  20:let q = p\n  21:while (! (== q s)) {\n    22:(9) app __x9__ = (SplitMatch S q R)\n    22:let e = __x9__\n    24:if (= e CONST_notDASHmatched) q = (+ q 1i) else if (== e p) q = (+ q 1i) else {\n      28:let __x10__ = \"\"\n      28:let __x11__ = p\n      28:while (< __x11__ (+ q 1i)) {\n        (10) access __x12__ = (S __x11__)\n        __x10__ = (+ __x10__ __x12__)\n        __x11__ = (+ __x11__ 1i)\n      }\n      28:let T = __x10__\n      29:(11) app __x13__ = (ToString lengthA)\n      29:(12) app __x14__ = (CreateDataPropertyOrThrow A [! __x13__] T)\n      29:[! __x14__]\n      30:lengthA = (+ lengthA 1i)\n      31:if (== lengthA lim) return A else 25:{}\n      32:p = e\n      33:q = p\n    }\n  }\n  34:let __x15__ = \"\"\n  34:let __x16__ = p\n  34:while (< __x16__ (+ s 1i)) {\n    (13) access __x17__ = (S __x16__)\n    __x15__ = (+ __x15__ __x17__)\n    __x16__ = (+ __x16__ 1i)\n  }\n  34:let T = __x15__\n  35:(14) app __x18__ = (ToString lengthA)\n  35:(15) app __x19__ = (CreateDataPropertyOrThrow A [! __x18__] T)\n  35:[! __x19__]\n  36:return A\n}"
  }, {
    "code": ["            1. Let _r_ be the number of code units in _R_.", "            1. Let _s_ be the number of code units in _S_.", "            1. If _q_ + _r_ > _s_, return ~not-matched~.", "            1. If there exists an integer _i_ between 0 (inclusive) and _r_ (exclusive) such that the code unit at index _q_ + _i_ within _S_ is different from the code unit at index _i_ within _R_, return ~not-matched~.", "            1. Return _q_ + _r_."],
    "head": {
      "name": "SplitMatch",
      "params": [{
        "kind": "Normal",
        "name": "S"
      }, {
        "kind": "Normal",
        "name": "q"
      }, {
        "kind": "Normal",
        "name": "R"
      }]
    },
    "ids": "sec-splitmatch",
    "rawBody": "{\n  0:let r = R[\"length\"]\n  1:let s = S[\"length\"]\n  2:if (< s (+ q r)) return CONST_notDASHmatched else 25:{}\n  3:(0) ??? \"If there exists an integer id:{i} between 0 ( inclusive ) and id:{r} ( exclusive ) such that the code unit at index id:{q} + id:{i} within id:{S} is different from the code unit at index id:{i} within id:{R} , return const:{not-matched} .\"\n  4:return (+ q r)\n}"
  }, {
    "code": ["          1. Let _O_ be ? RequireObjectCoercible(*this* value).", "          1. Let _S_ be ? ToString(_O_).", "          1. Let _isRegExp_ be ? IsRegExp(_searchString_).", "          1. If _isRegExp_ is *true*, throw a *TypeError* exception.", "          1. Let _searchStr_ be ? ToString(_searchString_).", "          1. Let _len_ be the length of _S_.", "          1. If _position_ is *undefined*, let _pos_ be 0; else let _pos_ be ? ToIntegerOrInfinity(_position_).", "          1. Let _start_ be the result of clamping _pos_ between 0 and _len_.", "          1. Let _searchLength_ be the length of _searchStr_.", "          1. If _searchLength_ = 0, return *true*.", "          1. Let _end_ be _start_ + _searchLength_.", "          1. If _end_ > _len_, return *false*.", "          1. Let _substring_ be the substring of _S_ from _start_ to _end_.", "          1. Return ! SameValueNonNumeric(_substring_, _searchStr_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "searchString"
      }, {
        "kind": "Optional",
        "name": "position"
      }],
      "ref": "String[\"prototype\"][\"startsWith\"]"
    },
    "ids": "sec-string.prototype.startswith",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (ToString O)\n  1:let S = [? __x1__]\n  2:(2) app __x2__ = (IsRegExp searchString)\n  2:let isRegExp = [? __x2__]\n  3:if (= isRegExp true) (0) throw TypeError else 25:{}\n  4:(3) app __x3__ = (ToString searchString)\n  4:let searchStr = [? __x3__]\n  5:let len = S[\"length\"]\n  6:if (= position undefined) let pos = 0i else {\n    (4) app __x4__ = (ToIntegerOrInfinity position)\n    let pos = [? __x4__]\n  }\n  7:(1) ??? \"Let id:{start} be the result of clamping id:{pos} between 0 and id:{len} .\"\n  8:let searchLength = searchStr[\"length\"]\n  9:if (== searchLength 0i) return true else 25:{}\n  10:let end = (+ start searchLength)\n  11:if (< len end) return false else 25:{}\n  12:let __x5__ = \"\"\n  12:let __x6__ = start\n  12:while (< __x6__ (+ end 1i)) {\n    (5) access __x7__ = (S __x6__)\n    __x5__ = (+ __x5__ __x7__)\n    __x6__ = (+ __x6__ 1i)\n  }\n  12:let substring = __x5__\n  13:(6) app __x8__ = (SameValueNonNumeric substring searchStr)\n  13:return [! __x8__]\n}"
  }, {
    "code": ["          1. Let _O_ be ? RequireObjectCoercible(*this* value).", "          1. Let _S_ be ? ToString(_O_).", "          1. Let _len_ be the length of _S_.", "          1. Let _intStart_ be ? ToIntegerOrInfinity(_start_).", "          1. If _end_ is *undefined*, let _intEnd_ be _len_; else let _intEnd_ be ? ToIntegerOrInfinity(_end_).", "          1. Let _finalStart_ be the result of clamping _intStart_ between 0 and _len_.", "          1. Let _finalEnd_ be the result of clamping _intEnd_ between 0 and _len_.", "          1. Let _from_ be min(_finalStart_, _finalEnd_).", "          1. Let _to_ be max(_finalStart_, _finalEnd_).", "          1. Return the substring of _S_ from _from_ to _to_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "start"
      }, {
        "kind": "Normal",
        "name": "end"
      }],
      "ref": "String[\"prototype\"][\"substring\"]"
    },
    "ids": "sec-string.prototype.substring",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (ToString O)\n  1:let S = [? __x1__]\n  2:let len = S[\"length\"]\n  3:(2) app __x2__ = (ToIntegerOrInfinity start)\n  3:let intStart = [? __x2__]\n  4:if (= end undefined) let intEnd = len else {\n    (3) app __x3__ = (ToIntegerOrInfinity end)\n    let intEnd = [? __x3__]\n  }\n  5:(0) ??? \"Let id:{finalStart} be the result of clamping id:{intStart} between 0 and id:{len} .\"\n  6:(1) ??? \"Let id:{finalEnd} be the result of clamping id:{intEnd} between 0 and id:{len} .\"\n  7:(4) app __x4__ = (min finalStart finalEnd)\n  7:let from = __x4__\n  8:(5) app __x5__ = (max finalStart finalEnd)\n  8:let to = __x5__\n  9:let __x6__ = \"\"\n  9:let __x7__ = from\n  9:while (< __x7__ (+ to 1i)) {\n    (6) access __x8__ = (S __x7__)\n    __x6__ = (+ __x6__ __x8__)\n    __x7__ = (+ __x7__ 1i)\n  }\n  9:return __x6__\n}"
  }, {
    "code": ["          1. Let _O_ be ? RequireObjectCoercible(*this* value).", "          1. Let _S_ be ? ToString(_O_).", "          1. Let _sText_ be ! StringToCodePoints(_S_).", "          1. Let _lowerText_ be the result of toLowercase(_sText_), according to the Unicode Default Case Conversion algorithm.", "          1. Let _L_ be ! CodePointsToString(_lowerText_).", "          1. Return _L_."],
    "head": {
      "origParams": [],
      "ref": "String[\"prototype\"][\"toLowerCase\"]"
    },
    "ids": "sec-string.prototype.tolowercase",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (ToString O)\n  1:let S = [? __x1__]\n  2:(2) app __x2__ = (StringToCodePoints S)\n  2:let sText = [! __x2__]\n  3:(0) ??? \"Let id:{lowerText} be the result of toLowercase ( id:{sText} ) , according to the Unicode Default Case Conversion algorithm .\"\n  4:(3) app __x3__ = (CodePointsToString lowerText)\n  4:let L = [! __x3__]\n  5:return L\n}"
  }, {
    "code": ["          1. Return ? thisStringValue(*this* value)."],
    "head": {
      "origParams": [],
      "ref": "String[\"prototype\"][\"toString\"]"
    },
    "ids": "sec-string.prototype.tostring",
    "rawBody": "{\n  0:(0) app __x0__ = (thisStringValue this)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Let _S_ be the *this* value.", "          1. Return ? TrimString(_S_, ~start+end~)."],
    "head": {
      "origParams": [],
      "ref": "String[\"prototype\"][\"trim\"]"
    },
    "ids": "sec-string.prototype.trim",
    "rawBody": "{\n  0:let S = this\n  1:(0) app __x0__ = (TrimString S CONST_startPLUSend)\n  1:return [? __x0__]\n}"
  }, {
    "code": ["            1. Let _str_ be ? RequireObjectCoercible(_string_).", "            1. Let _S_ be ? ToString(_str_).", "            1. If _where_ is ~start~, let _T_ be the String value that is a copy of _S_ with leading white space removed.", "            1. Else if _where_ is ~end~, let _T_ be the String value that is a copy of _S_ with trailing white space removed.", "            1. Else,", "              1. Assert: _where_ is ~start+end~.", "              1. Let _T_ be the String value that is a copy of _S_ with both leading and trailing white space removed.", "            1. Return _T_."],
    "head": {
      "name": "TrimString",
      "params": [{
        "kind": "Normal",
        "name": "string"
      }, {
        "kind": "Normal",
        "name": "where"
      }]
    },
    "ids": "sec-trimstring",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible string)\n  0:let str = [? __x0__]\n  1:(1) app __x1__ = (ToString str)\n  1:let S = [? __x1__]\n  2:(0) ??? \"If id:{where} is const:{start} , let id:{T} be the String value that is a copy of id:{S} with leading white space removed .\"\n  3:(1) ??? \"Else if id:{where} is const:{end} , let id:{T} be the String value that is a copy of id:{S} with trailing white space removed .\"\n  4:(2) ??? \"Else , in:{} out:{}\"\n  7:return T\n}"
  }, {
    "code": ["          1. Let _S_ be the *this* value.", "          1. Return ? TrimString(_S_, ~end~)."],
    "head": {
      "origParams": [],
      "ref": "String[\"prototype\"][\"trimEnd\"]"
    },
    "ids": "sec-string.prototype.trimend",
    "rawBody": "{\n  0:let S = this\n  1:(0) app __x0__ = (TrimString S CONST_end)\n  1:return [? __x0__]\n}"
  }, {
    "code": ["          1. Let _S_ be the *this* value.", "          1. Return ? TrimString(_S_, ~start~)."],
    "head": {
      "origParams": [],
      "ref": "String[\"prototype\"][\"trimStart\"]"
    },
    "ids": "sec-string.prototype.trimstart",
    "rawBody": "{\n  0:let S = this\n  1:(0) app __x0__ = (TrimString S CONST_start)\n  1:return [? __x0__]\n}"
  }, {
    "code": ["          1. Return ? thisStringValue(*this* value)."],
    "head": {
      "origParams": [],
      "ref": "String[\"prototype\"][\"valueOf\"]"
    },
    "ids": "sec-string.prototype.valueof",
    "rawBody": "{\n  0:(0) app __x0__ = (thisStringValue this)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Let _O_ be ? RequireObjectCoercible(*this* value).", "          1. Let _s_ be ? ToString(_O_).", "          1. Let _closure_ be a new Abstract Closure with no parameters that captures _s_ and performs the following steps when called:", "            1. Let _position_ be 0.", "            1. Let _len_ be the length of _s_.", "            1. Repeat, while _position_ < _len_,", "              1. Let _cp_ be ! CodePointAt(_s_, _position_).", "              1. Let _nextIndex_ be _position_ + _cp_.[[CodeUnitCount]].", "              1. Let _resultString_ be the substring of _s_ from _position_ to _nextIndex_.", "              1. Set _position_ to _nextIndex_.", "              1. Perform ? Yield(_resultString_).", "            1. Return *undefined*.", "          1. Return ! CreateIteratorFromClosure(_closure_, *\"%StringIteratorPrototype%\"*, %StringIteratorPrototype%)."],
    "head": {
      "origParams": [],
      "ref": "String[\"prototype\"][SYMBOL_iterator]"
    },
    "ids": "sec-string.prototype-@@iterator",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireObjectCoercible this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (ToString O)\n  1:let s = [? __x1__]\n  2:(0) ??? \"Let id:{closure} be a new Abstract Closure with no parameters that captures id:{s} and performs the following steps when called : in:{} out:{}\"\n  12:(2) app __x2__ = (CreateIteratorFromClosure closure \"%StringIteratorPrototype%\" INTRINSIC_StringIteratorPrototype)\n  12:return [! __x2__]\n}"
  }, {
    "code": ["          1. Return the MV of |NonZeroDigit|."],
    "head": {
      "idx": 0,
      "methodName": "CapturingGroupNumber",
      "prod": "DecimalEscape",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "NonZeroDigit",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-capturing-group-number",
    "rawBody": "{\n  0:(0) access __x0__ = (NonZeroDigit \"MV\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Let _n_ be the number of code points in |DecimalDigits|.", "          1. Return (the MV of |NonZeroDigit| × 10<sup>_n_</sup> plus the MV of |DecimalDigits|)."],
    "head": {
      "idx": 0,
      "methodName": "CapturingGroupNumber",
      "prod": "DecimalEscape",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "NonZeroDigit",
          "optional": false
        }, {
          "args": [],
          "name": "DecimalDigits",
          "optional": false
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-capturing-group-number",
    "rawBody": "{\n  0:(0) ??? \"Let id:{n} be the number of code points in nt:{DecimalDigits} .\"\n  1:(1) ??? \"Return ( the MV of nt:{NonZeroDigit} × 10 sup:{id:{n}} plus the MV of nt:{DecimalDigits} ) .\"\n}"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "IsCharacterClass",
      "prod": "ClassAtom",
      "rhs": {
        "tokens": [{
          "term": "-"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-is-character-class",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "IsCharacterClass",
      "prod": "ClassAtomNoDash",
      "rhs": {
        "tokens": [{
          "base": {
            "args": [],
            "name": "SourceCharacter",
            "optional": false
          },
          "cases": [{
            "term": "\\"
          }, {
            "term": "]"
          }, {
            "term": "-"
          }]
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-is-character-class",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 0,
      "methodName": "IsCharacterClass",
      "prod": "ClassEscape",
      "rhs": {
        "tokens": [{
          "term": "b"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-is-character-class",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 1,
      "methodName": "IsCharacterClass",
      "prod": "ClassEscape",
      "rhs": {
        "tokens": [{
          "term": "-"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-is-character-class",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *false*."],
    "head": {
      "idx": 3,
      "methodName": "IsCharacterClass",
      "prod": "ClassEscape",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CharacterEscape",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-is-character-class",
    "rawBody": "return false"
  }, {
    "code": ["          1. Return *true*."],
    "head": {
      "idx": 2,
      "methodName": "IsCharacterClass",
      "prod": "ClassEscape",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CharacterClassEscape",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-is-character-class",
    "rawBody": "return true"
  }, {
    "code": ["          1. Return the code point value of U+002D (HYPHEN-MINUS)."],
    "head": {
      "idx": 0,
      "methodName": "CharacterValue",
      "prod": "ClassAtom",
      "rhs": {
        "tokens": [{
          "term": "-"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-character-value",
    "rawBody": "return \"-\""
  }, {
    "code": ["          1. Let _ch_ be the code point matched by |SourceCharacter|.", "          1. Return the code point value of _ch_."],
    "head": {
      "idx": 0,
      "methodName": "CharacterValue",
      "prod": "ClassAtomNoDash",
      "rhs": {
        "tokens": [{
          "base": {
            "args": [],
            "name": "SourceCharacter",
            "optional": false
          },
          "cases": [{
            "term": "\\"
          }, {
            "term": "]"
          }, {
            "term": "-"
          }]
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-character-value",
    "rawBody": "{\n  0:let ch = SourceCharacter\n  1:return ch\n}"
  }, {
    "code": ["          1. Return the code point value of U+0008 (BACKSPACE)."],
    "head": {
      "idx": 0,
      "methodName": "CharacterValue",
      "prod": "ClassEscape",
      "rhs": {
        "tokens": [{
          "term": "b"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-character-value",
    "rawBody": "return \"\\b\""
  }, {
    "code": ["          1. Return the code point value of U+002D (HYPHEN-MINUS)."],
    "head": {
      "idx": 1,
      "methodName": "CharacterValue",
      "prod": "ClassEscape",
      "rhs": {
        "tokens": [{
          "term": "-"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-character-value",
    "rawBody": "return \"-\""
  }, {
    "code": ["          1. Return the code point value according to <emu-xref href=\"#table-controlescape-code-point-values\"></emu-xref>."],
    "head": {
      "idx": 0,
      "methodName": "CharacterValue",
      "prod": "CharacterEscape",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ControlEscape",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-character-value",
    "rawBody": "(0) ??? \"Return the code point value according to link:{table-controlescape-code-point-values} .\""
  }, {
    "code": ["          1. Let _ch_ be the code point matched by |ControlLetter|.", "          1. Let _i_ be _ch_'s code point value.", "          1. Return the remainder of dividing _i_ by 32."],
    "head": {
      "idx": 1,
      "methodName": "CharacterValue",
      "prod": "CharacterEscape",
      "rhs": {
        "tokens": [{
          "term": "c"
        }, {
          "args": [],
          "name": "ControlLetter",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-character-value",
    "rawBody": "{\n  0:let ch = ControlLetter\n  1:let i = ch\n  2:return (% i 32i)\n}"
  }, {
    "code": ["          1. Return the code point value of U+0000 (NULL)."],
    "head": {
      "idx": 2,
      "methodName": "CharacterValue",
      "prod": "CharacterEscape",
      "rhs": {
        "tokens": [{
          "term": "0"
        }, {
          "cases": [[{
            "args": [],
            "name": "DecimalDigit",
            "optional": false
          }]],
          "contains": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-character-value",
    "rawBody": "return \"\u0000\""
  }, {
    "code": ["          1. Return the MV of |HexEscapeSequence|."],
    "head": {
      "idx": 3,
      "methodName": "CharacterValue",
      "prod": "CharacterEscape",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "HexEscapeSequence",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-character-value",
    "rawBody": "{\n  0:(0) access __x0__ = (HexEscapeSequence \"MV\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Let _lead_ be the CharacterValue of |HexLeadSurrogate|.", "          1. Let _trail_ be the CharacterValue of |HexTrailSurrogate|.", "          1. Let _cp_ be UTF16SurrogatePairToCodePoint(_lead_, _trail_).", "          1. Return the code point value of _cp_."],
    "head": {
      "idx": 0,
      "methodName": "CharacterValue",
      "prod": "RegExpUnicodeEscapeSequence",
      "rhs": {
        "tokens": [{
          "term": "u"
        }, {
          "args": [],
          "name": "HexLeadSurrogate",
          "optional": false
        }, {
          "term": "\\u"
        }, {
          "args": [],
          "name": "HexTrailSurrogate",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-character-value",
    "rawBody": "{\n  0:(0) access __x0__ = (HexLeadSurrogate \"CharacterValue\")\n  0:let lead = __x0__\n  1:(1) access __x1__ = (HexTrailSurrogate \"CharacterValue\")\n  1:let trail = __x1__\n  2:(2) app __x2__ = (UTF16SurrogatePairToCodePoint lead trail)\n  2:let cp = __x2__\n  3:return cp\n}"
  }, {
    "code": ["          1. Return the MV of |Hex4Digits|."],
    "head": {
      "idx": 4,
      "methodName": "CharacterValue",
      "prod": "RegExpUnicodeEscapeSequence",
      "rhs": {
        "tokens": [{
          "term": "u"
        }, {
          "args": [],
          "name": "Hex4Digits",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-character-value",
    "rawBody": "{\n  0:(0) access __x0__ = (Hex4Digits \"MV\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return the MV of |CodePoint|."],
    "head": {
      "idx": 5,
      "methodName": "CharacterValue",
      "prod": "RegExpUnicodeEscapeSequence",
      "rhs": {
        "tokens": [{
          "term": "u{"
        }, {
          "args": [],
          "name": "CodePoint",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-character-value",
    "rawBody": "{\n  0:(0) access __x0__ = (CodePoint \"MV\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Let _ch_ be the code point matched by |IdentityEscape|.", "          1. Return the code point value of _ch_."],
    "head": {
      "idx": 5,
      "methodName": "CharacterValue",
      "prod": "CharacterEscape",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "IdentityEscape",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-character-value",
    "rawBody": "{\n  0:let ch = IdentityEscape\n  1:return ch\n}"
  }, {
    "code": ["          1. Return the List, in source text order, of Unicode code points in the source text matched by this production."],
    "head": {
      "idx": 0,
      "methodName": "SourceText",
      "prod": "UnicodePropertyNameCharacters",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "UnicodePropertyNameCharacter",
          "optional": false
        }, {
          "args": [],
          "name": "UnicodePropertyNameCharacters",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-sourcetext",
    "rawBody": "(0) ??? \"Return the List , in source text order , of Unicode code points in the source text matched by this production .\""
  }, {
    "code": ["          1. Return the List, in source text order, of Unicode code points in the source text matched by this production."],
    "head": {
      "idx": 0,
      "methodName": "SourceText",
      "prod": "UnicodePropertyValueCharacters",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "UnicodePropertyValueCharacter",
          "optional": false
        }, {
          "args": [],
          "name": "UnicodePropertyValueCharacters",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-static-semantics-sourcetext",
    "rawBody": "(0) ??? \"Return the List , in source text order , of Unicode code points in the source text matched by this production .\""
  }, {
    "code": ["          1. Let _idText_ be the source text matched by |RegExpIdentifierName|.", "          1. Let _idTextUnescaped_ be the result of replacing any occurrences of `\\\\` |RegExpUnicodeEscapeSequence| in _idText_ with the code point represented by the |RegExpUnicodeEscapeSequence|.", "          1. Return ! CodePointsToString(_idTextUnescaped_)."],
    "head": {
      "idx": 0,
      "methodName": "CapturingGroupName",
      "prod": "RegExpIdentifierName",
      "rhs": {
        "tokens": [{
          "args": ["?U"],
          "name": "RegExpIdentifierStart",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-capturinggroupname",
    "rawBody": "{\n  0:let idText = (get-syntax RegExpIdentifierName)\n  1:(0) ??? \"Let id:{idTextUnescaped} be the result of replacing any occurrences of code:{\\\\\\\\} nt:{RegExpUnicodeEscapeSequence} in id:{idText} with the code point represented by the nt:{RegExpUnicodeEscapeSequence} .\"\n  2:(0) app __x0__ = (CodePointsToString idTextUnescaped)\n  2:return [! __x0__]\n}"
  }, {
    "code": ["          1. Let _idText_ be the source text matched by |RegExpIdentifierName|.", "          1. Let _idTextUnescaped_ be the result of replacing any occurrences of `\\\\` |RegExpUnicodeEscapeSequence| in _idText_ with the code point represented by the |RegExpUnicodeEscapeSequence|.", "          1. Return ! CodePointsToString(_idTextUnescaped_)."],
    "head": {
      "idx": 1,
      "methodName": "CapturingGroupName",
      "prod": "RegExpIdentifierName",
      "rhs": {
        "tokens": [{
          "args": ["?U"],
          "name": "RegExpIdentifierName",
          "optional": false
        }, {
          "args": ["?U"],
          "name": "RegExpIdentifierPart",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-capturinggroupname",
    "rawBody": "{\n  0:let idText = (get-syntax RegExpIdentifierName)\n  1:(0) ??? \"Let id:{idTextUnescaped} be the result of replacing any occurrences of code:{\\\\\\\\} nt:{RegExpUnicodeEscapeSequence} in id:{idText} with the code point represented by the nt:{RegExpUnicodeEscapeSequence} .\"\n  2:(0) app __x0__ = (CodePointsToString idTextUnescaped)\n  2:return [! __x0__]\n}"
  }, {
    "code": ["          1. Evaluate |Disjunction| with 1 as its _direction_ argument to obtain a Matcher _m_.", "          1. Return a new Abstract Closure with parameters (_str_, _index_) that captures _m_ and performs the following steps when called:", "            1. Assert: Type(_str_) is String.", "            1. Assert: _index_ is a non-negative integer which is ≤ the length of _str_.", "            1. If _Unicode_ is *true*, let _Input_ be ! StringToCodePoints(_str_). Otherwise, let _Input_ be a List whose elements are the code units that are the elements of _str_. _Input_ will be used throughout the algorithms in <emu-xref href=\"#sec-pattern-semantics\"></emu-xref>. Each element of _Input_ is considered to be a character.", "            1. Let _InputLength_ be the number of characters contained in _Input_. This alias will be used throughout the algorithms in <emu-xref href=\"#sec-pattern-semantics\"></emu-xref>.", "            1. Let _listIndex_ be the index into _Input_ of the character that was obtained from element _index_ of _str_.", "            1. Let _c_ be a new Continuation with parameters (_y_) that captures nothing and performs the following steps when called:", "              1. Assert: _y_ is a State.", "              1. Return _y_.", "            1. Let _cap_ be a List of _NcapturingParens_ *undefined* values, indexed 1 through _NcapturingParens_.", "            1. Let _x_ be the State (_listIndex_, _cap_).", "            1. Return _m_(_x_, _c_)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "Pattern",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Disjunction",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-pattern",
    "rawBody": "{\n  0:(0) access __x0__ = (Disjunction \"Evaluation\" 1i)\n  0:let m = __x0__\n  1:(0) ??? \"Return a new Abstract Closure with parameters ( id:{str} , id:{index} ) that captures id:{m} and performs the following steps when called : in:{} out:{}\"\n}"
  }, {
    "code": ["          1. Evaluate |Alternative| with argument _direction_ to obtain a Matcher _m_.", "          1. Return _m_."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "Disjunction",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Alternative",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "direction"
      }]
    },
    "ids": "sec-disjunction",
    "rawBody": "{\n  0:(0) access __x0__ = (Alternative \"Evaluation\" direction)\n  0:let m = __x0__\n  1:return m\n}"
  }, {
    "code": ["          1. Evaluate |Alternative| with argument _direction_ to obtain a Matcher _m1_.", "          1. Evaluate |Disjunction| with argument _direction_ to obtain a Matcher _m2_.", "          1. Return a new Matcher with parameters (_x_, _c_) that captures _m1_ and _m2_ and performs the following steps when called:", "            1. Assert: _x_ is a State.", "            1. Assert: _c_ is a Continuation.", "            1. Let _r_ be _m1_(_x_, _c_).", "            1. If _r_ is not ~failure~, return _r_.", "            1. Return _m2_(_x_, _c_)."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "Disjunction",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Alternative",
          "optional": false
        }, {
          "term": "|"
        }, {
          "args": [],
          "name": "Disjunction",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "direction"
      }]
    },
    "ids": "sec-disjunction",
    "rawBody": "{\n  0:(0) access __x0__ = (Alternative \"Evaluation\" direction)\n  0:let m1 = __x0__\n  1:(1) access __x1__ = (Disjunction \"Evaluation\" direction)\n  1:let m2 = __x1__\n  2:(0) ??? \"Return a new Matcher with parameters ( id:{x} , id:{c} ) that captures id:{m1} and id:{m2} and performs the following steps when called : in:{} out:{}\"\n}"
  }, {
    "code": ["          1. Return a new Matcher with parameters (_x_, _c_) that captures nothing and performs the following steps when called:", "            1. Assert: _x_ is a State.", "            1. Assert: _c_ is a Continuation.", "            1. Return _c_(_x_)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "Alternative",
      "rhs": {
        "tokens": [{
          "empty": null
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "direction"
      }]
    },
    "ids": "sec-alternative",
    "rawBody": "(0) ??? \"Return a new Matcher with parameters ( id:{x} , id:{c} ) that captures nothing and performs the following steps when called : in:{} out:{}\""
  }, {
    "code": ["          1. Evaluate |Alternative| with argument _direction_ to obtain a Matcher _m1_.", "          1. Evaluate |Term| with argument _direction_ to obtain a Matcher _m2_.", "          1. If _direction_ = 1, then", "            1. Return a new Matcher with parameters (_x_, _c_) that captures _m1_ and _m2_ and performs the following steps when called:", "              1. Assert: _x_ is a State.", "              1. Assert: _c_ is a Continuation.", "              1. Let _d_ be a new Continuation with parameters (_y_) that captures _c_ and _m2_ and performs the following steps when called:", "                1. Assert: _y_ is a State.", "                1. Return _m2_(_y_, _c_).", "              1. Return _m1_(_x_, _d_).", "          1. Else,", "            1. Assert: _direction_ is -1.", "            1. Return a new Matcher with parameters (_x_, _c_) that captures _m1_ and _m2_ and performs the following steps when called:", "              1. Assert: _x_ is a State.", "              1. Assert: _c_ is a Continuation.", "              1. Let _d_ be a new Continuation with parameters (_y_) that captures _c_ and _m1_ and performs the following steps when called:", "                1. Assert: _y_ is a State.", "                1. Return _m1_(_y_, _c_).", "              1. Return _m2_(_x_, _d_)."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "Alternative",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Alternative",
          "optional": false
        }, {
          "args": [],
          "name": "Term",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "direction"
      }]
    },
    "ids": "sec-alternative",
    "rawBody": "{\n  0:(0) access __x0__ = (Alternative \"Evaluation\" direction)\n  0:let m1 = __x0__\n  1:(1) access __x1__ = (Term \"Evaluation\" direction)\n  1:let m2 = __x1__\n  10:if (== direction 1i) (0) ??? \"Return a new Matcher with parameters ( id:{x} , id:{c} ) that captures id:{m1} and id:{m2} and performs the following steps when called : in:{} out:{}\" else {\n    11:assert (= direction -1i)\n    12:(1) ??? \"Return a new Matcher with parameters ( id:{x} , id:{c} ) that captures id:{m1} and id:{m2} and performs the following steps when called : in:{} out:{}\"\n  }\n}"
  }, {
    "code": ["          1. Return the Matcher that is the result of evaluating |Assertion|."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "Term",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Assertion",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "direction"
      }]
    },
    "ids": "sec-term",
    "rawBody": "(0) ??? \"Return the Matcher that is the result of evaluating nt:{Assertion} .\""
  }, {
    "code": ["          1. Return the Matcher that is the result of evaluating |Atom| with argument _direction_."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "Term",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Atom",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "direction"
      }]
    },
    "ids": "sec-term",
    "rawBody": "(0) ??? \"Return the Matcher that is the result of evaluating nt:{Atom} with argument id:{direction} .\""
  }, {
    "code": ["          1. Evaluate |Atom| with argument _direction_ to obtain a Matcher _m_.", "          1. Evaluate |Quantifier| to obtain the three results: a non-negative integer _min_, a non-negative integer (or +∞) _max_, and Boolean _greedy_.", "          1. Assert: _min_ ≤ _max_.", "          1. Let _parenIndex_ be the number of left-capturing parentheses in the entire regular expression that occur to the left of this |Term|. This is the total number of <emu-grammar>Atom :: `(` GroupSpecifier Disjunction `)`</emu-grammar> Parse Nodes prior to or enclosing this |Term|.", "          1. Let _parenCount_ be the number of left-capturing parentheses in |Atom|. This is the total number of <emu-grammar>Atom :: `(` GroupSpecifier Disjunction `)`</emu-grammar> Parse Nodes enclosed by |Atom|.", "          1. Return a new Matcher with parameters (_x_, _c_) that captures _m_, _min_, _max_, _greedy_, _parenIndex_, and _parenCount_ and performs the following steps when called:", "            1. Assert: _x_ is a State.", "            1. Assert: _c_ is a Continuation.", "            1. Return ! RepeatMatcher(_m_, _min_, _max_, _greedy_, _x_, _c_, _parenIndex_, _parenCount_)."],
    "head": {
      "idx": 2,
      "methodName": "Evaluation",
      "prod": "Term",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Atom",
          "optional": false
        }, {
          "args": [],
          "name": "Quantifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "direction"
      }]
    },
    "ids": "sec-term",
    "rawBody": "{\n  0:(0) access __x0__ = (Atom \"Evaluation\" direction)\n  0:let m = __x0__\n  1:(0) ??? \"Evaluate nt:{Quantifier} to obtain the three results : a non - negative integer id:{min} , a non - negative integer ( or + ∞ ) id:{max} , and Boolean id:{greedy} .\"\n  2:assert (! (< max min))\n  3:(1) ??? \"Let id:{parenIndex} be the number of left - capturing parentheses in the entire regular expression that occur to the left of this nt:{Term} . This is the total number of grammar:{Atom4, [GroupSpecifier, Disjunction]} Parse Nodes prior to or enclosing this nt:{Term} .\"\n  4:(2) ??? \"Let id:{parenCount} be the number of left - capturing parentheses in nt:{Atom} . This is the total number of grammar:{Atom4, [GroupSpecifier, Disjunction]} Parse Nodes enclosed by nt:{Atom} .\"\n  5:(3) ??? \"Return a new Matcher with parameters ( id:{x} , id:{c} ) that captures id:{m} , id:{min} , id:{max} , id:{greedy} , id:{parenIndex} , and id:{parenCount} and performs the following steps when called : in:{} out:{}\"\n}"
  }, {
    "code": ["            1. If _max_ = 0, return _c_(_x_).", "            1. Let _d_ be a new Continuation with parameters (_y_) that captures _m_, _min_, _max_, _greedy_, _x_, _c_, _parenIndex_, and _parenCount_ and performs the following steps when called:", "              1. Assert: _y_ is a State.", "              1. [id=\"step-repeatmatcher-done\"] If _min_ = 0 and _y_'s _endIndex_ = _x_'s _endIndex_, return ~failure~.", "              1. If _min_ = 0, let _min2_ be 0; otherwise let _min2_ be _min_ - 1.", "              1. If _max_ is +∞, let _max2_ be +∞; otherwise let _max2_ be _max_ - 1.", "              1. Return ! RepeatMatcher(_m_, _min2_, _max2_, _greedy_, _y_, _c_, _parenIndex_, _parenCount_).", "            1. Let _cap_ be a copy of _x_'s _captures_ List.", "            1. [id=\"step-repeatmatcher-clear-captures\"] For each integer _k_ such that _parenIndex_ < _k_ and _k_ ≤ _parenIndex_ + _parenCount_, set _cap_[_k_] to *undefined*.", "            1. Let _e_ be _x_'s _endIndex_.", "            1. Let _xr_ be the State (_e_, _cap_).", "            1. If _min_ ≠ 0, return _m_(_xr_, _d_).", "            1. If _greedy_ is *false*, then", "              1. Let _z_ be _c_(_x_).", "              1. If _z_ is not ~failure~, return _z_.", "              1. Return _m_(_xr_, _d_).", "            1. Let _z_ be _m_(_xr_, _d_).", "            1. If _z_ is not ~failure~, return _z_.", "            1. Return _c_(_x_)."],
    "head": {
      "name": "RepeatMatcher",
      "params": [{
        "kind": "Normal",
        "name": "m"
      }, {
        "kind": "Normal",
        "name": "min"
      }, {
        "kind": "Normal",
        "name": "max"
      }, {
        "kind": "Normal",
        "name": "greedy"
      }, {
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "c"
      }, {
        "kind": "Normal",
        "name": "parenIndex"
      }, {
        "kind": "Normal",
        "name": "parenCount"
      }]
    },
    "ids": "sec-runtime-semantics-repeatmatcher-abstract-operation",
    "rawBody": "{\n  0:if (== max 0i) {\n    (0) app __x0__ = (c x)\n    return __x0__\n  } else 2:{}\n  1:(0) ??? \"Let id:{d} be a new Continuation with parameters ( id:{y} ) that captures id:{m} , id:{min} , id:{max} , id:{greedy} , id:{x} , id:{c} , id:{parenIndex} , and id:{parenCount} and performs the following steps when called : in:{} out:{}\"\n  7:let cap = (1) (copy-obj x[\"captures\"])\n  8:(2) ??? \"For each integer id:{k} such that id:{parenIndex} < id:{k} and id:{k} ≤ id:{parenIndex} + id:{parenCount} , set id:{cap} [ id:{k} ] to value:{undefined} .\"\n  9:let e = x[\"endIndex\"]\n  10:let xr = (3) (new [e, cap])\n  11:if (! (== min 0i)) {\n    (1) app __x1__ = (m xr d)\n    return __x1__\n  } else 2:{}\n  12:if (= greedy false) {\n    13:(2) app __x2__ = (c x)\n    13:let z = __x2__\n    14:if (! (= z CONST_failure)) return z else 2:{}\n    15:(3) app __x3__ = (m xr d)\n    15:return __x3__\n  } else 2:{}\n  16:(4) app __x4__ = (m xr d)\n  16:let z = __x4__\n  17:if (! (= z CONST_failure)) return z else 2:{}\n  18:(5) app __x5__ = (c x)\n  18:return __x5__\n}"
  }, {
    "code": ["          1. Return a new Matcher with parameters (_x_, _c_) that captures nothing and performs the following steps when called:", "            1. Assert: _x_ is a State.", "            1. Assert: _c_ is a Continuation.", "            1. Let _e_ be _x_'s _endIndex_.", "            1. If _e_ = 0, or if _Multiline_ is *true* and the character _Input_[_e_ - 1] is one of |LineTerminator|, then", "              1. Return _c_(_x_).", "            1. Return ~failure~."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "Assertion",
      "rhs": {
        "tokens": [{
          "term": "^"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-assertion",
    "rawBody": "(0) ??? \"Return a new Matcher with parameters ( id:{x} , id:{c} ) that captures nothing and performs the following steps when called : in:{} out:{}\""
  }, {
    "code": ["          1. Return a new Matcher with parameters (_x_, _c_) that captures nothing and performs the following steps when called:", "            1. Assert: _x_ is a State.", "            1. Assert: _c_ is a Continuation.", "            1. Let _e_ be _x_'s _endIndex_.", "            1. If _e_ = _InputLength_, or if _Multiline_ is *true* and the character _Input_[_e_] is one of |LineTerminator|, then", "              1. Return _c_(_x_).", "            1. Return ~failure~."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "Assertion",
      "rhs": {
        "tokens": [{
          "term": "$"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-assertion",
    "rawBody": "(0) ??? \"Return a new Matcher with parameters ( id:{x} , id:{c} ) that captures nothing and performs the following steps when called : in:{} out:{}\""
  }, {
    "code": ["          1. Return a new Matcher with parameters (_x_, _c_) that captures nothing and performs the following steps when called:", "            1. Assert: _x_ is a State.", "            1. Assert: _c_ is a Continuation.", "            1. Let _e_ be _x_'s _endIndex_.", "            1. Let _a_ be ! IsWordChar(_e_ - 1).", "            1. Let _b_ be ! IsWordChar(_e_).", "            1. If _a_ is *true* and _b_ is *false*, or if _a_ is *false* and _b_ is *true*, return _c_(_x_).", "            1. Return ~failure~."],
    "head": {
      "idx": 2,
      "methodName": "Evaluation",
      "prod": "Assertion",
      "rhs": {
        "tokens": [{
          "term": "\\"
        }, {
          "term": "b"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-assertion",
    "rawBody": "(0) ??? \"Return a new Matcher with parameters ( id:{x} , id:{c} ) that captures nothing and performs the following steps when called : in:{} out:{}\""
  }, {
    "code": ["          1. Return a new Matcher with parameters (_x_, _c_) that captures nothing and performs the following steps when called:", "            1. Assert: _x_ is a State.", "            1. Assert: _c_ is a Continuation.", "            1. Let _e_ be _x_'s _endIndex_.", "            1. Let _a_ be ! IsWordChar(_e_ - 1).", "            1. Let _b_ be ! IsWordChar(_e_).", "            1. If _a_ is *true* and _b_ is *true*, or if _a_ is *false* and _b_ is *false*, return _c_(_x_).", "            1. Return ~failure~."],
    "head": {
      "idx": 3,
      "methodName": "Evaluation",
      "prod": "Assertion",
      "rhs": {
        "tokens": [{
          "term": "\\"
        }, {
          "term": "B"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-assertion",
    "rawBody": "(0) ??? \"Return a new Matcher with parameters ( id:{x} , id:{c} ) that captures nothing and performs the following steps when called : in:{} out:{}\""
  }, {
    "code": ["          1. Evaluate |Disjunction| with 1 as its _direction_ argument to obtain a Matcher _m_.", "          1. Return a new Matcher with parameters (_x_, _c_) that captures _m_ and performs the following steps when called:", "            1. Assert: _x_ is a State.", "            1. Assert: _c_ is a Continuation.", "            1. Let _d_ be a new Continuation with parameters (_y_) that captures nothing and performs the following steps when called:", "              1. Assert: _y_ is a State.", "              1. Return _y_.", "            1. Let _r_ be _m_(_x_, _d_).", "            1. If _r_ is ~failure~, return ~failure~.", "            1. Let _y_ be _r_'s State.", "            1. Let _cap_ be _y_'s _captures_ List.", "            1. Let _xe_ be _x_'s _endIndex_.", "            1. Let _z_ be the State (_xe_, _cap_).", "            1. Return _c_(_z_)."],
    "head": {
      "idx": 4,
      "methodName": "Evaluation",
      "prod": "Assertion",
      "rhs": {
        "tokens": [{
          "term": "("
        }, {
          "term": "?"
        }, {
          "term": "="
        }, {
          "args": [],
          "name": "Disjunction",
          "optional": false
        }, {
          "term": ")"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-assertion",
    "rawBody": "{\n  0:(0) access __x0__ = (Disjunction \"Evaluation\" 1i)\n  0:let m = __x0__\n  1:(0) ??? \"Return a new Matcher with parameters ( id:{x} , id:{c} ) that captures id:{m} and performs the following steps when called : in:{} out:{}\"\n}"
  }, {
    "code": ["          1. Evaluate |Disjunction| with 1 as its _direction_ argument to obtain a Matcher _m_.", "          1. Return a new Matcher with parameters (_x_, _c_) that captures _m_ and performs the following steps when called:", "            1. Assert: _x_ is a State.", "            1. Assert: _c_ is a Continuation.", "            1. Let _d_ be a new Continuation with parameters (_y_) that captures nothing and performs the following steps when called:", "              1. Assert: _y_ is a State.", "              1. Return _y_.", "            1. Let _r_ be _m_(_x_, _d_).", "            1. If _r_ is not ~failure~, return ~failure~.", "            1. Return _c_(_x_)."],
    "head": {
      "idx": 5,
      "methodName": "Evaluation",
      "prod": "Assertion",
      "rhs": {
        "tokens": [{
          "term": "("
        }, {
          "term": "?"
        }, {
          "term": "!"
        }, {
          "args": [],
          "name": "Disjunction",
          "optional": false
        }, {
          "term": ")"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-assertion",
    "rawBody": "{\n  0:(0) access __x0__ = (Disjunction \"Evaluation\" 1i)\n  0:let m = __x0__\n  1:(0) ??? \"Return a new Matcher with parameters ( id:{x} , id:{c} ) that captures id:{m} and performs the following steps when called : in:{} out:{}\"\n}"
  }, {
    "code": ["          1. Evaluate |Disjunction| with -1 as its _direction_ argument to obtain a Matcher _m_.", "          1. Return a new Matcher with parameters (_x_, _c_) that captures _m_ and performs the following steps when called:", "            1. Assert: _x_ is a State.", "            1. Assert: _c_ is a Continuation.", "            1. Let _d_ be a new Continuation with parameters (_y_) that captures nothing and performs the following steps when called:", "              1. Assert: _y_ is a State.", "              1. Return _y_.", "            1. Let _r_ be _m_(_x_, _d_).", "            1. If _r_ is ~failure~, return ~failure~.", "            1. Let _y_ be _r_'s State.", "            1. Let _cap_ be _y_'s _captures_ List.", "            1. Let _xe_ be _x_'s _endIndex_.", "            1. Let _z_ be the State (_xe_, _cap_).", "            1. Return _c_(_z_)."],
    "head": {
      "idx": 6,
      "methodName": "Evaluation",
      "prod": "Assertion",
      "rhs": {
        "tokens": [{
          "term": "("
        }, {
          "term": "?"
        }, {
          "term": "<="
        }, {
          "args": [],
          "name": "Disjunction",
          "optional": false
        }, {
          "term": ")"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-assertion",
    "rawBody": "{\n  0:(0) access __x0__ = (Disjunction \"Evaluation\" -1i)\n  0:let m = __x0__\n  1:(0) ??? \"Return a new Matcher with parameters ( id:{x} , id:{c} ) that captures id:{m} and performs the following steps when called : in:{} out:{}\"\n}"
  }, {
    "code": ["          1. Evaluate |Disjunction| with -1 as its _direction_ argument to obtain a Matcher _m_.", "          1. Return a new Matcher with parameters (_x_, _c_) that captures _m_ and performs the following steps when called:", "            1. Assert: _x_ is a State.", "            1. Assert: _c_ is a Continuation.", "            1. Let _d_ be a new Continuation with parameters (_y_) that captures nothing and performs the following steps when called:", "              1. Assert: _y_ is a State.", "              1. Return _y_.", "            1. Let _r_ be _m_(_x_, _d_).", "            1. If _r_ is not ~failure~, return ~failure~.", "            1. Return _c_(_x_)."],
    "head": {
      "idx": 7,
      "methodName": "Evaluation",
      "prod": "Assertion",
      "rhs": {
        "tokens": [{
          "term": "("
        }, {
          "term": "?"
        }, {
          "term": "<!"
        }, {
          "args": [],
          "name": "Disjunction",
          "optional": false
        }, {
          "term": ")"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-assertion",
    "rawBody": "{\n  0:(0) access __x0__ = (Disjunction \"Evaluation\" -1i)\n  0:let m = __x0__\n  1:(0) ??? \"Return a new Matcher with parameters ( id:{x} , id:{c} ) that captures id:{m} and performs the following steps when called : in:{} out:{}\"\n}"
  }, {
    "code": ["            1. If _e_ = -1 or _e_ is _InputLength_, return *false*.", "            1. Let _c_ be the character _Input_[_e_].", "            1. If _c_ is in _WordCharacters_, return *true*.", "            1. Return *false*."],
    "head": {
      "name": "IsWordChar",
      "params": [{
        "kind": "Normal",
        "name": "e"
      }]
    },
    "ids": "sec-runtime-semantics-iswordchar-abstract-operation",
    "rawBody": "{\n  0:if (|| (== e -1i) (= e InputLength)) return false else 5:{}\n  1:let c = Input[e]\n  2:if (contains WordCharacters c) return true else 5:{}\n  3:return false\n}"
  }, {
    "code": ["          1. Evaluate |QuantifierPrefix| to obtain the two results: an integer _min_ and an integer (or +∞) _max_.", "          1. Return the three results _min_, _max_, and *true*."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "Quantifier",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "QuantifierPrefix",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-quantifier",
    "rawBody": "{\n  0:(0) access __x0__ = (QuantifierPrefix \"Evaluation\")\n  0:let min = __x0__[0i]\n  0:let max = __x0__[1i]\n  1:return (0) (new [min, max, true])\n}"
  }, {
    "code": ["          1. Evaluate |QuantifierPrefix| to obtain the two results: an integer _min_ and an integer (or +∞) _max_.", "          1. Return the three results _min_, _max_, and *false*."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "Quantifier",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "QuantifierPrefix",
          "optional": false
        }, {
          "term": "?"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-quantifier",
    "rawBody": "{\n  0:(0) access __x0__ = (QuantifierPrefix \"Evaluation\")\n  0:let min = __x0__[0i]\n  0:let max = __x0__[1i]\n  1:return (0) (new [min, max, false])\n}"
  }, {
    "code": ["          1. Return the two results 0 and +∞."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "QuantifierPrefix",
      "rhs": {
        "tokens": [{
          "term": "*"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-quantifier",
    "rawBody": "return (0) (new [0i, Infinity])"
  }, {
    "code": ["          1. Return the two results 1 and +∞."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "QuantifierPrefix",
      "rhs": {
        "tokens": [{
          "term": "+"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-quantifier",
    "rawBody": "return (0) (new [1i, Infinity])"
  }, {
    "code": ["          1. Return the two results 0 and 1."],
    "head": {
      "idx": 2,
      "methodName": "Evaluation",
      "prod": "QuantifierPrefix",
      "rhs": {
        "tokens": [{
          "term": "?"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-quantifier",
    "rawBody": "return (0) (new [0i, 1i])"
  }, {
    "code": ["          1. Let _i_ be the MV of |DecimalDigits| (see <emu-xref href=\"#sec-literals-numeric-literals\"></emu-xref>).", "          1. Return the two results _i_ and _i_."],
    "head": {
      "idx": 3,
      "methodName": "Evaluation",
      "prod": "QuantifierPrefix",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "DecimalDigits",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-quantifier",
    "rawBody": "{\n  0:(0) access __x0__ = (DecimalDigits \"MV\")\n  0:let i = __x0__\n  1:return (0) (new [i, i])\n}"
  }, {
    "code": ["          1. Let _i_ be the MV of |DecimalDigits|.", "          1. Return the two results _i_ and +∞."],
    "head": {
      "idx": 4,
      "methodName": "Evaluation",
      "prod": "QuantifierPrefix",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "DecimalDigits",
          "optional": false
        }, {
          "term": ","
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-quantifier",
    "rawBody": "{\n  0:(0) access __x0__ = (DecimalDigits \"MV\")\n  0:let i = __x0__\n  1:return (0) (new [i, Infinity])\n}"
  }, {
    "code": ["          1. Let _i_ be the MV of the first |DecimalDigits|.", "          1. Let _j_ be the MV of the second |DecimalDigits|.", "          1. Return the two results _i_ and _j_."],
    "head": {
      "idx": 5,
      "methodName": "Evaluation",
      "prod": "QuantifierPrefix",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "DecimalDigits",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "DecimalDigits",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-quantifier",
    "rawBody": "{\n  0:(0) access __x0__ = (DecimalDigits0 \"MV\")\n  0:let i = __x0__\n  1:(1) access __x1__ = (DecimalDigits1 \"MV\")\n  1:let j = __x1__\n  2:return (0) (new [i, j])\n}"
  }, {
    "code": ["          1. Let _ch_ be the character matched by |PatternCharacter|.", "          1. Let _A_ be a one-element CharSet containing the character _ch_.", "          1. Return ! CharacterSetMatcher(_A_, *false*, _direction_)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "Atom",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "PatternCharacter",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "direction"
      }]
    },
    "ids": "sec-atom",
    "rawBody": "{\n  0:let ch = PatternCharacter\n  1:let A = (0) (new [ch])\n  2:(0) app __x0__ = (CharacterSetMatcher A false direction)\n  2:return [! __x0__]\n}"
  }, {
    "code": ["          1. Let _A_ be the CharSet of all characters.", "          1. If _DotAll_ is not *true*, then", "            1. Remove from _A_ all characters corresponding to a code point on the right-hand side of the |LineTerminator| production.", "          1. Return ! CharacterSetMatcher(_A_, *false*, _direction_)."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "Atom",
      "rhs": {
        "tokens": [{
          "term": "."
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "direction"
      }]
    },
    "ids": "sec-atom",
    "rawBody": "{\n  0:(0) ??? \"Let id:{A} be the CharSet of all characters .\"\n  1:if (! (= DotAll true)) (1) ??? \"Remove from id:{A} all characters corresponding to a code point on the right - hand side of the nt:{LineTerminator} production .\" else 5:{}\n  3:(0) app __x0__ = (CharacterSetMatcher A false direction)\n  3:return [! __x0__]\n}"
  }, {
    "code": ["          1. Return the Matcher that is the result of evaluating |AtomEscape| with argument _direction_."],
    "head": {
      "idx": 2,
      "methodName": "Evaluation",
      "prod": "Atom",
      "rhs": {
        "tokens": [{
          "term": "\\"
        }, {
          "args": [],
          "name": "AtomEscape",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "direction"
      }]
    },
    "ids": "sec-atom",
    "rawBody": "(0) ??? \"Return the Matcher that is the result of evaluating nt:{AtomEscape} with argument id:{direction} .\""
  }, {
    "code": ["          1. Evaluate |CharacterClass| to obtain a CharSet _A_ and a Boolean _invert_.", "          1. Return ! CharacterSetMatcher(_A_, _invert_, _direction_)."],
    "head": {
      "idx": 3,
      "methodName": "Evaluation",
      "prod": "Atom",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CharacterClass",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "direction"
      }]
    },
    "ids": "sec-atom",
    "rawBody": "{\n  0:(0) access __x0__ = (CharacterClass \"Evaluation\")\n  0:let A = __x0__[0i]\n  0:let invert = __x0__[1i]\n  1:(1) app __x1__ = (CharacterSetMatcher A invert direction)\n  1:return [! __x1__]\n}"
  }, {
    "code": ["          1. Evaluate |Disjunction| with argument _direction_ to obtain a Matcher _m_.", "          1. Let _parenIndex_ be the number of left-capturing parentheses in the entire regular expression that occur to the left of this |Atom|. This is the total number of <emu-grammar>Atom :: `(` GroupSpecifier Disjunction `)`</emu-grammar> Parse Nodes prior to or enclosing this |Atom|.", "          1. Return a new Matcher with parameters (_x_, _c_) that captures _direction_, _m_, and _parenIndex_ and performs the following steps when called:", "            1. Assert: _x_ is a State.", "            1. Assert: _c_ is a Continuation.", "            1. Let _d_ be a new Continuation with parameters (_y_) that captures _x_, _c_, _direction_, and _parenIndex_ and performs the following steps when called:", "              1. Assert: _y_ is a State.", "              1. Let _cap_ be a copy of _y_'s _captures_ List.", "              1. Let _xe_ be _x_'s _endIndex_.", "              1. Let _ye_ be _y_'s _endIndex_.", "              1. If _direction_ = 1, then", "                1. Assert: _xe_ ≤ _ye_.", "                1. Let _s_ be a List whose elements are the characters of _Input_ at indices _xe_ (inclusive) through _ye_ (exclusive).", "              1. Else,", "                1. Assert: _direction_ is -1.", "                1. Assert: _ye_ ≤ _xe_.", "                1. Let _s_ be a List whose elements are the characters of _Input_ at indices _ye_ (inclusive) through _xe_ (exclusive).", "              1. Set _cap_[_parenIndex_ + 1] to _s_.", "              1. Let _z_ be the State (_ye_, _cap_).", "              1. Return _c_(_z_).", "            1. Return _m_(_x_, _d_)."],
    "head": {
      "idx": 4,
      "methodName": "Evaluation",
      "prod": "Atom",
      "rhs": {
        "tokens": [{
          "term": "("
        }, {
          "args": [],
          "name": "GroupSpecifier",
          "optional": false
        }, {
          "args": [],
          "name": "Disjunction",
          "optional": false
        }, {
          "term": ")"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "direction"
      }]
    },
    "ids": "sec-atom",
    "rawBody": "{\n  0:(0) access __x0__ = (Disjunction \"Evaluation\" direction)\n  0:let m = __x0__\n  1:(0) ??? \"Let id:{parenIndex} be the number of left - capturing parentheses in the entire regular expression that occur to the left of this nt:{Atom} . This is the total number of grammar:{Atom4, [GroupSpecifier, Disjunction]} Parse Nodes prior to or enclosing this nt:{Atom} .\"\n  2:(1) ??? \"Return a new Matcher with parameters ( id:{x} , id:{c} ) that captures id:{direction} , id:{m} , and id:{parenIndex} and performs the following steps when called : in:{} out:{}\"\n}"
  }, {
    "code": ["          1. Return the Matcher that is the result of evaluating |Disjunction| with argument _direction_."],
    "head": {
      "idx": 5,
      "methodName": "Evaluation",
      "prod": "Atom",
      "rhs": {
        "tokens": [{
          "term": "("
        }, {
          "term": "?"
        }, {
          "term": ":"
        }, {
          "args": [],
          "name": "Disjunction",
          "optional": false
        }, {
          "term": ")"
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "direction"
      }]
    },
    "ids": "sec-atom",
    "rawBody": "(0) ??? \"Return the Matcher that is the result of evaluating nt:{Disjunction} with argument id:{direction} .\""
  }, {
    "code": ["            1. Return a new Matcher with parameters (_x_, _c_) that captures _A_, _invert_, and _direction_ and performs the following steps when called:", "              1. Assert: _x_ is a State.", "              1. Assert: _c_ is a Continuation.", "              1. Let _e_ be _x_'s _endIndex_.", "              1. Let _f_ be _e_ + _direction_.", "              1. If _f_ < 0 or _f_ > _InputLength_, return ~failure~.", "              1. Let _index_ be min(_e_, _f_).", "              1. Let _ch_ be the character _Input_[_index_].", "              1. Let _cc_ be Canonicalize(_ch_).", "              1. If there exists a member _a_ of _A_ such that Canonicalize(_a_) is _cc_, let _found_ be *true*. Otherwise, let _found_ be *false*.", "              1. If _invert_ is *false* and _found_ is *false*, return ~failure~.", "              1. If _invert_ is *true* and _found_ is *true*, return ~failure~.", "              1. Let _cap_ be _x_'s _captures_ List.", "              1. Let _y_ be the State (_f_, _cap_).", "              1. Return _c_(_y_)."],
    "head": {
      "name": "CharacterSetMatcher",
      "params": [{
        "kind": "Normal",
        "name": "A"
      }, {
        "kind": "Normal",
        "name": "invert"
      }, {
        "kind": "Normal",
        "name": "direction"
      }]
    },
    "ids": "sec-runtime-semantics-charactersetmatcher-abstract-operation",
    "rawBody": "(0) ??? \"Return a new Matcher with parameters ( id:{x} , id:{c} ) that captures id:{A} , id:{invert} , and id:{direction} and performs the following steps when called : in:{} out:{}\""
  }, {
    "code": ["            1. If _Unicode_ is *true* and _IgnoreCase_ is *true*, then", "              1. If the file CaseFolding.txt of the Unicode Character Database provides a simple or common case folding mapping for _ch_, return the result of applying that mapping to _ch_.", "              1. Return _ch_.", "            1. If _IgnoreCase_ is *false*, return _ch_.", "            1. Assert: _ch_ is a UTF-16 code unit.", "            1. Let _cp_ be the code point whose numeric value is that of _ch_.", "            1. Let _u_ be the result of toUppercase(« _cp_ »), according to the Unicode Default Case Conversion algorithm.", "            1. Let _uStr_ be ! CodePointsToString(_u_).", "            1. If _uStr_ does not consist of a single code unit, return _ch_.", "            1. Let _cu_ be _uStr_'s single code unit element.", "            1. If the numeric value of _ch_ ≥ 128 and the numeric value of _cu_ < 128, return _ch_.", "            1. Return _cu_."],
    "head": {
      "name": "Canonicalize",
      "params": [{
        "kind": "Normal",
        "name": "ch"
      }]
    },
    "ids": "sec-runtime-semantics-canonicalize-ch",
    "rawBody": "{\n  0:if (&& (= Unicode true) (= IgnoreCase true)) {\n    1:(0) ??? \"If the file CaseFolding . txt of the Unicode Character Database provides a simple or common case folding mapping for id:{ch} , return the result of applying that mapping to id:{ch} .\"\n    2:return ch\n  } else 4:{}\n  3:if (= IgnoreCase false) return ch else 4:{}\n  5:(1) ??? \"Let id:{cp} be the code point whose numeric value is that of id:{ch} .\"\n  6:(2) ??? \"Let id:{u} be the result of toUppercase ( « id:{cp} » ) , according to the Unicode Default Case Conversion algorithm .\"\n  7:(0) app __x0__ = (CodePointsToString u)\n  7:let uStr = [! __x0__]\n  8:(3) ??? \"If id:{uStr} does not consist of a single code unit , return id:{ch} .\"\n  9:(4) ??? \"Let id:{cu} be id:{uStr} ' s single code unit element .\"\n  10:(5) ??? \"If the numeric value of id:{ch} ≥ 128 and the numeric value of id:{cu} < 128 , return id:{ch} .\"\n  11:return cu\n}"
  }, {
    "code": ["            1. Assert: _p_ is a List of Unicode code points that is identical to a List of Unicode code points that is a Unicode <emu-not-ref>property name</emu-not-ref> or property alias listed in the “<emu-not-ref>Property name</emu-not-ref> and aliases” column of <emu-xref href=\"#table-nonbinary-unicode-properties\"></emu-xref> or <emu-xref href=\"#table-binary-unicode-properties\"></emu-xref>.", "            1. Let _c_ be the canonical <emu-not-ref>property name</emu-not-ref> of _p_ as given in the “Canonical <emu-not-ref>property name</emu-not-ref>” column of the corresponding row.", "            1. Return the List of Unicode code points of _c_."],
    "head": {
      "name": "UnicodeMatchProperty",
      "params": [{
        "kind": "Normal",
        "name": "p"
      }]
    },
    "ids": "sec-runtime-semantics-unicodematchproperty-p",
    "rawBody": "{\n  1:(0) ??? \"Let id:{c} be the canonical property name of id:{p} as given in the “ Canonical property name ” column of the corresponding row .\"\n  2:(1) ??? \"Return the List of Unicode code points of id:{c} .\"\n}"
  }, {
    "code": ["            1. Assert: _p_ is a List of Unicode code points that is identical to a List of Unicode code points that is a canonical, unaliased Unicode property name listed in the “Canonical property name” column of <emu-xref href=\"#table-nonbinary-unicode-properties\"></emu-xref>.", "            1. Assert: _v_ is a List of Unicode code points that is identical to a List of Unicode code points that is a property value or property value alias for Unicode property _p_ listed in the “Property value and aliases” column of <emu-xref href=\"#table-unicode-general-category-values\"></emu-xref> or <emu-xref href=\"#table-unicode-script-values\"></emu-xref>.", "            1. Let _value_ be the canonical property value of _v_ as given in the “Canonical property value” column of the corresponding row.", "            1. Return the List of Unicode code points of _value_."],
    "head": {
      "name": "UnicodeMatchPropertyValue",
      "params": [{
        "kind": "Normal",
        "name": "p"
      }, {
        "kind": "Normal",
        "name": "v"
      }]
    },
    "ids": "sec-runtime-semantics-unicodematchpropertyvalue-p-v",
    "rawBody": "{\n  2:(0) ??? \"Let id:{value} be the canonical property value of id:{v} as given in the “ Canonical property value ” column of the corresponding row .\"\n  3:(1) ??? \"Return the List of Unicode code points of id:{value} .\"\n}"
  }, {
    "code": ["          1. Evaluate |DecimalEscape| to obtain an integer _n_.", "          1. Assert: _n_ ≤ _NcapturingParens_.", "          1. Return ! BackreferenceMatcher(_n_, _direction_)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "AtomEscape",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "DecimalEscape",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "direction"
      }]
    },
    "ids": "sec-atomescape",
    "rawBody": "{\n  0:(0) access __x0__ = (DecimalEscape \"Evaluation\")\n  0:let n = __x0__\n  1:assert (! (< NcapturingParens n))\n  2:(1) app __x1__ = (BackreferenceMatcher n direction)\n  2:return [! __x1__]\n}"
  }, {
    "code": ["          1. Evaluate |CharacterEscape| to obtain a character _ch_.", "          1. Let _A_ be a one-element CharSet containing the character _ch_.", "          1. Return ! CharacterSetMatcher(_A_, *false*, _direction_)."],
    "head": {
      "idx": 2,
      "methodName": "Evaluation",
      "prod": "AtomEscape",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CharacterEscape",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "direction"
      }]
    },
    "ids": "sec-atomescape",
    "rawBody": "{\n  0:(0) access __x0__ = (CharacterEscape \"Evaluation\")\n  0:let ch = __x0__\n  1:let A = (0) (new [ch])\n  2:(1) app __x1__ = (CharacterSetMatcher A false direction)\n  2:return [! __x1__]\n}"
  }, {
    "code": ["          1. Evaluate |CharacterClassEscape| to obtain a CharSet _A_.", "          1. Return ! CharacterSetMatcher(_A_, *false*, _direction_)."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "AtomEscape",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CharacterClassEscape",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "direction"
      }]
    },
    "ids": "sec-atomescape",
    "rawBody": "{\n  0:(0) access __x0__ = (CharacterClassEscape \"Evaluation\")\n  0:let A = __x0__\n  1:(1) app __x1__ = (CharacterSetMatcher A false direction)\n  1:return [! __x1__]\n}"
  }, {
    "code": ["          1. Search the enclosing |Pattern| for an instance of a |GroupSpecifier| containing a |RegExpIdentifierName| which has a CapturingGroupName equal to the CapturingGroupName of the |RegExpIdentifierName| contained in |GroupName|.", "          1. Assert: A unique such |GroupSpecifier| is found.", "          1. Let _parenIndex_ be the number of left-capturing parentheses in the entire regular expression that occur to the left of the located |GroupSpecifier|. This is the total number of <emu-grammar>Atom :: `(` GroupSpecifier Disjunction `)`</emu-grammar> Parse Nodes prior to or enclosing the located |GroupSpecifier|, including its immediately enclosing |Atom|.", "          1. Return ! BackreferenceMatcher(_parenIndex_, _direction_)."],
    "head": {
      "idx": 3,
      "methodName": "Evaluation",
      "prod": "AtomEscape",
      "rhs": {
        "tokens": [{
          "term": "k"
        }, {
          "args": [],
          "name": "GroupName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": [{
        "kind": "Normal",
        "name": "direction"
      }]
    },
    "ids": "sec-atomescape",
    "rawBody": "{\n  0:(0) ??? \"Search the enclosing nt:{Pattern} for an instance of a nt:{GroupSpecifier} containing a nt:{RegExpIdentifierName} which has a CapturingGroupName equal to the CapturingGroupName of the nt:{RegExpIdentifierName} contained in nt:{GroupName} .\"\n  2:(1) ??? \"Let id:{parenIndex} be the number of left - capturing parentheses in the entire regular expression that occur to the left of the located nt:{GroupSpecifier} . This is the total number of grammar:{Atom4, [GroupSpecifier, Disjunction]} Parse Nodes prior to or enclosing the located nt:{GroupSpecifier} , including its immediately enclosing nt:{Atom} .\"\n  3:(0) app __x0__ = (BackreferenceMatcher parenIndex direction)\n  3:return [! __x0__]\n}"
  }, {
    "code": ["            1. Assert: _n_ ≥ 1.", "            1. Return a new Matcher with parameters (_x_, _c_) that captures _n_ and _direction_ and performs the following steps when called:", "              1. Assert: _x_ is a State.", "              1. Assert: _c_ is a Continuation.", "              1. Let _cap_ be _x_'s _captures_ List.", "              1. Let _s_ be _cap_[_n_].", "              1. If _s_ is *undefined*, return _c_(_x_).", "              1. Let _e_ be _x_'s _endIndex_.", "              1. Let _len_ be the number of elements in _s_.", "              1. Let _f_ be _e_ + _direction_ × _len_.", "              1. If _f_ < 0 or _f_ > _InputLength_, return ~failure~.", "              1. Let _g_ be min(_e_, _f_).", "              1. If there exists an integer _i_ between 0 (inclusive) and _len_ (exclusive) such that Canonicalize(_s_[_i_]) is not the same character value as Canonicalize(_Input_[_g_ + _i_]), return ~failure~.", "              1. Let _y_ be the State (_f_, _cap_).", "              1. Return _c_(_y_)."],
    "head": {
      "name": "BackreferenceMatcher",
      "params": [{
        "kind": "Normal",
        "name": "n"
      }, {
        "kind": "Normal",
        "name": "direction"
      }]
    },
    "ids": "sec-backreference-matcher",
    "rawBody": "{\n  0:assert (! (< n 1i))\n  1:(0) ??? \"Return a new Matcher with parameters ( id:{x} , id:{c} ) that captures id:{n} and id:{direction} and performs the following steps when called : in:{} out:{}\"\n}"
  }, {
    "code": ["          1. Let _cv_ be the CharacterValue of this |CharacterEscape|.", "          1. Return the character whose character value is _cv_."],
    "head": {
      "idx": 0,
      "methodName": "CharacterEscape",
      "prod": "CharacterEscape",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ControlEscape",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-characterescape",
    "rawBody": "{\n  0:(0) access __x0__ = (this \"CharacterValue\")\n  0:let cv = __x0__\n  1:return cv\n}"
  }, {
    "code": ["          1. Let _cv_ be the CharacterValue of this |CharacterEscape|.", "          1. Return the character whose character value is _cv_."],
    "head": {
      "idx": 1,
      "methodName": "CharacterEscape",
      "prod": "CharacterEscape",
      "rhs": {
        "tokens": [{
          "term": "c"
        }, {
          "args": [],
          "name": "ControlLetter",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-characterescape",
    "rawBody": "{\n  0:(0) access __x0__ = (this \"CharacterValue\")\n  0:let cv = __x0__\n  1:return cv\n}"
  }, {
    "code": ["          1. Let _cv_ be the CharacterValue of this |CharacterEscape|.", "          1. Return the character whose character value is _cv_."],
    "head": {
      "idx": 2,
      "methodName": "CharacterEscape",
      "prod": "CharacterEscape",
      "rhs": {
        "tokens": [{
          "term": "0"
        }, {
          "cases": [[{
            "args": [],
            "name": "DecimalDigit",
            "optional": false
          }]],
          "contains": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-characterescape",
    "rawBody": "{\n  0:(0) access __x0__ = (this \"CharacterValue\")\n  0:let cv = __x0__\n  1:return cv\n}"
  }, {
    "code": ["          1. Let _cv_ be the CharacterValue of this |CharacterEscape|.", "          1. Return the character whose character value is _cv_."],
    "head": {
      "idx": 3,
      "methodName": "CharacterEscape",
      "prod": "CharacterEscape",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "HexEscapeSequence",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-characterescape",
    "rawBody": "{\n  0:(0) access __x0__ = (this \"CharacterValue\")\n  0:let cv = __x0__\n  1:return cv\n}"
  }, {
    "code": ["          1. Let _cv_ be the CharacterValue of this |CharacterEscape|.", "          1. Return the character whose character value is _cv_."],
    "head": {
      "idx": 4,
      "methodName": "CharacterEscape",
      "prod": "CharacterEscape",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RegExpUnicodeEscapeSequence",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-characterescape",
    "rawBody": "{\n  0:(0) access __x0__ = (this \"CharacterValue\")\n  0:let cv = __x0__\n  1:return cv\n}"
  }, {
    "code": ["          1. Let _cv_ be the CharacterValue of this |CharacterEscape|.", "          1. Return the character whose character value is _cv_."],
    "head": {
      "idx": 5,
      "methodName": "CharacterEscape",
      "prod": "CharacterEscape",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "IdentityEscape",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-characterescape",
    "rawBody": "{\n  0:(0) access __x0__ = (this \"CharacterValue\")\n  0:let cv = __x0__\n  1:return cv\n}"
  }, {
    "code": ["          1. Return the CapturingGroupNumber of this |DecimalEscape|."],
    "head": {
      "idx": 0,
      "methodName": "DecimalEscape",
      "prod": "DecimalEscape",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "NonZeroDigit",
          "optional": false
        }, {
          "args": [],
          "name": "DecimalDigits",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-decimalescape",
    "rawBody": "{\n  0:(0) access __x0__ = (this \"CapturingGroupNumber\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return the ten-element CharSet containing the characters `0` through `9` inclusive."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "CharacterClassEscape",
      "rhs": {
        "tokens": [{
          "term": "d"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-characterclassescape",
    "rawBody": "(0) ??? \"Return the ten - element CharSet containing the characters code:{0} through code:{9} inclusive .\""
  }, {
    "code": ["          1. Return the CharSet containing all characters not in the CharSet returned by <emu-grammar>CharacterClassEscape :: `d`</emu-grammar> ."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "CharacterClassEscape",
      "rhs": {
        "tokens": [{
          "term": "D"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-characterclassescape",
    "rawBody": "(0) ??? \"Return the CharSet containing all characters not in the CharSet returned by grammar:{CharacterClassEscape0, []} .\""
  }, {
    "code": ["          1. Return the CharSet containing all characters corresponding to a code point on the right-hand side of the |WhiteSpace| or |LineTerminator| productions."],
    "head": {
      "idx": 2,
      "methodName": "Evaluation",
      "prod": "CharacterClassEscape",
      "rhs": {
        "tokens": [{
          "term": "s"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-characterclassescape",
    "rawBody": "(0) ??? \"Return the CharSet containing all characters corresponding to a code point on the right - hand side of the nt:{WhiteSpace} or nt:{LineTerminator} productions .\""
  }, {
    "code": ["          1. Return the CharSet containing all characters not in the CharSet returned by <emu-grammar>CharacterClassEscape :: `s`</emu-grammar> ."],
    "head": {
      "idx": 3,
      "methodName": "Evaluation",
      "prod": "CharacterClassEscape",
      "rhs": {
        "tokens": [{
          "term": "S"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-characterclassescape",
    "rawBody": "(0) ??? \"Return the CharSet containing all characters not in the CharSet returned by grammar:{CharacterClassEscape2, []} .\""
  }, {
    "code": ["          1. Return _WordCharacters_."],
    "head": {
      "idx": 4,
      "methodName": "Evaluation",
      "prod": "CharacterClassEscape",
      "rhs": {
        "tokens": [{
          "term": "w"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-characterclassescape",
    "rawBody": "return WordCharacters"
  }, {
    "code": ["          1. Return the CharSet containing all characters not in the CharSet returned by <emu-grammar>CharacterClassEscape :: `w`</emu-grammar> ."],
    "head": {
      "idx": 5,
      "methodName": "Evaluation",
      "prod": "CharacterClassEscape",
      "rhs": {
        "tokens": [{
          "term": "W"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-characterclassescape",
    "rawBody": "(0) ??? \"Return the CharSet containing all characters not in the CharSet returned by grammar:{CharacterClassEscape4, []} .\""
  }, {
    "code": ["          1. Return the CharSet containing all Unicode code points included in the CharSet returned by |UnicodePropertyValueExpression|."],
    "head": {
      "idx": 6,
      "methodName": "Evaluation",
      "prod": "CharacterClassEscape",
      "rhs": {
        "tokens": [{
          "term": "p{"
        }, {
          "args": [],
          "name": "UnicodePropertyValueExpression",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-characterclassescape",
    "rawBody": "(0) ??? \"Return the CharSet containing all Unicode code points included in the CharSet returned by nt:{UnicodePropertyValueExpression} .\""
  }, {
    "code": ["          1. Return the CharSet containing all Unicode code points not included in the CharSet returned by |UnicodePropertyValueExpression|."],
    "head": {
      "idx": 7,
      "methodName": "Evaluation",
      "prod": "CharacterClassEscape",
      "rhs": {
        "tokens": [{
          "term": "P{"
        }, {
          "args": [],
          "name": "UnicodePropertyValueExpression",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-characterclassescape",
    "rawBody": "(0) ??? \"Return the CharSet containing all Unicode code points not included in the CharSet returned by nt:{UnicodePropertyValueExpression} .\""
  }, {
    "code": ["          1. Let _ps_ be SourceText of |UnicodePropertyName|.", "          1. Let _p_ be ! UnicodeMatchProperty(_ps_).", "          1. Assert: _p_ is a Unicode property name or property alias listed in the “Property name and aliases” column of <emu-xref href=\"#table-nonbinary-unicode-properties\"></emu-xref>.", "          1. Let _vs_ be SourceText of |UnicodePropertyValue|.", "          1. Let _v_ be ! UnicodeMatchPropertyValue(_p_, _vs_).", "          1. Return the CharSet containing all Unicode code points whose character database definition includes the property _p_ with value _v_."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "UnicodePropertyValueExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "UnicodePropertyName",
          "optional": false
        }, {
          "term": "="
        }, {
          "args": [],
          "name": "UnicodePropertyValue",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-characterclassescape",
    "rawBody": "{\n  0:(0) access __x0__ = (UnicodePropertyName \"SourceText\")\n  0:let ps = __x0__\n  1:(1) app __x1__ = (UnicodeMatchProperty ps)\n  1:let p = [! __x1__]\n  3:(2) access __x2__ = (UnicodePropertyValue \"SourceText\")\n  3:let vs = __x2__\n  4:(3) app __x3__ = (UnicodeMatchPropertyValue p vs)\n  4:let v = [! __x3__]\n  5:(0) ??? \"Return the CharSet containing all Unicode code points whose character database definition includes the property id:{p} with value id:{v} .\"\n}"
  }, {
    "code": ["          1. Let _s_ be SourceText of |LoneUnicodePropertyNameOrValue|.", "          1. If ! UnicodeMatchPropertyValue(`General_Category`, _s_) is identical to a List of Unicode code points that is the name of a Unicode general category or general category alias listed in the “Property value and aliases” column of <emu-xref href=\"#table-unicode-general-category-values\"></emu-xref>, then", "            1. Return the CharSet containing all Unicode code points whose character database definition includes the property “General_Category” with value _s_.", "          1. Let _p_ be ! UnicodeMatchProperty(_s_).", "          1. Assert: _p_ is a binary Unicode property or binary property alias listed in the “Property name and aliases” column of <emu-xref href=\"#table-binary-unicode-properties\"></emu-xref>.", "          1. Return the CharSet containing all Unicode code points whose character database definition includes the property _p_ with value “True”."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "UnicodePropertyValueExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LoneUnicodePropertyNameOrValue",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-characterclassescape",
    "rawBody": "{\n  0:(0) access __x0__ = (LoneUnicodePropertyNameOrValue \"SourceText\")\n  0:let s = __x0__\n  1:(0) ??? \"If ! UnicodeMatchPropertyValue ( code:{General_Category} , id:{s} ) is identical to a List of Unicode code points that is the name of a Unicode general category or general category alias listed in the “ Property value and aliases ” column of link:{table-unicode-general-category-values} , then in:{} out:{}\"\n  3:(1) app __x1__ = (UnicodeMatchProperty s)\n  3:let p = [! __x1__]\n  5:(1) ??? \"Return the CharSet containing all Unicode code points whose character database definition includes the property id:{p} with value “ True ” .\"\n}"
  }, {
    "code": ["          1. Evaluate |ClassRanges| to obtain a CharSet _A_.", "          1. Return the two results _A_ and *false*."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "CharacterClass",
      "rhs": {
        "tokens": [{
          "term": "["
        }, {
          "args": [],
          "name": "ClassRanges",
          "optional": false
        }, {
          "term": "]"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-characterclass",
    "rawBody": "{\n  0:(0) access __x0__ = (ClassRanges \"Evaluation\")\n  0:let A = __x0__\n  1:return (0) (new [A, false])\n}"
  }, {
    "code": ["          1. Evaluate |ClassRanges| to obtain a CharSet _A_.", "          1. Return the two results _A_ and *true*."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "CharacterClass",
      "rhs": {
        "tokens": [{
          "term": "["
        }, {
          "term": "^"
        }, {
          "args": [],
          "name": "ClassRanges",
          "optional": false
        }, {
          "term": "]"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-characterclass",
    "rawBody": "{\n  0:(0) access __x0__ = (ClassRanges \"Evaluation\")\n  0:let A = __x0__\n  1:return (0) (new [A, true])\n}"
  }, {
    "code": ["          1. Return the empty CharSet."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "ClassRanges",
      "rhs": {
        "tokens": [{
          "empty": null
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-classranges",
    "rawBody": "return (0) (new [])"
  }, {
    "code": ["          1. Return the CharSet that is the result of evaluating |NonemptyClassRanges|."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "ClassRanges",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "NonemptyClassRanges",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-classranges",
    "rawBody": "{\n  0:(0) access __x0__ = (NonemptyClassRanges \"Evaluation\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return the CharSet that is the result of evaluating |ClassAtom|."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "NonemptyClassRanges",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ClassAtom",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-nonemptyclassranges",
    "rawBody": "{\n  0:(0) access __x0__ = (ClassAtom \"Evaluation\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Evaluate |ClassAtom| to obtain a CharSet _A_.", "          1. Evaluate |NonemptyClassRangesNoDash| to obtain a CharSet _B_.", "          1. Return the union of CharSets _A_ and _B_."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "NonemptyClassRanges",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ClassAtom",
          "optional": false
        }, {
          "args": [],
          "name": "NonemptyClassRangesNoDash",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-nonemptyclassranges",
    "rawBody": "{\n  0:(0) access __x0__ = (ClassAtom \"Evaluation\")\n  0:let A = __x0__\n  1:(1) access __x1__ = (NonemptyClassRangesNoDash \"Evaluation\")\n  1:let B = __x1__\n  2:return (+ A B)\n}"
  }, {
    "code": ["          1. Evaluate the first |ClassAtom| to obtain a CharSet _A_.", "          1. Evaluate the second |ClassAtom| to obtain a CharSet _B_.", "          1. Evaluate |ClassRanges| to obtain a CharSet _C_.", "          1. Let _D_ be ! CharacterRange(_A_, _B_).", "          1. Return the union of _D_ and _C_."],
    "head": {
      "idx": 2,
      "methodName": "Evaluation",
      "prod": "NonemptyClassRanges",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ClassAtom",
          "optional": false
        }, {
          "term": "-"
        }, {
          "args": [],
          "name": "ClassAtom",
          "optional": false
        }, {
          "args": [],
          "name": "ClassRanges",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-nonemptyclassranges",
    "rawBody": "{\n  0:(0) access __x0__ = (ClassAtom0 \"Evaluation\")\n  0:let A = __x0__\n  1:(1) access __x1__ = (ClassAtom1 \"Evaluation\")\n  1:let B = __x1__\n  2:(2) access __x2__ = (ClassRanges \"Evaluation\")\n  2:let C = __x2__\n  3:(3) app __x3__ = (CharacterRange A B)\n  3:let D = [! __x3__]\n  4:(0) ??? \"Return the union of id:{D} and id:{C} .\"\n}"
  }, {
    "code": ["            1. Assert: _A_ and _B_ each contain exactly one character.", "            1. Let _a_ be the one character in CharSet _A_.", "            1. Let _b_ be the one character in CharSet _B_.", "            1. Let _i_ be the character value of character _a_.", "            1. Let _j_ be the character value of character _b_.", "            1. Assert: _i_ ≤ _j_.", "            1. Return the CharSet containing all characters with a character value greater than or equal to _i_ and less than or equal to _j_."],
    "head": {
      "name": "CharacterRange",
      "params": [{
        "kind": "Normal",
        "name": "A"
      }, {
        "kind": "Normal",
        "name": "B"
      }]
    },
    "ids": "sec-runtime-semantics-characterrange-abstract-operation",
    "rawBody": "{\n  1:let a = A[0i]\n  2:let b = B[0i]\n  3:let i = a\n  4:let j = b\n  5:assert (! (< j i))\n  6:(0) ??? \"Return the CharSet containing all characters with a character value greater than or equal to id:{i} and less than or equal to id:{j} .\"\n}"
  }, {
    "code": ["          1. Return the CharSet that is the result of evaluating |ClassAtom|."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "NonemptyClassRangesNoDash",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ClassAtom",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-nonemptyclassrangesnodash",
    "rawBody": "{\n  0:(0) access __x0__ = (ClassAtom \"Evaluation\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Evaluate |ClassAtomNoDash| to obtain a CharSet _A_.", "          1. Evaluate |NonemptyClassRangesNoDash| to obtain a CharSet _B_.", "          1. Return the union of CharSets _A_ and _B_."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "NonemptyClassRangesNoDash",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ClassAtomNoDash",
          "optional": false
        }, {
          "args": [],
          "name": "NonemptyClassRangesNoDash",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-nonemptyclassrangesnodash",
    "rawBody": "{\n  0:(0) access __x0__ = (ClassAtomNoDash \"Evaluation\")\n  0:let A = __x0__\n  1:(1) access __x1__ = (NonemptyClassRangesNoDash \"Evaluation\")\n  1:let B = __x1__\n  2:return (+ A B)\n}"
  }, {
    "code": ["          1. Evaluate |ClassAtomNoDash| to obtain a CharSet _A_.", "          1. Evaluate |ClassAtom| to obtain a CharSet _B_.", "          1. Evaluate |ClassRanges| to obtain a CharSet _C_.", "          1. Let _D_ be ! CharacterRange(_A_, _B_).", "          1. Return the union of _D_ and _C_."],
    "head": {
      "idx": 2,
      "methodName": "Evaluation",
      "prod": "NonemptyClassRangesNoDash",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ClassAtomNoDash",
          "optional": false
        }, {
          "term": "-"
        }, {
          "args": [],
          "name": "ClassAtom",
          "optional": false
        }, {
          "args": [],
          "name": "ClassRanges",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-nonemptyclassrangesnodash",
    "rawBody": "{\n  0:(0) access __x0__ = (ClassAtomNoDash \"Evaluation\")\n  0:let A = __x0__\n  1:(1) access __x1__ = (ClassAtom \"Evaluation\")\n  1:let B = __x1__\n  2:(2) access __x2__ = (ClassRanges \"Evaluation\")\n  2:let C = __x2__\n  3:(3) app __x3__ = (CharacterRange A B)\n  3:let D = [! __x3__]\n  4:(0) ??? \"Return the union of id:{D} and id:{C} .\"\n}"
  }, {
    "code": ["          1. Return the CharSet containing the single character `-` U+002D (HYPHEN-MINUS)."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "ClassAtom",
      "rhs": {
        "tokens": [{
          "term": "-"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-classatom",
    "rawBody": "(0) ??? \"Return the CharSet containing the single character code:{-} U + 002D ( HYPHEN - MINUS ) .\""
  }, {
    "code": ["          1. Return the CharSet that is the result of evaluating |ClassAtomNoDash|."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "ClassAtom",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ClassAtomNoDash",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-classatom",
    "rawBody": "{\n  0:(0) access __x0__ = (ClassAtomNoDash \"Evaluation\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Return the CharSet containing the character matched by |SourceCharacter|."],
    "head": {
      "idx": 0,
      "methodName": "Evaluation",
      "prod": "ClassAtomNoDash",
      "rhs": {
        "tokens": [{
          "base": {
            "args": [],
            "name": "SourceCharacter",
            "optional": false
          },
          "cases": [{
            "term": "\\"
          }, {
            "term": "]"
          }, {
            "term": "-"
          }]
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-classatomnodash",
    "rawBody": "return (0) (new [SourceCharacter])"
  }, {
    "code": ["          1. Return the CharSet that is the result of evaluating |ClassEscape|."],
    "head": {
      "idx": 1,
      "methodName": "Evaluation",
      "prod": "ClassAtomNoDash",
      "rhs": {
        "tokens": [{
          "term": "\\"
        }, {
          "args": [],
          "name": "ClassEscape",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-classatomnodash",
    "rawBody": "{\n  0:(0) access __x0__ = (ClassEscape \"Evaluation\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Let _cv_ be the CharacterValue of this |ClassEscape|.", "          1. Let _c_ be the character whose character value is _cv_.", "          1. Return the CharSet containing the single character _c_."],
    "head": {
      "idx": 0,
      "methodName": "ClassEscape",
      "prod": "ClassEscape",
      "rhs": {
        "tokens": [{
          "term": "b"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-classescape",
    "rawBody": "{\n  0:(0) access __x0__ = (this \"CharacterValue\")\n  0:let cv = __x0__\n  1:let c = cv\n  2:return (0) (new [c])\n}"
  }, {
    "code": ["          1. Let _cv_ be the CharacterValue of this |ClassEscape|.", "          1. Let _c_ be the character whose character value is _cv_.", "          1. Return the CharSet containing the single character _c_."],
    "head": {
      "idx": 1,
      "methodName": "ClassEscape",
      "prod": "ClassEscape",
      "rhs": {
        "tokens": [{
          "term": "-"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-classescape",
    "rawBody": "{\n  0:(0) access __x0__ = (this \"CharacterValue\")\n  0:let cv = __x0__\n  1:let c = cv\n  2:return (0) (new [c])\n}"
  }, {
    "code": ["          1. Let _cv_ be the CharacterValue of this |ClassEscape|.", "          1. Let _c_ be the character whose character value is _cv_.", "          1. Return the CharSet containing the single character _c_."],
    "head": {
      "idx": 3,
      "methodName": "ClassEscape",
      "prod": "ClassEscape",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CharacterEscape",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-classescape",
    "rawBody": "{\n  0:(0) access __x0__ = (this \"CharacterValue\")\n  0:let cv = __x0__\n  1:let c = cv\n  2:return (0) (new [c])\n}"
  }, {
    "code": ["          1. Return the CharSet that is the result of evaluating |CharacterClassEscape|."],
    "head": {
      "idx": 2,
      "methodName": "ClassEscape",
      "prod": "ClassEscape",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CharacterClassEscape",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-classescape",
    "rawBody": "{\n  0:(0) access __x0__ = (CharacterClassEscape \"Evaluation\")\n  0:return __x0__\n}"
  }, {
    "code": ["          1. Let _patternIsRegExp_ be ? IsRegExp(_pattern_).", "          1. If NewTarget is *undefined*, then", "            1. Let _newTarget_ be the active function object.", "            1. If _patternIsRegExp_ is *true* and _flags_ is *undefined*, then", "              1. Let _patternConstructor_ be ? Get(_pattern_, *\"constructor\"*).", "              1. If SameValue(_newTarget_, _patternConstructor_) is *true*, return _pattern_.", "          1. Else, let _newTarget_ be NewTarget.", "          1. If Type(_pattern_) is Object and _pattern_ has a [[RegExpMatcher]] internal slot, then", "            1. Let _P_ be _pattern_.[[OriginalSource]].", "            1. If _flags_ is *undefined*, let _F_ be _pattern_.[[OriginalFlags]].", "            1. Else, let _F_ be _flags_.", "          1. Else if _patternIsRegExp_ is *true*, then", "            1. Let _P_ be ? Get(_pattern_, *\"source\"*).", "            1. If _flags_ is *undefined*, then", "              1. Let _F_ be ? Get(_pattern_, *\"flags\"*).", "            1. Else, let _F_ be _flags_.", "          1. Else,", "            1. Let _P_ be _pattern_.", "            1. Let _F_ be _flags_.", "          1. Let _O_ be ? RegExpAlloc(_newTarget_).", "          1. Return ? RegExpInitialize(_O_, _P_, _F_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "pattern"
      }, {
        "kind": "Normal",
        "name": "flags"
      }],
      "ref": "RegExp"
    },
    "ids": "sec-regexp-pattern-flags",
    "rawBody": "{\n  0:(0) app __x0__ = (IsRegExp pattern)\n  0:let patternIsRegExp = [? __x0__]\n  6:if (= NewTarget undefined) {\n    2:let newTarget = CONTEXT[\"Function\"]\n    3:if (&& (= patternIsRegExp true) (= flags undefined)) {\n      4:(1) app __x1__ = (Get pattern \"constructor\")\n      4:let patternConstructor = [? __x1__]\n      5:(2) app __x2__ = (SameValue newTarget patternConstructor)\n      5:if (= __x2__ true) return pattern else 0:{}\n    } else 0:{}\n  } else let newTarget = NewTarget\n  16:if (&& (= (typeof pattern) Object) (! (= pattern[\"RegExpMatcher\"] absent))) {\n    8:let P = pattern[\"OriginalSource\"]\n    10:if (= flags undefined) let F = pattern[\"OriginalFlags\"] else let F = flags\n  } else if (= patternIsRegExp true) {\n    12:(3) app __x3__ = (Get pattern \"source\")\n    12:let P = [? __x3__]\n    15:if (= flags undefined) {\n      14:(4) app __x4__ = (Get pattern \"flags\")\n      14:let F = [? __x4__]\n    } else let F = flags\n  } else {\n    17:let P = pattern\n    18:let F = flags\n  }\n  19:(5) app __x5__ = (RegExpAlloc newTarget)\n  19:let O = [? __x5__]\n  20:(6) app __x6__ = (RegExpInitialize O P F)\n  20:return [? __x6__]\n}"
  }, {
    "code": ["            1. Let _obj_ be ? OrdinaryCreateFromConstructor(_newTarget_, *\"%RegExp.prototype%\"*, « [[RegExpMatcher]], [[OriginalSource]], [[OriginalFlags]] »).", "            1. Perform ! DefinePropertyOrThrow(_obj_, *\"lastIndex\"*, PropertyDescriptor { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).", "            1. Return _obj_."],
    "head": {
      "name": "RegExpAlloc",
      "params": [{
        "kind": "Normal",
        "name": "newTarget"
      }]
    },
    "ids": "sec-regexpalloc",
    "rawBody": "{\n  0:(0) app __x0__ = (OrdinaryCreateFromConstructor newTarget \"%RegExp.prototype%\" (0) (new [\"RegExpMatcher\", \"OriginalSource\", \"OriginalFlags\"]))\n  0:let obj = [? __x0__]\n  1:(1) app __x1__ = (DefinePropertyOrThrow obj \"lastIndex\" (1) (new PropertyDescriptor(\"Writable\" -> true, \"Enumerable\" -> false, \"Configurable\" -> false)))\n  1:[! __x1__]\n  2:return obj\n}"
  }, {
    "code": ["            1. If _pattern_ is *undefined*, let _P_ be the empty String.", "            1. Else, let _P_ be ? ToString(_pattern_).", "            1. If _flags_ is *undefined*, let _F_ be the empty String.", "            1. Else, let _F_ be ? ToString(_flags_).", "            1. If _F_ contains any code unit other than *\"g\"*, *\"i\"*, *\"m\"*, *\"s\"*, *\"u\"*, or *\"y\"* or if it contains the same code unit more than once, throw a *SyntaxError* exception.", "            1. If _F_ contains *\"u\"*, let _u_ be *true*; else let _u_ be *false*.", "            1. If _u_ is *true*, then", "              1. Let _patternText_ be ! StringToCodePoints(_P_).", "              1. Let _patternCharacters_ be a List whose elements are the code points of _patternText_.", "            1. Else,", "              1. Let _patternText_ be the result of interpreting each of _P_'s 16-bit elements as a Unicode BMP code point. UTF-16 decoding is not applied to the elements.", "              1. Let _patternCharacters_ be a List whose elements are the code unit elements of _P_.", "            1. Let _parseResult_ be ParsePattern(_patternText_, _u_).", "            1. If _parseResult_ is a non-empty List of *SyntaxError* objects, throw a *SyntaxError* exception.", "            1. Assert: _parseResult_ is a Parse Node for |Pattern|.", "            1. Set _obj_.[[OriginalSource]] to _P_.", "            1. Set _obj_.[[OriginalFlags]] to _F_.", "            1. Set _obj_.[[RegExpMatcher]] to the Abstract Closure that evaluates _parseResult_ by applying the semantics provided in <emu-xref href=\"#sec-pattern-semantics\"></emu-xref> using _patternCharacters_ as the pattern's List of |SourceCharacter| values and _F_ as the flag parameters.", "            1. Perform ? Set(_obj_, *\"lastIndex\"*, *+0*<sub>𝔽</sub>, *true*).", "            1. Return _obj_."],
    "head": {
      "name": "RegExpInitialize",
      "params": [{
        "kind": "Normal",
        "name": "obj"
      }, {
        "kind": "Normal",
        "name": "pattern"
      }, {
        "kind": "Normal",
        "name": "flags"
      }]
    },
    "ids": "sec-regexpinitialize",
    "rawBody": "{\n  1:if (= pattern undefined) let P = \"\" else {\n    (0) app __x0__ = (ToString pattern)\n    let P = [? __x0__]\n  }\n  3:if (= flags undefined) let F = \"\" else {\n    (1) app __x1__ = (ToString flags)\n    let F = [? __x1__]\n  }\n  4:(0) ??? \"If id:{F} contains any code unit other than value:{\\\"g\\\"} , value:{\\\"i\\\"} , value:{\\\"m\\\"} , value:{\\\"s\\\"} , value:{\\\"u\\\"} , or value:{\\\"y\\\"} or if it contains the same code unit more than once , throw a value:{SyntaxError} exception .\"\n  5:if (contains F \"u\") let u = true else let u = false\n  9:if (= u true) {\n    7:(2) app __x2__ = (StringToCodePoints P)\n    7:let patternText = [! __x2__]\n    8:(1) ??? \"Let id:{patternCharacters} be a List whose elements are the code points of id:{patternText} .\"\n  } else {\n    10:(2) ??? \"Let id:{patternText} be the result of interpreting each of id:{P} ' s 16 - bit elements as a Unicode BMP code point . UTF - 16 decoding is not applied to the elements .\"\n    11:(3) ??? \"Let id:{patternCharacters} be a List whose elements are the code unit elements of id:{P} .\"\n  }\n  12:(3) app __x3__ = (ParsePattern patternText u)\n  12:let parseResult = __x3__\n  13:(4) ??? \"If id:{parseResult} is a non - empty List of value:{SyntaxError} objects , throw a value:{SyntaxError} exception .\"\n  15:obj[\"OriginalSource\"] = P\n  16:obj[\"OriginalFlags\"] = F\n  17:obj[\"RegExpMatcher\"] = null\n  18:(4) app __x4__ = (Set obj \"lastIndex\" 0i true)\n  18:[? __x4__]\n  19:return obj\n}"
  }, {
    "code": ["            1. If _u_ is *true*, then", "              1. Let _parseResult_ be ParseText(_patternText_, |Pattern[+U, +N]|).", "            1. Else,", "              1. Let _parseResult_ be ParseText(_patternText_, |Pattern[~U, ~N]|).", "              1. If _parseResult_ is a Parse Node and _parseResult_ contains a |GroupName|, then", "                1. Set _parseResult_ to ParseText(_patternText_, |Pattern[~U, +N]|).", "            1. Return _parseResult_."],
    "head": {
      "name": "ParsePattern",
      "params": [{
        "kind": "Normal",
        "name": "patternText"
      }, {
        "kind": "Normal",
        "name": "u"
      }]
    },
    "ids": "sec-parsepattern",
    "rawBody": "{\n  2:if (= u true) let parseResult = (parse-syntax patternText \"Pattern\" (0) (new [true, true])) else {\n    3:let parseResult = (parse-syntax patternText \"Pattern\" (1) (new [false, false]))\n    4:parseResult = (parse-syntax patternText \"Pattern\" (2) (new [false, true]))\n  }\n  6:return parseResult\n}"
  }, {
    "code": ["            1. Let _obj_ be ? RegExpAlloc(%RegExp%).", "            1. Return ? RegExpInitialize(_obj_, _P_, _F_)."],
    "head": {
      "name": "RegExpCreate",
      "params": [{
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Normal",
        "name": "F"
      }]
    },
    "ids": "sec-regexpcreate",
    "rawBody": "{\n  0:(0) app __x0__ = (RegExpAlloc INTRINSIC_RegExp)\n  0:let obj = [? __x0__]\n  1:(1) app __x1__ = (RegExpInitialize obj P F)\n  1:return [? __x1__]\n}"
  }, {
    "code": ["            1. Let _S_ be a String in the form of a |Pattern[~U]| (|Pattern[+U]| if _F_ contains *\"u\"*) equivalent to _P_ interpreted as UTF-16 encoded Unicode code points (<emu-xref href=\"#sec-ecmascript-language-types-string-type\"></emu-xref>), in which certain code points are escaped as described below. _S_ may or may not be identical to _P_; however, the Abstract Closure that would result from evaluating _S_ as a |Pattern[~U]| (|Pattern[+U]| if _F_ contains *\"u\"*) must behave identically to the Abstract Closure given by the constructed object's [[RegExpMatcher]] internal slot. Multiple calls to this abstract operation using the same values for _P_ and _F_ must produce identical results.", "            1. The code points `/` or any |LineTerminator| occurring in the pattern shall be escaped in _S_ as necessary to ensure that the string-concatenation of *\"/\"*, _S_, *\"/\"*, and _F_ can be parsed (in an appropriate lexical context) as a |RegularExpressionLiteral| that behaves identically to the constructed regular expression. For example, if _P_ is *\"/\"*, then _S_ could be *\"\\\\/\"* or *\"\\\\u002F\"*, among other possibilities, but not *\"/\"*, because `///` followed by _F_ would be parsed as a |SingleLineComment| rather than a |RegularExpressionLiteral|. If _P_ is the empty String, this specification can be met by letting _S_ be *\"(?:)\"*.", "            1. Return _S_."],
    "head": {
      "name": "EscapeRegExpPattern",
      "params": [{
        "kind": "Normal",
        "name": "P"
      }, {
        "kind": "Normal",
        "name": "F"
      }]
    },
    "ids": "sec-escaperegexppattern",
    "rawBody": "{\n  0:(0) ??? \"Let id:{S} be a String in the form of a nt:{Pattern[~U]} ( nt:{Pattern[+U]} if id:{F} contains value:{\\\"u\\\"} ) equivalent to id:{P} interpreted as UTF - 16 encoded Unicode code points ( link:{sec-ecmascript-language-types-string-type} ) , in which certain code points are escaped as described below . id:{S} may or may not be identical to id:{P} ; however , the Abstract Closure that would result from evaluating id:{S} as a nt:{Pattern[~U]} ( nt:{Pattern[+U]} if id:{F} contains value:{\\\"u\\\"} ) must behave identically to the Abstract Closure given by the constructed object ' s [ [ RegExpMatcher ] ] internal slot . Multiple calls to this abstract operation using the same values for id:{P} and id:{F} must produce identical results .\"\n  1:(1) ??? \"The code points code:{/} or any nt:{LineTerminator} occurring in the pattern shall be escaped in id:{S} as necessary to ensure that the string - concatenation of value:{\\\"/\\\"} , id:{S} , value:{\\\"/\\\"} , and id:{F} can be parsed ( in an appropriate lexical context ) as a nt:{RegularExpressionLiteral} that behaves identically to the constructed regular expression . For example , if id:{P} is value:{\\\"/\\\"} , then id:{S} could be value:{\\\"/\\\"} or value:{\\\"u002F\\\"} , among other possibilities , but not value:{\\\"/\\\"} , because code:{///} followed by id:{F} would be parsed as a nt:{SingleLineComment} rather than a nt:{RegularExpressionLiteral} . If id:{P} is the empty String , this specification can be met by letting id:{S} be value:{\\\"(?:)\\\"} .\"\n  2:return S\n}"
  }, {
    "code": ["          1. Return the *this* value."],
    "head": {
      "origParams": [],
      "ref": "getRegExp[SYMBOL_species]"
    },
    "ids": "sec-get-regexp-@@species",
    "rawBody": "return this"
  }, {
    "code": ["          1. Let _R_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_R_, [[RegExpMatcher]]).", "          1. Let _S_ be ? ToString(_string_).", "          1. Return ? RegExpBuiltinExec(_R_, _S_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "string"
      }],
      "ref": "RegExp[\"prototype\"][\"exec\"]"
    },
    "ids": "sec-regexp.prototype.exec",
    "rawBody": "{\n  0:let R = this\n  1:(0) app __x0__ = (RequireInternalSlot R \"RegExpMatcher\")\n  1:[? __x0__]\n  2:(1) app __x1__ = (ToString string)\n  2:let S = [? __x1__]\n  3:(2) app __x2__ = (RegExpBuiltinExec R S)\n  3:return [? __x2__]\n}"
  }, {
    "code": ["            1. Assert: Type(_R_) is Object.", "            1. Assert: Type(_S_) is String.", "            1. Let _exec_ be ? Get(_R_, *\"exec\"*).", "            1. If IsCallable(_exec_) is *true*, then", "              1. Let _result_ be ? Call(_exec_, _R_, « _S_ »).", "              1. If Type(_result_) is neither Object nor Null, throw a *TypeError* exception.", "              1. Return _result_.", "            1. Perform ? RequireInternalSlot(_R_, [[RegExpMatcher]]).", "            1. Return ? RegExpBuiltinExec(_R_, _S_)."],
    "head": {
      "name": "RegExpExec",
      "params": [{
        "kind": "Normal",
        "name": "R"
      }, {
        "kind": "Normal",
        "name": "S"
      }]
    },
    "ids": "sec-regexpexec",
    "rawBody": "{\n  0:assert (= (typeof R) Object)\n  1:assert (= (typeof S) String)\n  2:(0) app __x0__ = (Get R \"exec\")\n  2:let exec = [? __x0__]\n  3:(1) app __x1__ = (IsCallable exec)\n  3:if (= __x1__ true) {\n    4:(2) app __x2__ = (Call exec R (0) (new [S]))\n    4:let result = [? __x2__]\n    5:if (! (|| (= (typeof result) Object) (= (typeof result) Null))) (1) throw TypeError else 14:{}\n    6:return result\n  } else 14:{}\n  7:(3) app __x3__ = (RequireInternalSlot R \"RegExpMatcher\")\n  7:[? __x3__]\n  8:(4) app __x4__ = (RegExpBuiltinExec R S)\n  8:return [? __x4__]\n}"
  }, {
    "code": ["            1. Assert: _R_ is an initialized RegExp instance.", "            1. Assert: Type(_S_) is String.", "            1. Let _length_ be the number of code units in _S_.", "            1. Let _lastIndex_ be ℝ(? ToLength(? Get(_R_, *\"lastIndex\"*))).", "            1. Let _flags_ be _R_.[[OriginalFlags]].", "            1. If _flags_ contains *\"g\"*, let _global_ be *true*; else let _global_ be *false*.", "            1. If _flags_ contains *\"y\"*, let _sticky_ be *true*; else let _sticky_ be *false*.", "            1. If _global_ is *false* and _sticky_ is *false*, set _lastIndex_ to 0.", "            1. Let _matcher_ be _R_.[[RegExpMatcher]].", "            1. If _flags_ contains *\"u\"*, let _fullUnicode_ be *true*; else let _fullUnicode_ be *false*.", "            1. Let _matchSucceeded_ be *false*.", "            1. Repeat, while _matchSucceeded_ is *false*,", "              1. If _lastIndex_ > _length_, then", "                1. If _global_ is *true* or _sticky_ is *true*, then", "                  1. Perform ? Set(_R_, *\"lastIndex\"*, *+0*<sub>𝔽</sub>, *true*).", "                1. Return *null*.", "              1. Let _r_ be _matcher_(_S_, _lastIndex_).", "              1. If _r_ is ~failure~, then", "                1. If _sticky_ is *true*, then", "                  1. Perform ? Set(_R_, *\"lastIndex\"*, *+0*<sub>𝔽</sub>, *true*).", "                  1. Return *null*.", "                1. Set _lastIndex_ to AdvanceStringIndex(_S_, _lastIndex_, _fullUnicode_).", "              1. Else,", "                1. Assert: _r_ is a State.", "                1. Set _matchSucceeded_ to *true*.", "            1. Let _e_ be _r_'s _endIndex_ value.", "            1. If _fullUnicode_ is *true*, then", "              1. _e_ is an index into the _Input_ character list, derived from _S_, matched by _matcher_. Let _eUTF_ be the smallest index into _S_ that corresponds to the character at element _e_ of _Input_. If _e_ is greater than or equal to the number of elements in _Input_, then _eUTF_ is the number of code units in _S_.", "              1. Set _e_ to _eUTF_.", "            1. If _global_ is *true* or _sticky_ is *true*, then", "              1. Perform ? Set(_R_, *\"lastIndex\"*, 𝔽(_e_), *true*).", "            1. Let _n_ be the number of elements in _r_'s _captures_ List. (This is the same value as <emu-xref href=\"#sec-notation\"></emu-xref>'s _NcapturingParens_.)", "            1. Assert: _n_ < 2<sup>32</sup> - 1.", "            1. Let _A_ be ! ArrayCreate(_n_ + 1).", "            1. Assert: The mathematical value of _A_'s *\"length\"* property is _n_ + 1.", "            1. Perform ! CreateDataPropertyOrThrow(_A_, *\"index\"*, 𝔽(_lastIndex_)).", "            1. Perform ! CreateDataPropertyOrThrow(_A_, *\"input\"*, _S_).", "            1. Let _matchedSubstr_ be the substring of _S_ from _lastIndex_ to _e_.", "            1. Perform ! CreateDataPropertyOrThrow(_A_, *\"0\"*, _matchedSubstr_).", "            1. If _R_ contains any |GroupName|, then", "              1. Let _groups_ be ! OrdinaryObjectCreate(*null*).", "            1. Else,", "              1. Let _groups_ be *undefined*.", "            1. Perform ! CreateDataPropertyOrThrow(_A_, *\"groups\"*, _groups_).", "            1. For each integer _i_ such that _i_ ≥ 1 and _i_ ≤ _n_, do", "              1. Let _captureI_ be _i_<sup>th</sup> element of _r_'s _captures_ List.", "              1. If _captureI_ is *undefined*, let _capturedValue_ be *undefined*.", "              1. Else if _fullUnicode_ is *true*, then", "                1. Assert: _captureI_ is a List of code points.", "                1. Let _capturedValue_ be ! CodePointsToString(_captureI_).", "              1. Else,", "                1. Assert: _fullUnicode_ is *false*.", "                1. Assert: _captureI_ is a List of code units.", "                1. Let _capturedValue_ be the String value consisting of the code units of _captureI_.", "              1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_i_)), _capturedValue_).", "              1. If the _i_<sup>th</sup> capture of _R_ was defined with a |GroupName|, then", "                1. Let _s_ be the CapturingGroupName of the corresponding |RegExpIdentifierName|.", "                1. Perform ! CreateDataPropertyOrThrow(_groups_, _s_, _capturedValue_).", "            1. Return _A_."],
    "head": {
      "name": "RegExpBuiltinExec",
      "params": [{
        "kind": "Normal",
        "name": "R"
      }, {
        "kind": "Normal",
        "name": "S"
      }]
    },
    "ids": "sec-regexpbuiltinexec",
    "rawBody": "{\n  1:assert (= (typeof S) String)\n  2:let length = S[\"length\"]\n  3:(0) app __x0__ = (Get R \"lastIndex\")\n  3:(1) app __x1__ = (ToLength [? __x0__])\n  3:let lastIndex = [? __x1__]\n  4:let flags = R[\"OriginalFlags\"]\n  5:if (contains flags \"g\") let global = true else let global = false\n  6:if (contains flags \"y\") let sticky = true else let sticky = false\n  7:if (&& (= global false) (= sticky false)) lastIndex = 0i else 52:{}\n  8:let matcher = R[\"RegExpMatcher\"]\n  9:if (contains flags \"u\") let fullUnicode = true else let fullUnicode = false\n  10:let matchSucceeded = false\n  11:while (= matchSucceeded false) {\n    12:if (< length lastIndex) {\n      13:if (|| (= global true) (= sticky true)) {\n        14:(2) app __x2__ = (Set R \"lastIndex\" 0i true)\n        14:[? __x2__]\n      } else 52:{}\n      15:return null\n    } else 52:{}\n    16:(3) app __x3__ = (matcher S lastIndex)\n    16:let r = __x3__\n    22:if (= r CONST_failure) {\n      18:if (= sticky true) {\n        19:(4) app __x4__ = (Set R \"lastIndex\" 0i true)\n        19:[? __x4__]\n        20:return null\n      } else 52:{}\n      21:(5) app __x5__ = (AdvanceStringIndex S lastIndex fullUnicode)\n      21:lastIndex = __x5__\n    } else matchSucceeded = true\n  }\n  25:let e = r[\"endIndex\"]\n  26:if (= fullUnicode true) {\n    27:(0) ??? \"id:{e} is an index into the id:{Input} character list , derived from id:{S} , matched by id:{matcher} . Let id:{eUTF} be the smallest index into id:{S} that corresponds to the character at element id:{e} of id:{Input} . If id:{e} is greater than or equal to the number of elements in id:{Input} , then id:{eUTF} is the number of code units in id:{S} .\"\n    28:e = eUTF\n  } else 52:{}\n  29:if (|| (= global true) (= sticky true)) {\n    30:(6) app __x6__ = (Set R \"lastIndex\" e true)\n    30:[? __x6__]\n  } else 52:{}\n  31:(1) ??? \"Let id:{n} be the number of elements in id:{r} ' s id:{captures} List . ( This is the same value as link:{sec-notation} ' s id:{NcapturingParens} . )\"\n  32:assert (< n (- (** 2.0 32i) 1i))\n  33:(7) app __x7__ = (ArrayCreate (+ n 1i))\n  33:let A = [! __x7__]\n  35:(8) app __x8__ = (CreateDataPropertyOrThrow A \"index\" lastIndex)\n  35:[! __x8__]\n  36:(9) app __x9__ = (CreateDataPropertyOrThrow A \"input\" S)\n  36:[! __x9__]\n  37:let __x10__ = \"\"\n  37:let __x11__ = lastIndex\n  37:while (< __x11__ (+ e 1i)) {\n    (10) access __x12__ = (S __x11__)\n    __x10__ = (+ __x10__ __x12__)\n    __x11__ = (+ __x11__ 1i)\n  }\n  37:let matchedSubstr = __x10__\n  38:(11) app __x13__ = (CreateDataPropertyOrThrow A \"0\" matchedSubstr)\n  38:[! __x13__]\n  39:(2) ??? \"If id:{R} contains any nt:{GroupName} , then in:{} out:{}\"\n  41:(3) ??? \"Else , in:{} out:{}\"\n  43:(12) app __x14__ = (CreateDataPropertyOrThrow A \"groups\" groups)\n  43:[! __x14__]\n  44:(4) ??? \"For each integer id:{i} such that id:{i} ≥ 1 and id:{i} ≤ id:{n} , do in:{} out:{}\"\n  58:return A\n}"
  }, {
    "code": ["            1. Assert: _index_ ≤ 2<sup>53</sup> - 1.", "            1. If _unicode_ is *false*, return _index_ + 1.", "            1. Let _length_ be the number of code units in _S_.", "            1. If _index_ + 1 ≥ _length_, return _index_ + 1.", "            1. Let _cp_ be ! CodePointAt(_S_, _index_).", "            1. Return _index_ + _cp_.[[CodeUnitCount]]."],
    "head": {
      "name": "AdvanceStringIndex",
      "params": [{
        "kind": "Normal",
        "name": "S"
      }, {
        "kind": "Normal",
        "name": "index"
      }, {
        "kind": "Normal",
        "name": "unicode"
      }]
    },
    "ids": "sec-advancestringindex",
    "rawBody": "{\n  0:assert (! (< (- (** 2.0 53i) 1i) index))\n  1:if (= unicode false) return (+ index 1i) else 52:{}\n  2:let length = S[\"length\"]\n  3:if (! (< (+ index 1i) length)) return (+ index 1i) else 52:{}\n  4:(0) app __x0__ = (CodePointAt S index)\n  4:let cp = [! __x0__]\n  5:return (+ index cp[\"CodeUnitCount\"])\n}"
  }, {
    "code": ["          1. Let _R_ be the *this* value.", "          1. If Type(_R_) is not Object, throw a *TypeError* exception.", "          1. If _R_ does not have an [[OriginalFlags]] internal slot, then", "            1. If SameValue(_R_, %RegExp.prototype%) is *true*, return *undefined*.", "            1. Otherwise, throw a *TypeError* exception.", "          1. Let _flags_ be _R_.[[OriginalFlags]].", "          1. If _flags_ contains the code unit 0x0073 (LATIN SMALL LETTER S), return *true*.", "          1. Return *false*."],
    "head": {
      "origParams": [],
      "ref": "getRegExp[\"prototype\"][\"dotAll\"]"
    },
    "ids": "sec-get-regexp.prototype.dotAll",
    "rawBody": "{\n  0:let R = this\n  1:if (! (= (typeof R) Object)) (0) throw TypeError else 52:{}\n  2:if (= R[\"OriginalFlags\"] absent) {\n    4:(0) app __x0__ = (SameValue R INTRINSIC_RegExp_prototype)\n    4:if (= __x0__ true) return undefined else (1) throw TypeError\n  } else 52:{}\n  5:let flags = R[\"OriginalFlags\"]\n  6:if (contains flags \"s\") return true else 52:{}\n  7:return false\n}"
  }, {
    "code": ["          1. Let _R_ be the *this* value.", "          1. If Type(_R_) is not Object, throw a *TypeError* exception.", "          1. Let _result_ be the empty String.", "          1. Let _global_ be ! ToBoolean(? Get(_R_, *\"global\"*)).", "          1. If _global_ is *true*, append the code unit 0x0067 (LATIN SMALL LETTER G) as the last code unit of _result_.", "          1. Let _ignoreCase_ be ! ToBoolean(? Get(_R_, *\"ignoreCase\"*)).", "          1. If _ignoreCase_ is *true*, append the code unit 0x0069 (LATIN SMALL LETTER I) as the last code unit of _result_.", "          1. Let _multiline_ be ! ToBoolean(? Get(_R_, *\"multiline\"*)).", "          1. If _multiline_ is *true*, append the code unit 0x006D (LATIN SMALL LETTER M) as the last code unit of _result_.", "          1. Let _dotAll_ be ! ToBoolean(? Get(_R_, *\"dotAll\"*)).", "          1. If _dotAll_ is *true*, append the code unit 0x0073 (LATIN SMALL LETTER S) as the last code unit of _result_.", "          1. Let _unicode_ be ! ToBoolean(? Get(_R_, *\"unicode\"*)).", "          1. If _unicode_ is *true*, append the code unit 0x0075 (LATIN SMALL LETTER U) as the last code unit of _result_.", "          1. Let _sticky_ be ! ToBoolean(? Get(_R_, *\"sticky\"*)).", "          1. If _sticky_ is *true*, append the code unit 0x0079 (LATIN SMALL LETTER Y) as the last code unit of _result_.", "          1. Return _result_."],
    "head": {
      "origParams": [],
      "ref": "getRegExp[\"prototype\"][\"flags\"]"
    },
    "ids": "sec-get-regexp.prototype.flags",
    "rawBody": "{\n  0:let R = this\n  1:if (! (= (typeof R) Object)) (0) throw TypeError else 52:{}\n  2:let result = \"\"\n  3:(0) app __x0__ = (Get R \"global\")\n  3:(1) app __x1__ = (ToBoolean [? __x0__])\n  3:let global = [! __x1__]\n  4:if (= global true) let result = (+ result \"g\") else 52:{}\n  5:(2) app __x2__ = (Get R \"ignoreCase\")\n  5:(3) app __x3__ = (ToBoolean [? __x2__])\n  5:let ignoreCase = [! __x3__]\n  6:if (= ignoreCase true) let result = (+ result \"i\") else 52:{}\n  7:(4) app __x4__ = (Get R \"multiline\")\n  7:(5) app __x5__ = (ToBoolean [? __x4__])\n  7:let multiline = [! __x5__]\n  8:if (= multiline true) let result = (+ result \"m\") else 52:{}\n  9:(6) app __x6__ = (Get R \"dotAll\")\n  9:(7) app __x7__ = (ToBoolean [? __x6__])\n  9:let dotAll = [! __x7__]\n  10:if (= dotAll true) let result = (+ result \"s\") else 52:{}\n  11:(8) app __x8__ = (Get R \"unicode\")\n  11:(9) app __x9__ = (ToBoolean [? __x8__])\n  11:let unicode = [! __x9__]\n  12:if (= unicode true) let result = (+ result \"u\") else 52:{}\n  13:(10) app __x10__ = (Get R \"sticky\")\n  13:(11) app __x11__ = (ToBoolean [? __x10__])\n  13:let sticky = [! __x11__]\n  14:if (= sticky true) let result = (+ result \"y\") else 52:{}\n  15:return result\n}"
  }, {
    "code": ["          1. Let _R_ be the *this* value.", "          1. If Type(_R_) is not Object, throw a *TypeError* exception.", "          1. If _R_ does not have an [[OriginalFlags]] internal slot, then", "            1. If SameValue(_R_, %RegExp.prototype%) is *true*, return *undefined*.", "            1. Otherwise, throw a *TypeError* exception.", "          1. Let _flags_ be _R_.[[OriginalFlags]].", "          1. If _flags_ contains the code unit 0x0067 (LATIN SMALL LETTER G), return *true*.", "          1. Return *false*."],
    "head": {
      "origParams": [],
      "ref": "getRegExp[\"prototype\"][\"global\"]"
    },
    "ids": "sec-get-regexp.prototype.global",
    "rawBody": "{\n  0:let R = this\n  1:if (! (= (typeof R) Object)) (0) throw TypeError else 52:{}\n  2:if (= R[\"OriginalFlags\"] absent) {\n    4:(0) app __x0__ = (SameValue R INTRINSIC_RegExp_prototype)\n    4:if (= __x0__ true) return undefined else (1) throw TypeError\n  } else 52:{}\n  5:let flags = R[\"OriginalFlags\"]\n  6:if (contains flags \"g\") return true else 52:{}\n  7:return false\n}"
  }, {
    "code": ["          1. Let _R_ be the *this* value.", "          1. If Type(_R_) is not Object, throw a *TypeError* exception.", "          1. If _R_ does not have an [[OriginalFlags]] internal slot, then", "            1. If SameValue(_R_, %RegExp.prototype%) is *true*, return *undefined*.", "            1. Otherwise, throw a *TypeError* exception.", "          1. Let _flags_ be _R_.[[OriginalFlags]].", "          1. If _flags_ contains the code unit 0x0069 (LATIN SMALL LETTER I), return *true*.", "          1. Return *false*."],
    "head": {
      "origParams": [],
      "ref": "getRegExp[\"prototype\"][\"ignoreCase\"]"
    },
    "ids": "sec-get-regexp.prototype.ignorecase",
    "rawBody": "{\n  0:let R = this\n  1:if (! (= (typeof R) Object)) (0) throw TypeError else 52:{}\n  2:if (= R[\"OriginalFlags\"] absent) {\n    4:(0) app __x0__ = (SameValue R INTRINSIC_RegExp_prototype)\n    4:if (= __x0__ true) return undefined else (1) throw TypeError\n  } else 52:{}\n  5:let flags = R[\"OriginalFlags\"]\n  6:if (contains flags \"i\") return true else 52:{}\n  7:return false\n}"
  }, {
    "code": ["          1. Let _rx_ be the *this* value.", "          1. If Type(_rx_) is not Object, throw a *TypeError* exception.", "          1. Let _S_ be ? ToString(_string_).", "          1. Let _global_ be ! ToBoolean(? Get(_rx_, *\"global\"*)).", "          1. If _global_ is *false*, then", "            1. Return ? RegExpExec(_rx_, _S_).", "          1. Else,", "            1. Assert: _global_ is *true*.", "            1. Let _fullUnicode_ be ! ToBoolean(? Get(_rx_, *\"unicode\"*)).", "            1. Perform ? Set(_rx_, *\"lastIndex\"*, *+0*<sub>𝔽</sub>, *true*).", "            1. Let _A_ be ! ArrayCreate(0).", "            1. Let _n_ be 0.", "            1. Repeat,", "              1. Let _result_ be ? RegExpExec(_rx_, _S_).", "              1. If _result_ is *null*, then", "                1. If _n_ = 0, return *null*.", "                1. Return _A_.", "              1. Else,", "                1. Let _matchStr_ be ? ToString(? Get(_result_, *\"0\"*)).", "                1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _matchStr_).", "                1. If _matchStr_ is the empty String, then", "                  1. Let _thisIndex_ be ℝ(? ToLength(? Get(_rx_, *\"lastIndex\"*))).", "                  1. Let _nextIndex_ be AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_).", "                  1. Perform ? Set(_rx_, *\"lastIndex\"*, 𝔽(_nextIndex_), *true*).", "                1. Set _n_ to _n_ + 1."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "string"
      }],
      "ref": "RegExp[\"prototype\"][SYMBOL_match]"
    },
    "ids": "sec-regexp.prototype-@@match",
    "rawBody": "{\n  0:let rx = this\n  1:if (! (= (typeof rx) Object)) (0) throw TypeError else 52:{}\n  2:(0) app __x0__ = (ToString string)\n  2:let S = [? __x0__]\n  3:(1) app __x1__ = (Get rx \"global\")\n  3:(2) app __x2__ = (ToBoolean [? __x1__])\n  3:let global = [! __x2__]\n  6:if (= global false) {\n    5:(3) app __x3__ = (RegExpExec rx S)\n    5:return [? __x3__]\n  } else {\n    7:assert (= global true)\n    8:(4) app __x4__ = (Get rx \"unicode\")\n    8:(5) app __x5__ = (ToBoolean [? __x4__])\n    8:let fullUnicode = [! __x5__]\n    9:(6) app __x6__ = (Set rx \"lastIndex\" 0i true)\n    9:[? __x6__]\n    10:(7) app __x7__ = (ArrayCreate 0i)\n    10:let A = [! __x7__]\n    11:let n = 0i\n    12:while true {\n      13:(8) app __x8__ = (RegExpExec rx S)\n      13:let result = [? __x8__]\n      17:if (= result null) {\n        15:if (== n 0i) return null else 52:{}\n        16:return A\n      } else {\n        18:(9) app __x9__ = (Get result \"0\")\n        18:(10) app __x10__ = (ToString [? __x9__])\n        18:let matchStr = [? __x10__]\n        19:(11) app __x11__ = (ToString n)\n        19:(12) app __x12__ = (CreateDataPropertyOrThrow A [! __x11__] matchStr)\n        19:[! __x12__]\n        20:if (= matchStr \"\") {\n          21:(13) app __x13__ = (Get rx \"lastIndex\")\n          21:(14) app __x14__ = (ToLength [? __x13__])\n          21:let thisIndex = [? __x14__]\n          22:(15) app __x15__ = (AdvanceStringIndex S thisIndex fullUnicode)\n          22:let nextIndex = __x15__\n          23:(16) app __x16__ = (Set rx \"lastIndex\" nextIndex true)\n          23:[? __x16__]\n        } else 52:{}\n        24:n = (+ n 1i)\n      }\n    }\n  }\n}"
  }, {
    "code": ["          1. Let _R_ be the *this* value.", "          1. If Type(_R_) is not Object, throw a *TypeError* exception.", "          1. Let _S_ be ? ToString(_string_).", "          1. Let _C_ be ? SpeciesConstructor(_R_, %RegExp%).", "          1. Let _flags_ be ? ToString(? Get(_R_, *\"flags\"*)).", "          1. Let _matcher_ be ? Construct(_C_, « _R_, _flags_ »).", "          1. Let _lastIndex_ be ? ToLength(? Get(_R_, *\"lastIndex\"*)).", "          1. Perform ? Set(_matcher_, *\"lastIndex\"*, _lastIndex_, *true*).", "          1. If _flags_ contains *\"g\"*, let _global_ be *true*.", "          1. Else, let _global_ be *false*.", "          1. If _flags_ contains *\"u\"*, let _fullUnicode_ be *true*.", "          1. Else, let _fullUnicode_ be *false*.", "          1. Return ! CreateRegExpStringIterator(_matcher_, _S_, _global_, _fullUnicode_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "string"
      }],
      "ref": "RegExp[\"prototype\"][SYMBOL_matchAll]"
    },
    "ids": "sec-regexp-prototype-matchall",
    "rawBody": "{\n  0:let R = this\n  1:if (! (= (typeof R) Object)) (0) throw TypeError else 52:{}\n  2:(0) app __x0__ = (ToString string)\n  2:let S = [? __x0__]\n  3:(1) app __x1__ = (SpeciesConstructor R INTRINSIC_RegExp)\n  3:let C = [? __x1__]\n  4:(2) app __x2__ = (Get R \"flags\")\n  4:(3) app __x3__ = (ToString [? __x2__])\n  4:let flags = [? __x3__]\n  5:(4) app __x4__ = (Construct C (1) (new [R, flags]))\n  5:let matcher = [? __x4__]\n  6:(5) app __x5__ = (Get R \"lastIndex\")\n  6:(6) app __x6__ = (ToLength [? __x5__])\n  6:let lastIndex = [? __x6__]\n  7:(7) app __x7__ = (Set matcher \"lastIndex\" lastIndex true)\n  7:[? __x7__]\n  9:if (contains flags \"g\") let global = true else let global = false\n  11:if (contains flags \"u\") let fullUnicode = true else let fullUnicode = false\n  12:(8) app __x8__ = (CreateRegExpStringIterator matcher S global fullUnicode)\n  12:return [! __x8__]\n}"
  }, {
    "code": ["          1. Let _R_ be the *this* value.", "          1. If Type(_R_) is not Object, throw a *TypeError* exception.", "          1. If _R_ does not have an [[OriginalFlags]] internal slot, then", "            1. If SameValue(_R_, %RegExp.prototype%) is *true*, return *undefined*.", "            1. Otherwise, throw a *TypeError* exception.", "          1. Let _flags_ be _R_.[[OriginalFlags]].", "          1. If _flags_ contains the code unit 0x006D (LATIN SMALL LETTER M), return *true*.", "          1. Return *false*."],
    "head": {
      "origParams": [],
      "ref": "getRegExp[\"prototype\"][\"multiline\"]"
    },
    "ids": "sec-get-regexp.prototype.multiline",
    "rawBody": "{\n  0:let R = this\n  1:if (! (= (typeof R) Object)) (0) throw TypeError else 52:{}\n  2:if (= R[\"OriginalFlags\"] absent) {\n    4:(0) app __x0__ = (SameValue R INTRINSIC_RegExp_prototype)\n    4:if (= __x0__ true) return undefined else (1) throw TypeError\n  } else 52:{}\n  5:let flags = R[\"OriginalFlags\"]\n  6:if (contains flags \"m\") return true else 52:{}\n  7:return false\n}"
  }, {
    "code": ["          1. Let _rx_ be the *this* value.", "          1. If Type(_rx_) is not Object, throw a *TypeError* exception.", "          1. Let _S_ be ? ToString(_string_).", "          1. Let _lengthS_ be the number of code unit elements in _S_.", "          1. Let _functionalReplace_ be IsCallable(_replaceValue_).", "          1. If _functionalReplace_ is *false*, then", "            1. Set _replaceValue_ to ? ToString(_replaceValue_).", "          1. Let _global_ be ! ToBoolean(? Get(_rx_, *\"global\"*)).", "          1. If _global_ is *true*, then", "            1. Let _fullUnicode_ be ! ToBoolean(? Get(_rx_, *\"unicode\"*)).", "            1. Perform ? Set(_rx_, *\"lastIndex\"*, *+0*<sub>𝔽</sub>, *true*).", "          1. Let _results_ be a new empty List.", "          1. Let _done_ be *false*.", "          1. Repeat, while _done_ is *false*,", "            1. Let _result_ be ? RegExpExec(_rx_, _S_).", "            1. If _result_ is *null*, set _done_ to *true*.", "            1. Else,", "              1. Append _result_ to the end of _results_.", "              1. If _global_ is *false*, set _done_ to *true*.", "              1. Else,", "                1. Let _matchStr_ be ? ToString(? Get(_result_, *\"0\"*)).", "                1. If _matchStr_ is the empty String, then", "                  1. Let _thisIndex_ be ℝ(? ToLength(? Get(_rx_, *\"lastIndex\"*))).", "                  1. Let _nextIndex_ be AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_).", "                  1. Perform ? Set(_rx_, *\"lastIndex\"*, 𝔽(_nextIndex_), *true*).", "          1. Let _accumulatedResult_ be the empty String.", "          1. Let _nextSourcePosition_ be 0.", "          1. For each element _result_ of _results_, do", "            1. Let _resultLength_ be ? LengthOfArrayLike(_result_).", "            1. Let _nCaptures_ be max(_resultLength_ - 1, 0).", "            1. Let _matched_ be ? ToString(? Get(_result_, *\"0\"*)).", "            1. Let _matchLength_ be the number of code units in _matched_.", "            1. Let _position_ be ? ToIntegerOrInfinity(? Get(_result_, *\"index\"*)).", "            1. Set _position_ to the result of clamping _position_ between 0 and _lengthS_.", "            1. Let _n_ be 1.", "            1. Let _captures_ be a new empty List.", "            1. Repeat, while _n_ ≤ _nCaptures_,", "              1. Let _capN_ be ? Get(_result_, ! ToString(𝔽(_n_))).", "              1. If _capN_ is not *undefined*, then", "                1. Set _capN_ to ? ToString(_capN_).", "              1. Append _capN_ as the last element of _captures_.", "              1. Set _n_ to _n_ + 1.", "            1. Let _namedCaptures_ be ? Get(_result_, *\"groups\"*).", "            1. If _functionalReplace_ is *true*, then", "              1. Let _replacerArgs_ be « _matched_ ».", "              1. Append in List order the elements of _captures_ to the end of the List _replacerArgs_.", "              1. Append 𝔽(_position_) and _S_ to _replacerArgs_.", "              1. If _namedCaptures_ is not *undefined*, then", "                1. Append _namedCaptures_ as the last element of _replacerArgs_.", "              1. Let _replValue_ be ? Call(_replaceValue_, *undefined*, _replacerArgs_).", "              1. Let _replacement_ be ? ToString(_replValue_).", "            1. Else,", "              1. If _namedCaptures_ is not *undefined*, then", "                1. Set _namedCaptures_ to ? ToObject(_namedCaptures_).", "              1. Let _replacement_ be ? GetSubstitution(_matched_, _S_, _position_, _captures_, _namedCaptures_, _replaceValue_).", "            1. If _position_ ≥ _nextSourcePosition_, then", "              1. NOTE: _position_ should not normally move backwards. If it does, it is an indication of an ill-behaving RegExp subclass or use of an access triggered side-effect to change the global flag or other characteristics of _rx_. In such cases, the corresponding substitution is ignored.", "              1. Set _accumulatedResult_ to the string-concatenation of _accumulatedResult_, the substring of _S_ from _nextSourcePosition_ to _position_, and _replacement_.", "              1. Set _nextSourcePosition_ to _position_ + _matchLength_.", "          1. If _nextSourcePosition_ ≥ _lengthS_, return _accumulatedResult_.", "          1. Return the string-concatenation of _accumulatedResult_ and the substring of _S_ from _nextSourcePosition_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "string"
      }, {
        "kind": "Normal",
        "name": "replaceValue"
      }],
      "ref": "RegExp[\"prototype\"][SYMBOL_replace]"
    },
    "ids": "sec-regexp.prototype-@@replace",
    "rawBody": "{\n  0:let rx = this\n  1:if (! (= (typeof rx) Object)) (0) throw TypeError else 56:{}\n  2:(0) app __x0__ = (ToString string)\n  2:let S = [? __x0__]\n  3:let lengthS = S[\"length\"]\n  4:(1) app __x1__ = (IsCallable replaceValue)\n  4:let functionalReplace = __x1__\n  5:if (= functionalReplace false) {\n    6:(2) app __x2__ = (ToString replaceValue)\n    6:replaceValue = [? __x2__]\n  } else 56:{}\n  7:(3) app __x3__ = (Get rx \"global\")\n  7:(4) app __x4__ = (ToBoolean [? __x3__])\n  7:let global = [! __x4__]\n  8:if (= global true) {\n    9:(5) app __x5__ = (Get rx \"unicode\")\n    9:(6) app __x6__ = (ToBoolean [? __x5__])\n    9:let fullUnicode = [! __x6__]\n    10:(7) app __x7__ = (Set rx \"lastIndex\" 0i true)\n    10:[? __x7__]\n  } else 56:{}\n  11:let results = (1) (new [])\n  12:let done = false\n  13:while (= done false) {\n    14:(8) app __x8__ = (RegExpExec rx S)\n    14:let result = [? __x8__]\n    16:if (= result null) done = true else {\n      17:append result -> results\n      19:if (= global false) done = true else {\n        20:(9) app __x9__ = (Get result \"0\")\n        20:(10) app __x10__ = (ToString [? __x9__])\n        20:let matchStr = [? __x10__]\n        21:if (= matchStr \"\") {\n          22:(11) app __x11__ = (Get rx \"lastIndex\")\n          22:(12) app __x12__ = (ToLength [? __x11__])\n          22:let thisIndex = [? __x12__]\n          23:(13) app __x13__ = (AdvanceStringIndex S thisIndex fullUnicode)\n          23:let nextIndex = __x13__\n          24:(14) app __x14__ = (Set rx \"lastIndex\" nextIndex true)\n          24:[? __x14__]\n        } else 56:{}\n      }\n    }\n  }\n  25:let accumulatedResult = \"\"\n  26:let nextSourcePosition = 0i\n  27:let __x15__ = results\n  27:let __x16__ = 0i\n  27:while (< __x16__ __x15__[\"length\"]) {\n    let result = __x15__[__x16__]\n    28:(15) app __x17__ = (LengthOfArrayLike result)\n    28:let resultLength = [? __x17__]\n    29:(16) app __x18__ = (max (- resultLength 1i) 0i)\n    29:let nCaptures = __x18__\n    30:(17) app __x19__ = (Get result \"0\")\n    30:(18) app __x20__ = (ToString [? __x19__])\n    30:let matched = [? __x20__]\n    31:let matchLength = matched[\"length\"]\n    32:(19) app __x21__ = (Get result \"index\")\n    32:(20) app __x22__ = (ToIntegerOrInfinity [? __x21__])\n    32:let position = [? __x22__]\n    33:(2) ??? \"Set id:{position} to the result of clamping id:{position} between 0 and id:{lengthS} .\"\n    34:let n = 1i\n    35:let captures = (3) (new [])\n    36:while (! (< nCaptures n)) {\n      37:(21) app __x23__ = (ToString n)\n      37:(22) app __x24__ = (Get result [! __x23__])\n      37:let capN = [? __x24__]\n      38:if (! (= capN undefined)) {\n        39:(23) app __x25__ = (ToString capN)\n        39:capN = [? __x25__]\n      } else 56:{}\n      40:append capN -> captures\n      41:n = (+ n 1i)\n    }\n    42:(24) app __x26__ = (Get result \"groups\")\n    42:let namedCaptures = [? __x26__]\n    51:if (= functionalReplace true) {\n      44:let replacerArgs = (4) (new [matched])\n      45:let __x27__ = captures\n      45:let __x28__ = 0i\n      45:while (< __x28__ __x27__[\"length\"]) {\n        let __x29__ = __x27__[__x28__]\n        append __x29__ -> replacerArgs\n        __x28__ = (+ __x28__ 1i)\n      }\n      46:append position -> replacerArgs\n      46:append S -> replacerArgs\n      47:if (! (= namedCaptures undefined)) append namedCaptures -> replacerArgs else 56:{}\n      49:(25) app __x30__ = (Call replaceValue undefined replacerArgs)\n      49:let replValue = [? __x30__]\n      50:(26) app __x31__ = (ToString replValue)\n      50:let replacement = [? __x31__]\n    } else {\n      52:if (! (= namedCaptures undefined)) {\n        53:(27) app __x32__ = (ToObject namedCaptures)\n        53:namedCaptures = [? __x32__]\n      } else 56:{}\n      54:(28) app __x33__ = (GetSubstitution matched S position captures namedCaptures replaceValue)\n      54:let replacement = [? __x33__]\n    }\n    55:if (! (< position nextSourcePosition)) {\n      57:let __x34__ = \"\"\n      57:let __x35__ = nextSourcePosition\n      57:while (< __x35__ (+ position 1i)) {\n        (29) access __x36__ = (S __x35__)\n        __x34__ = (+ __x34__ __x36__)\n        __x35__ = (+ __x35__ 1i)\n      }\n      57:accumulatedResult = (+ (+ accumulatedResult __x34__) replacement)\n      58:nextSourcePosition = (+ position matchLength)\n    } else 56:{}\n    __x16__ = (+ __x16__ 1i)\n  }\n  59:if (! (< nextSourcePosition lengthS)) return accumulatedResult else 56:{}\n  60:(5) ??? \"Return the string - concatenation of id:{accumulatedResult} and the substring of id:{S} from id:{nextSourcePosition} .\"\n}"
  }, {
    "code": ["          1. Let _rx_ be the *this* value.", "          1. If Type(_rx_) is not Object, throw a *TypeError* exception.", "          1. Let _S_ be ? ToString(_string_).", "          1. Let _previousLastIndex_ be ? Get(_rx_, *\"lastIndex\"*).", "          1. If SameValue(_previousLastIndex_, *+0*<sub>𝔽</sub>) is *false*, then", "            1. Perform ? Set(_rx_, *\"lastIndex\"*, *+0*<sub>𝔽</sub>, *true*).", "          1. Let _result_ be ? RegExpExec(_rx_, _S_).", "          1. Let _currentLastIndex_ be ? Get(_rx_, *\"lastIndex\"*).", "          1. If SameValue(_currentLastIndex_, _previousLastIndex_) is *false*, then", "            1. Perform ? Set(_rx_, *\"lastIndex\"*, _previousLastIndex_, *true*).", "          1. If _result_ is *null*, return *-1*<sub>𝔽</sub>.", "          1. Return ? Get(_result_, *\"index\"*)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "string"
      }],
      "ref": "RegExp[\"prototype\"][SYMBOL_search]"
    },
    "ids": "sec-regexp.prototype-@@search",
    "rawBody": "{\n  0:let rx = this\n  1:if (! (= (typeof rx) Object)) (0) throw TypeError else 56:{}\n  2:(0) app __x0__ = (ToString string)\n  2:let S = [? __x0__]\n  3:(1) app __x1__ = (Get rx \"lastIndex\")\n  3:let previousLastIndex = [? __x1__]\n  4:(2) app __x2__ = (SameValue previousLastIndex 0i)\n  4:if (= __x2__ false) {\n    5:(3) app __x3__ = (Set rx \"lastIndex\" 0i true)\n    5:[? __x3__]\n  } else 56:{}\n  6:(4) app __x4__ = (RegExpExec rx S)\n  6:let result = [? __x4__]\n  7:(5) app __x5__ = (Get rx \"lastIndex\")\n  7:let currentLastIndex = [? __x5__]\n  8:(6) app __x6__ = (SameValue currentLastIndex previousLastIndex)\n  8:if (= __x6__ false) {\n    9:(7) app __x7__ = (Set rx \"lastIndex\" previousLastIndex true)\n    9:[? __x7__]\n  } else 56:{}\n  10:if (= result null) return -1i else 56:{}\n  11:(8) app __x8__ = (Get result \"index\")\n  11:return [? __x8__]\n}"
  }, {
    "code": ["          1. Let _R_ be the *this* value.", "          1. If Type(_R_) is not Object, throw a *TypeError* exception.", "          1. If _R_ does not have an [[OriginalSource]] internal slot, then", "            1. If SameValue(_R_, %RegExp.prototype%) is *true*, return *\"(?:)\"*.", "            1. Otherwise, throw a *TypeError* exception.", "          1. Assert: _R_ has an [[OriginalFlags]] internal slot.", "          1. Let _src_ be _R_.[[OriginalSource]].", "          1. Let _flags_ be _R_.[[OriginalFlags]].", "          1. Return EscapeRegExpPattern(_src_, _flags_)."],
    "head": {
      "origParams": [],
      "ref": "getRegExp[\"prototype\"][\"source\"]"
    },
    "ids": "sec-get-regexp.prototype.source",
    "rawBody": "{\n  0:let R = this\n  1:if (! (= (typeof R) Object)) (0) throw TypeError else 56:{}\n  2:if (= R[\"OriginalSource\"] absent) {\n    4:(0) app __x0__ = (SameValue R INTRINSIC_RegExp_prototype)\n    4:if (= __x0__ true) return \"(?:)\" else (1) throw TypeError\n  } else 56:{}\n  5:assert (! (= R[\"OriginalFlags\"] absent))\n  6:let src = R[\"OriginalSource\"]\n  7:let flags = R[\"OriginalFlags\"]\n  8:(1) app __x1__ = (EscapeRegExpPattern src flags)\n  8:return __x1__\n}"
  }, {
    "code": ["          1. Let _rx_ be the *this* value.", "          1. If Type(_rx_) is not Object, throw a *TypeError* exception.", "          1. Let _S_ be ? ToString(_string_).", "          1. Let _C_ be ? SpeciesConstructor(_rx_, %RegExp%).", "          1. Let _flags_ be ? ToString(? Get(_rx_, *\"flags\"*)).", "          1. If _flags_ contains *\"u\"*, let _unicodeMatching_ be *true*.", "          1. Else, let _unicodeMatching_ be *false*.", "          1. If _flags_ contains *\"y\"*, let _newFlags_ be _flags_.", "          1. Else, let _newFlags_ be the string-concatenation of _flags_ and *\"y\"*.", "          1. Let _splitter_ be ? Construct(_C_, « _rx_, _newFlags_ »).", "          1. Let _A_ be ! ArrayCreate(0).", "          1. Let _lengthA_ be 0.", "          1. If _limit_ is *undefined*, let _lim_ be 2<sup>32</sup> - 1; else let _lim_ be ℝ(? ToUint32(_limit_)).", "          1. If _lim_ is 0, return _A_.", "          1. Let _size_ be the length of _S_.", "          1. If _size_ is 0, then", "            1. Let _z_ be ? RegExpExec(_splitter_, _S_).", "            1. If _z_ is not *null*, return _A_.", "            1. Perform ! CreateDataPropertyOrThrow(_A_, *\"0\"*, _S_).", "            1. Return _A_.", "          1. Let _p_ be 0.", "          1. Let _q_ be _p_.", "          1. Repeat, while _q_ < _size_,", "            1. Perform ? Set(_splitter_, *\"lastIndex\"*, 𝔽(_q_), *true*).", "            1. Let _z_ be ? RegExpExec(_splitter_, _S_).", "            1. If _z_ is *null*, set _q_ to AdvanceStringIndex(_S_, _q_, _unicodeMatching_).", "            1. Else,", "              1. Let _e_ be ℝ(? ToLength(? Get(_splitter_, *\"lastIndex\"*))).", "              1. Set _e_ to min(_e_, _size_).", "              1. If _e_ = _p_, set _q_ to AdvanceStringIndex(_S_, _q_, _unicodeMatching_).", "              1. Else,", "                1. Let _T_ be the substring of _S_ from _p_ to _q_.", "                1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_lengthA_)), _T_).", "                1. Set _lengthA_ to _lengthA_ + 1.", "                1. If _lengthA_ = _lim_, return _A_.", "                1. Set _p_ to _e_.", "                1. Let _numberOfCaptures_ be ? LengthOfArrayLike(_z_).", "                1. Set _numberOfCaptures_ to max(_numberOfCaptures_ - 1, 0).", "                1. Let _i_ be 1.", "                1. Repeat, while _i_ ≤ _numberOfCaptures_,", "                  1. Let _nextCapture_ be ? Get(_z_, ! ToString(𝔽(_i_))).", "                  1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_lengthA_)), _nextCapture_).", "                  1. Set _i_ to _i_ + 1.", "                  1. Set _lengthA_ to _lengthA_ + 1.", "                  1. If _lengthA_ = _lim_, return _A_.", "                1. Set _q_ to _p_.", "          1. Let _T_ be the substring of _S_ from _p_ to _size_.", "          1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_lengthA_)), _T_).", "          1. Return _A_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "string"
      }, {
        "kind": "Normal",
        "name": "limit"
      }],
      "ref": "RegExp[\"prototype\"][SYMBOL_split]"
    },
    "ids": "sec-regexp.prototype-@@split",
    "rawBody": "{\n  0:let rx = this\n  1:if (! (= (typeof rx) Object)) (0) throw TypeError else 56:{}\n  2:(0) app __x0__ = (ToString string)\n  2:let S = [? __x0__]\n  3:(1) app __x1__ = (SpeciesConstructor rx INTRINSIC_RegExp)\n  3:let C = [? __x1__]\n  4:(2) app __x2__ = (Get rx \"flags\")\n  4:(3) app __x3__ = (ToString [? __x2__])\n  4:let flags = [? __x3__]\n  6:if (contains flags \"u\") let unicodeMatching = true else let unicodeMatching = false\n  8:if (contains flags \"y\") let newFlags = flags else let newFlags = (+ flags \"y\")\n  9:(4) app __x4__ = (Construct C (1) (new [rx, newFlags]))\n  9:let splitter = [? __x4__]\n  10:(5) app __x5__ = (ArrayCreate 0i)\n  10:let A = [! __x5__]\n  11:let lengthA = 0i\n  12:if (= limit undefined) let lim = (- (** 2.0 32i) 1i) else {\n    (6) app __x6__ = (ToUint32 limit)\n    let lim = [? __x6__]\n  }\n  13:if (= lim 0i) return A else 56:{}\n  14:let size = S[\"length\"]\n  15:if (= size 0i) {\n    16:(7) app __x7__ = (RegExpExec splitter S)\n    16:let z = [? __x7__]\n    17:if (! (= z null)) return A else 56:{}\n    18:(8) app __x8__ = (CreateDataPropertyOrThrow A \"0\" S)\n    18:[! __x8__]\n    19:return A\n  } else 56:{}\n  20:let p = 0i\n  21:let q = p\n  22:while (< q size) {\n    23:(9) app __x9__ = (Set splitter \"lastIndex\" q true)\n    23:[? __x9__]\n    24:(10) app __x10__ = (RegExpExec splitter S)\n    24:let z = [? __x10__]\n    26:if (= z null) {\n      (11) app __x11__ = (AdvanceStringIndex S q unicodeMatching)\n      q = __x11__\n    } else {\n      27:(12) app __x12__ = (Get splitter \"lastIndex\")\n      27:(13) app __x13__ = (ToLength [? __x12__])\n      27:let e = [? __x13__]\n      28:(14) app __x14__ = (min e size)\n      28:e = __x14__\n      30:if (== e p) {\n        (15) app __x15__ = (AdvanceStringIndex S q unicodeMatching)\n        q = __x15__\n      } else {\n        31:let __x16__ = \"\"\n        31:let __x17__ = p\n        31:while (< __x17__ (+ q 1i)) {\n          (16) access __x18__ = (S __x17__)\n          __x16__ = (+ __x16__ __x18__)\n          __x17__ = (+ __x17__ 1i)\n        }\n        31:let T = __x16__\n        32:(17) app __x19__ = (ToString lengthA)\n        32:(18) app __x20__ = (CreateDataPropertyOrThrow A [! __x19__] T)\n        32:[! __x20__]\n        33:lengthA = (+ lengthA 1i)\n        34:if (== lengthA lim) return A else 56:{}\n        35:p = e\n        36:(19) app __x21__ = (LengthOfArrayLike z)\n        36:let numberOfCaptures = [? __x21__]\n        37:(20) app __x22__ = (max (- numberOfCaptures 1i) 0i)\n        37:numberOfCaptures = __x22__\n        38:let i = 1i\n        39:while (! (< numberOfCaptures i)) {\n          40:(21) app __x23__ = (ToString i)\n          40:(22) app __x24__ = (Get z [! __x23__])\n          40:let nextCapture = [? __x24__]\n          41:(23) app __x25__ = (ToString lengthA)\n          41:(24) app __x26__ = (CreateDataPropertyOrThrow A [! __x25__] nextCapture)\n          41:[! __x26__]\n          42:i = (+ i 1i)\n          43:lengthA = (+ lengthA 1i)\n          44:if (== lengthA lim) return A else 56:{}\n        }\n        45:q = p\n      }\n    }\n  }\n  46:let __x27__ = \"\"\n  46:let __x28__ = p\n  46:while (< __x28__ (+ size 1i)) {\n    (25) access __x29__ = (S __x28__)\n    __x27__ = (+ __x27__ __x29__)\n    __x28__ = (+ __x28__ 1i)\n  }\n  46:let T = __x27__\n  47:(26) app __x30__ = (ToString lengthA)\n  47:(27) app __x31__ = (CreateDataPropertyOrThrow A [! __x30__] T)\n  47:[! __x31__]\n  48:return A\n}"
  }, {
    "code": ["          1. Let _R_ be the *this* value.", "          1. If Type(_R_) is not Object, throw a *TypeError* exception.", "          1. If _R_ does not have an [[OriginalFlags]] internal slot, then", "            1. If SameValue(_R_, %RegExp.prototype%) is *true*, return *undefined*.", "            1. Otherwise, throw a *TypeError* exception.", "          1. Let _flags_ be _R_.[[OriginalFlags]].", "          1. If _flags_ contains the code unit 0x0079 (LATIN SMALL LETTER Y), return *true*.", "          1. Return *false*."],
    "head": {
      "origParams": [],
      "ref": "getRegExp[\"prototype\"][\"sticky\"]"
    },
    "ids": "sec-get-regexp.prototype.sticky",
    "rawBody": "{\n  0:let R = this\n  1:if (! (= (typeof R) Object)) (0) throw TypeError else 56:{}\n  2:if (= R[\"OriginalFlags\"] absent) {\n    4:(0) app __x0__ = (SameValue R INTRINSIC_RegExp_prototype)\n    4:if (= __x0__ true) return undefined else (1) throw TypeError\n  } else 56:{}\n  5:let flags = R[\"OriginalFlags\"]\n  6:if (contains flags \"y\") return true else 56:{}\n  7:return false\n}"
  }, {
    "code": ["          1. Let _R_ be the *this* value.", "          1. If Type(_R_) is not Object, throw a *TypeError* exception.", "          1. Let _string_ be ? ToString(_S_).", "          1. Let _match_ be ? RegExpExec(_R_, _string_).", "          1. If _match_ is not *null*, return *true*; else return *false*."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "S"
      }],
      "ref": "RegExp[\"prototype\"][\"test\"]"
    },
    "ids": "sec-regexp.prototype.test",
    "rawBody": "{\n  0:let R = this\n  1:if (! (= (typeof R) Object)) (0) throw TypeError else 56:{}\n  2:(0) app __x0__ = (ToString S)\n  2:let string = [? __x0__]\n  3:(1) app __x1__ = (RegExpExec R string)\n  3:let match = [? __x1__]\n  4:if (! (= match null)) return true else return false\n}"
  }, {
    "code": ["          1. Let _R_ be the *this* value.", "          1. If Type(_R_) is not Object, throw a *TypeError* exception.", "          1. Let _pattern_ be ? ToString(? Get(_R_, *\"source\"*)).", "          1. Let _flags_ be ? ToString(? Get(_R_, *\"flags\"*)).", "          1. Let _result_ be the string-concatenation of *\"/\"*, _pattern_, *\"/\"*, and _flags_.", "          1. Return _result_."],
    "head": {
      "origParams": [],
      "ref": "RegExp[\"prototype\"][\"toString\"]"
    },
    "ids": "sec-regexp.prototype.tostring",
    "rawBody": "{\n  0:let R = this\n  1:if (! (= (typeof R) Object)) (0) throw TypeError else 56:{}\n  2:(0) app __x0__ = (Get R \"source\")\n  2:(1) app __x1__ = (ToString [? __x0__])\n  2:let pattern = [? __x1__]\n  3:(2) app __x2__ = (Get R \"flags\")\n  3:(3) app __x3__ = (ToString [? __x2__])\n  3:let flags = [? __x3__]\n  4:let result = (+ (+ (+ \"/\" pattern) \"/\") flags)\n  5:return result\n}"
  }, {
    "code": ["          1. Let _R_ be the *this* value.", "          1. If Type(_R_) is not Object, throw a *TypeError* exception.", "          1. If _R_ does not have an [[OriginalFlags]] internal slot, then", "            1. If SameValue(_R_, %RegExp.prototype%) is *true*, return *undefined*.", "            1. Otherwise, throw a *TypeError* exception.", "          1. Let _flags_ be _R_.[[OriginalFlags]].", "          1. If _flags_ contains the code unit 0x0075 (LATIN SMALL LETTER U), return *true*.", "          1. Return *false*."],
    "head": {
      "origParams": [],
      "ref": "getRegExp[\"prototype\"][\"unicode\"]"
    },
    "ids": "sec-get-regexp.prototype.unicode",
    "rawBody": "{\n  0:let R = this\n  1:if (! (= (typeof R) Object)) (0) throw TypeError else 56:{}\n  2:if (= R[\"OriginalFlags\"] absent) {\n    4:(0) app __x0__ = (SameValue R INTRINSIC_RegExp_prototype)\n    4:if (= __x0__ true) return undefined else (1) throw TypeError\n  } else 56:{}\n  5:let flags = R[\"OriginalFlags\"]\n  6:if (contains flags \"u\") return true else 56:{}\n  7:return false\n}"
  }, {
    "code": ["          1. Assert: Type(_S_) is String.", "          1. Assert: Type(_global_) is Boolean.", "          1. Assert: Type(_fullUnicode_) is Boolean.", "          1. Let _closure_ be a new Abstract Closure with no parameters that captures _R_, _S_, _global_, and _fullUnicode_ and performs the following steps when called:", "            1. Repeat,", "              1. Let _match_ be ? RegExpExec(_R_, _S_).", "              1. If _match_ is *null*, return *undefined*.", "              1. If _global_ is *false*, then", "                1. Perform ? Yield(_match_).", "                1. Return *undefined*.", "              1. Let _matchStr_ be ? ToString(? Get(_match_, *\"0\"*)).", "              1. If _matchStr_ is the empty String, then", "                1. Let _thisIndex_ be ℝ(? ToLength(? Get(_R_, *\"lastIndex\"*))).", "                1. Let _nextIndex_ be ! AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_).", "                1. Perform ? Set(_R_, *\"lastIndex\"*, 𝔽(_nextIndex_), *true*).", "              1. Perform ? Yield(_match_).", "          1. Return ! CreateIteratorFromClosure(_closure_, *\"%RegExpStringIteratorPrototype%\"*, %RegExpStringIteratorPrototype%)."],
    "head": {
      "name": "CreateRegExpStringIterator",
      "params": [{
        "kind": "Normal",
        "name": "R"
      }, {
        "kind": "Normal",
        "name": "S"
      }, {
        "kind": "Normal",
        "name": "global"
      }, {
        "kind": "Normal",
        "name": "fullUnicode"
      }]
    },
    "ids": "sec-createregexpstringiterator",
    "rawBody": "{\n  0:assert (= (typeof S) String)\n  1:assert (= (typeof global) Boolean)\n  2:assert (= (typeof fullUnicode) Boolean)\n  3:(0) ??? \"Let id:{closure} be a new Abstract Closure with no parameters that captures id:{R} , id:{S} , id:{global} , and id:{fullUnicode} and performs the following steps when called : in:{} out:{}\"\n  16:(0) app __x0__ = (CreateIteratorFromClosure closure \"%RegExpStringIteratorPrototype%\" INTRINSIC_RegExpStringIteratorPrototype)\n  16:return [! __x0__]\n}"
  }, {
    "code": ["          1. If NewTarget is *undefined*, let _newTarget_ be the active function object; else let _newTarget_ be NewTarget.", "          1. Let _proto_ be ? GetPrototypeFromConstructor(_newTarget_, *\"%Array.prototype%\"*).", "          1. Let _numberOfArgs_ be the number of elements in _values_.", "          1. If _numberOfArgs_ = 0, then", "            1. Return ! ArrayCreate(0, _proto_).", "          1. Else if _numberOfArgs_ = 1, then", "            1. Let _len_ be _values_[0].", "            1. Let _array_ be ! ArrayCreate(0, _proto_).", "            1. If Type(_len_) is not Number, then", "              1. Perform ! CreateDataPropertyOrThrow(_array_, *\"0\"*, _len_).", "              1. Let _intLen_ be *1*<sub>𝔽</sub>.", "            1. Else,", "              1. Let _intLen_ be ! ToUint32(_len_).", "              1. If _intLen_ is not the same value as _len_, throw a *RangeError* exception.", "            1. Perform ! Set(_array_, *\"length\"*, _intLen_, *true*).", "            1. Return _array_.", "          1. Else,", "            1. Assert: _numberOfArgs_ ≥ 2.", "            1. Let _array_ be ? ArrayCreate(_numberOfArgs_, _proto_).", "            1. Let _k_ be 0.", "            1. Repeat, while _k_ < _numberOfArgs_,", "              1. Let _Pk_ be ! ToString(𝔽(_k_)).", "              1. Let _itemK_ be _values_[_k_].", "              1. Perform ! CreateDataPropertyOrThrow(_array_, _Pk_, _itemK_).", "              1. Set _k_ to _k_ + 1.", "            1. Assert: The mathematical value of _array_'s *\"length\"* property is _numberOfArgs_.", "            1. Return _array_."],
    "head": {
      "origParams": [{
        "kind": "Variadic",
        "name": "values"
      }],
      "ref": "Array"
    },
    "ids": "sec-array",
    "rawBody": "{\n  0:if (= NewTarget undefined) let newTarget = CONTEXT[\"Function\"] else let newTarget = NewTarget\n  1:(0) app __x0__ = (GetPrototypeFromConstructor newTarget \"%Array.prototype%\")\n  1:let proto = [? __x0__]\n  2:let numberOfArgs = values[\"length\"]\n  16:if (== numberOfArgs 0i) {\n    4:(1) app __x1__ = (ArrayCreate 0i proto)\n    4:return [! __x1__]\n  } else if (== numberOfArgs 1i) {\n    6:let len = values[0i]\n    7:(2) app __x2__ = (ArrayCreate 0i proto)\n    7:let array = [! __x2__]\n    11:if (! (= (typeof len) Number)) {\n      9:(3) app __x3__ = (CreateDataPropertyOrThrow array \"0\" len)\n      9:[! __x3__]\n      10:let intLen = 1i\n    } else {\n      12:(4) app __x4__ = (ToUint32 len)\n      12:let intLen = [! __x4__]\n      13:if (! (= intLen len)) (0) throw RangeError else 25:{}\n    }\n    14:(5) app __x5__ = (Set array \"length\" intLen true)\n    14:[! __x5__]\n    15:return array\n  } else {\n    17:assert (! (< numberOfArgs 2i))\n    18:(6) app __x6__ = (ArrayCreate numberOfArgs proto)\n    18:let array = [? __x6__]\n    19:let k = 0i\n    20:while (< k numberOfArgs) {\n      21:(7) app __x7__ = (ToString k)\n      21:let Pk = [! __x7__]\n      22:let itemK = values[k]\n      23:(8) app __x8__ = (CreateDataPropertyOrThrow array Pk itemK)\n      23:[! __x8__]\n      24:k = (+ k 1i)\n    }\n    26:return array\n  }\n}"
  }, {
    "code": ["          1. Let _C_ be the *this* value.", "          1. If _mapfn_ is *undefined*, let _mapping_ be *false*.", "          1. Else,", "            1. If IsCallable(_mapfn_) is *false*, throw a *TypeError* exception.", "            1. Let _mapping_ be *true*.", "          1. Let _usingIterator_ be ? GetMethod(_items_, @@iterator).", "          1. If _usingIterator_ is not *undefined*, then", "            1. If IsConstructor(_C_) is *true*, then", "              1. Let _A_ be ? Construct(_C_).", "            1. Else,", "              1. Let _A_ be ! ArrayCreate(0).", "            1. Let _iteratorRecord_ be ? GetIterator(_items_, ~sync~, _usingIterator_).", "            1. Let _k_ be 0.", "            1. Repeat,", "              1. If _k_ ≥ 2<sup>53</sup> - 1, then", "                1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).", "                1. Return ? IteratorClose(_iteratorRecord_, _error_).", "              1. Let _Pk_ be ! ToString(𝔽(_k_)).", "              1. Let _next_ be ? IteratorStep(_iteratorRecord_).", "              1. If _next_ is *false*, then", "                1. Perform ? Set(_A_, *\"length\"*, 𝔽(_k_), *true*).", "                1. Return _A_.", "              1. Let _nextValue_ be ? IteratorValue(_next_).", "              1. If _mapping_ is *true*, then", "                1. Let _mappedValue_ be Call(_mapfn_, _thisArg_, « _nextValue_, 𝔽(_k_) »).", "                1. If _mappedValue_ is an abrupt completion, return ? IteratorClose(_iteratorRecord_, _mappedValue_).", "                1. Set _mappedValue_ to _mappedValue_.[[Value]].", "              1. Else, let _mappedValue_ be _nextValue_.", "              1. Let _defineStatus_ be CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_).", "              1. If _defineStatus_ is an abrupt completion, return ? IteratorClose(_iteratorRecord_, _defineStatus_).", "              1. Set _k_ to _k_ + 1.", "          1. NOTE: _items_ is not an Iterable so assume it is an array-like object.", "          1. Let _arrayLike_ be ! ToObject(_items_).", "          1. Let _len_ be ? LengthOfArrayLike(_arrayLike_).", "          1. If IsConstructor(_C_) is *true*, then", "            1. Let _A_ be ? Construct(_C_, « 𝔽(_len_) »).", "          1. Else,", "            1. Let _A_ be ? ArrayCreate(_len_).", "          1. Let _k_ be 0.", "          1. Repeat, while _k_ < _len_,", "            1. Let _Pk_ be ! ToString(𝔽(_k_)).", "            1. Let _kValue_ be ? Get(_arrayLike_, _Pk_).", "            1. If _mapping_ is *true*, then", "              1. Let _mappedValue_ be ? Call(_mapfn_, _thisArg_, « _kValue_, 𝔽(_k_) »).", "            1. Else, let _mappedValue_ be _kValue_.", "            1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_).", "            1. Set _k_ to _k_ + 1.", "          1. Perform ? Set(_A_, *\"length\"*, 𝔽(_len_), *true*).", "          1. Return _A_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "items"
      }, {
        "kind": "Optional",
        "name": "mapfn"
      }, {
        "kind": "Optional",
        "name": "thisArg"
      }],
      "ref": "Array[\"from\"]"
    },
    "ids": "sec-array.from",
    "rawBody": "{\n  0:let C = this\n  2:if (= mapfn undefined) let mapping = false else {\n    3:(0) app __x0__ = (IsCallable mapfn)\n    3:if (= __x0__ false) (0) throw TypeError else 31:{}\n    4:let mapping = true\n  }\n  5:(1) app __x1__ = (GetMethod items SYMBOL_iterator)\n  5:let usingIterator = [? __x1__]\n  6:if (! (= usingIterator undefined)) {\n    9:(2) app __x2__ = (IsConstructor C)\n    9:if (= __x2__ true) {\n      8:(3) app __x3__ = (Construct C)\n      8:let A = [? __x3__]\n    } else {\n      10:(4) app __x4__ = (ArrayCreate 0i)\n      10:let A = [! __x4__]\n    }\n    11:(5) app __x5__ = (GetIterator items CONST_sync usingIterator)\n    11:let iteratorRecord = [? __x5__]\n    12:let k = 0i\n    13:while true {\n      14:if (! (< k (- (** 2.0 53i) 1i))) {\n        15:(6) app __x6__ = (ThrowCompletion (1) (new OrdinaryObject()))\n        15:let error = __x6__\n        16:(7) app __x7__ = (IteratorClose iteratorRecord error)\n        16:return [? __x7__]\n      } else 31:{}\n      17:(8) app __x8__ = (ToString k)\n      17:let Pk = [! __x8__]\n      18:(9) app __x9__ = (IteratorStep iteratorRecord)\n      18:let next = [? __x9__]\n      19:if (= next false) {\n        20:(10) app __x10__ = (Set A \"length\" k true)\n        20:[? __x10__]\n        21:return A\n      } else 31:{}\n      22:(11) app __x11__ = (IteratorValue next)\n      22:let nextValue = [? __x11__]\n      27:if (= mapping true) {\n        24:(12) app __x12__ = (Call mapfn thisArg (2) (new [nextValue, k]))\n        24:let mappedValue = __x12__\n        25:(13) app __x13__ = (IsAbruptCompletion mappedValue)\n        25:if __x13__ {\n          (14) app __x14__ = (IteratorClose iteratorRecord mappedValue)\n          return [? __x14__]\n        } else 31:{}\n        26:mappedValue = mappedValue[\"Value\"]\n      } else let mappedValue = nextValue\n      28:(15) app __x15__ = (CreateDataPropertyOrThrow A Pk mappedValue)\n      28:let defineStatus = __x15__\n      29:(16) app __x16__ = (IsAbruptCompletion defineStatus)\n      29:if __x16__ {\n        (17) app __x17__ = (IteratorClose iteratorRecord defineStatus)\n        return [? __x17__]\n      } else 31:{}\n      30:k = (+ k 1i)\n    }\n  } else 31:{}\n  32:(18) app __x18__ = (ToObject items)\n  32:let arrayLike = [! __x18__]\n  33:(19) app __x19__ = (LengthOfArrayLike arrayLike)\n  33:let len = [? __x19__]\n  36:(20) app __x20__ = (IsConstructor C)\n  36:if (= __x20__ true) {\n    35:(21) app __x21__ = (Construct C (3) (new [len]))\n    35:let A = [? __x21__]\n  } else {\n    37:(22) app __x22__ = (ArrayCreate len)\n    37:let A = [? __x22__]\n  }\n  38:let k = 0i\n  39:while (< k len) {\n    40:(23) app __x23__ = (ToString k)\n    40:let Pk = [! __x23__]\n    41:(24) app __x24__ = (Get arrayLike Pk)\n    41:let kValue = [? __x24__]\n    44:if (= mapping true) {\n      43:(25) app __x25__ = (Call mapfn thisArg (4) (new [kValue, k]))\n      43:let mappedValue = [? __x25__]\n    } else let mappedValue = kValue\n    45:(26) app __x26__ = (CreateDataPropertyOrThrow A Pk mappedValue)\n    45:[? __x26__]\n    46:k = (+ k 1i)\n  }\n  47:(27) app __x27__ = (Set A \"length\" len true)\n  47:[? __x27__]\n  48:return A\n}"
  }, {
    "code": ["          1. Return ? IsArray(_arg_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "arg"
      }],
      "ref": "Array[\"isArray\"]"
    },
    "ids": "sec-array.isarray",
    "rawBody": "{\n  0:(0) app __x0__ = (IsArray arg)\n  0:return [? __x0__]\n}"
  }, {
    "code": ["          1. Let _len_ be the number of elements in _items_.", "          1. Let _lenNumber_ be 𝔽(_len_).", "          1. Let _C_ be the *this* value.", "          1. If IsConstructor(_C_) is *true*, then", "            1. Let _A_ be ? Construct(_C_, « _lenNumber_ »).", "          1. Else,", "            1. Let _A_ be ? ArrayCreate(_len_).", "          1. Let _k_ be 0.", "          1. Repeat, while _k_ < _len_,", "            1. Let _kValue_ be _items_[_k_].", "            1. Let _Pk_ be ! ToString(𝔽(_k_)).", "            1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _kValue_).", "            1. Set _k_ to _k_ + 1.", "          1. Perform ? Set(_A_, *\"length\"*, _lenNumber_, *true*).", "          1. Return _A_."],
    "head": {
      "origParams": [{
        "kind": "Variadic",
        "name": "items"
      }],
      "ref": "Array[\"of\"]"
    },
    "ids": "sec-array.of",
    "rawBody": "{\n  0:let len = items[\"length\"]\n  1:let lenNumber = len\n  2:let C = this\n  5:(0) app __x0__ = (IsConstructor C)\n  5:if (= __x0__ true) {\n    4:(1) app __x1__ = (Construct C (0) (new [lenNumber]))\n    4:let A = [? __x1__]\n  } else {\n    6:(2) app __x2__ = (ArrayCreate len)\n    6:let A = [? __x2__]\n  }\n  7:let k = 0i\n  8:while (< k len) {\n    9:let kValue = items[k]\n    10:(3) app __x3__ = (ToString k)\n    10:let Pk = [! __x3__]\n    11:(4) app __x4__ = (CreateDataPropertyOrThrow A Pk kValue)\n    11:[? __x4__]\n    12:k = (+ k 1i)\n  }\n  13:(5) app __x5__ = (Set A \"length\" lenNumber true)\n  13:[? __x5__]\n  14:return A\n}"
  }, {
    "code": ["          1. Return the *this* value."],
    "head": {
      "origParams": [],
      "ref": "getArray[SYMBOL_species]"
    },
    "ids": "sec-get-array-@@species",
    "rawBody": "return this"
  }, {
    "code": ["          1. Let _O_ be ? ToObject(*this* value).", "          1. Let _A_ be ? ArraySpeciesCreate(_O_, 0).", "          1. Let _n_ be 0.", "          1. Prepend _O_ to _items_.", "          1. For each element _E_ of _items_, do", "            1. Let _spreadable_ be ? IsConcatSpreadable(_E_).", "            1. If _spreadable_ is *true*, then", "              1. Let _k_ be 0.", "              1. Let _len_ be ? LengthOfArrayLike(_E_).", "              1. If _n_ + _len_ > 2<sup>53</sup> - 1, throw a *TypeError* exception.", "              1. Repeat, while _k_ < _len_,", "                1. Let _P_ be ! ToString(𝔽(_k_)).", "                1. Let _exists_ be ? HasProperty(_E_, _P_).", "                1. If _exists_ is *true*, then", "                  1. Let _subElement_ be ? Get(_E_, _P_).", "                  1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _subElement_).", "                1. Set _n_ to _n_ + 1.", "                1. Set _k_ to _k_ + 1.", "            1. Else,", "              1. NOTE: _E_ is added as a single item rather than spread.", "              1. If _n_ ≥ 2<sup>53</sup> - 1, throw a *TypeError* exception.", "              1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _E_).", "              1. Set _n_ to _n_ + 1.", "          1. [id=\"step-array-proto-concat-set-length\"] Perform ? Set(_A_, *\"length\"*, 𝔽(_n_), *true*).", "          1. Return _A_."],
    "head": {
      "origParams": [{
        "kind": "Variadic",
        "name": "items"
      }],
      "ref": "Array[\"prototype\"][\"concat\"]"
    },
    "ids": "sec-array.prototype.concat",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (ArraySpeciesCreate O 0i)\n  1:let A = [? __x1__]\n  2:let n = 0i\n  3:(0) ??? \"Prepend id:{O} to id:{items} .\"\n  4:let __x2__ = items\n  4:let __x3__ = 0i\n  4:while (< __x3__ __x2__[\"length\"]) {\n    let E = __x2__[__x3__]\n    5:(2) app __x4__ = (IsConcatSpreadable E)\n    5:let spreadable = [? __x4__]\n    18:if (= spreadable true) {\n      7:let k = 0i\n      8:(3) app __x5__ = (LengthOfArrayLike E)\n      8:let len = [? __x5__]\n      9:if (< (- (** 2.0 53i) 1i) (+ n len)) (1) throw TypeError else 19:{}\n      10:while (< k len) {\n        11:(4) app __x6__ = (ToString k)\n        11:let P = [! __x6__]\n        12:(5) app __x7__ = (HasProperty E P)\n        12:let exists = [? __x7__]\n        13:if (= exists true) {\n          14:(6) app __x8__ = (Get E P)\n          14:let subElement = [? __x8__]\n          15:(7) app __x9__ = (ToString n)\n          15:(8) app __x10__ = (CreateDataPropertyOrThrow A [! __x9__] subElement)\n          15:[? __x10__]\n        } else 19:{}\n        16:n = (+ n 1i)\n        17:k = (+ k 1i)\n      }\n    } else {\n      20:if (! (< n (- (** 2.0 53i) 1i))) (2) throw TypeError else 19:{}\n      21:(9) app __x11__ = (ToString n)\n      21:(10) app __x12__ = (CreateDataPropertyOrThrow A [! __x11__] E)\n      21:[? __x12__]\n      22:n = (+ n 1i)\n    }\n    __x3__ = (+ __x3__ 1i)\n  }\n  23:(11) app __x13__ = (Set A \"length\" n true)\n  23:[? __x13__]\n  24:return A\n}"
  }, {
    "code": ["            1. If Type(_O_) is not Object, return *false*.", "            1. Let _spreadable_ be ? Get(_O_, @@isConcatSpreadable).", "            1. If _spreadable_ is not *undefined*, return ! ToBoolean(_spreadable_).", "            1. Return ? IsArray(_O_)."],
    "head": {
      "name": "IsConcatSpreadable",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }]
    },
    "ids": "sec-isconcatspreadable",
    "rawBody": "{\n  0:if (! (= (typeof O) Object)) return false else 19:{}\n  1:(0) app __x0__ = (Get O SYMBOL_isConcatSpreadable)\n  1:let spreadable = [? __x0__]\n  2:if (! (= spreadable undefined)) {\n    (1) app __x1__ = (ToBoolean spreadable)\n    return [! __x1__]\n  } else 19:{}\n  3:(2) app __x2__ = (IsArray O)\n  3:return [? __x2__]\n}"
  }, {
    "code": ["          1. Let _O_ be ? ToObject(*this* value).", "          1. Let _len_ be ? LengthOfArrayLike(_O_).", "          1. Let _relativeTarget_ be ? ToIntegerOrInfinity(_target_).", "          1. If _relativeTarget_ is -∞, let _to_ be 0.", "          1. Else if _relativeTarget_ < 0, let _to_ be max(_len_ + _relativeTarget_, 0).", "          1. Else, let _to_ be min(_relativeTarget_, _len_).", "          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).", "          1. If _relativeStart_ is -∞, let _from_ be 0.", "          1. Else if _relativeStart_ < 0, let _from_ be max(_len_ + _relativeStart_, 0).", "          1. Else, let _from_ be min(_relativeStart_, _len_).", "          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).", "          1. If _relativeEnd_ is -∞, let _final_ be 0.", "          1. Else if _relativeEnd_ < 0, let _final_ be max(_len_ + _relativeEnd_, 0).", "          1. Else, let _final_ be min(_relativeEnd_, _len_).", "          1. Let _count_ be min(_final_ - _from_, _len_ - _to_).", "          1. If _from_ < _to_ and _to_ < _from_ + _count_, then", "            1. Let _direction_ be -1.", "            1. Set _from_ to _from_ + _count_ - 1.", "            1. Set _to_ to _to_ + _count_ - 1.", "          1. Else,", "            1. Let _direction_ be 1.", "          1. Repeat, while _count_ > 0,", "            1. Let _fromKey_ be ! ToString(𝔽(_from_)).", "            1. Let _toKey_ be ! ToString(𝔽(_to_)).", "            1. Let _fromPresent_ be ? HasProperty(_O_, _fromKey_).", "            1. If _fromPresent_ is *true*, then", "              1. Let _fromVal_ be ? Get(_O_, _fromKey_).", "              1. Perform ? Set(_O_, _toKey_, _fromVal_, *true*).", "            1. Else,", "              1. Assert: _fromPresent_ is *false*.", "              1. Perform ? DeletePropertyOrThrow(_O_, _toKey_).", "            1. Set _from_ to _from_ + _direction_.", "            1. Set _to_ to _to_ + _direction_.", "            1. Set _count_ to _count_ - 1.", "          1. Return _O_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "target"
      }, {
        "kind": "Normal",
        "name": "start"
      }, {
        "kind": "Optional",
        "name": "end"
      }],
      "ref": "Array[\"prototype\"][\"copyWithin\"]"
    },
    "ids": "sec-array.prototype.copywithin",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (LengthOfArrayLike O)\n  1:let len = [? __x1__]\n  2:(2) app __x2__ = (ToIntegerOrInfinity target)\n  2:let relativeTarget = [? __x2__]\n  5:if (= relativeTarget -Infinity) let to = 0i else if (< relativeTarget 0i) {\n    (3) app __x3__ = (max (+ len relativeTarget) 0i)\n    let to = __x3__\n  } else {\n    (4) app __x4__ = (min relativeTarget len)\n    let to = __x4__\n  }\n  6:(5) app __x5__ = (ToIntegerOrInfinity start)\n  6:let relativeStart = [? __x5__]\n  9:if (= relativeStart -Infinity) let from = 0i else if (< relativeStart 0i) {\n    (6) app __x6__ = (max (+ len relativeStart) 0i)\n    let from = __x6__\n  } else {\n    (7) app __x7__ = (min relativeStart len)\n    let from = __x7__\n  }\n  10:if (= end undefined) let relativeEnd = len else {\n    (8) app __x8__ = (ToIntegerOrInfinity end)\n    let relativeEnd = [? __x8__]\n  }\n  13:if (= relativeEnd -Infinity) let final = 0i else if (< relativeEnd 0i) {\n    (9) app __x9__ = (max (+ len relativeEnd) 0i)\n    let final = __x9__\n  } else {\n    (10) app __x10__ = (min relativeEnd len)\n    let final = __x10__\n  }\n  14:(11) app __x11__ = (min (- final from) (- len to))\n  14:let count = __x11__\n  19:if (&& (< from to) (< to (+ from count))) {\n    16:let direction = -1i\n    17:from = (- (+ from count) 1i)\n    18:to = (- (+ to count) 1i)\n  } else let direction = 1i\n  21:while (< 0i count) {\n    22:(12) app __x12__ = (ToString from)\n    22:let fromKey = [! __x12__]\n    23:(13) app __x13__ = (ToString to)\n    23:let toKey = [! __x13__]\n    24:(14) app __x14__ = (HasProperty O fromKey)\n    24:let fromPresent = [? __x14__]\n    28:if (= fromPresent true) {\n      26:(15) app __x15__ = (Get O fromKey)\n      26:let fromVal = [? __x15__]\n      27:(16) app __x16__ = (Set O toKey fromVal true)\n      27:[? __x16__]\n    } else {\n      29:assert (= fromPresent false)\n      30:(17) app __x17__ = (DeletePropertyOrThrow O toKey)\n      30:[? __x17__]\n    }\n    31:from = (+ from direction)\n    32:to = (+ to direction)\n    33:count = (- count 1i)\n  }\n  34:return O\n}"
  }, {
    "code": ["          1. Let _O_ be ? ToObject(*this* value).", "          1. Return CreateArrayIterator(_O_, ~key+value~)."],
    "head": {
      "origParams": [],
      "ref": "Array[\"prototype\"][\"entries\"]"
    },
    "ids": "sec-array.prototype.entries",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (CreateArrayIterator O CONST_keyPLUSvalue)\n  1:return __x1__\n}"
  }, {
    "code": ["          1. Let _O_ be ? ToObject(*this* value).", "          1. Let _len_ be ? LengthOfArrayLike(_O_).", "          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.", "          1. Let _k_ be 0.", "          1. Repeat, while _k_ < _len_,", "            1. Let _Pk_ be ! ToString(𝔽(_k_)).", "            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).", "            1. If _kPresent_ is *true*, then", "              1. Let _kValue_ be ? Get(_O_, _Pk_).", "              1. Let _testResult_ be ! ToBoolean(? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).", "              1. If _testResult_ is *false*, return *false*.", "            1. Set _k_ to _k_ + 1.", "          1. Return *true*."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "callbackfn"
      }, {
        "kind": "Optional",
        "name": "thisArg"
      }],
      "ref": "Array[\"prototype\"][\"every\"]"
    },
    "ids": "sec-array.prototype.every",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (LengthOfArrayLike O)\n  1:let len = [? __x1__]\n  2:(2) app __x2__ = (IsCallable callbackfn)\n  2:if (= __x2__ false) (0) throw TypeError else 19:{}\n  3:let k = 0i\n  4:while (< k len) {\n    5:(3) app __x3__ = (ToString k)\n    5:let Pk = [! __x3__]\n    6:(4) app __x4__ = (HasProperty O Pk)\n    6:let kPresent = [? __x4__]\n    7:if (= kPresent true) {\n      8:(5) app __x5__ = (Get O Pk)\n      8:let kValue = [? __x5__]\n      9:(6) app __x6__ = (Call callbackfn thisArg (1) (new [kValue, k, O]))\n      9:(7) app __x7__ = (ToBoolean [? __x6__])\n      9:let testResult = [! __x7__]\n      10:if (= testResult false) return false else 19:{}\n    } else 19:{}\n    11:k = (+ k 1i)\n  }\n  12:return true\n}"
  }, {
    "code": ["          1. Let _O_ be ? ToObject(*this* value).", "          1. Let _len_ be ? LengthOfArrayLike(_O_).", "          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).", "          1. If _relativeStart_ is -∞, let _k_ be 0.", "          1. Else if _relativeStart_ < 0, let _k_ be max(_len_ + _relativeStart_, 0).", "          1. Else, let _k_ be min(_relativeStart_, _len_).", "          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).", "          1. If _relativeEnd_ is -∞, let _final_ be 0.", "          1. Else if _relativeEnd_ < 0, let _final_ be max(_len_ + _relativeEnd_, 0).", "          1. Else, let _final_ be min(_relativeEnd_, _len_).", "          1. Repeat, while _k_ < _final_,", "            1. Let _Pk_ be ! ToString(𝔽(_k_)).", "            1. Perform ? Set(_O_, _Pk_, _value_, *true*).", "            1. Set _k_ to _k_ + 1.", "          1. Return _O_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Optional",
        "name": "start"
      }, {
        "kind": "Optional",
        "name": "end"
      }],
      "ref": "Array[\"prototype\"][\"fill\"]"
    },
    "ids": "sec-array.prototype.fill",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (LengthOfArrayLike O)\n  1:let len = [? __x1__]\n  2:(2) app __x2__ = (ToIntegerOrInfinity start)\n  2:let relativeStart = [? __x2__]\n  5:if (= relativeStart -Infinity) let k = 0i else if (< relativeStart 0i) {\n    (3) app __x3__ = (max (+ len relativeStart) 0i)\n    let k = __x3__\n  } else {\n    (4) app __x4__ = (min relativeStart len)\n    let k = __x4__\n  }\n  6:if (= end undefined) let relativeEnd = len else {\n    (5) app __x5__ = (ToIntegerOrInfinity end)\n    let relativeEnd = [? __x5__]\n  }\n  9:if (= relativeEnd -Infinity) let final = 0i else if (< relativeEnd 0i) {\n    (6) app __x6__ = (max (+ len relativeEnd) 0i)\n    let final = __x6__\n  } else {\n    (7) app __x7__ = (min relativeEnd len)\n    let final = __x7__\n  }\n  10:while (< k final) {\n    11:(8) app __x8__ = (ToString k)\n    11:let Pk = [! __x8__]\n    12:(9) app __x9__ = (Set O Pk value true)\n    12:[? __x9__]\n    13:k = (+ k 1i)\n  }\n  14:return O\n}"
  }, {
    "code": ["          1. Let _O_ be ? ToObject(*this* value).", "          1. Let _len_ be ? LengthOfArrayLike(_O_).", "          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.", "          1. Let _A_ be ? ArraySpeciesCreate(_O_, 0).", "          1. Let _k_ be 0.", "          1. Let _to_ be 0.", "          1. Repeat, while _k_ < _len_,", "            1. Let _Pk_ be ! ToString(𝔽(_k_)).", "            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).", "            1. If _kPresent_ is *true*, then", "              1. Let _kValue_ be ? Get(_O_, _Pk_).", "              1. Let _selected_ be ! ToBoolean(? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).", "              1. If _selected_ is *true*, then", "                1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_to_)), _kValue_).", "                1. Set _to_ to _to_ + 1.", "            1. Set _k_ to _k_ + 1.", "          1. Return _A_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "callbackfn"
      }, {
        "kind": "Optional",
        "name": "thisArg"
      }],
      "ref": "Array[\"prototype\"][\"filter\"]"
    },
    "ids": "sec-array.prototype.filter",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (LengthOfArrayLike O)\n  1:let len = [? __x1__]\n  2:(2) app __x2__ = (IsCallable callbackfn)\n  2:if (= __x2__ false) (0) throw TypeError else 19:{}\n  3:(3) app __x3__ = (ArraySpeciesCreate O 0i)\n  3:let A = [? __x3__]\n  4:let k = 0i\n  5:let to = 0i\n  6:while (< k len) {\n    7:(4) app __x4__ = (ToString k)\n    7:let Pk = [! __x4__]\n    8:(5) app __x5__ = (HasProperty O Pk)\n    8:let kPresent = [? __x5__]\n    9:if (= kPresent true) {\n      10:(6) app __x6__ = (Get O Pk)\n      10:let kValue = [? __x6__]\n      11:(7) app __x7__ = (Call callbackfn thisArg (1) (new [kValue, k, O]))\n      11:(8) app __x8__ = (ToBoolean [? __x7__])\n      11:let selected = [! __x8__]\n      12:if (= selected true) {\n        13:(9) app __x9__ = (ToString to)\n        13:(10) app __x10__ = (CreateDataPropertyOrThrow A [! __x9__] kValue)\n        13:[? __x10__]\n        14:to = (+ to 1i)\n      } else 19:{}\n    } else 19:{}\n    15:k = (+ k 1i)\n  }\n  16:return A\n}"
  }, {
    "code": ["          1. Let _O_ be ? ToObject(*this* value).", "          1. Let _len_ be ? LengthOfArrayLike(_O_).", "          1. If IsCallable(_predicate_) is *false*, throw a *TypeError* exception.", "          1. Let _k_ be 0.", "          1. Repeat, while _k_ < _len_,", "            1. Let _Pk_ be ! ToString(𝔽(_k_)).", "            1. Let _kValue_ be ? Get(_O_, _Pk_).", "            1. Let _testResult_ be ! ToBoolean(? Call(_predicate_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).", "            1. If _testResult_ is *true*, return _kValue_.", "            1. Set _k_ to _k_ + 1.", "          1. Return *undefined*."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "predicate"
      }, {
        "kind": "Optional",
        "name": "thisArg"
      }],
      "ref": "Array[\"prototype\"][\"find\"]"
    },
    "ids": "sec-array.prototype.find",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (LengthOfArrayLike O)\n  1:let len = [? __x1__]\n  2:(2) app __x2__ = (IsCallable predicate)\n  2:if (= __x2__ false) (0) throw TypeError else 19:{}\n  3:let k = 0i\n  4:while (< k len) {\n    5:(3) app __x3__ = (ToString k)\n    5:let Pk = [! __x3__]\n    6:(4) app __x4__ = (Get O Pk)\n    6:let kValue = [? __x4__]\n    7:(5) app __x5__ = (Call predicate thisArg (1) (new [kValue, k, O]))\n    7:(6) app __x6__ = (ToBoolean [? __x5__])\n    7:let testResult = [! __x6__]\n    8:if (= testResult true) return kValue else 19:{}\n    9:k = (+ k 1i)\n  }\n  10:return undefined\n}"
  }, {
    "code": ["          1. Let _O_ be ? ToObject(*this* value).", "          1. Let _len_ be ? LengthOfArrayLike(_O_).", "          1. If IsCallable(_predicate_) is *false*, throw a *TypeError* exception.", "          1. Let _k_ be 0.", "          1. Repeat, while _k_ < _len_,", "            1. Let _Pk_ be ! ToString(𝔽(_k_)).", "            1. Let _kValue_ be ? Get(_O_, _Pk_).", "            1. Let _testResult_ be ! ToBoolean(? Call(_predicate_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).", "            1. If _testResult_ is *true*, return 𝔽(_k_).", "            1. Set _k_ to _k_ + 1.", "          1. Return *-1*<sub>𝔽</sub>."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "predicate"
      }, {
        "kind": "Optional",
        "name": "thisArg"
      }],
      "ref": "Array[\"prototype\"][\"findIndex\"]"
    },
    "ids": "sec-array.prototype.findindex",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (LengthOfArrayLike O)\n  1:let len = [? __x1__]\n  2:(2) app __x2__ = (IsCallable predicate)\n  2:if (= __x2__ false) (0) throw TypeError else 19:{}\n  3:let k = 0i\n  4:while (< k len) {\n    5:(3) app __x3__ = (ToString k)\n    5:let Pk = [! __x3__]\n    6:(4) app __x4__ = (Get O Pk)\n    6:let kValue = [? __x4__]\n    7:(5) app __x5__ = (Call predicate thisArg (1) (new [kValue, k, O]))\n    7:(6) app __x6__ = (ToBoolean [? __x5__])\n    7:let testResult = [! __x6__]\n    8:if (= testResult true) return k else 19:{}\n    9:k = (+ k 1i)\n  }\n  10:return -1i\n}"
  }, {
    "code": ["          1. Let _O_ be ? ToObject(*this* value).", "          1. Let _sourceLen_ be ? LengthOfArrayLike(_O_).", "          1. Let _depthNum_ be 1.", "          1. If _depth_ is not *undefined*, then", "            1. Set _depthNum_ to ? ToIntegerOrInfinity(_depth_).", "            1. If _depthNum_ < 0, set _depthNum_ to 0.", "          1. Let _A_ be ? ArraySpeciesCreate(_O_, 0).", "          1. Perform ? FlattenIntoArray(_A_, _O_, _sourceLen_, 0, _depthNum_).", "          1. Return _A_."],
    "head": {
      "origParams": [{
        "kind": "Optional",
        "name": "depth"
      }],
      "ref": "Array[\"prototype\"][\"flat\"]"
    },
    "ids": "sec-array.prototype.flat",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (LengthOfArrayLike O)\n  1:let sourceLen = [? __x1__]\n  2:let depthNum = 1i\n  3:if (! (= depth undefined)) {\n    4:(2) app __x2__ = (ToIntegerOrInfinity depth)\n    4:depthNum = [? __x2__]\n    5:if (< depthNum 0i) depthNum = 0i else 19:{}\n  } else 19:{}\n  6:(3) app __x3__ = (ArraySpeciesCreate O 0i)\n  6:let A = [? __x3__]\n  7:(4) app __x4__ = (FlattenIntoArray A O sourceLen 0i depthNum)\n  7:[? __x4__]\n  8:return A\n}"
  }, {
    "code": ["            1. Assert: Type(_target_) is Object.", "            1. Assert: Type(_source_) is Object.", "            1. Assert: If _mapperFunction_ is present, then ! IsCallable(_mapperFunction_) is *true*, _thisArg_ is present, and _depth_ is 1.", "            1. Let _targetIndex_ be _start_.", "            1. Let _sourceIndex_ be *+0*<sub>𝔽</sub>.", "            1. Repeat, while ℝ(_sourceIndex_) < _sourceLen_,", "              1. Let _P_ be ! ToString(_sourceIndex_).", "              1. Let _exists_ be ? HasProperty(_source_, _P_).", "              1. If _exists_ is *true*, then", "                1. Let _element_ be ? Get(_source_, _P_).", "                1. If _mapperFunction_ is present, then", "                  1. Set _element_ to ? Call(_mapperFunction_, _thisArg_, « _element_, _sourceIndex_, _source_ »).", "                1. Let _shouldFlatten_ be *false*.", "                1. If _depth_ > 0, then", "                  1. Set _shouldFlatten_ to ? IsArray(_element_).", "                1. If _shouldFlatten_ is *true*, then", "                  1. If _depth_ is +∞, let _newDepth_ be +∞.", "                  1. Else, let _newDepth_ be _depth_ - 1.", "                  1. Let _elementLen_ be ? LengthOfArrayLike(_element_).", "                  1. Set _targetIndex_ to ? FlattenIntoArray(_target_, _element_, _elementLen_, _targetIndex_, _newDepth_).", "                1. Else,", "                  1. If _targetIndex_ ≥ 2<sup>53</sup> - 1, throw a *TypeError* exception.", "                  1. Perform ? CreateDataPropertyOrThrow(_target_, ! ToString(𝔽(_targetIndex_)), _element_).", "                  1. Set _targetIndex_ to _targetIndex_ + 1.", "              1. Set _sourceIndex_ to _sourceIndex_ + *1*<sub>𝔽</sub>.", "            1. Return _targetIndex_."],
    "head": {
      "name": "FlattenIntoArray",
      "params": [{
        "kind": "Normal",
        "name": "target"
      }, {
        "kind": "Normal",
        "name": "source"
      }, {
        "kind": "Normal",
        "name": "sourceLen"
      }, {
        "kind": "Normal",
        "name": "start"
      }, {
        "kind": "Normal",
        "name": "depth"
      }, {
        "kind": "Optional",
        "name": "mapperFunction"
      }, {
        "kind": "Optional",
        "name": "thisArg"
      }]
    },
    "ids": "sec-flattenintoarray",
    "rawBody": "{\n  0:assert (= (typeof target) Object)\n  1:assert (= (typeof source) Object)\n  3:let targetIndex = start\n  4:let sourceIndex = 0i\n  5:while (< sourceIndex sourceLen) {\n    6:(0) app __x0__ = (ToString sourceIndex)\n    6:let P = [! __x0__]\n    7:(1) app __x1__ = (HasProperty source P)\n    7:let exists = [? __x1__]\n    8:if (= exists true) {\n      9:(2) app __x2__ = (Get source P)\n      9:let element = [? __x2__]\n      10:if (! (= mapperFunction absent)) {\n        11:(3) app __x3__ = (Call mapperFunction thisArg (0) (new [element, sourceIndex, source]))\n        11:element = [? __x3__]\n      } else 2:{}\n      12:let shouldFlatten = false\n      13:if (< 0i depth) {\n        14:(4) app __x4__ = (IsArray element)\n        14:shouldFlatten = [? __x4__]\n      } else 2:{}\n      20:if (= shouldFlatten true) {\n        17:if (= depth Infinity) let newDepth = Infinity else let newDepth = (- depth 1i)\n        18:(5) app __x5__ = (LengthOfArrayLike element)\n        18:let elementLen = [? __x5__]\n        19:(6) app __x6__ = (FlattenIntoArray target element elementLen targetIndex newDepth)\n        19:targetIndex = [? __x6__]\n      } else {\n        21:if (! (< targetIndex (- (** 2.0 53i) 1i))) (1) throw TypeError else 2:{}\n        22:(7) app __x7__ = (ToString targetIndex)\n        22:(8) app __x8__ = (CreateDataPropertyOrThrow target [! __x7__] element)\n        22:[? __x8__]\n        23:targetIndex = (+ targetIndex 1i)\n      }\n    } else 2:{}\n    24:sourceIndex = (+ sourceIndex 1i)\n  }\n  25:return targetIndex\n}"
  }, {
    "code": ["          1. Let _O_ be ? ToObject(*this* value).", "          1. Let _sourceLen_ be ? LengthOfArrayLike(_O_).", "          1. If ! IsCallable(_mapperFunction_) is *false*, throw a *TypeError* exception.", "          1. Let _A_ be ? ArraySpeciesCreate(_O_, 0).", "          1. Perform ? FlattenIntoArray(_A_, _O_, _sourceLen_, 0, 1, _mapperFunction_, _thisArg_).", "          1. Return _A_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "mapperFunction"
      }, {
        "kind": "Optional",
        "name": "thisArg"
      }],
      "ref": "Array[\"prototype\"][\"flatMap\"]"
    },
    "ids": "sec-array.prototype.flatmap",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (LengthOfArrayLike O)\n  1:let sourceLen = [? __x1__]\n  2:(2) app __x2__ = (IsCallable mapperFunction)\n  2:if (= [! __x2__] false) (0) throw TypeError else 2:{}\n  3:(3) app __x3__ = (ArraySpeciesCreate O 0i)\n  3:let A = [? __x3__]\n  4:(4) app __x4__ = (FlattenIntoArray A O sourceLen 0i 1i mapperFunction thisArg)\n  4:[? __x4__]\n  5:return A\n}"
  }, {
    "code": ["          1. Let _O_ be ? ToObject(*this* value).", "          1. Let _len_ be ? LengthOfArrayLike(_O_).", "          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.", "          1. Let _k_ be 0.", "          1. Repeat, while _k_ < _len_,", "            1. Let _Pk_ be ! ToString(𝔽(_k_)).", "            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).", "            1. If _kPresent_ is *true*, then", "              1. Let _kValue_ be ? Get(_O_, _Pk_).", "              1. Perform ? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »).", "            1. Set _k_ to _k_ + 1.", "          1. Return *undefined*."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "callbackfn"
      }, {
        "kind": "Optional",
        "name": "thisArg"
      }],
      "ref": "Array[\"prototype\"][\"forEach\"]"
    },
    "ids": "sec-array.prototype.foreach",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (LengthOfArrayLike O)\n  1:let len = [? __x1__]\n  2:(2) app __x2__ = (IsCallable callbackfn)\n  2:if (= __x2__ false) (0) throw TypeError else 2:{}\n  3:let k = 0i\n  4:while (< k len) {\n    5:(3) app __x3__ = (ToString k)\n    5:let Pk = [! __x3__]\n    6:(4) app __x4__ = (HasProperty O Pk)\n    6:let kPresent = [? __x4__]\n    7:if (= kPresent true) {\n      8:(5) app __x5__ = (Get O Pk)\n      8:let kValue = [? __x5__]\n      9:(6) app __x6__ = (Call callbackfn thisArg (1) (new [kValue, k, O]))\n      9:[? __x6__]\n    } else 2:{}\n    10:k = (+ k 1i)\n  }\n  11:return undefined\n}"
  }, {
    "code": ["          1. Let _O_ be ? ToObject(*this* value).", "          1. Let _len_ be ? LengthOfArrayLike(_O_).", "          1. If _len_ is 0, return *false*.", "          1. Let _n_ be ? ToIntegerOrInfinity(_fromIndex_).", "          1. Assert: If _fromIndex_ is *undefined*, then _n_ is 0.", "          1. If _n_ is +∞, return *false*.", "          1. Else if _n_ is -∞, set _n_ to 0.", "          1. If _n_ ≥ 0, then", "            1. Let _k_ be _n_.", "          1. Else,", "            1. Let _k_ be _len_ + _n_.", "            1. If _k_ < 0, set _k_ to 0.", "          1. Repeat, while _k_ < _len_,", "            1. Let _elementK_ be ? Get(_O_, ! ToString(𝔽(_k_))).", "            1. If SameValueZero(_searchElement_, _elementK_) is *true*, return *true*.", "            1. Set _k_ to _k_ + 1.", "          1. Return *false*."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "searchElement"
      }, {
        "kind": "Optional",
        "name": "fromIndex"
      }],
      "ref": "Array[\"prototype\"][\"includes\"]"
    },
    "ids": "sec-array.prototype.includes",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (LengthOfArrayLike O)\n  1:let len = [? __x1__]\n  2:if (= len 0i) return false else 4:{}\n  3:(2) app __x2__ = (ToIntegerOrInfinity fromIndex)\n  3:let n = [? __x2__]\n  6:if (= n Infinity) return false else if (= n -Infinity) n = 0i else 4:{}\n  9:if (! (< n 0i)) let k = n else {\n    10:let k = (+ len n)\n    11:if (< k 0i) k = 0i else 4:{}\n  }\n  12:while (< k len) {\n    13:(3) app __x3__ = (ToString k)\n    13:(4) app __x4__ = (Get O [! __x3__])\n    13:let elementK = [? __x4__]\n    14:(5) app __x5__ = (SameValueZero searchElement elementK)\n    14:if (= __x5__ true) return true else 4:{}\n    15:k = (+ k 1i)\n  }\n  16:return false\n}"
  }, {
    "code": ["          1. Let _O_ be ? ToObject(*this* value).", "          1. Let _len_ be ? LengthOfArrayLike(_O_).", "          1. If _len_ is 0, return *-1*<sub>𝔽</sub>.", "          1. Let _n_ be ? ToIntegerOrInfinity(_fromIndex_).", "          1. Assert: If _fromIndex_ is *undefined*, then _n_ is 0.", "          1. If _n_ is +∞, return *-1*<sub>𝔽</sub>.", "          1. Else if _n_ is -∞, set _n_ to 0.", "          1. If _n_ ≥ 0, then", "            1. Let _k_ be _n_.", "          1. Else,", "            1. Let _k_ be _len_ + _n_.", "            1. If _k_ < 0, set _k_ to 0.", "          1. Repeat, while _k_ < _len_,", "            1. Let _kPresent_ be ? HasProperty(_O_, ! ToString(𝔽(_k_))).", "            1. If _kPresent_ is *true*, then", "              1. Let _elementK_ be ? Get(_O_, ! ToString(𝔽(_k_))).", "              1. Let _same_ be the result of performing Strict Equality Comparison _searchElement_ === _elementK_.", "              1. If _same_ is *true*, return 𝔽(_k_).", "            1. Set _k_ to _k_ + 1.", "          1. Return *-1*<sub>𝔽</sub>."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "searchElement"
      }, {
        "kind": "Optional",
        "name": "fromIndex"
      }],
      "ref": "Array[\"prototype\"][\"indexOf\"]"
    },
    "ids": "sec-array.prototype.indexof",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (LengthOfArrayLike O)\n  1:let len = [? __x1__]\n  2:if (= len 0i) return -1i else 4:{}\n  3:(2) app __x2__ = (ToIntegerOrInfinity fromIndex)\n  3:let n = [? __x2__]\n  6:if (= n Infinity) return -1i else if (= n -Infinity) n = 0i else 4:{}\n  9:if (! (< n 0i)) let k = n else {\n    10:let k = (+ len n)\n    11:if (< k 0i) k = 0i else 4:{}\n  }\n  12:while (< k len) {\n    13:(3) app __x3__ = (ToString k)\n    13:(4) app __x4__ = (HasProperty O [! __x3__])\n    13:let kPresent = [? __x4__]\n    14:if (= kPresent true) {\n      15:(5) app __x5__ = (ToString k)\n      15:(6) app __x6__ = (Get O [! __x5__])\n      15:let elementK = [? __x6__]\n      16:(7) app __x7__ = (StrictEqualityComparison searchElement elementK)\n      16:let same = __x7__\n      17:if (= same true) return k else 4:{}\n    } else 4:{}\n    18:k = (+ k 1i)\n  }\n  19:return -1i\n}"
  }, {
    "code": ["          1. Let _O_ be ? ToObject(*this* value).", "          1. Let _len_ be ? LengthOfArrayLike(_O_).", "          1. If _separator_ is *undefined*, let _sep_ be the single-element String *\",\"*.", "          1. Else, let _sep_ be ? ToString(_separator_).", "          1. Let _R_ be the empty String.", "          1. Let _k_ be 0.", "          1. Repeat, while _k_ < _len_,", "            1. If _k_ > 0, set _R_ to the string-concatenation of _R_ and _sep_.", "            1. Let _element_ be ? Get(_O_, ! ToString(𝔽(_k_))).", "            1. If _element_ is *undefined* or *null*, let _next_ be the empty String; otherwise, let _next_ be ? ToString(_element_).", "            1. Set _R_ to the string-concatenation of _R_ and _next_.", "            1. Set _k_ to _k_ + 1.", "          1. Return _R_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "separator"
      }],
      "ref": "Array[\"prototype\"][\"join\"]"
    },
    "ids": "sec-array.prototype.join",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (LengthOfArrayLike O)\n  1:let len = [? __x1__]\n  2:(0) ??? \"If id:{separator} is value:{undefined} , let id:{sep} be the single - element String value:{\\\",\\\"} .\"\n  3:(2) app sep = (ToString separator)\n  3:[? sep]\n  4:let R = \"\"\n  5:let k = 0i\n  6:while (< k len) {\n    7:if (< 0i k) R = (+ R sep) else 4:{}\n    8:(3) app __x2__ = (ToString k)\n    8:(4) app __x3__ = (Get O [! __x2__])\n    8:let element = [? __x3__]\n    9:if (|| (= element undefined) (= element null)) let next = \"\" else {\n      (5) app __x4__ = (ToString element)\n      let next = [? __x4__]\n    }\n    10:R = (+ R next)\n    11:k = (+ k 1i)\n  }\n  12:return R\n}"
  }, {
    "code": ["          1. Let _O_ be ? ToObject(*this* value).", "          1. Return CreateArrayIterator(_O_, ~key~)."],
    "head": {
      "origParams": [],
      "ref": "Array[\"prototype\"][\"keys\"]"
    },
    "ids": "sec-array.prototype.keys",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (CreateArrayIterator O CONST_key)\n  1:return __x1__\n}"
  }, {
    "code": ["          1. Let _O_ be ? ToObject(*this* value).", "          1. Let _len_ be ? LengthOfArrayLike(_O_).", "          1. If _len_ is 0, return *-1*<sub>𝔽</sub>.", "          1. If _fromIndex_ is present, let _n_ be ? ToIntegerOrInfinity(_fromIndex_); else let _n_ be _len_ - 1.", "          1. If _n_ is -∞, return *-1*<sub>𝔽</sub>.", "          1. If _n_ ≥ 0, then", "            1. Let _k_ be min(_n_, _len_ - 1).", "          1. Else,", "            1. Let _k_ be _len_ + _n_.", "          1. Repeat, while _k_ ≥ 0,", "            1. Let _kPresent_ be ? HasProperty(_O_, ! ToString(𝔽(_k_))).", "            1. If _kPresent_ is *true*, then", "              1. Let _elementK_ be ? Get(_O_, ! ToString(𝔽(_k_))).", "              1. Let _same_ be the result of performing Strict Equality Comparison _searchElement_ === _elementK_.", "              1. If _same_ is *true*, return 𝔽(_k_).", "            1. Set _k_ to _k_ - 1.", "          1. Return *-1*<sub>𝔽</sub>."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "searchElement"
      }, {
        "kind": "Optional",
        "name": "fromIndex"
      }],
      "ref": "Array[\"prototype\"][\"lastIndexOf\"]"
    },
    "ids": "sec-array.prototype.lastindexof",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (LengthOfArrayLike O)\n  1:let len = [? __x1__]\n  2:if (= len 0i) return -1i else 4:{}\n  3:if (! (= fromIndex absent)) {\n    (2) app __x2__ = (ToIntegerOrInfinity fromIndex)\n    let n = [? __x2__]\n  } else let n = (- len 1i)\n  4:if (= n -Infinity) return -1i else 4:{}\n  7:if (! (< n 0i)) {\n    6:(3) app __x3__ = (min n (- len 1i))\n    6:let k = __x3__\n  } else let k = (+ len n)\n  9:while (! (< k 0i)) {\n    10:(4) app __x4__ = (ToString k)\n    10:(5) app __x5__ = (HasProperty O [! __x4__])\n    10:let kPresent = [? __x5__]\n    11:if (= kPresent true) {\n      12:(6) app __x6__ = (ToString k)\n      12:(7) app __x7__ = (Get O [! __x6__])\n      12:let elementK = [? __x7__]\n      13:(8) app __x8__ = (StrictEqualityComparison searchElement elementK)\n      13:let same = __x8__\n      14:if (= same true) return k else 4:{}\n    } else 4:{}\n    15:k = (- k 1i)\n  }\n  16:return -1i\n}"
  }, {
    "code": ["          1. Let _O_ be ? ToObject(*this* value).", "          1. Let _len_ be ? LengthOfArrayLike(_O_).", "          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.", "          1. Let _A_ be ? ArraySpeciesCreate(_O_, _len_).", "          1. Let _k_ be 0.", "          1. Repeat, while _k_ < _len_,", "            1. Let _Pk_ be ! ToString(𝔽(_k_)).", "            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).", "            1. If _kPresent_ is *true*, then", "              1. Let _kValue_ be ? Get(_O_, _Pk_).", "              1. Let _mappedValue_ be ? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »).", "              1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_).", "            1. Set _k_ to _k_ + 1.", "          1. Return _A_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "callbackfn"
      }, {
        "kind": "Optional",
        "name": "thisArg"
      }],
      "ref": "Array[\"prototype\"][\"map\"]"
    },
    "ids": "sec-array.prototype.map",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (LengthOfArrayLike O)\n  1:let len = [? __x1__]\n  2:(2) app __x2__ = (IsCallable callbackfn)\n  2:if (= __x2__ false) (0) throw TypeError else 4:{}\n  3:(3) app __x3__ = (ArraySpeciesCreate O len)\n  3:let A = [? __x3__]\n  4:let k = 0i\n  5:while (< k len) {\n    6:(4) app __x4__ = (ToString k)\n    6:let Pk = [! __x4__]\n    7:(5) app __x5__ = (HasProperty O Pk)\n    7:let kPresent = [? __x5__]\n    8:if (= kPresent true) {\n      9:(6) app __x6__ = (Get O Pk)\n      9:let kValue = [? __x6__]\n      10:(7) app __x7__ = (Call callbackfn thisArg (1) (new [kValue, k, O]))\n      10:let mappedValue = [? __x7__]\n      11:(8) app __x8__ = (CreateDataPropertyOrThrow A Pk mappedValue)\n      11:[? __x8__]\n    } else 4:{}\n    12:k = (+ k 1i)\n  }\n  13:return A\n}"
  }, {
    "code": ["          1. Let _O_ be ? ToObject(*this* value).", "          1. Let _len_ be ? LengthOfArrayLike(_O_).", "          1. If _len_ = 0, then", "            1. Perform ? Set(_O_, *\"length\"*, *+0*<sub>𝔽</sub>, *true*).", "            1. Return *undefined*.", "          1. Else,", "            1. Assert: _len_ > 0.", "            1. Let _newLen_ be 𝔽(_len_ - 1).", "            1. Let _index_ be ! ToString(_newLen_).", "            1. Let _element_ be ? Get(_O_, _index_).", "            1. Perform ? DeletePropertyOrThrow(_O_, _index_).", "            1. Perform ? Set(_O_, *\"length\"*, _newLen_, *true*).", "            1. Return _element_."],
    "head": {
      "origParams": [],
      "ref": "Array[\"prototype\"][\"pop\"]"
    },
    "ids": "sec-array.prototype.pop",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (LengthOfArrayLike O)\n  1:let len = [? __x1__]\n  5:if (== len 0i) {\n    3:(2) app __x2__ = (Set O \"length\" 0i true)\n    3:[? __x2__]\n    4:return undefined\n  } else {\n    6:assert (< 0i len)\n    7:let newLen = (- len 1i)\n    8:(3) app __x3__ = (ToString newLen)\n    8:let index = [! __x3__]\n    9:(4) app __x4__ = (Get O index)\n    9:let element = [? __x4__]\n    10:(5) app __x5__ = (DeletePropertyOrThrow O index)\n    10:[? __x5__]\n    11:(6) app __x6__ = (Set O \"length\" newLen true)\n    11:[? __x6__]\n    12:return element\n  }\n}"
  }, {
    "code": ["          1. Let _O_ be ? ToObject(*this* value).", "          1. Let _len_ be ? LengthOfArrayLike(_O_).", "          1. Let _argCount_ be the number of elements in _items_.", "          1. If _len_ + _argCount_ > 2<sup>53</sup> - 1, throw a *TypeError* exception.", "          1. For each element _E_ of _items_, do", "            1. Perform ? Set(_O_, ! ToString(𝔽(_len_)), _E_, *true*).", "            1. Set _len_ to _len_ + 1.", "          1. Perform ? Set(_O_, *\"length\"*, 𝔽(_len_), *true*).", "          1. Return 𝔽(_len_)."],
    "head": {
      "origParams": [{
        "kind": "Variadic",
        "name": "items"
      }],
      "ref": "Array[\"prototype\"][\"push\"]"
    },
    "ids": "sec-array.prototype.push",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (LengthOfArrayLike O)\n  1:let len = [? __x1__]\n  2:let argCount = items[\"length\"]\n  3:if (< (- (** 2.0 53i) 1i) (+ len argCount)) (0) throw TypeError else 4:{}\n  4:let __x2__ = items\n  4:let __x3__ = 0i\n  4:while (< __x3__ __x2__[\"length\"]) {\n    let E = __x2__[__x3__]\n    5:(2) app __x4__ = (ToString len)\n    5:(3) app __x5__ = (Set O [! __x4__] E true)\n    5:[? __x5__]\n    6:len = (+ len 1i)\n    __x3__ = (+ __x3__ 1i)\n  }\n  7:(4) app __x6__ = (Set O \"length\" len true)\n  7:[? __x6__]\n  8:return len\n}"
  }, {
    "code": ["          1. Let _O_ be ? ToObject(*this* value).", "          1. Let _len_ be ? LengthOfArrayLike(_O_).", "          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.", "          1. If _len_ = 0 and _initialValue_ is not present, throw a *TypeError* exception.", "          1. Let _k_ be 0.", "          1. Let _accumulator_ be *undefined*.", "          1. If _initialValue_ is present, then", "            1. Set _accumulator_ to _initialValue_.", "          1. Else,", "            1. Let _kPresent_ be *false*.", "            1. Repeat, while _kPresent_ is *false* and _k_ < _len_,", "              1. Let _Pk_ be ! ToString(𝔽(_k_)).", "              1. Set _kPresent_ to ? HasProperty(_O_, _Pk_).", "              1. If _kPresent_ is *true*, then", "                1. Set _accumulator_ to ? Get(_O_, _Pk_).", "              1. Set _k_ to _k_ + 1.", "            1. If _kPresent_ is *false*, throw a *TypeError* exception.", "          1. Repeat, while _k_ < _len_,", "            1. Let _Pk_ be ! ToString(𝔽(_k_)).", "            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).", "            1. If _kPresent_ is *true*, then", "              1. Let _kValue_ be ? Get(_O_, _Pk_).", "              1. Set _accumulator_ to ? Call(_callbackfn_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »).", "            1. Set _k_ to _k_ + 1.", "          1. Return _accumulator_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "callbackfn"
      }, {
        "kind": "Optional",
        "name": "initialValue"
      }],
      "ref": "Array[\"prototype\"][\"reduce\"]"
    },
    "ids": "sec-array.prototype.reduce",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (LengthOfArrayLike O)\n  1:let len = [? __x1__]\n  2:(2) app __x2__ = (IsCallable callbackfn)\n  2:if (= __x2__ false) (0) throw TypeError else 4:{}\n  3:if (&& (== len 0i) (= initialValue absent)) (1) throw TypeError else 4:{}\n  4:let k = 0i\n  5:let accumulator = undefined\n  8:if (! (= initialValue absent)) accumulator = initialValue else {\n    9:let kPresent = false\n    10:while (&& (= kPresent false) (< k len)) {\n      11:(3) app __x3__ = (ToString k)\n      11:let Pk = [! __x3__]\n      12:(4) app __x4__ = (HasProperty O Pk)\n      12:kPresent = [? __x4__]\n      13:if (= kPresent true) {\n        14:(5) app __x5__ = (Get O Pk)\n        14:accumulator = [? __x5__]\n      } else 4:{}\n      15:k = (+ k 1i)\n    }\n    16:if (= kPresent false) (2) throw TypeError else 4:{}\n  }\n  17:while (< k len) {\n    18:(6) app __x6__ = (ToString k)\n    18:let Pk = [! __x6__]\n    19:(7) app __x7__ = (HasProperty O Pk)\n    19:let kPresent = [? __x7__]\n    20:if (= kPresent true) {\n      21:(8) app __x8__ = (Get O Pk)\n      21:let kValue = [? __x8__]\n      22:(9) app __x9__ = (Call callbackfn undefined (3) (new [accumulator, kValue, k, O]))\n      22:accumulator = [? __x9__]\n    } else 4:{}\n    23:k = (+ k 1i)\n  }\n  24:return accumulator\n}"
  }, {
    "code": ["          1. Let _O_ be ? ToObject(*this* value).", "          1. Let _len_ be ? LengthOfArrayLike(_O_).", "          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.", "          1. If _len_ is 0 and _initialValue_ is not present, throw a *TypeError* exception.", "          1. Let _k_ be _len_ - 1.", "          1. Let _accumulator_ be *undefined*.", "          1. If _initialValue_ is present, then", "            1. Set _accumulator_ to _initialValue_.", "          1. Else,", "            1. Let _kPresent_ be *false*.", "            1. Repeat, while _kPresent_ is *false* and _k_ ≥ 0,", "              1. Let _Pk_ be ! ToString(𝔽(_k_)).", "              1. Set _kPresent_ to ? HasProperty(_O_, _Pk_).", "              1. If _kPresent_ is *true*, then", "                1. Set _accumulator_ to ? Get(_O_, _Pk_).", "              1. Set _k_ to _k_ - 1.", "            1. If _kPresent_ is *false*, throw a *TypeError* exception.", "          1. Repeat, while _k_ ≥ 0,", "            1. Let _Pk_ be ! ToString(𝔽(_k_)).", "            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).", "            1. If _kPresent_ is *true*, then", "              1. Let _kValue_ be ? Get(_O_, _Pk_).", "              1. Set _accumulator_ to ? Call(_callbackfn_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »).", "            1. Set _k_ to _k_ - 1.", "          1. Return _accumulator_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "callbackfn"
      }, {
        "kind": "Optional",
        "name": "initialValue"
      }],
      "ref": "Array[\"prototype\"][\"reduceRight\"]"
    },
    "ids": "sec-array.prototype.reduceright",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (LengthOfArrayLike O)\n  1:let len = [? __x1__]\n  2:(2) app __x2__ = (IsCallable callbackfn)\n  2:if (= __x2__ false) (0) throw TypeError else 4:{}\n  3:if (&& (= len 0i) (= initialValue absent)) (1) throw TypeError else 4:{}\n  4:let k = (- len 1i)\n  5:let accumulator = undefined\n  8:if (! (= initialValue absent)) accumulator = initialValue else {\n    9:let kPresent = false\n    10:while (&& (= kPresent false) (! (< k 0i))) {\n      11:(3) app __x3__ = (ToString k)\n      11:let Pk = [! __x3__]\n      12:(4) app __x4__ = (HasProperty O Pk)\n      12:kPresent = [? __x4__]\n      13:if (= kPresent true) {\n        14:(5) app __x5__ = (Get O Pk)\n        14:accumulator = [? __x5__]\n      } else 4:{}\n      15:k = (- k 1i)\n    }\n    16:if (= kPresent false) (2) throw TypeError else 4:{}\n  }\n  17:while (! (< k 0i)) {\n    18:(6) app __x6__ = (ToString k)\n    18:let Pk = [! __x6__]\n    19:(7) app __x7__ = (HasProperty O Pk)\n    19:let kPresent = [? __x7__]\n    20:if (= kPresent true) {\n      21:(8) app __x8__ = (Get O Pk)\n      21:let kValue = [? __x8__]\n      22:(9) app __x9__ = (Call callbackfn undefined (3) (new [accumulator, kValue, k, O]))\n      22:accumulator = [? __x9__]\n    } else 4:{}\n    23:k = (- k 1i)\n  }\n  24:return accumulator\n}"
  }, {
    "code": ["          1. Let _O_ be ? ToObject(*this* value).", "          1. Let _len_ be ? LengthOfArrayLike(_O_).", "          1. Let _middle_ be floor(_len_ / 2).", "          1. Let _lower_ be 0.", "          1. Repeat, while _lower_ ≠ _middle_,", "            1. Let _upper_ be _len_ - _lower_ - 1.", "            1. Let _upperP_ be ! ToString(𝔽(_upper_)).", "            1. Let _lowerP_ be ! ToString(𝔽(_lower_)).", "            1. Let _lowerExists_ be ? HasProperty(_O_, _lowerP_).", "            1. If _lowerExists_ is *true*, then", "              1. Let _lowerValue_ be ? Get(_O_, _lowerP_).", "            1. Let _upperExists_ be ? HasProperty(_O_, _upperP_).", "            1. If _upperExists_ is *true*, then", "              1. Let _upperValue_ be ? Get(_O_, _upperP_).", "            1. If _lowerExists_ is *true* and _upperExists_ is *true*, then", "              1. Perform ? Set(_O_, _lowerP_, _upperValue_, *true*).", "              1. Perform ? Set(_O_, _upperP_, _lowerValue_, *true*).", "            1. Else if _lowerExists_ is *false* and _upperExists_ is *true*, then", "              1. Perform ? Set(_O_, _lowerP_, _upperValue_, *true*).", "              1. Perform ? DeletePropertyOrThrow(_O_, _upperP_).", "            1. Else if _lowerExists_ is *true* and _upperExists_ is *false*, then", "              1. Perform ? DeletePropertyOrThrow(_O_, _lowerP_).", "              1. Perform ? Set(_O_, _upperP_, _lowerValue_, *true*).", "            1. Else,", "              1. Assert: _lowerExists_ and _upperExists_ are both *false*.", "              1. No action is required.", "            1. Set _lower_ to _lower_ + 1.", "          1. Return _O_."],
    "head": {
      "origParams": [],
      "ref": "Array[\"prototype\"][\"reverse\"]"
    },
    "ids": "sec-array.prototype.reverse",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (LengthOfArrayLike O)\n  1:let len = [? __x1__]\n  2:(2) app __x2__ = (floor (/ len 2i))\n  2:let middle = __x2__\n  3:let lower = 0i\n  4:while (! (== lower middle)) {\n    5:let upper = (- (- len lower) 1i)\n    6:(3) app __x3__ = (ToString upper)\n    6:let upperP = [! __x3__]\n    7:(4) app __x4__ = (ToString lower)\n    7:let lowerP = [! __x4__]\n    8:(5) app __x5__ = (HasProperty O lowerP)\n    8:let lowerExists = [? __x5__]\n    9:if (= lowerExists true) {\n      10:(6) app __x6__ = (Get O lowerP)\n      10:let lowerValue = [? __x6__]\n    } else 25:{}\n    11:(7) app __x7__ = (HasProperty O upperP)\n    11:let upperExists = [? __x7__]\n    12:if (= upperExists true) {\n      13:(8) app __x8__ = (Get O upperP)\n      13:let upperValue = [? __x8__]\n    } else 25:{}\n    23:if (&& (= lowerExists true) (= upperExists true)) {\n      15:(9) app __x9__ = (Set O lowerP upperValue true)\n      15:[? __x9__]\n      16:(10) app __x10__ = (Set O upperP lowerValue true)\n      16:[? __x10__]\n    } else if (&& (= lowerExists false) (= upperExists true)) {\n      18:(11) app __x11__ = (Set O lowerP upperValue true)\n      18:[? __x11__]\n      19:(12) app __x12__ = (DeletePropertyOrThrow O upperP)\n      19:[? __x12__]\n    } else if (&& (= lowerExists true) (= upperExists false)) {\n      21:(13) app __x13__ = (DeletePropertyOrThrow O lowerP)\n      21:[? __x13__]\n      22:(14) app __x14__ = (Set O upperP lowerValue true)\n      22:[? __x14__]\n    } else assert (&& (= lowerExists false) (= upperExists false))\n    26:lower = (+ lower 1i)\n  }\n  27:return O\n}"
  }, {
    "code": ["          1. Let _O_ be ? ToObject(*this* value).", "          1. Let _len_ be ? LengthOfArrayLike(_O_).", "          1. If _len_ = 0, then", "            1. Perform ? Set(_O_, *\"length\"*, *+0*<sub>𝔽</sub>, *true*).", "            1. Return *undefined*.", "          1. Let _first_ be ? Get(_O_, *\"0\"*).", "          1. Let _k_ be 1.", "          1. Repeat, while _k_ < _len_,", "            1. Let _from_ be ! ToString(𝔽(_k_)).", "            1. Let _to_ be ! ToString(𝔽(_k_ - 1)).", "            1. Let _fromPresent_ be ? HasProperty(_O_, _from_).", "            1. If _fromPresent_ is *true*, then", "              1. Let _fromVal_ be ? Get(_O_, _from_).", "              1. Perform ? Set(_O_, _to_, _fromVal_, *true*).", "            1. Else,", "              1. Assert: _fromPresent_ is *false*.", "              1. Perform ? DeletePropertyOrThrow(_O_, _to_).", "            1. Set _k_ to _k_ + 1.", "          1. Perform ? DeletePropertyOrThrow(_O_, ! ToString(𝔽(_len_ - 1))).", "          1. Perform ? Set(_O_, *\"length\"*, 𝔽(_len_ - 1), *true*).", "          1. Return _first_."],
    "head": {
      "origParams": [],
      "ref": "Array[\"prototype\"][\"shift\"]"
    },
    "ids": "sec-array.prototype.shift",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (LengthOfArrayLike O)\n  1:let len = [? __x1__]\n  2:if (== len 0i) {\n    3:(2) app __x2__ = (Set O \"length\" 0i true)\n    3:[? __x2__]\n    4:return undefined\n  } else 25:{}\n  5:(3) app __x3__ = (Get O \"0\")\n  5:let first = [? __x3__]\n  6:let k = 1i\n  7:while (< k len) {\n    8:(4) app __x4__ = (ToString k)\n    8:let from = [! __x4__]\n    9:(5) app __x5__ = (ToString (- k 1i))\n    9:let to = [! __x5__]\n    10:(6) app __x6__ = (HasProperty O from)\n    10:let fromPresent = [? __x6__]\n    14:if (= fromPresent true) {\n      12:(7) app __x7__ = (Get O from)\n      12:let fromVal = [? __x7__]\n      13:(8) app __x8__ = (Set O to fromVal true)\n      13:[? __x8__]\n    } else {\n      15:assert (= fromPresent false)\n      16:(9) app __x9__ = (DeletePropertyOrThrow O to)\n      16:[? __x9__]\n    }\n    17:k = (+ k 1i)\n  }\n  18:(10) app __x10__ = (ToString (- len 1i))\n  18:(11) app __x11__ = (DeletePropertyOrThrow O [! __x10__])\n  18:[? __x11__]\n  19:(12) app __x12__ = (Set O \"length\" (- len 1i) true)\n  19:[? __x12__]\n  20:return first\n}"
  }, {
    "code": ["          1. Let _O_ be ? ToObject(*this* value).", "          1. Let _len_ be ? LengthOfArrayLike(_O_).", "          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).", "          1. If _relativeStart_ is -∞, let _k_ be 0.", "          1. Else if _relativeStart_ < 0, let _k_ be max(_len_ + _relativeStart_, 0).", "          1. Else, let _k_ be min(_relativeStart_, _len_).", "          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).", "          1. If _relativeEnd_ is -∞, let _final_ be 0.", "          1. Else if _relativeEnd_ < 0, let _final_ be max(_len_ + _relativeEnd_, 0).", "          1. Else, let _final_ be min(_relativeEnd_, _len_).", "          1. Let _count_ be max(_final_ - _k_, 0).", "          1. Let _A_ be ? ArraySpeciesCreate(_O_, _count_).", "          1. Let _n_ be 0.", "          1. Repeat, while _k_ < _final_,", "            1. Let _Pk_ be ! ToString(𝔽(_k_)).", "            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).", "            1. If _kPresent_ is *true*, then", "              1. Let _kValue_ be ? Get(_O_, _Pk_).", "              1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _kValue_).", "            1. Set _k_ to _k_ + 1.", "            1. Set _n_ to _n_ + 1.", "          1. [id=\"step-array-proto-slice-set-length\"] Perform ? Set(_A_, *\"length\"*, 𝔽(_n_), *true*).", "          1. Return _A_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "start"
      }, {
        "kind": "Normal",
        "name": "end"
      }],
      "ref": "Array[\"prototype\"][\"slice\"]"
    },
    "ids": "sec-array.prototype.slice",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (LengthOfArrayLike O)\n  1:let len = [? __x1__]\n  2:(2) app __x2__ = (ToIntegerOrInfinity start)\n  2:let relativeStart = [? __x2__]\n  5:if (= relativeStart -Infinity) let k = 0i else if (< relativeStart 0i) {\n    (3) app __x3__ = (max (+ len relativeStart) 0i)\n    let k = __x3__\n  } else {\n    (4) app __x4__ = (min relativeStart len)\n    let k = __x4__\n  }\n  6:if (= end undefined) let relativeEnd = len else {\n    (5) app __x5__ = (ToIntegerOrInfinity end)\n    let relativeEnd = [? __x5__]\n  }\n  9:if (= relativeEnd -Infinity) let final = 0i else if (< relativeEnd 0i) {\n    (6) app __x6__ = (max (+ len relativeEnd) 0i)\n    let final = __x6__\n  } else {\n    (7) app __x7__ = (min relativeEnd len)\n    let final = __x7__\n  }\n  10:(8) app __x8__ = (max (- final k) 0i)\n  10:let count = __x8__\n  11:(9) app __x9__ = (ArraySpeciesCreate O count)\n  11:let A = [? __x9__]\n  12:let n = 0i\n  13:while (< k final) {\n    14:(10) app __x10__ = (ToString k)\n    14:let Pk = [! __x10__]\n    15:(11) app __x11__ = (HasProperty O Pk)\n    15:let kPresent = [? __x11__]\n    16:if (= kPresent true) {\n      17:(12) app __x12__ = (Get O Pk)\n      17:let kValue = [? __x12__]\n      18:(13) app __x13__ = (ToString n)\n      18:(14) app __x14__ = (CreateDataPropertyOrThrow A [! __x13__] kValue)\n      18:[? __x14__]\n    } else 25:{}\n    19:k = (+ k 1i)\n    20:n = (+ n 1i)\n  }\n  21:(15) app __x15__ = (Set A \"length\" n true)\n  21:[? __x15__]\n  22:return A\n}"
  }, {
    "code": ["          1. Let _O_ be ? ToObject(*this* value).", "          1. Let _len_ be ? LengthOfArrayLike(_O_).", "          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.", "          1. Let _k_ be 0.", "          1. Repeat, while _k_ < _len_,", "            1. Let _Pk_ be ! ToString(𝔽(_k_)).", "            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).", "            1. If _kPresent_ is *true*, then", "              1. Let _kValue_ be ? Get(_O_, _Pk_).", "              1. Let _testResult_ be ! ToBoolean(? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).", "              1. If _testResult_ is *true*, return *true*.", "            1. Set _k_ to _k_ + 1.", "          1. Return *false*."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "callbackfn"
      }, {
        "kind": "Optional",
        "name": "thisArg"
      }],
      "ref": "Array[\"prototype\"][\"some\"]"
    },
    "ids": "sec-array.prototype.some",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (LengthOfArrayLike O)\n  1:let len = [? __x1__]\n  2:(2) app __x2__ = (IsCallable callbackfn)\n  2:if (= __x2__ false) (0) throw TypeError else 25:{}\n  3:let k = 0i\n  4:while (< k len) {\n    5:(3) app __x3__ = (ToString k)\n    5:let Pk = [! __x3__]\n    6:(4) app __x4__ = (HasProperty O Pk)\n    6:let kPresent = [? __x4__]\n    7:if (= kPresent true) {\n      8:(5) app __x5__ = (Get O Pk)\n      8:let kValue = [? __x5__]\n      9:(6) app __x6__ = (Call callbackfn thisArg (1) (new [kValue, k, O]))\n      9:(7) app __x7__ = (ToBoolean [? __x6__])\n      9:let testResult = [! __x7__]\n      10:if (= testResult true) return true else 25:{}\n    } else 25:{}\n    11:k = (+ k 1i)\n  }\n  12:return false\n}"
  }, {
    "code": ["          1. [id=\"step-array-sort-comparefn\"] If _comparefn_ is not *undefined* and IsCallable(_comparefn_) is *false*, throw a *TypeError* exception.", "          1. Let _obj_ be ? ToObject(*this* value).", "          1. [id=\"step-array-sort-len\"] Let _len_ be ? LengthOfArrayLike(_obj_).", "          1. Let _items_ be a new empty List.", "          1. Let _k_ be 0.", "          1. Repeat, while _k_ < _len_,", "            1. Let _Pk_ be ! ToString(𝔽(_k_)).", "            1. Let _kPresent_ be ? HasProperty(_obj_, _Pk_).", "            1. If _kPresent_ is *true*, then", "              1. Let _kValue_ be ? Get(_obj_, _Pk_).", "              1. Append _kValue_ to _items_.", "            1. Set _k_ to _k_ + 1.", "          1. Let _itemCount_ be the number of elements in _items_.", "          1. [id=\"step-array-sort\"] Sort _items_ using an implementation-defined sequence of calls to SortCompare. If any such call returns an abrupt completion, stop before performing any further calls to SortCompare or steps in this algorithm and return that completion.", "          1. Let _j_ be 0.", "          1. Repeat, while _j_ < _itemCount_,", "            1. Perform ? Set(_obj_, ! ToString(𝔽(_j_)), _items_[_j_], *true*).", "            1. Set _j_ to _j_ + 1.", "          1. Repeat, while _j_ < _len_,", "            1. Perform ? DeletePropertyOrThrow(_obj_, ! ToString(𝔽(_j_))).", "            1. Set _j_ to _j_ + 1.", "          1. Return _obj_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "comparefn"
      }],
      "ref": "Array[\"prototype\"][\"sort\"]"
    },
    "ids": "sec-array.prototype.sort",
    "rawBody": "{\n  0:let __x0__ = true\n  0:__x0__ = (! (= comparefn undefined))\n  0:if __x0__ {\n    (0) app __x1__ = (IsCallable comparefn)\n    __x0__ = (= __x1__ false)\n  } else 25:{}\n  0:if __x0__ (0) throw TypeError else 25:{}\n  1:(1) app __x2__ = (ToObject this)\n  1:let obj = [? __x2__]\n  2:(2) app __x3__ = (LengthOfArrayLike obj)\n  2:let len = [? __x3__]\n  3:let items = (1) (new [])\n  4:let k = 0i\n  5:while (< k len) {\n    6:(3) app __x4__ = (ToString k)\n    6:let Pk = [! __x4__]\n    7:(4) app __x5__ = (HasProperty obj Pk)\n    7:let kPresent = [? __x5__]\n    8:if (= kPresent true) {\n      9:(5) app __x6__ = (Get obj Pk)\n      9:let kValue = [? __x6__]\n      10:append kValue -> items\n    } else 25:{}\n    11:k = (+ k 1i)\n  }\n  12:let itemCount = items[\"length\"]\n  13:(2) ??? \"Sort id:{items} using an implementation - defined sequence of calls to SortCompare . If any such call returns an abrupt completion , stop before performing any further calls to SortCompare or steps in this algorithm and return that completion .\"\n  14:let j = 0i\n  15:while (< j itemCount) {\n    16:(6) app __x7__ = (ToString j)\n    16:(7) app __x8__ = (Set obj [! __x7__] items[j] true)\n    16:[? __x8__]\n    17:j = (+ j 1i)\n  }\n  18:while (< j len) {\n    19:(8) app __x9__ = (ToString j)\n    19:(9) app __x10__ = (DeletePropertyOrThrow obj [! __x9__])\n    19:[? __x10__]\n    20:j = (+ j 1i)\n  }\n  21:return obj\n}"
  }, {
    "code": ["            1. If _x_ and _y_ are both *undefined*, return *+0*<sub>𝔽</sub>.", "            1. If _x_ is *undefined*, return *1*<sub>𝔽</sub>.", "            1. If _y_ is *undefined*, return *-1*<sub>𝔽</sub>.", "            1. If _comparefn_ is not *undefined*, then", "              1. Let _v_ be ? ToNumber(? Call(_comparefn_, *undefined*, « _x_, _y_ »)).", "              1. If _v_ is *NaN*, return *+0*<sub>𝔽</sub>.", "              1. Return _v_.", "            1. [id=\"step-sortcompare-tostring-x\"] Let _xString_ be ? ToString(_x_).", "            1. [id=\"step-sortcompare-tostring-y\"] Let _yString_ be ? ToString(_y_).", "            1. Let _xSmaller_ be the result of performing Abstract Relational Comparison _xString_ < _yString_.", "            1. If _xSmaller_ is *true*, return *-1*<sub>𝔽</sub>.", "            1. Let _ySmaller_ be the result of performing Abstract Relational Comparison _yString_ < _xString_.", "            1. If _ySmaller_ is *true*, return *1*<sub>𝔽</sub>.", "            1. Return *+0*<sub>𝔽</sub>."],
    "head": {
      "name": "SortCompare",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "sec-sortcompare",
    "rawBody": "{\n  0:if (&& (= x undefined) (= y undefined)) return 0i else 25:{}\n  1:if (= x undefined) return 1i else 25:{}\n  2:if (= y undefined) return -1i else 25:{}\n  3:if (! (= comparefn undefined)) {\n    4:(0) app __x0__ = (Call comparefn undefined (0) (new [x, y]))\n    4:(1) app __x1__ = (ToNumber [? __x0__])\n    4:let v = [? __x1__]\n    5:if (= v NaN) return 0i else 25:{}\n    6:return v\n  } else 25:{}\n  7:(2) app __x2__ = (ToString x)\n  7:let xString = [? __x2__]\n  8:(3) app __x3__ = (ToString y)\n  8:let yString = [? __x3__]\n  9:(4) app __x4__ = (AbstractRelationalComparison xString yString)\n  9:let xSmaller = __x4__\n  10:if (= xSmaller true) return -1i else 25:{}\n  11:(5) app __x5__ = (AbstractRelationalComparison yString xString)\n  11:let ySmaller = __x5__\n  12:if (= ySmaller true) return 1i else 25:{}\n  13:return 0i\n}"
  }, {
    "code": ["          1. Let _O_ be ? ToObject(*this* value).", "          1. Let _len_ be ? LengthOfArrayLike(_O_).", "          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).", "          1. If _relativeStart_ is -∞, let _actualStart_ be 0.", "          1. Else if _relativeStart_ < 0, let _actualStart_ be max(_len_ + _relativeStart_, 0).", "          1. Else, let _actualStart_ be min(_relativeStart_, _len_).", "          1. If _start_ is not present, then", "            1. Let _insertCount_ be 0.", "            1. Let _actualDeleteCount_ be 0.", "          1. Else if _deleteCount_ is not present, then", "            1. Let _insertCount_ be 0.", "            1. Let _actualDeleteCount_ be _len_ - _actualStart_.", "          1. Else,", "            1. Let _insertCount_ be the number of elements in _items_.", "            1. Let _dc_ be ? ToIntegerOrInfinity(_deleteCount_).", "            1. Let _actualDeleteCount_ be the result of clamping _dc_ between 0 and _len_ - _actualStart_.", "          1. If _len_ + _insertCount_ - _actualDeleteCount_ > 2<sup>53</sup> - 1, throw a *TypeError* exception.", "          1. Let _A_ be ? ArraySpeciesCreate(_O_, _actualDeleteCount_).", "          1. Let _k_ be 0.", "          1. Repeat, while _k_ < _actualDeleteCount_,", "            1. Let _from_ be ! ToString(𝔽(_actualStart_ + _k_)).", "            1. Let _fromPresent_ be ? HasProperty(_O_, _from_).", "            1. If _fromPresent_ is *true*, then", "              1. Let _fromValue_ be ? Get(_O_, _from_).", "              1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_k_)), _fromValue_).", "            1. Set _k_ to _k_ + 1.", "          1. Perform ? Set(_A_, *\"length\"*, 𝔽(_actualDeleteCount_), *true*).", "          1. Let _itemCount_ be the number of elements in _items_.", "          1. If _itemCount_ < _actualDeleteCount_, then", "            1. Set _k_ to _actualStart_.", "            1. Repeat, while _k_ < (_len_ - _actualDeleteCount_),", "              1. Let _from_ be ! ToString(𝔽(_k_ + _actualDeleteCount_)).", "              1. Let _to_ be ! ToString(𝔽(_k_ + _itemCount_)).", "              1. Let _fromPresent_ be ? HasProperty(_O_, _from_).", "              1. If _fromPresent_ is *true*, then", "                1. Let _fromValue_ be ? Get(_O_, _from_).", "                1. Perform ? Set(_O_, _to_, _fromValue_, *true*).", "              1. Else,", "                1. Assert: _fromPresent_ is *false*.", "                1. Perform ? DeletePropertyOrThrow(_O_, _to_).", "              1. Set _k_ to _k_ + 1.", "            1. Set _k_ to _len_.", "            1. Repeat, while _k_ > (_len_ - _actualDeleteCount_ + _itemCount_),", "              1. Perform ? DeletePropertyOrThrow(_O_, ! ToString(𝔽(_k_ - 1))).", "              1. Set _k_ to _k_ - 1.", "          1. Else if _itemCount_ > _actualDeleteCount_, then", "            1. Set _k_ to (_len_ - _actualDeleteCount_).", "            1. Repeat, while _k_ > _actualStart_,", "              1. Let _from_ be ! ToString(𝔽(_k_ + _actualDeleteCount_ - 1)).", "              1. Let _to_ be ! ToString(𝔽(_k_ + _itemCount_ - 1)).", "              1. Let _fromPresent_ be ? HasProperty(_O_, _from_).", "              1. If _fromPresent_ is *true*, then", "                1. Let _fromValue_ be ? Get(_O_, _from_).", "                1. Perform ? Set(_O_, _to_, _fromValue_, *true*).", "              1. Else,", "                1. Assert: _fromPresent_ is *false*.", "                1. Perform ? DeletePropertyOrThrow(_O_, _to_).", "              1. Set _k_ to _k_ - 1.", "          1. Set _k_ to _actualStart_.", "          1. For each element _E_ of _items_, do", "            1. Perform ? Set(_O_, ! ToString(𝔽(_k_)), _E_, *true*).", "            1. Set _k_ to _k_ + 1.", "          1. [id=\"step-array-proto-splice-set-length\"] Perform ? Set(_O_, *\"length\"*, 𝔽(_len_ - _actualDeleteCount_ + _itemCount_), *true*).", "          1. Return _A_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "start"
      }, {
        "kind": "Normal",
        "name": "deleteCount"
      }, {
        "kind": "Variadic",
        "name": "items"
      }],
      "ref": "Array[\"prototype\"][\"splice\"]"
    },
    "ids": "sec-array.prototype.splice",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (LengthOfArrayLike O)\n  1:let len = [? __x1__]\n  2:(2) app __x2__ = (ToIntegerOrInfinity start)\n  2:let relativeStart = [? __x2__]\n  5:if (= relativeStart -Infinity) let actualStart = 0i else if (< relativeStart 0i) {\n    (3) app __x3__ = (max (+ len relativeStart) 0i)\n    let actualStart = __x3__\n  } else {\n    (4) app __x4__ = (min relativeStart len)\n    let actualStart = __x4__\n  }\n  12:if (= start absent) {\n    7:let insertCount = 0i\n    8:let actualDeleteCount = 0i\n  } else if (= deleteCount absent) {\n    10:let insertCount = 0i\n    11:let actualDeleteCount = (- len actualStart)\n  } else {\n    13:let insertCount = items[\"length\"]\n    14:(5) app __x5__ = (ToIntegerOrInfinity deleteCount)\n    14:let dc = [? __x5__]\n    15:(0) ??? \"Let id:{actualDeleteCount} be the result of clamping id:{dc} between 0 and id:{len} - id:{actualStart} .\"\n  }\n  16:if (< (- (** 2.0 53i) 1i) (- (+ len insertCount) actualDeleteCount)) (1) throw TypeError else 25:{}\n  17:(6) app __x6__ = (ArraySpeciesCreate O actualDeleteCount)\n  17:let A = [? __x6__]\n  18:let k = 0i\n  19:while (< k actualDeleteCount) {\n    20:(7) app __x7__ = (ToString (+ actualStart k))\n    20:let from = [! __x7__]\n    21:(8) app __x8__ = (HasProperty O from)\n    21:let fromPresent = [? __x8__]\n    22:if (= fromPresent true) {\n      23:(9) app __x9__ = (Get O from)\n      23:let fromValue = [? __x9__]\n      24:(10) app __x10__ = (ToString k)\n      24:(11) app __x11__ = (CreateDataPropertyOrThrow A [! __x10__] fromValue)\n      24:[? __x11__]\n    } else 25:{}\n    25:k = (+ k 1i)\n  }\n  26:(12) app __x12__ = (Set A \"length\" actualDeleteCount true)\n  26:[? __x12__]\n  27:let itemCount = items[\"length\"]\n  45:if (< itemCount actualDeleteCount) {\n    29:k = actualStart\n    30:while (< k (- len actualDeleteCount)) {\n      31:(13) app __x13__ = (ToString (+ k actualDeleteCount))\n      31:let from = [! __x13__]\n      32:(14) app __x14__ = (ToString (+ k itemCount))\n      32:let to = [! __x14__]\n      33:(15) app __x15__ = (HasProperty O from)\n      33:let fromPresent = [? __x15__]\n      37:if (= fromPresent true) {\n        35:(16) app __x16__ = (Get O from)\n        35:let fromValue = [? __x16__]\n        36:(17) app __x17__ = (Set O to fromValue true)\n        36:[? __x17__]\n      } else {\n        38:assert (= fromPresent false)\n        39:(18) app __x18__ = (DeletePropertyOrThrow O to)\n        39:[? __x18__]\n      }\n      40:k = (+ k 1i)\n    }\n    41:k = len\n    42:while (< (+ (- len actualDeleteCount) itemCount) k) {\n      43:(19) app __x19__ = (ToString (- k 1i))\n      43:(20) app __x20__ = (DeletePropertyOrThrow O [! __x19__])\n      43:[? __x20__]\n      44:k = (- k 1i)\n    }\n  } else if (< actualDeleteCount itemCount) {\n    46:k = (- len actualDeleteCount)\n    47:while (< actualStart k) {\n      48:(21) app __x21__ = (ToString (- (+ k actualDeleteCount) 1i))\n      48:let from = [! __x21__]\n      49:(22) app __x22__ = (ToString (- (+ k itemCount) 1i))\n      49:let to = [! __x22__]\n      50:(23) app __x23__ = (HasProperty O from)\n      50:let fromPresent = [? __x23__]\n      54:if (= fromPresent true) {\n        52:(24) app __x24__ = (Get O from)\n        52:let fromValue = [? __x24__]\n        53:(25) app __x25__ = (Set O to fromValue true)\n        53:[? __x25__]\n      } else {\n        55:assert (= fromPresent false)\n        56:(26) app __x26__ = (DeletePropertyOrThrow O to)\n        56:[? __x26__]\n      }\n      57:k = (- k 1i)\n    }\n  } else 25:{}\n  58:k = actualStart\n  59:let __x27__ = items\n  59:let __x28__ = 0i\n  59:while (< __x28__ __x27__[\"length\"]) {\n    let E = __x27__[__x28__]\n    60:(27) app __x29__ = (ToString k)\n    60:(28) app __x30__ = (Set O [! __x29__] E true)\n    60:[? __x30__]\n    61:k = (+ k 1i)\n    __x28__ = (+ __x28__ 1i)\n  }\n  62:(29) app __x31__ = (Set O \"length\" (+ (- len actualDeleteCount) itemCount) true)\n  62:[? __x31__]\n  63:return A\n}"
  }, {
    "code": ["          1. Let _array_ be ? ToObject(*this* value).", "          1. Let _len_ be ? LengthOfArrayLike(_array_).", "          1. Let _separator_ be the String value for the list-separator String appropriate for the host environment's current locale (this is derived in an implementation-defined way).", "          1. Let _R_ be the empty String.", "          1. Let _k_ be 0.", "          1. Repeat, while _k_ < _len_,", "            1. If _k_ > 0, then", "              1. Set _R_ to the string-concatenation of _R_ and _separator_.", "            1. Let _nextElement_ be ? Get(_array_, ! ToString(𝔽(_k_))).", "            1. If _nextElement_ is not *undefined* or *null*, then", "              1. Let _S_ be ? ToString(? Invoke(_nextElement_, *\"toLocaleString\"*)).", "              1. Set _R_ to the string-concatenation of _R_ and _S_.", "            1. Set _k_ to _k_ + 1.", "          1. Return _R_."],
    "head": {
      "origParams": [{
        "kind": "Optional",
        "name": "reserved1"
      }, {
        "kind": "Optional",
        "name": "reserved2"
      }],
      "ref": "Array[\"prototype\"][\"toLocaleString\"]"
    },
    "ids": "sec-array.prototype.tolocalestring",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let array = [? __x0__]\n  1:(1) app __x1__ = (LengthOfArrayLike array)\n  1:let len = [? __x1__]\n  2:(0) ??? \"Let id:{separator} be the String value for the list - separator String appropriate for the host environment ' s current locale ( this is derived in an implementation - defined way ) .\"\n  3:let R = \"\"\n  4:let k = 0i\n  5:while (< k len) {\n    6:if (< 0i k) R = (+ R separator) else 25:{}\n    8:(2) app __x2__ = (ToString k)\n    8:(3) app __x3__ = (Get array [! __x2__])\n    8:let nextElement = [? __x3__]\n    9:if (! (|| (= nextElement undefined) (= nextElement null))) {\n      10:(4) app __x4__ = (Invoke nextElement \"toLocaleString\")\n      10:(5) app __x5__ = (ToString [? __x4__])\n      10:let S = [? __x5__]\n      11:R = (+ R S)\n    } else 25:{}\n    12:k = (+ k 1i)\n  }\n  13:return R\n}"
  }, {
    "code": ["          1. Let _array_ be ? ToObject(*this* value).", "          1. Let _func_ be ? Get(_array_, *\"join\"*).", "          1. If IsCallable(_func_) is *false*, set _func_ to the intrinsic function %Object.prototype.toString%.", "          1. Return ? Call(_func_, _array_)."],
    "head": {
      "origParams": [],
      "ref": "Array[\"prototype\"][\"toString\"]"
    },
    "ids": "sec-array.prototype.tostring",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let array = [? __x0__]\n  1:(1) app __x1__ = (Get array \"join\")\n  1:let func = [? __x1__]\n  2:(2) app __x2__ = (IsCallable func)\n  2:if (= __x2__ false) func = INTRINSIC_Object_prototype_toString else 25:{}\n  3:(3) app __x3__ = (Call func array)\n  3:return [? __x3__]\n}"
  }, {
    "code": ["          1. Let _O_ be ? ToObject(*this* value).", "          1. Let _len_ be ? LengthOfArrayLike(_O_).", "          1. Let _argCount_ be the number of elements in _items_.", "          1. If _argCount_ > 0, then", "            1. If _len_ + _argCount_ > 2<sup>53</sup> - 1, throw a *TypeError* exception.", "            1. Let _k_ be _len_.", "            1. Repeat, while _k_ > 0,", "              1. Let _from_ be ! ToString(𝔽(_k_ - 1)).", "              1. Let _to_ be ! ToString(𝔽(_k_ + _argCount_ - 1)).", "              1. Let _fromPresent_ be ? HasProperty(_O_, _from_).", "              1. If _fromPresent_ is *true*, then", "                1. Let _fromValue_ be ? Get(_O_, _from_).", "                1. Perform ? Set(_O_, _to_, _fromValue_, *true*).", "              1. Else,", "                1. Assert: _fromPresent_ is *false*.", "                1. Perform ? DeletePropertyOrThrow(_O_, _to_).", "              1. Set _k_ to _k_ - 1.", "            1. Let _j_ be *+0*<sub>𝔽</sub>.", "            1. For each element _E_ of _items_, do", "              1. Perform ? Set(_O_, ! ToString(_j_), _E_, *true*).", "              1. Set _j_ to _j_ + *1*<sub>𝔽</sub>.", "          1. Perform ? Set(_O_, *\"length\"*, 𝔽(_len_ + _argCount_), *true*).", "          1. Return 𝔽(_len_ + _argCount_)."],
    "head": {
      "origParams": [{
        "kind": "Variadic",
        "name": "items"
      }],
      "ref": "Array[\"prototype\"][\"unshift\"]"
    },
    "ids": "sec-array.prototype.unshift",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (LengthOfArrayLike O)\n  1:let len = [? __x1__]\n  2:let argCount = items[\"length\"]\n  3:if (< 0i argCount) {\n    4:if (< (- (** 2.0 53i) 1i) (+ len argCount)) (0) throw TypeError else 25:{}\n    5:let k = len\n    6:while (< 0i k) {\n      7:(2) app __x2__ = (ToString (- k 1i))\n      7:let from = [! __x2__]\n      8:(3) app __x3__ = (ToString (- (+ k argCount) 1i))\n      8:let to = [! __x3__]\n      9:(4) app __x4__ = (HasProperty O from)\n      9:let fromPresent = [? __x4__]\n      13:if (= fromPresent true) {\n        11:(5) app __x5__ = (Get O from)\n        11:let fromValue = [? __x5__]\n        12:(6) app __x6__ = (Set O to fromValue true)\n        12:[? __x6__]\n      } else {\n        14:assert (= fromPresent false)\n        15:(7) app __x7__ = (DeletePropertyOrThrow O to)\n        15:[? __x7__]\n      }\n      16:k = (- k 1i)\n    }\n    17:let j = 0i\n    18:let __x8__ = items\n    18:let __x9__ = 0i\n    18:while (< __x9__ __x8__[\"length\"]) {\n      let E = __x8__[__x9__]\n      19:(8) app __x10__ = (ToString j)\n      19:(9) app __x11__ = (Set O [! __x10__] E true)\n      19:[? __x11__]\n      20:j = (+ j 1i)\n      __x9__ = (+ __x9__ 1i)\n    }\n  } else 25:{}\n  21:(10) app __x12__ = (Set O \"length\" (+ len argCount) true)\n  21:[? __x12__]\n  22:return (+ len argCount)\n}"
  }, {
    "code": ["          1. Let _O_ be ? ToObject(*this* value).", "          1. Return CreateArrayIterator(_O_, ~value~)."],
    "head": {
      "origParams": [],
      "ref": "Array[\"prototype\"][\"values\"]"
    },
    "ids": "sec-array.prototype.values",
    "rawBody": "{\n  0:(0) app __x0__ = (ToObject this)\n  0:let O = [? __x0__]\n  1:(1) app __x1__ = (CreateArrayIterator O CONST_value)\n  1:return __x1__\n}"
  }, {
    "code": ["          1. Let _unscopableList_ be ! OrdinaryObjectCreate(*null*).", "          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"copyWithin\"*, *true*).", "          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"entries\"*, *true*).", "          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"fill\"*, *true*).", "          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"find\"*, *true*).", "          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"findIndex\"*, *true*).", "          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"flat\"*, *true*).", "          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"flatMap\"*, *true*).", "          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"includes\"*, *true*).", "          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"keys\"*, *true*).", "          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"values\"*, *true*).", "          1. Return _unscopableList_."],
    "head": {
      "origParams": [],
      "ref": "Array[\"prototype\"][SYMBOL_unscopables]"
    },
    "ids": "sec-array.prototype-@@unscopables",
    "rawBody": "{\n  0:(0) app __x0__ = (OrdinaryObjectCreate null)\n  0:let unscopableList = [! __x0__]\n  1:(1) app __x1__ = (CreateDataPropertyOrThrow unscopableList \"copyWithin\" true)\n  1:[! __x1__]\n  2:(2) app __x2__ = (CreateDataPropertyOrThrow unscopableList \"entries\" true)\n  2:[! __x2__]\n  3:(3) app __x3__ = (CreateDataPropertyOrThrow unscopableList \"fill\" true)\n  3:[! __x3__]\n  4:(4) app __x4__ = (CreateDataPropertyOrThrow unscopableList \"find\" true)\n  4:[! __x4__]\n  5:(5) app __x5__ = (CreateDataPropertyOrThrow unscopableList \"findIndex\" true)\n  5:[! __x5__]\n  6:(6) app __x6__ = (CreateDataPropertyOrThrow unscopableList \"flat\" true)\n  6:[! __x6__]\n  7:(7) app __x7__ = (CreateDataPropertyOrThrow unscopableList \"flatMap\" true)\n  7:[! __x7__]\n  8:(8) app __x8__ = (CreateDataPropertyOrThrow unscopableList \"includes\" true)\n  8:[! __x8__]\n  9:(9) app __x9__ = (CreateDataPropertyOrThrow unscopableList \"keys\" true)\n  9:[! __x9__]\n  10:(10) app __x10__ = (CreateDataPropertyOrThrow unscopableList \"values\" true)\n  10:[! __x10__]\n  11:return unscopableList\n}"
  }, {
    "code": ["          1. Assert: Type(_array_) is Object.", "          1. Assert: _kind_ is ~key+value~, ~key~, or ~value~.", "          1. Let _closure_ be a new Abstract Closure with no parameters that captures _kind_ and _array_ and performs the following steps when called:", "            1. Let _index_ be 0.", "            1. Repeat,", "              1. If _array_ has a [[TypedArrayName]] internal slot, then", "                1. If IsDetachedBuffer(_array_.[[ViewedArrayBuffer]]) is *true*, throw a *TypeError* exception.", "                1. Let _len_ be _array_.[[ArrayLength]].", "              1. Else,", "                1. Let _len_ be ? LengthOfArrayLike(_array_).", "              1. If _index_ ≥ _len_, return *undefined*.", "              1. If _kind_ is ~key~, perform ? Yield(𝔽(_index_)).", "              1. Else,", "                1. Let _elementKey_ be ! ToString(𝔽(_index_)).", "                1. Let _elementValue_ be ? Get(_array_, _elementKey_).", "                1. If _kind_ is ~value~, perform ? Yield(_elementValue_).", "                1. Else,", "                  1. Assert: _kind_ is ~key+value~.", "                  1. Perform ? Yield(! CreateArrayFromList(« 𝔽(_index_), _elementValue_ »)).", "              1. Set _index_ to _index_ + 1.", "          1. Return ! CreateIteratorFromClosure(_closure_, *\"%ArrayIteratorPrototype%\"*, %ArrayIteratorPrototype%)."],
    "head": {
      "name": "CreateArrayIterator",
      "params": [{
        "kind": "Normal",
        "name": "array"
      }, {
        "kind": "Normal",
        "name": "kind"
      }]
    },
    "ids": "sec-createarrayiterator",
    "rawBody": "{\n  0:assert (= (typeof array) Object)\n  1:assert (|| (|| (= kind CONST_keyPLUSvalue) (= kind CONST_key)) (= kind CONST_value))\n  2:(0) ??? \"Let id:{closure} be a new Abstract Closure with no parameters that captures id:{kind} and id:{array} and performs the following steps when called : in:{} out:{}\"\n  20:(0) app __x0__ = (CreateIteratorFromClosure closure \"%ArrayIteratorPrototype%\" INTRINSIC_ArrayIteratorPrototype)\n  20:return [! __x0__]\n}"
  }, {
    "code": ["            1. Assert: _source_ is an Object that has a [[TypedArrayName]] internal slot.", "            1. Let _targetBuffer_ be _target_.[[ViewedArrayBuffer]].", "            1. If IsDetachedBuffer(_targetBuffer_) is *true*, throw a *TypeError* exception.", "            1. Let _targetLength_ be _target_.[[ArrayLength]].", "            1. Let _srcBuffer_ be _source_.[[ViewedArrayBuffer]].", "            1. If IsDetachedBuffer(_srcBuffer_) is *true*, throw a *TypeError* exception.", "            1. Let _targetName_ be the String value of _target_.[[TypedArrayName]].", "            1. Let _targetType_ be the Element Type value in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _targetName_.", "            1. Let _targetElementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _targetName_.", "            1. Let _targetByteOffset_ be _target_.[[ByteOffset]].", "            1. Let _srcName_ be the String value of _source_.[[TypedArrayName]].", "            1. Let _srcType_ be the Element Type value in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _srcName_.", "            1. Let _srcElementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _srcName_.", "            1. Let _srcLength_ be _source_.[[ArrayLength]].", "            1. Let _srcByteOffset_ be _source_.[[ByteOffset]].", "            1. If _targetOffset_ is +∞, throw a *RangeError* exception.", "            1. If _srcLength_ + _targetOffset_ > _targetLength_, throw a *RangeError* exception.", "            1. If _target_.[[ContentType]] ≠ _source_.[[ContentType]], throw a *TypeError* exception.", "            1. If both IsSharedArrayBuffer(_srcBuffer_) and IsSharedArrayBuffer(_targetBuffer_) are *true*, then", "              1. If _srcBuffer_.[[ArrayBufferData]] and _targetBuffer_.[[ArrayBufferData]] are the same Shared Data Block values, let _same_ be *true*; else let _same_ be *false*.", "            1. Else, let _same_ be SameValue(_srcBuffer_, _targetBuffer_).", "            1. If _same_ is *true*, then", "              1. Let _srcByteLength_ be _source_.[[ByteLength]].", "              1. Set _srcBuffer_ to ? CloneArrayBuffer(_srcBuffer_, _srcByteOffset_, _srcByteLength_, %ArrayBuffer%).", "              1. NOTE: %ArrayBuffer% is used to clone _srcBuffer_ because is it known to not have any observable side-effects.", "              1. Let _srcByteIndex_ be 0.", "            1. Else, let _srcByteIndex_ be _srcByteOffset_.", "            1. Let _targetByteIndex_ be _targetOffset_ × _targetElementSize_ + _targetByteOffset_.", "            1. Let _limit_ be _targetByteIndex_ + _targetElementSize_ × _srcLength_.", "            1. If _srcType_ is the same as _targetType_, then", "              1. NOTE: If _srcType_ and _targetType_ are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.", "              1. Repeat, while _targetByteIndex_ < _limit_,", "                1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, ~Uint8~, *true*, ~Unordered~).", "                1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, ~Uint8~, _value_, *true*, ~Unordered~).", "                1. Set _srcByteIndex_ to _srcByteIndex_ + 1.", "                1. Set _targetByteIndex_ to _targetByteIndex_ + 1.", "            1. Else,", "              1. Repeat, while _targetByteIndex_ < _limit_,", "                1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, _srcType_, *true*, ~Unordered~).", "                1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, _targetType_, _value_, *true*, ~Unordered~).", "                1. Set _srcByteIndex_ to _srcByteIndex_ + _srcElementSize_.", "                1. Set _targetByteIndex_ to _targetByteIndex_ + _targetElementSize_."],
    "head": {
      "name": "SetTypedArrayFromTypedArray",
      "params": [{
        "kind": "Normal",
        "name": "target"
      }, {
        "kind": "Normal",
        "name": "targetOffset"
      }, {
        "kind": "Normal",
        "name": "source"
      }]
    },
    "ids": "sec-settypedarrayfromtypedarray",
    "rawBody": "{\n  1:let targetBuffer = target[\"ViewedArrayBuffer\"]\n  2:(0) app __x0__ = (IsDetachedBuffer targetBuffer)\n  2:if (= __x0__ true) (0) throw TypeError else 30:{}\n  3:let targetLength = target[\"ArrayLength\"]\n  4:let srcBuffer = source[\"ViewedArrayBuffer\"]\n  5:(1) app __x1__ = (IsDetachedBuffer srcBuffer)\n  5:if (= __x1__ true) (1) throw TypeError else 30:{}\n  6:let targetName = target[\"TypedArrayName\"]\n  7:(2) ??? \"Let id:{targetType} be the Element Type value in link:{table-the-typedarray-constructors} for id:{targetName} .\"\n  8:(3) ??? \"Let id:{targetElementSize} be the Element Size value specified in link:{table-the-typedarray-constructors} for id:{targetName} .\"\n  9:let targetByteOffset = target[\"ByteOffset\"]\n  10:let srcName = source[\"TypedArrayName\"]\n  11:(4) ??? \"Let id:{srcType} be the Element Type value in link:{table-the-typedarray-constructors} for id:{srcName} .\"\n  12:(5) ??? \"Let id:{srcElementSize} be the Element Size value specified in link:{table-the-typedarray-constructors} for id:{srcName} .\"\n  13:let srcLength = source[\"ArrayLength\"]\n  14:let srcByteOffset = source[\"ByteOffset\"]\n  15:if (= targetOffset Infinity) (6) throw RangeError else 30:{}\n  16:if (< targetLength (+ srcLength targetOffset)) (7) throw RangeError else 30:{}\n  17:if (! (== target[\"ContentType\"] source[\"ContentType\"])) (8) throw TypeError else 30:{}\n  20:(2) app __x2__ = (IsSharedArrayBuffer srcBuffer)\n  20:(3) app __x3__ = (IsSharedArrayBuffer targetBuffer)\n  20:if (&& (= __x2__ true) (= __x3__ true)) if (= srcBuffer[\"ArrayBufferData\"] targetBuffer[\"ArrayBufferData\"]) let same = true else let same = false else {\n    (4) app __x4__ = (SameValue srcBuffer targetBuffer)\n    let same = __x4__\n  }\n  26:if (= same true) {\n    22:let srcByteLength = source[\"ByteLength\"]\n    23:(5) app __x5__ = (CloneArrayBuffer srcBuffer srcByteOffset srcByteLength INTRINSIC_ArrayBuffer)\n    23:srcBuffer = [? __x5__]\n    25:let srcByteIndex = 0i\n  } else let srcByteIndex = srcByteOffset\n  27:let targetByteIndex = (+ (* targetOffset targetElementSize) targetByteOffset)\n  28:let limit = (* (+ targetByteIndex targetElementSize) srcLength)\n  36:if (= srcType targetType) while (< targetByteIndex limit) {\n    32:(6) app __x6__ = (GetValueFromBuffer srcBuffer srcByteIndex CONST_Uint8 true CONST_Unordered)\n    32:let value = __x6__\n    33:(7) app __x7__ = (SetValueInBuffer targetBuffer targetByteIndex CONST_Uint8 value true CONST_Unordered)\n    33:__x7__\n    34:srcByteIndex = (+ srcByteIndex 1i)\n    35:targetByteIndex = (+ targetByteIndex 1i)\n  } else while (< targetByteIndex limit) {\n    38:(8) app __x8__ = (GetValueFromBuffer srcBuffer srcByteIndex srcType true CONST_Unordered)\n    38:let value = __x8__\n    39:(9) app __x9__ = (SetValueInBuffer targetBuffer targetByteIndex targetType value true CONST_Unordered)\n    39:__x9__\n    40:srcByteIndex = (+ srcByteIndex srcElementSize)\n    41:targetByteIndex = (+ targetByteIndex targetElementSize)\n  }\n}"
  }, {
    "code": ["            1. Assert: _source_ is any ECMAScript language value other than an Object with a [[TypedArrayName]] internal slot.", "            1. Let _targetBuffer_ be _target_.[[ViewedArrayBuffer]].", "            1. If IsDetachedBuffer(_targetBuffer_) is *true*, throw a *TypeError* exception.", "            1. Let _targetLength_ be _target_.[[ArrayLength]].", "            1. Let _targetName_ be the String value of _target_.[[TypedArrayName]].", "            1. Let _targetElementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _targetName_.", "            1. Let _targetType_ be the Element Type value in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _targetName_.", "            1. Let _targetByteOffset_ be _target_.[[ByteOffset]].", "            1. Let _src_ be ? ToObject(_source_).", "            1. Let _srcLength_ be ? LengthOfArrayLike(_src_).", "            1. If _targetOffset_ is +∞, throw a *RangeError* exception.", "            1. If _srcLength_ + _targetOffset_ > _targetLength_, throw a *RangeError* exception.", "            1. Let _targetByteIndex_ be _targetOffset_ × _targetElementSize_ + _targetByteOffset_.", "            1. Let _k_ be 0.", "            1. Let _limit_ be _targetByteIndex_ + _targetElementSize_ × _srcLength_.", "            1. Repeat, while _targetByteIndex_ < _limit_,", "              1. Let _Pk_ be ! ToString(𝔽(_k_)).", "              1. Let _value_ be ? Get(_src_, _Pk_).", "              1. If _target_.[[ContentType]] is ~BigInt~, set _value_ to ? ToBigInt(_value_).", "              1. Otherwise, set _value_ to ? ToNumber(_value_).", "              1. If IsDetachedBuffer(_targetBuffer_) is *true*, throw a *TypeError* exception.", "              1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, _targetType_, _value_, *true*, ~Unordered~).", "              1. Set _k_ to _k_ + 1.", "              1. Set _targetByteIndex_ to _targetByteIndex_ + _targetElementSize_."],
    "head": {
      "name": "SetTypedArrayFromArrayLike",
      "params": [{
        "kind": "Normal",
        "name": "target"
      }, {
        "kind": "Normal",
        "name": "targetOffset"
      }, {
        "kind": "Normal",
        "name": "source"
      }]
    },
    "ids": "sec-settypedarrayfromarraylike",
    "rawBody": "{\n  1:let targetBuffer = target[\"ViewedArrayBuffer\"]\n  2:(0) app __x0__ = (IsDetachedBuffer targetBuffer)\n  2:if (= __x0__ true) (0) throw TypeError else 0:{}\n  3:let targetLength = target[\"ArrayLength\"]\n  4:let targetName = target[\"TypedArrayName\"]\n  5:(1) ??? \"Let id:{targetElementSize} be the Element Size value specified in link:{table-the-typedarray-constructors} for id:{targetName} .\"\n  6:(2) ??? \"Let id:{targetType} be the Element Type value in link:{table-the-typedarray-constructors} for id:{targetName} .\"\n  7:let targetByteOffset = target[\"ByteOffset\"]\n  8:(1) app __x1__ = (ToObject source)\n  8:let src = [? __x1__]\n  9:(2) app __x2__ = (LengthOfArrayLike src)\n  9:let srcLength = [? __x2__]\n  10:if (= targetOffset Infinity) (3) throw RangeError else 0:{}\n  11:if (< targetLength (+ srcLength targetOffset)) (4) throw RangeError else 0:{}\n  12:let targetByteIndex = (+ (* targetOffset targetElementSize) targetByteOffset)\n  13:let k = 0i\n  14:let limit = (* (+ targetByteIndex targetElementSize) srcLength)\n  15:while (< targetByteIndex limit) {\n    16:(3) app __x3__ = (ToString k)\n    16:let Pk = [! __x3__]\n    17:(4) app __x4__ = (Get src Pk)\n    17:let value = [? __x4__]\n    19:if (= target[\"ContentType\"] CONST_BigInt) {\n      (5) app __x5__ = (ToBigInt value)\n      value = [? __x5__]\n    } else {\n      (6) app __x6__ = (ToNumber value)\n      value = [? __x6__]\n    }\n    20:(7) app __x7__ = (IsDetachedBuffer targetBuffer)\n    20:if (= __x7__ true) (5) throw TypeError else 0:{}\n    21:(8) app __x8__ = (SetValueInBuffer targetBuffer targetByteIndex targetType value true CONST_Unordered)\n    21:__x8__\n    22:k = (+ k 1i)\n    23:targetByteIndex = (+ targetByteIndex targetElementSize)\n  }\n}"
  }, {
    "code": ["          1. Assert: Both Type(_x_) and Type(_y_) are Number or both are BigInt.", "          1. If _comparefn_ is not *undefined*, then", "            1. Let _v_ be ? ToNumber(? Call(_comparefn_, *undefined*, « _x_, _y_ »)).", "            1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.", "            1. If _v_ is *NaN*, return *+0*<sub>𝔽</sub>.", "            1. Return _v_.", "          1. If _x_ and _y_ are both *NaN*, return *+0*<sub>𝔽</sub>.", "          1. If _x_ is *NaN*, return *1*<sub>𝔽</sub>.", "          1. If _y_ is *NaN*, return *-1*<sub>𝔽</sub>.", "          1. If _x_ < _y_, return *-1*<sub>𝔽</sub>.", "          1. If _x_ > _y_, return *1*<sub>𝔽</sub>.", "          1. If _x_ is *-0*<sub>𝔽</sub> and _y_ is *+0*<sub>𝔽</sub>, return *-1*<sub>𝔽</sub>.", "          1. If _x_ is *+0*<sub>𝔽</sub> and _y_ is *-0*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>.", "          1. Return *+0*<sub>𝔽</sub>."],
    "head": {
      "name": "%TypedArray%.prototype.sort",
      "params": [{
        "kind": "Normal",
        "name": "comparefn"
      }]
    },
    "ids": "sec-%typedarray%.prototype.sort",
    "rawBody": "{\n  1:if (! (= comparefn undefined)) {\n    2:(0) app __x0__ = (Call comparefn undefined (0) (new [x, y]))\n    2:(1) app __x1__ = (ToNumber [? __x0__])\n    2:let v = [? __x1__]\n    3:(2) app __x2__ = (IsDetachedBuffer buffer)\n    3:if (= __x2__ true) (1) throw TypeError else 0:{}\n    4:if (= v NaN) return 0i else 0:{}\n    5:return v\n  } else 0:{}\n  6:if (&& (= x NaN) (= y NaN)) return 0i else 0:{}\n  7:if (= x NaN) return 1i else 0:{}\n  8:if (= y NaN) return -1i else 0:{}\n  9:if (< x y) return -1i else 0:{}\n  10:if (< y x) return 1i else 0:{}\n  11:if (&& (= x -0.0) (= y 0i)) return -1i else 0:{}\n  12:if (&& (= x 0i) (= y -0.0)) return 1i else 0:{}\n  13:return 0i\n}"
  }, {
    "code": ["          1. Assert: _exemplar_ is an Object that has [[TypedArrayName]] and [[ContentType]] internal slots.", "          1. Let _defaultConstructor_ be the intrinsic object listed in column one of <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _exemplar_.[[TypedArrayName]].", "          1. Let _constructor_ be ? SpeciesConstructor(_exemplar_, _defaultConstructor_).", "          1. Let _result_ be ? TypedArrayCreate(_constructor_, _argumentList_).", "          1. Assert: _result_ has [[TypedArrayName]] and [[ContentType]] internal slots.", "          1. If _result_.[[ContentType]] ≠ _exemplar_.[[ContentType]], throw a *TypeError* exception.", "          1. Return _result_."],
    "head": {
      "name": "TypedArraySpeciesCreate",
      "params": [{
        "kind": "Normal",
        "name": "exemplar"
      }, {
        "kind": "Normal",
        "name": "argumentList"
      }]
    },
    "ids": "typedarray-species-create",
    "rawBody": "{\n  1:(0) ??? \"Let id:{defaultConstructor} be the intrinsic object listed in column one of link:{table-the-typedarray-constructors} for id:{exemplar} . [ [ TypedArrayName ] ] .\"\n  2:(0) app __x0__ = (SpeciesConstructor exemplar defaultConstructor)\n  2:let constructor = [? __x0__]\n  3:(1) app __x1__ = (TypedArrayCreate constructor argumentList)\n  3:let result = [? __x1__]\n  5:if (! (== result[\"ContentType\"] exemplar[\"ContentType\"])) (1) throw TypeError else 4:{}\n  6:return result\n}"
  }, {
    "code": ["          1. Let _newTypedArray_ be ? Construct(_constructor_, _argumentList_).", "          1. Perform ? ValidateTypedArray(_newTypedArray_).", "          1. If _argumentList_ is a List of a single Number, then", "            1. If _newTypedArray_.[[ArrayLength]] < ℝ(_argumentList_[0]), throw a *TypeError* exception.", "          1. Return _newTypedArray_."],
    "head": {
      "name": "TypedArrayCreate",
      "params": [{
        "kind": "Normal",
        "name": "constructor"
      }, {
        "kind": "Normal",
        "name": "argumentList"
      }]
    },
    "ids": "typedarray-create",
    "rawBody": "{\n  0:(0) app __x0__ = (Construct constructor argumentList)\n  0:let newTypedArray = [? __x0__]\n  1:(1) app __x1__ = (ValidateTypedArray newTypedArray)\n  1:[? __x1__]\n  2:(0) ??? \"If id:{argumentList} is a List of a single Number , then in:{} out:{}\"\n  4:return newTypedArray\n}"
  }, {
    "code": ["          1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).", "          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.", "          1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].", "          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.", "          1. Return _buffer_."],
    "head": {
      "name": "ValidateTypedArray",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }]
    },
    "ids": "sec-validatetypedarray",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireInternalSlot O \"TypedArrayName\")\n  0:[? __x0__]\n  1:assert (! (= O[\"ViewedArrayBuffer\"] absent))\n  2:let buffer = O[\"ViewedArrayBuffer\"]\n  3:(1) app __x1__ = (IsDetachedBuffer buffer)\n  3:if (= __x1__ true) (0) throw TypeError else 4:{}\n  4:return buffer\n}"
  }, {
    "code": ["            1. Let _proto_ be ? GetPrototypeFromConstructor(_newTarget_, _defaultProto_).", "            1. Let _obj_ be ! IntegerIndexedObjectCreate(_proto_).", "            1. Assert: _obj_.[[ViewedArrayBuffer]] is *undefined*.", "            1. Set _obj_.[[TypedArrayName]] to _constructorName_.", "            1. If _constructorName_ is *\"BigInt64Array\"* or *\"BigUint64Array\"*, set _obj_.[[ContentType]] to ~BigInt~.", "            1. Otherwise, set _obj_.[[ContentType]] to ~Number~.", "            1. If _length_ is not present, then", "              1. Set _obj_.[[ByteLength]] to 0.", "              1. Set _obj_.[[ByteOffset]] to 0.", "              1. Set _obj_.[[ArrayLength]] to 0.", "            1. Else,", "              1. Perform ? AllocateTypedArrayBuffer(_obj_, _length_).", "            1. Return _obj_."],
    "head": {
      "name": "AllocateTypedArray",
      "params": [{
        "kind": "Normal",
        "name": "constructorName"
      }, {
        "kind": "Normal",
        "name": "newTarget"
      }, {
        "kind": "Normal",
        "name": "defaultProto"
      }, {
        "kind": "Optional",
        "name": "length"
      }]
    },
    "ids": "sec-allocatetypedarray",
    "rawBody": "{\n  0:(0) app __x0__ = (GetPrototypeFromConstructor newTarget defaultProto)\n  0:let proto = [? __x0__]\n  1:(1) app __x1__ = (IntegerIndexedObjectCreate proto)\n  1:let obj = [! __x1__]\n  2:assert (= obj[\"ViewedArrayBuffer\"] undefined)\n  3:obj[\"TypedArrayName\"] = constructorName\n  5:if (|| (= constructorName \"BigInt64Array\") (= constructorName \"BigUint64Array\")) obj[\"ContentType\"] = CONST_BigInt else obj[\"ContentType\"] = CONST_Number\n  10:if (= length absent) {\n    7:obj[\"ByteLength\"] = 0i\n    8:obj[\"ByteOffset\"] = 0i\n    9:obj[\"ArrayLength\"] = 0i\n  } else {\n    11:(2) app __x2__ = (AllocateTypedArrayBuffer obj length)\n    11:[? __x2__]\n  }\n  12:return obj\n}"
  }, {
    "code": ["            1. Assert: _O_ is an Object that has a [[TypedArrayName]] internal slot.", "            1. Assert: _srcArray_ is an Object that has a [[TypedArrayName]] internal slot.", "            1. Let _srcData_ be _srcArray_.[[ViewedArrayBuffer]].", "            1. If IsDetachedBuffer(_srcData_) is *true*, throw a *TypeError* exception.", "            1. Let _constructorName_ be the String value of _O_.[[TypedArrayName]].", "            1. Let _elementType_ be the Element Type value in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _constructorName_.", "            1. Let _elementLength_ be _srcArray_.[[ArrayLength]].", "            1. Let _srcName_ be the String value of _srcArray_.[[TypedArrayName]].", "            1. Let _srcType_ be the Element Type value in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _srcName_.", "            1. Let _srcElementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _srcName_.", "            1. Let _srcByteOffset_ be _srcArray_.[[ByteOffset]].", "            1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _constructorName_.", "            1. Let _byteLength_ be _elementSize_ × _elementLength_.", "            1. If IsSharedArrayBuffer(_srcData_) is *false*, then", "              1. Let _bufferConstructor_ be ? SpeciesConstructor(_srcData_, %ArrayBuffer%).", "            1. Else,", "              1. Let _bufferConstructor_ be %ArrayBuffer%.", "            1. If _elementType_ is the same as _srcType_, then", "              1. Let _data_ be ? CloneArrayBuffer(_srcData_, _srcByteOffset_, _byteLength_, _bufferConstructor_).", "            1. Else,", "              1. Let _data_ be ? AllocateArrayBuffer(_bufferConstructor_, _byteLength_).", "              1. If IsDetachedBuffer(_srcData_) is *true*, throw a *TypeError* exception.", "              1. If _srcArray_.[[ContentType]] ≠ _O_.[[ContentType]], throw a *TypeError* exception.", "              1. Let _srcByteIndex_ be _srcByteOffset_.", "              1. Let _targetByteIndex_ be 0.", "              1. Let _count_ be _elementLength_.", "              1. Repeat, while _count_ > 0,", "                1. Let _value_ be GetValueFromBuffer(_srcData_, _srcByteIndex_, _srcType_, *true*, ~Unordered~).", "                1. Perform SetValueInBuffer(_data_, _targetByteIndex_, _elementType_, _value_, *true*, ~Unordered~).", "                1. Set _srcByteIndex_ to _srcByteIndex_ + _srcElementSize_.", "                1. Set _targetByteIndex_ to _targetByteIndex_ + _elementSize_.", "                1. Set _count_ to _count_ - 1.", "            1. Set _O_.[[ViewedArrayBuffer]] to _data_.", "            1. Set _O_.[[ByteLength]] to _byteLength_.", "            1. Set _O_.[[ByteOffset]] to 0.", "            1. Set _O_.[[ArrayLength]] to _elementLength_."],
    "head": {
      "name": "InitializeTypedArrayFromTypedArray",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "srcArray"
      }]
    },
    "ids": "sec-initializetypedarrayfromtypedarray",
    "rawBody": "{\n  2:let srcData = srcArray[\"ViewedArrayBuffer\"]\n  3:(0) app __x0__ = (IsDetachedBuffer srcData)\n  3:if (= __x0__ true) (0) throw TypeError else 1:{}\n  4:let constructorName = O[\"TypedArrayName\"]\n  5:(1) ??? \"Let id:{elementType} be the Element Type value in link:{table-the-typedarray-constructors} for id:{constructorName} .\"\n  6:let elementLength = srcArray[\"ArrayLength\"]\n  7:let srcName = srcArray[\"TypedArrayName\"]\n  8:(2) ??? \"Let id:{srcType} be the Element Type value in link:{table-the-typedarray-constructors} for id:{srcName} .\"\n  9:(3) ??? \"Let id:{srcElementSize} be the Element Size value specified in link:{table-the-typedarray-constructors} for id:{srcName} .\"\n  10:let srcByteOffset = srcArray[\"ByteOffset\"]\n  11:(4) ??? \"Let id:{elementSize} be the Element Size value specified in link:{table-the-typedarray-constructors} for id:{constructorName} .\"\n  12:let byteLength = (* elementSize elementLength)\n  15:(1) app __x1__ = (IsSharedArrayBuffer srcData)\n  15:if (= __x1__ false) {\n    14:(2) app __x2__ = (SpeciesConstructor srcData INTRINSIC_ArrayBuffer)\n    14:let bufferConstructor = [? __x2__]\n  } else let bufferConstructor = INTRINSIC_ArrayBuffer\n  19:if (= elementType srcType) {\n    18:(3) app __x3__ = (CloneArrayBuffer srcData srcByteOffset byteLength bufferConstructor)\n    18:let data = [? __x3__]\n  } else {\n    20:(4) app __x4__ = (AllocateArrayBuffer bufferConstructor byteLength)\n    20:let data = [? __x4__]\n    21:(5) app __x5__ = (IsDetachedBuffer srcData)\n    21:if (= __x5__ true) (5) throw TypeError else 1:{}\n    22:if (! (== srcArray[\"ContentType\"] O[\"ContentType\"])) (6) throw TypeError else 1:{}\n    23:let srcByteIndex = srcByteOffset\n    24:let targetByteIndex = 0i\n    25:let count = elementLength\n    26:while (< 0i count) {\n      27:(6) app __x6__ = (GetValueFromBuffer srcData srcByteIndex srcType true CONST_Unordered)\n      27:let value = __x6__\n      28:(7) app __x7__ = (SetValueInBuffer data targetByteIndex elementType value true CONST_Unordered)\n      28:__x7__\n      29:srcByteIndex = (+ srcByteIndex srcElementSize)\n      30:targetByteIndex = (+ targetByteIndex elementSize)\n      31:count = (- count 1i)\n    }\n  }\n  32:O[\"ViewedArrayBuffer\"] = data\n  33:O[\"ByteLength\"] = byteLength\n  34:O[\"ByteOffset\"] = 0i\n  35:O[\"ArrayLength\"] = elementLength\n}"
  }, {
    "code": ["            1. Assert: _O_ is an Object that has a [[TypedArrayName]] internal slot.", "            1. Assert: _buffer_ is an Object that has an [[ArrayBufferData]] internal slot.", "            1. Let _constructorName_ be the String value of _O_.[[TypedArrayName]].", "            1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _constructorName_.", "            1. Let _offset_ be ? ToIndex(_byteOffset_).", "            1. If _offset_ modulo _elementSize_ ≠ 0, throw a *RangeError* exception.", "            1. If _length_ is not *undefined*, then", "              1. Let _newLength_ be ? ToIndex(_length_).", "            1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.", "            1. Let _bufferByteLength_ be _buffer_.[[ArrayBufferByteLength]].", "            1. If _length_ is *undefined*, then", "              1. If _bufferByteLength_ modulo _elementSize_ ≠ 0, throw a *RangeError* exception.", "              1. Let _newByteLength_ be _bufferByteLength_ - _offset_.", "              1. If _newByteLength_ < 0, throw a *RangeError* exception.", "            1. Else,", "              1. Let _newByteLength_ be _newLength_ × _elementSize_.", "              1. If _offset_ + _newByteLength_ > _bufferByteLength_, throw a *RangeError* exception.", "            1. Set _O_.[[ViewedArrayBuffer]] to _buffer_.", "            1. Set _O_.[[ByteLength]] to _newByteLength_.", "            1. Set _O_.[[ByteOffset]] to _offset_.", "            1. Set _O_.[[ArrayLength]] to _newByteLength_ / _elementSize_."],
    "head": {
      "name": "InitializeTypedArrayFromArrayBuffer",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "buffer"
      }, {
        "kind": "Normal",
        "name": "byteOffset"
      }, {
        "kind": "Normal",
        "name": "length"
      }]
    },
    "ids": "sec-initializetypedarrayfromarraybuffer",
    "rawBody": "{\n  2:let constructorName = O[\"TypedArrayName\"]\n  3:(0) ??? \"Let id:{elementSize} be the Element Size value specified in link:{table-the-typedarray-constructors} for id:{constructorName} .\"\n  4:(0) app __x0__ = (ToIndex byteOffset)\n  4:let offset = [? __x0__]\n  5:if (! (== (%% offset elementSize) 0i)) (1) throw RangeError else 1:{}\n  6:if (! (= length undefined)) {\n    7:(1) app __x1__ = (ToIndex length)\n    7:let newLength = [? __x1__]\n  } else 1:{}\n  8:(2) app __x2__ = (IsDetachedBuffer buffer)\n  8:if (= __x2__ true) (2) throw TypeError else 1:{}\n  9:let bufferByteLength = buffer[\"ArrayBufferByteLength\"]\n  14:if (= length undefined) {\n    11:if (! (== (%% bufferByteLength elementSize) 0i)) (3) throw RangeError else 1:{}\n    12:let newByteLength = (- bufferByteLength offset)\n    13:if (< newByteLength 0i) (4) throw RangeError else 1:{}\n  } else {\n    15:let newByteLength = (* newLength elementSize)\n    16:if (< bufferByteLength (+ offset newByteLength)) (5) throw RangeError else 1:{}\n  }\n  17:O[\"ViewedArrayBuffer\"] = buffer\n  18:O[\"ByteLength\"] = newByteLength\n  19:O[\"ByteOffset\"] = offset\n  20:O[\"ArrayLength\"] = (/ newByteLength elementSize)\n}"
  }, {
    "code": ["            1. Assert: _O_ is an Object that has a [[TypedArrayName]] internal slot.", "            1. Let _len_ be the number of elements in _values_.", "            1. Perform ? AllocateTypedArrayBuffer(_O_, _len_).", "            1. Let _k_ be 0.", "            1. Repeat, while _k_ < _len_,", "              1. Let _Pk_ be ! ToString(𝔽(_k_)).", "              1. Let _kValue_ be the first element of _values_ and remove that element from _values_.", "              1. Perform ? Set(_O_, _Pk_, _kValue_, *true*).", "              1. Set _k_ to _k_ + 1.", "            1. Assert: _values_ is now an empty List."],
    "head": {
      "name": "InitializeTypedArrayFromList",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "values"
      }]
    },
    "ids": "sec-initializetypedarrayfromlist",
    "rawBody": "{\n  1:let len = values[\"length\"]\n  2:(0) app __x0__ = (AllocateTypedArrayBuffer O len)\n  2:[? __x0__]\n  3:let k = 0i\n  4:while (< k len) {\n    5:(1) app __x1__ = (ToString k)\n    5:let Pk = [! __x1__]\n    6:let kValue = (pop values 0i)\n    7:(2) app __x2__ = (Set O Pk kValue true)\n    7:[? __x2__]\n    8:k = (+ k 1i)\n  }\n}"
  }, {
    "code": ["            1. Assert: _O_ is an Object that has a [[TypedArrayName]] internal slot.", "            1. Let _len_ be ? LengthOfArrayLike(_arrayLike_).", "            1. Perform ? AllocateTypedArrayBuffer(_O_, _len_).", "            1. Let _k_ be 0.", "            1. Repeat, while _k_ < _len_,", "              1. Let _Pk_ be ! ToString(𝔽(_k_)).", "              1. Let _kValue_ be ? Get(_arrayLike_, _Pk_).", "              1. Perform ? Set(_O_, _Pk_, _kValue_, *true*).", "              1. Set _k_ to _k_ + 1."],
    "head": {
      "name": "InitializeTypedArrayFromArrayLike",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "arrayLike"
      }]
    },
    "ids": "sec-initializetypedarrayfromarraylike",
    "rawBody": "{\n  1:(0) app __x0__ = (LengthOfArrayLike arrayLike)\n  1:let len = [? __x0__]\n  2:(1) app __x1__ = (AllocateTypedArrayBuffer O len)\n  2:[? __x1__]\n  3:let k = 0i\n  4:while (< k len) {\n    5:(2) app __x2__ = (ToString k)\n    5:let Pk = [! __x2__]\n    6:(3) app __x3__ = (Get arrayLike Pk)\n    6:let kValue = [? __x3__]\n    7:(4) app __x4__ = (Set O Pk kValue true)\n    7:[? __x4__]\n    8:k = (+ k 1i)\n  }\n}"
  }, {
    "code": ["            1. Assert: _O_ is an Object that has a [[ViewedArrayBuffer]] internal slot.", "            1. Assert: _O_.[[ViewedArrayBuffer]] is *undefined*.", "            1. Let _constructorName_ be the String value of _O_.[[TypedArrayName]].", "            1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _constructorName_.", "            1. Let _byteLength_ be _elementSize_ × _length_.", "            1. Let _data_ be ? AllocateArrayBuffer(%ArrayBuffer%, _byteLength_).", "            1. Set _O_.[[ViewedArrayBuffer]] to _data_.", "            1. Set _O_.[[ByteLength]] to _byteLength_.", "            1. Set _O_.[[ByteOffset]] to 0.", "            1. Set _O_.[[ArrayLength]] to _length_.", "            1. Return _O_."],
    "head": {
      "name": "AllocateTypedArrayBuffer",
      "params": [{
        "kind": "Normal",
        "name": "O"
      }, {
        "kind": "Normal",
        "name": "length"
      }]
    },
    "ids": "sec-allocatetypedarraybuffer",
    "rawBody": "{\n  1:assert (= O[\"ViewedArrayBuffer\"] undefined)\n  2:let constructorName = O[\"TypedArrayName\"]\n  3:(0) ??? \"Let id:{elementSize} be the Element Size value specified in link:{table-the-typedarray-constructors} for id:{constructorName} .\"\n  4:let byteLength = (* elementSize length)\n  5:(0) app __x0__ = (AllocateArrayBuffer INTRINSIC_ArrayBuffer byteLength)\n  5:let data = [? __x0__]\n  6:O[\"ViewedArrayBuffer\"] = data\n  7:O[\"ByteLength\"] = byteLength\n  8:O[\"ByteOffset\"] = 0i\n  9:O[\"ArrayLength\"] = length\n  10:return O\n}"
  }, {
    "code": ["          1. If NewTarget is *undefined*, throw a *TypeError* exception.", "          1. Let _map_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Map.prototype%\"*, « [[MapData]] »).", "          1. Set _map_.[[MapData]] to a new empty List.", "          1. If _iterable_ is either *undefined* or *null*, return _map_.", "          1. Let _adder_ be ? Get(_map_, *\"set\"*).", "          1. Return ? AddEntriesFromIterable(_map_, _iterable_, _adder_)."],
    "head": {
      "origParams": [{
        "kind": "Optional",
        "name": "iterable"
      }],
      "ref": "Map"
    },
    "ids": "sec-map-iterable",
    "rawBody": "{\n  0:if (= NewTarget undefined) (0) throw TypeError else 0:{}\n  1:(0) app __x0__ = (OrdinaryCreateFromConstructor NewTarget \"%Map.prototype%\" (1) (new [\"MapData\"]))\n  1:let map = [? __x0__]\n  2:map[\"MapData\"] = (2) (new [])\n  3:if (|| (= iterable undefined) (= iterable null)) return map else 0:{}\n  4:(1) app __x1__ = (Get map \"set\")\n  4:let adder = [? __x1__]\n  5:(2) app __x2__ = (AddEntriesFromIterable map iterable adder)\n  5:return [? __x2__]\n}"
  }, {
    "code": ["          1. If IsCallable(_adder_) is *false*, throw a *TypeError* exception.", "          1. Assert: _iterable_ is present, and is neither *undefined* nor *null*.", "          1. Let _iteratorRecord_ be ? GetIterator(_iterable_).", "          1. Repeat,", "            1. Let _next_ be ? IteratorStep(_iteratorRecord_).", "            1. If _next_ is *false*, return _target_.", "            1. Let _nextItem_ be ? IteratorValue(_next_).", "            1. If Type(_nextItem_) is not Object, then", "              1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).", "              1. Return ? IteratorClose(_iteratorRecord_, _error_).", "            1. Let _k_ be Get(_nextItem_, *\"0\"*).", "            1. If _k_ is an abrupt completion, return ? IteratorClose(_iteratorRecord_, _k_).", "            1. Let _v_ be Get(_nextItem_, *\"1\"*).", "            1. If _v_ is an abrupt completion, return ? IteratorClose(_iteratorRecord_, _v_).", "            1. Let _status_ be Call(_adder_, _target_, « _k_.[[Value]], _v_.[[Value]] »).", "            1. If _status_ is an abrupt completion, return ? IteratorClose(_iteratorRecord_, _status_)."],
    "head": {
      "name": "AddEntriesFromIterable",
      "params": [{
        "kind": "Normal",
        "name": "target"
      }, {
        "kind": "Normal",
        "name": "iterable"
      }, {
        "kind": "Normal",
        "name": "adder"
      }]
    },
    "ids": "sec-add-entries-from-iterable",
    "rawBody": "{\n  0:(0) app __x0__ = (IsCallable adder)\n  0:if (= __x0__ false) (0) throw TypeError else 1:{}\n  2:(1) app __x1__ = (GetIterator iterable)\n  2:let iteratorRecord = [? __x1__]\n  3:while true {\n    4:(2) app __x2__ = (IteratorStep iteratorRecord)\n    4:let next = [? __x2__]\n    5:if (= next false) return target else 1:{}\n    6:(3) app __x3__ = (IteratorValue next)\n    6:let nextItem = [? __x3__]\n    7:if (! (= (typeof nextItem) Object)) {\n      8:(4) app __x4__ = (ThrowCompletion (1) (new OrdinaryObject()))\n      8:let error = __x4__\n      9:(5) app __x5__ = (IteratorClose iteratorRecord error)\n      9:return [? __x5__]\n    } else 1:{}\n    10:(6) app __x6__ = (Get nextItem \"0\")\n    10:let k = __x6__\n    11:(7) app __x7__ = (IsAbruptCompletion k)\n    11:if __x7__ {\n      (8) app __x8__ = (IteratorClose iteratorRecord k)\n      return [? __x8__]\n    } else 1:{}\n    12:(9) app __x9__ = (Get nextItem \"1\")\n    12:let v = __x9__\n    13:(10) app __x10__ = (IsAbruptCompletion v)\n    13:if __x10__ {\n      (11) app __x11__ = (IteratorClose iteratorRecord v)\n      return [? __x11__]\n    } else 1:{}\n    14:(12) app __x12__ = (Call adder target (2) (new [k[\"Value\"], v[\"Value\"]]))\n    14:let status = __x12__\n    15:(13) app __x13__ = (IsAbruptCompletion status)\n    15:if __x13__ {\n      (14) app __x14__ = (IteratorClose iteratorRecord status)\n      return [? __x14__]\n    } else 1:{}\n  }\n}"
  }, {
    "code": ["          1. Return the *this* value."],
    "head": {
      "origParams": [],
      "ref": "getMap[SYMBOL_species]"
    },
    "ids": "sec-get-map-@@species",
    "rawBody": "return this"
  }, {
    "code": ["          1. Let _M_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).", "          1. Let _entries_ be the List that is _M_.[[MapData]].", "          1. For each Record { [[Key]], [[Value]] } _p_ of _entries_, do", "            1. Set _p_.[[Key]] to ~empty~.", "            1. Set _p_.[[Value]] to ~empty~.", "          1. Return *undefined*."],
    "head": {
      "origParams": [],
      "ref": "Map[\"prototype\"][\"clear\"]"
    },
    "ids": "sec-map.prototype.clear",
    "rawBody": "{\n  0:let M = this\n  1:(0) app __x0__ = (RequireInternalSlot M \"MapData\")\n  1:[? __x0__]\n  2:let entries = M[\"MapData\"]\n  3:let __x1__ = entries\n  3:let __x2__ = 0i\n  3:while (< __x2__ __x1__[\"length\"]) {\n    let p = __x1__[__x2__]\n    4:p[\"Key\"] = CONST_empty\n    5:p[\"Value\"] = CONST_empty\n    __x2__ = (+ __x2__ 1i)\n  }\n  6:return undefined\n}"
  }, {
    "code": ["          1. Let _M_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).", "          1. Let _entries_ be the List that is _M_.[[MapData]].", "          1. For each Record { [[Key]], [[Value]] } _p_ of _entries_, do", "            1. If _p_.[[Key]] is not ~empty~ and SameValueZero(_p_.[[Key]], _key_) is *true*, then", "              1. Set _p_.[[Key]] to ~empty~.", "              1. Set _p_.[[Value]] to ~empty~.", "              1. Return *true*.", "          1. Return *false*."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "key"
      }],
      "ref": "Map[\"prototype\"][\"delete\"]"
    },
    "ids": "sec-map.prototype.delete",
    "rawBody": "{\n  0:let M = this\n  1:(0) app __x0__ = (RequireInternalSlot M \"MapData\")\n  1:[? __x0__]\n  2:let entries = M[\"MapData\"]\n  3:let __x1__ = entries\n  3:let __x2__ = 0i\n  3:while (< __x2__ __x1__[\"length\"]) {\n    let p = __x1__[__x2__]\n    4:let __x3__ = true\n    4:__x3__ = (! (= p[\"Key\"] CONST_empty))\n    4:if __x3__ {\n      (1) app __x4__ = (SameValueZero p[\"Key\"] key)\n      __x3__ = (= __x4__ true)\n    } else 1:{}\n    4:if __x3__ {\n      5:p[\"Key\"] = CONST_empty\n      6:p[\"Value\"] = CONST_empty\n      7:return true\n    } else 1:{}\n    __x2__ = (+ __x2__ 1i)\n  }\n  8:return false\n}"
  }, {
    "code": ["          1. Let _M_ be the *this* value.", "          1. Return ? CreateMapIterator(_M_, ~key+value~)."],
    "head": {
      "origParams": [],
      "ref": "Map[\"prototype\"][\"entries\"]"
    },
    "ids": "sec-map.prototype.entries",
    "rawBody": "{\n  0:let M = this\n  1:(0) app __x0__ = (CreateMapIterator M CONST_keyPLUSvalue)\n  1:return [? __x0__]\n}"
  }, {
    "code": ["          1. Let _M_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).", "          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.", "          1. Let _entries_ be the List that is _M_.[[MapData]].", "          1. For each Record { [[Key]], [[Value]] } _e_ of _entries_, do", "            1. If _e_.[[Key]] is not ~empty~, then", "              1. Perform ? Call(_callbackfn_, _thisArg_, « _e_.[[Value]], _e_.[[Key]], _M_ »).", "          1. Return *undefined*."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "callbackfn"
      }, {
        "kind": "Optional",
        "name": "thisArg"
      }],
      "ref": "Map[\"prototype\"][\"forEach\"]"
    },
    "ids": "sec-map.prototype.foreach",
    "rawBody": "{\n  0:let M = this\n  1:(0) app __x0__ = (RequireInternalSlot M \"MapData\")\n  1:[? __x0__]\n  2:(1) app __x1__ = (IsCallable callbackfn)\n  2:if (= __x1__ false) (0) throw TypeError else 1:{}\n  3:let entries = M[\"MapData\"]\n  4:let __x2__ = entries\n  4:let __x3__ = 0i\n  4:while (< __x3__ __x2__[\"length\"]) {\n    let e = __x2__[__x3__]\n    5:if (! (= e[\"Key\"] CONST_empty)) {\n      6:(2) app __x4__ = (Call callbackfn thisArg (1) (new [e[\"Value\"], e[\"Key\"], M]))\n      6:[? __x4__]\n    } else 1:{}\n    __x3__ = (+ __x3__ 1i)\n  }\n  7:return undefined\n}"
  }, {
    "code": ["          1. Let _M_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).", "          1. Let _entries_ be the List that is _M_.[[MapData]].", "          1. For each Record { [[Key]], [[Value]] } _p_ of _entries_, do", "            1. If _p_.[[Key]] is not ~empty~ and SameValueZero(_p_.[[Key]], _key_) is *true*, return _p_.[[Value]].", "          1. Return *undefined*."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "key"
      }],
      "ref": "Map[\"prototype\"][\"get\"]"
    },
    "ids": "sec-map.prototype.get",
    "rawBody": "{\n  0:let M = this\n  1:(0) app __x0__ = (RequireInternalSlot M \"MapData\")\n  1:[? __x0__]\n  2:let entries = M[\"MapData\"]\n  3:let __x1__ = entries\n  3:let __x2__ = 0i\n  3:while (< __x2__ __x1__[\"length\"]) {\n    let p = __x1__[__x2__]\n    4:let __x3__ = true\n    4:__x3__ = (! (= p[\"Key\"] CONST_empty))\n    4:if __x3__ {\n      (1) app __x4__ = (SameValueZero p[\"Key\"] key)\n      __x3__ = (= __x4__ true)\n    } else 1:{}\n    4:if __x3__ return p[\"Value\"] else 1:{}\n    __x2__ = (+ __x2__ 1i)\n  }\n  5:return undefined\n}"
  }, {
    "code": ["          1. Let _M_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).", "          1. Let _entries_ be the List that is _M_.[[MapData]].", "          1. For each Record { [[Key]], [[Value]] } _p_ of _entries_, do", "            1. If _p_.[[Key]] is not ~empty~ and SameValueZero(_p_.[[Key]], _key_) is *true*, return *true*.", "          1. Return *false*."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "key"
      }],
      "ref": "Map[\"prototype\"][\"has\"]"
    },
    "ids": "sec-map.prototype.has",
    "rawBody": "{\n  0:let M = this\n  1:(0) app __x0__ = (RequireInternalSlot M \"MapData\")\n  1:[? __x0__]\n  2:let entries = M[\"MapData\"]\n  3:let __x1__ = entries\n  3:let __x2__ = 0i\n  3:while (< __x2__ __x1__[\"length\"]) {\n    let p = __x1__[__x2__]\n    4:let __x3__ = true\n    4:__x3__ = (! (= p[\"Key\"] CONST_empty))\n    4:if __x3__ {\n      (1) app __x4__ = (SameValueZero p[\"Key\"] key)\n      __x3__ = (= __x4__ true)\n    } else 1:{}\n    4:if __x3__ return true else 1:{}\n    __x2__ = (+ __x2__ 1i)\n  }\n  5:return false\n}"
  }, {
    "code": ["          1. Let _M_ be the *this* value.", "          1. Return ? CreateMapIterator(_M_, ~key~)."],
    "head": {
      "origParams": [],
      "ref": "Map[\"prototype\"][\"keys\"]"
    },
    "ids": "sec-map.prototype.keys",
    "rawBody": "{\n  0:let M = this\n  1:(0) app __x0__ = (CreateMapIterator M CONST_key)\n  1:return [? __x0__]\n}"
  }, {
    "code": ["          1. Let _M_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).", "          1. Let _entries_ be the List that is _M_.[[MapData]].", "          1. For each Record { [[Key]], [[Value]] } _p_ of _entries_, do", "            1. If _p_.[[Key]] is not ~empty~ and SameValueZero(_p_.[[Key]], _key_) is *true*, then", "              1. Set _p_.[[Value]] to _value_.", "              1. Return _M_.", "          1. If _key_ is *-0*<sub>𝔽</sub>, set _key_ to *+0*<sub>𝔽</sub>.", "          1. Let _p_ be the Record { [[Key]]: _key_, [[Value]]: _value_ }.", "          1. Append _p_ as the last element of _entries_.", "          1. Return _M_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "key"
      }, {
        "kind": "Normal",
        "name": "value"
      }],
      "ref": "Map[\"prototype\"][\"set\"]"
    },
    "ids": "sec-map.prototype.set",
    "rawBody": "{\n  0:let M = this\n  1:(0) app __x0__ = (RequireInternalSlot M \"MapData\")\n  1:[? __x0__]\n  2:let entries = M[\"MapData\"]\n  3:let __x1__ = entries\n  3:let __x2__ = 0i\n  3:while (< __x2__ __x1__[\"length\"]) {\n    let p = __x1__[__x2__]\n    4:let __x3__ = true\n    4:__x3__ = (! (= p[\"Key\"] CONST_empty))\n    4:if __x3__ {\n      (1) app __x4__ = (SameValueZero p[\"Key\"] key)\n      __x3__ = (= __x4__ true)\n    } else 1:{}\n    4:if __x3__ {\n      5:p[\"Value\"] = value\n      6:return M\n    } else 1:{}\n    __x2__ = (+ __x2__ 1i)\n  }\n  7:if (= key -0.0) key = 0i else 1:{}\n  8:let p = (0) (new Record(\"Key\" -> key, \"Value\" -> value))\n  9:append p -> entries\n  10:return M\n}"
  }, {
    "code": ["          1. Let _M_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).", "          1. Let _entries_ be the List that is _M_.[[MapData]].", "          1. Let _count_ be 0.", "          1. For each Record { [[Key]], [[Value]] } _p_ of _entries_, do", "            1. If _p_.[[Key]] is not ~empty~, set _count_ to _count_ + 1.", "          1. Return 𝔽(_count_)."],
    "head": {
      "origParams": [],
      "ref": "getMap[\"prototype\"][\"size\"]"
    },
    "ids": "sec-get-map.prototype.size",
    "rawBody": "{\n  0:let M = this\n  1:(0) app __x0__ = (RequireInternalSlot M \"MapData\")\n  1:[? __x0__]\n  2:let entries = M[\"MapData\"]\n  3:let count = 0i\n  4:let __x1__ = entries\n  4:let __x2__ = 0i\n  4:while (< __x2__ __x1__[\"length\"]) {\n    let p = __x1__[__x2__]\n    5:if (! (= p[\"Key\"] CONST_empty)) count = (+ count 1i) else 1:{}\n    __x2__ = (+ __x2__ 1i)\n  }\n  6:return count\n}"
  }, {
    "code": ["          1. Let _M_ be the *this* value.", "          1. Return ? CreateMapIterator(_M_, ~value~)."],
    "head": {
      "origParams": [],
      "ref": "Map[\"prototype\"][\"values\"]"
    },
    "ids": "sec-map.prototype.values",
    "rawBody": "{\n  0:let M = this\n  1:(0) app __x0__ = (CreateMapIterator M CONST_value)\n  1:return [? __x0__]\n}"
  }, {
    "code": ["          1. Assert: _kind_ is ~key+value~, ~key~, or ~value~.", "          1. Perform ? RequireInternalSlot(_map_, [[MapData]]).", "          1. Let _closure_ be a new Abstract Closure with no parameters that captures _map_ and _kind_ and performs the following steps when called:", "            1. Let _entries_ be the List that is _map_.[[MapData]].", "            1. Let _index_ be 0.", "            1. Let _numEntries_ be the number of elements of _entries_.", "            1. Repeat, while _index_ < _numEntries_,", "              1. Let _e_ be the Record { [[Key]], [[Value]] } that is the value of _entries_[_index_].", "              1. Set _index_ to _index_ + 1.", "              1. If _e_.[[Key]] is not ~empty~, then", "                1. If _kind_ is ~key~, let _result_ be _e_.[[Key]].", "                1. Else if _kind_ is ~value~, let _result_ be _e_.[[Value]].", "                1. Else,", "                  1. Assert: _kind_ is ~key+value~.", "                  1. Let _result_ be ! CreateArrayFromList(« _e_.[[Key]], _e_.[[Value]] »).", "                1. Perform ? Yield(_result_).", "                1. NOTE: the number of elements in _entries_ may have changed while execution of this abstract operation was paused by Yield.", "                1. Set _numEntries_ to the number of elements of _entries_.", "            1. Return *undefined*.", "          1. Return ! CreateIteratorFromClosure(_closure_, *\"%MapIteratorPrototype%\"*, %MapIteratorPrototype%)."],
    "head": {
      "name": "CreateMapIterator",
      "params": [{
        "kind": "Normal",
        "name": "map"
      }, {
        "kind": "Normal",
        "name": "kind"
      }]
    },
    "ids": "sec-createmapiterator",
    "rawBody": "{\n  0:assert (|| (|| (= kind CONST_keyPLUSvalue) (= kind CONST_key)) (= kind CONST_value))\n  1:(0) app __x0__ = (RequireInternalSlot map \"MapData\")\n  1:[? __x0__]\n  2:(0) ??? \"Let id:{closure} be a new Abstract Closure with no parameters that captures id:{map} and id:{kind} and performs the following steps when called : in:{} out:{}\"\n  19:(1) app __x1__ = (CreateIteratorFromClosure closure \"%MapIteratorPrototype%\" INTRINSIC_MapIteratorPrototype)\n  19:return [! __x1__]\n}"
  }, {
    "code": ["          1. If NewTarget is *undefined*, throw a *TypeError* exception.", "          1. Let _set_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Set.prototype%\"*, « [[SetData]] »).", "          1. Set _set_.[[SetData]] to a new empty List.", "          1. If _iterable_ is either *undefined* or *null*, return _set_.", "          1. Let _adder_ be ? Get(_set_, *\"add\"*).", "          1. If IsCallable(_adder_) is *false*, throw a *TypeError* exception.", "          1. Let _iteratorRecord_ be ? GetIterator(_iterable_).", "          1. Repeat,", "            1. Let _next_ be ? IteratorStep(_iteratorRecord_).", "            1. If _next_ is *false*, return _set_.", "            1. Let _nextValue_ be ? IteratorValue(_next_).", "            1. Let _status_ be Call(_adder_, _set_, « _nextValue_ »).", "            1. If _status_ is an abrupt completion, return ? IteratorClose(_iteratorRecord_, _status_)."],
    "head": {
      "origParams": [{
        "kind": "Optional",
        "name": "iterable"
      }],
      "ref": "Set"
    },
    "ids": "sec-set-iterable",
    "rawBody": "{\n  0:if (= NewTarget undefined) (0) throw TypeError else 16:{}\n  1:(0) app __x0__ = (OrdinaryCreateFromConstructor NewTarget \"%Set.prototype%\" (1) (new [\"SetData\"]))\n  1:let set = [? __x0__]\n  2:set[\"SetData\"] = (2) (new [])\n  3:if (|| (= iterable undefined) (= iterable null)) return set else 16:{}\n  4:(1) app __x1__ = (Get set \"add\")\n  4:let adder = [? __x1__]\n  5:(2) app __x2__ = (IsCallable adder)\n  5:if (= __x2__ false) (3) throw TypeError else 16:{}\n  6:(3) app __x3__ = (GetIterator iterable)\n  6:let iteratorRecord = [? __x3__]\n  7:while true {\n    8:(4) app __x4__ = (IteratorStep iteratorRecord)\n    8:let next = [? __x4__]\n    9:if (= next false) return set else 16:{}\n    10:(5) app __x5__ = (IteratorValue next)\n    10:let nextValue = [? __x5__]\n    11:(6) app __x6__ = (Call adder set (4) (new [nextValue]))\n    11:let status = __x6__\n    12:(7) app __x7__ = (IsAbruptCompletion status)\n    12:if __x7__ {\n      (8) app __x8__ = (IteratorClose iteratorRecord status)\n      return [? __x8__]\n    } else 16:{}\n  }\n}"
  }, {
    "code": ["          1. Return the *this* value."],
    "head": {
      "origParams": [],
      "ref": "getSet[SYMBOL_species]"
    },
    "ids": "sec-get-set-@@species",
    "rawBody": "return this"
  }, {
    "code": ["          1. Let _S_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).", "          1. Let _entries_ be the List that is _S_.[[SetData]].", "          1. For each element _e_ of _entries_, do", "            1. If _e_ is not ~empty~ and SameValueZero(_e_, _value_) is *true*, then", "              1. Return _S_.", "          1. If _value_ is *-0*<sub>𝔽</sub>, set _value_ to *+0*<sub>𝔽</sub>.", "          1. Append _value_ as the last element of _entries_.", "          1. Return _S_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "value"
      }],
      "ref": "Set[\"prototype\"][\"add\"]"
    },
    "ids": "sec-set.prototype.add",
    "rawBody": "{\n  0:let S = this\n  1:(0) app __x0__ = (RequireInternalSlot S \"SetData\")\n  1:[? __x0__]\n  2:let entries = S[\"SetData\"]\n  3:let __x1__ = entries\n  3:let __x2__ = 0i\n  3:while (< __x2__ __x1__[\"length\"]) {\n    let e = __x1__[__x2__]\n    4:let __x3__ = true\n    4:__x3__ = (! (= e CONST_empty))\n    4:if __x3__ {\n      (1) app __x4__ = (SameValueZero e value)\n      __x3__ = (= __x4__ true)\n    } else 16:{}\n    4:if __x3__ return S else 16:{}\n    __x2__ = (+ __x2__ 1i)\n  }\n  6:if (= value -0.0) value = 0i else 16:{}\n  7:append value -> entries\n  8:return S\n}"
  }, {
    "code": ["          1. Let _S_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).", "          1. Let _entries_ be the List that is _S_.[[SetData]].", "          1. For each element _e_ of _entries_, do", "            1. Replace the element of _entries_ whose value is _e_ with an element whose value is ~empty~.", "          1. Return *undefined*."],
    "head": {
      "origParams": [],
      "ref": "Set[\"prototype\"][\"clear\"]"
    },
    "ids": "sec-set.prototype.clear",
    "rawBody": "{\n  0:let S = this\n  1:(0) app __x0__ = (RequireInternalSlot S \"SetData\")\n  1:[? __x0__]\n  2:let entries = S[\"SetData\"]\n  3:let __x1__ = entries\n  3:let __x2__ = 0i\n  3:while (< __x2__ __x1__[\"length\"]) {\n    let e = __x1__[__x2__]\n    4:(0) ??? \"Replace the element of id:{entries} whose value is id:{e} with an element whose value is const:{empty} .\"\n    __x2__ = (+ __x2__ 1i)\n  }\n  5:return undefined\n}"
  }, {
    "code": ["          1. Let _S_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).", "          1. Let _entries_ be the List that is _S_.[[SetData]].", "          1. For each element _e_ of _entries_, do", "            1. If _e_ is not ~empty~ and SameValueZero(_e_, _value_) is *true*, then", "              1. Replace the element of _entries_ whose value is _e_ with an element whose value is ~empty~.", "              1. Return *true*.", "          1. Return *false*."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "value"
      }],
      "ref": "Set[\"prototype\"][\"delete\"]"
    },
    "ids": "sec-set.prototype.delete",
    "rawBody": "{\n  0:let S = this\n  1:(0) app __x0__ = (RequireInternalSlot S \"SetData\")\n  1:[? __x0__]\n  2:let entries = S[\"SetData\"]\n  3:let __x1__ = entries\n  3:let __x2__ = 0i\n  3:while (< __x2__ __x1__[\"length\"]) {\n    let e = __x1__[__x2__]\n    4:let __x3__ = true\n    4:__x3__ = (! (= e CONST_empty))\n    4:if __x3__ {\n      (1) app __x4__ = (SameValueZero e value)\n      __x3__ = (= __x4__ true)\n    } else 16:{}\n    4:if __x3__ {\n      5:(0) ??? \"Replace the element of id:{entries} whose value is id:{e} with an element whose value is const:{empty} .\"\n      6:return true\n    } else 16:{}\n    __x2__ = (+ __x2__ 1i)\n  }\n  7:return false\n}"
  }, {
    "code": ["          1. Let _S_ be the *this* value.", "          1. Return ? CreateSetIterator(_S_, ~key+value~)."],
    "head": {
      "origParams": [],
      "ref": "Set[\"prototype\"][\"entries\"]"
    },
    "ids": "sec-set.prototype.entries",
    "rawBody": "{\n  0:let S = this\n  1:(0) app __x0__ = (CreateSetIterator S CONST_keyPLUSvalue)\n  1:return [? __x0__]\n}"
  }, {
    "code": ["          1. Let _S_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).", "          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.", "          1. Let _entries_ be the List that is _S_.[[SetData]].", "          1. For each element _e_ of _entries_, do", "            1. If _e_ is not ~empty~, then", "              1. Perform ? Call(_callbackfn_, _thisArg_, « _e_, _e_, _S_ »).", "          1. Return *undefined*."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "callbackfn"
      }, {
        "kind": "Optional",
        "name": "thisArg"
      }],
      "ref": "Set[\"prototype\"][\"forEach\"]"
    },
    "ids": "sec-set.prototype.foreach",
    "rawBody": "{\n  0:let S = this\n  1:(0) app __x0__ = (RequireInternalSlot S \"SetData\")\n  1:[? __x0__]\n  2:(1) app __x1__ = (IsCallable callbackfn)\n  2:if (= __x1__ false) (0) throw TypeError else 16:{}\n  3:let entries = S[\"SetData\"]\n  4:let __x2__ = entries\n  4:let __x3__ = 0i\n  4:while (< __x3__ __x2__[\"length\"]) {\n    let e = __x2__[__x3__]\n    5:if (! (= e CONST_empty)) {\n      6:(2) app __x4__ = (Call callbackfn thisArg (1) (new [e, e, S]))\n      6:[? __x4__]\n    } else 16:{}\n    __x3__ = (+ __x3__ 1i)\n  }\n  7:return undefined\n}"
  }, {
    "code": ["          1. Let _S_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).", "          1. Let _entries_ be the List that is _S_.[[SetData]].", "          1. For each element _e_ of _entries_, do", "            1. If _e_ is not ~empty~ and SameValueZero(_e_, _value_) is *true*, return *true*.", "          1. Return *false*."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "value"
      }],
      "ref": "Set[\"prototype\"][\"has\"]"
    },
    "ids": "sec-set.prototype.has",
    "rawBody": "{\n  0:let S = this\n  1:(0) app __x0__ = (RequireInternalSlot S \"SetData\")\n  1:[? __x0__]\n  2:let entries = S[\"SetData\"]\n  3:let __x1__ = entries\n  3:let __x2__ = 0i\n  3:while (< __x2__ __x1__[\"length\"]) {\n    let e = __x1__[__x2__]\n    4:let __x3__ = true\n    4:__x3__ = (! (= e CONST_empty))\n    4:if __x3__ {\n      (1) app __x4__ = (SameValueZero e value)\n      __x3__ = (= __x4__ true)\n    } else 16:{}\n    4:if __x3__ return true else 16:{}\n    __x2__ = (+ __x2__ 1i)\n  }\n  5:return false\n}"
  }, {
    "code": ["          1. Let _S_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).", "          1. Let _entries_ be the List that is _S_.[[SetData]].", "          1. Let _count_ be 0.", "          1. For each element _e_ of _entries_, do", "            1. If _e_ is not ~empty~, set _count_ to _count_ + 1.", "          1. Return 𝔽(_count_)."],
    "head": {
      "origParams": [],
      "ref": "getSet[\"prototype\"][\"size\"]"
    },
    "ids": "sec-get-set.prototype.size",
    "rawBody": "{\n  0:let S = this\n  1:(0) app __x0__ = (RequireInternalSlot S \"SetData\")\n  1:[? __x0__]\n  2:let entries = S[\"SetData\"]\n  3:let count = 0i\n  4:let __x1__ = entries\n  4:let __x2__ = 0i\n  4:while (< __x2__ __x1__[\"length\"]) {\n    let e = __x1__[__x2__]\n    5:if (! (= e CONST_empty)) count = (+ count 1i) else 16:{}\n    __x2__ = (+ __x2__ 1i)\n  }\n  6:return count\n}"
  }, {
    "code": ["          1. Let _S_ be the *this* value.", "          1. Return ? CreateSetIterator(_S_, ~value~)."],
    "head": {
      "origParams": [],
      "ref": "Set[\"prototype\"][\"values\"]"
    },
    "ids": "sec-set.prototype.values",
    "rawBody": "{\n  0:let S = this\n  1:(0) app __x0__ = (CreateSetIterator S CONST_value)\n  1:return [? __x0__]\n}"
  }, {
    "code": ["          1. Assert: _kind_ is ~key+value~ or ~value~.", "          1. Perform ? RequireInternalSlot(_set_, [[SetData]]).", "          1. Let _closure_ be a new Abstract Closure with no parameters that captures _set_ and _kind_ and performs the following steps when called:", "            1. Let _index_ be 0.", "            1. Let _entries_ be the List that is _set_.[[SetData]].", "            1. Let _numEntries_ be the number of elements of _entries_.", "            1. Repeat, while _index_ < _numEntries_,", "              1. Let _e_ be _entries_[_index_].", "              1. Set _index_ to _index_ + 1.", "              1. If _e_ is not ~empty~, then", "                1. If _kind_ is ~key+value~, then", "                  1. Perform ? Yield(! CreateArrayFromList(« _e_, _e_ »)).", "                1. Else,", "                  1. Assert: _kind_ is ~value~.", "                  1. Perform ? Yield(_e_).", "                1. NOTE: the number of elements in _entries_ may have changed while execution of this abstract operation was paused by Yield.", "                1. Set _numEntries_ to the number of elements of _entries_.", "            1. Return *undefined*.", "          1. Return ! CreateIteratorFromClosure(_closure_, *\"%SetIteratorPrototype%\"*, %SetIteratorPrototype%)."],
    "head": {
      "name": "CreateSetIterator",
      "params": [{
        "kind": "Normal",
        "name": "set"
      }, {
        "kind": "Normal",
        "name": "kind"
      }]
    },
    "ids": "sec-createsetiterator",
    "rawBody": "{\n  0:assert (|| (= kind CONST_keyPLUSvalue) (= kind CONST_value))\n  1:(0) app __x0__ = (RequireInternalSlot set \"SetData\")\n  1:[? __x0__]\n  2:(0) ??? \"Let id:{closure} be a new Abstract Closure with no parameters that captures id:{set} and id:{kind} and performs the following steps when called : in:{} out:{}\"\n  18:(1) app __x1__ = (CreateIteratorFromClosure closure \"%SetIteratorPrototype%\" INTRINSIC_SetIteratorPrototype)\n  18:return [! __x1__]\n}"
  }, {
    "code": ["          1. If NewTarget is *undefined*, throw a *TypeError* exception.", "          1. Let _map_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%WeakMap.prototype%\"*, « [[WeakMapData]] »).", "          1. Set _map_.[[WeakMapData]] to a new empty List.", "          1. If _iterable_ is either *undefined* or *null*, return _map_.", "          1. Let _adder_ be ? Get(_map_, *\"set\"*).", "          1. Return ? AddEntriesFromIterable(_map_, _iterable_, _adder_)."],
    "head": {
      "origParams": [{
        "kind": "Optional",
        "name": "iterable"
      }],
      "ref": "WeakMap"
    },
    "ids": "sec-weakmap-iterable",
    "rawBody": "{\n  0:if (= NewTarget undefined) (0) throw TypeError else 15:{}\n  1:(0) app __x0__ = (OrdinaryCreateFromConstructor NewTarget \"%WeakMap.prototype%\" (1) (new [\"WeakMapData\"]))\n  1:let map = [? __x0__]\n  2:map[\"WeakMapData\"] = (2) (new [])\n  3:if (|| (= iterable undefined) (= iterable null)) return map else 15:{}\n  4:(1) app __x1__ = (Get map \"set\")\n  4:let adder = [? __x1__]\n  5:(2) app __x2__ = (AddEntriesFromIterable map iterable adder)\n  5:return [? __x2__]\n}"
  }, {
    "code": ["          1. Let _M_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_M_, [[WeakMapData]]).", "          1. Let _entries_ be the List that is _M_.[[WeakMapData]].", "          1. If Type(_key_) is not Object, return *false*.", "          1. For each Record { [[Key]], [[Value]] } _p_ of _entries_, do", "            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, then", "              1. Set _p_.[[Key]] to ~empty~.", "              1. Set _p_.[[Value]] to ~empty~.", "              1. Return *true*.", "          1. Return *false*."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "key"
      }],
      "ref": "WeakMap[\"prototype\"][\"delete\"]"
    },
    "ids": "sec-weakmap.prototype.delete",
    "rawBody": "{\n  0:let M = this\n  1:(0) app __x0__ = (RequireInternalSlot M \"WeakMapData\")\n  1:[? __x0__]\n  2:let entries = M[\"WeakMapData\"]\n  3:if (! (= (typeof key) Object)) return false else 15:{}\n  4:let __x1__ = entries\n  4:let __x2__ = 0i\n  4:while (< __x2__ __x1__[\"length\"]) {\n    let p = __x1__[__x2__]\n    5:let __x3__ = true\n    5:__x3__ = (! (= p[\"Key\"] CONST_empty))\n    5:if __x3__ {\n      (1) app __x4__ = (SameValue p[\"Key\"] key)\n      __x3__ = (= __x4__ true)\n    } else 15:{}\n    5:if __x3__ {\n      6:p[\"Key\"] = CONST_empty\n      7:p[\"Value\"] = CONST_empty\n      8:return true\n    } else 15:{}\n    __x2__ = (+ __x2__ 1i)\n  }\n  9:return false\n}"
  }, {
    "code": ["          1. Let _M_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_M_, [[WeakMapData]]).", "          1. Let _entries_ be the List that is _M_.[[WeakMapData]].", "          1. If Type(_key_) is not Object, return *undefined*.", "          1. For each Record { [[Key]], [[Value]] } _p_ of _entries_, do", "            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, return _p_.[[Value]].", "          1. Return *undefined*."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "key"
      }],
      "ref": "WeakMap[\"prototype\"][\"get\"]"
    },
    "ids": "sec-weakmap.prototype.get",
    "rawBody": "{\n  0:let M = this\n  1:(0) app __x0__ = (RequireInternalSlot M \"WeakMapData\")\n  1:[? __x0__]\n  2:let entries = M[\"WeakMapData\"]\n  3:if (! (= (typeof key) Object)) return undefined else 15:{}\n  4:let __x1__ = entries\n  4:let __x2__ = 0i\n  4:while (< __x2__ __x1__[\"length\"]) {\n    let p = __x1__[__x2__]\n    5:let __x3__ = true\n    5:__x3__ = (! (= p[\"Key\"] CONST_empty))\n    5:if __x3__ {\n      (1) app __x4__ = (SameValue p[\"Key\"] key)\n      __x3__ = (= __x4__ true)\n    } else 15:{}\n    5:if __x3__ return p[\"Value\"] else 15:{}\n    __x2__ = (+ __x2__ 1i)\n  }\n  6:return undefined\n}"
  }, {
    "code": ["          1. Let _M_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_M_, [[WeakMapData]]).", "          1. Let _entries_ be the List that is _M_.[[WeakMapData]].", "          1. If Type(_key_) is not Object, return *false*.", "          1. For each Record { [[Key]], [[Value]] } _p_ of _entries_, do", "            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, return *true*.", "          1. Return *false*."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "key"
      }],
      "ref": "WeakMap[\"prototype\"][\"has\"]"
    },
    "ids": "sec-weakmap.prototype.has",
    "rawBody": "{\n  0:let M = this\n  1:(0) app __x0__ = (RequireInternalSlot M \"WeakMapData\")\n  1:[? __x0__]\n  2:let entries = M[\"WeakMapData\"]\n  3:if (! (= (typeof key) Object)) return false else 15:{}\n  4:let __x1__ = entries\n  4:let __x2__ = 0i\n  4:while (< __x2__ __x1__[\"length\"]) {\n    let p = __x1__[__x2__]\n    5:let __x3__ = true\n    5:__x3__ = (! (= p[\"Key\"] CONST_empty))\n    5:if __x3__ {\n      (1) app __x4__ = (SameValue p[\"Key\"] key)\n      __x3__ = (= __x4__ true)\n    } else 15:{}\n    5:if __x3__ return true else 15:{}\n    __x2__ = (+ __x2__ 1i)\n  }\n  6:return false\n}"
  }, {
    "code": ["          1. Let _M_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_M_, [[WeakMapData]]).", "          1. Let _entries_ be the List that is _M_.[[WeakMapData]].", "          1. If Type(_key_) is not Object, throw a *TypeError* exception.", "          1. For each Record { [[Key]], [[Value]] } _p_ of _entries_, do", "            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, then", "              1. Set _p_.[[Value]] to _value_.", "              1. Return _M_.", "          1. Let _p_ be the Record { [[Key]]: _key_, [[Value]]: _value_ }.", "          1. Append _p_ as the last element of _entries_.", "          1. Return _M_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "key"
      }, {
        "kind": "Normal",
        "name": "value"
      }],
      "ref": "WeakMap[\"prototype\"][\"set\"]"
    },
    "ids": "sec-weakmap.prototype.set",
    "rawBody": "{\n  0:let M = this\n  1:(0) app __x0__ = (RequireInternalSlot M \"WeakMapData\")\n  1:[? __x0__]\n  2:let entries = M[\"WeakMapData\"]\n  3:if (! (= (typeof key) Object)) (0) throw TypeError else 15:{}\n  4:let __x1__ = entries\n  4:let __x2__ = 0i\n  4:while (< __x2__ __x1__[\"length\"]) {\n    let p = __x1__[__x2__]\n    5:let __x3__ = true\n    5:__x3__ = (! (= p[\"Key\"] CONST_empty))\n    5:if __x3__ {\n      (1) app __x4__ = (SameValue p[\"Key\"] key)\n      __x3__ = (= __x4__ true)\n    } else 15:{}\n    5:if __x3__ {\n      6:p[\"Value\"] = value\n      7:return M\n    } else 15:{}\n    __x2__ = (+ __x2__ 1i)\n  }\n  8:let p = (1) (new Record(\"Key\" -> key, \"Value\" -> value))\n  9:append p -> entries\n  10:return M\n}"
  }, {
    "code": ["          1. If NewTarget is *undefined*, throw a *TypeError* exception.", "          1. Let _set_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%WeakSet.prototype%\"*, « [[WeakSetData]] »).", "          1. Set _set_.[[WeakSetData]] to a new empty List.", "          1. If _iterable_ is either *undefined* or *null*, return _set_.", "          1. Let _adder_ be ? Get(_set_, *\"add\"*).", "          1. If IsCallable(_adder_) is *false*, throw a *TypeError* exception.", "          1. Let _iteratorRecord_ be ? GetIterator(_iterable_).", "          1. Repeat,", "            1. Let _next_ be ? IteratorStep(_iteratorRecord_).", "            1. If _next_ is *false*, return _set_.", "            1. Let _nextValue_ be ? IteratorValue(_next_).", "            1. Let _status_ be Call(_adder_, _set_, « _nextValue_ »).", "            1. If _status_ is an abrupt completion, return ? IteratorClose(_iteratorRecord_, _status_)."],
    "head": {
      "origParams": [{
        "kind": "Optional",
        "name": "iterable"
      }],
      "ref": "WeakSet"
    },
    "ids": "sec-weakset-iterable",
    "rawBody": "{\n  0:if (= NewTarget undefined) (0) throw TypeError else 15:{}\n  1:(0) app __x0__ = (OrdinaryCreateFromConstructor NewTarget \"%WeakSet.prototype%\" (1) (new [\"WeakSetData\"]))\n  1:let set = [? __x0__]\n  2:set[\"WeakSetData\"] = (2) (new [])\n  3:if (|| (= iterable undefined) (= iterable null)) return set else 15:{}\n  4:(1) app __x1__ = (Get set \"add\")\n  4:let adder = [? __x1__]\n  5:(2) app __x2__ = (IsCallable adder)\n  5:if (= __x2__ false) (3) throw TypeError else 15:{}\n  6:(3) app __x3__ = (GetIterator iterable)\n  6:let iteratorRecord = [? __x3__]\n  7:while true {\n    8:(4) app __x4__ = (IteratorStep iteratorRecord)\n    8:let next = [? __x4__]\n    9:if (= next false) return set else 15:{}\n    10:(5) app __x5__ = (IteratorValue next)\n    10:let nextValue = [? __x5__]\n    11:(6) app __x6__ = (Call adder set (4) (new [nextValue]))\n    11:let status = __x6__\n    12:(7) app __x7__ = (IsAbruptCompletion status)\n    12:if __x7__ {\n      (8) app __x8__ = (IteratorClose iteratorRecord status)\n      return [? __x8__]\n    } else 15:{}\n  }\n}"
  }, {
    "code": ["          1. Let _S_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_S_, [[WeakSetData]]).", "          1. If Type(_value_) is not Object, throw a *TypeError* exception.", "          1. Let _entries_ be the List that is _S_.[[WeakSetData]].", "          1. For each element _e_ of _entries_, do", "            1. If _e_ is not ~empty~ and SameValue(_e_, _value_) is *true*, then", "              1. Return _S_.", "          1. Append _value_ as the last element of _entries_.", "          1. Return _S_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "value"
      }],
      "ref": "WeakSet[\"prototype\"][\"add\"]"
    },
    "ids": "sec-weakset.prototype.add",
    "rawBody": "{\n  0:let S = this\n  1:(0) app __x0__ = (RequireInternalSlot S \"WeakSetData\")\n  1:[? __x0__]\n  2:if (! (= (typeof value) Object)) (0) throw TypeError else 15:{}\n  3:let entries = S[\"WeakSetData\"]\n  4:let __x1__ = entries\n  4:let __x2__ = 0i\n  4:while (< __x2__ __x1__[\"length\"]) {\n    let e = __x1__[__x2__]\n    5:let __x3__ = true\n    5:__x3__ = (! (= e CONST_empty))\n    5:if __x3__ {\n      (1) app __x4__ = (SameValue e value)\n      __x3__ = (= __x4__ true)\n    } else 15:{}\n    5:if __x3__ return S else 15:{}\n    __x2__ = (+ __x2__ 1i)\n  }\n  7:append value -> entries\n  8:return S\n}"
  }, {
    "code": ["          1. Let _S_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_S_, [[WeakSetData]]).", "          1. If Type(_value_) is not Object, return *false*.", "          1. Let _entries_ be the List that is _S_.[[WeakSetData]].", "          1. For each element _e_ of _entries_, do", "            1. If _e_ is not ~empty~ and SameValue(_e_, _value_) is *true*, then", "              1. Replace the element of _entries_ whose value is _e_ with an element whose value is ~empty~.", "              1. Return *true*.", "          1. Return *false*."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "value"
      }],
      "ref": "WeakSet[\"prototype\"][\"delete\"]"
    },
    "ids": "sec-weakset.prototype.delete",
    "rawBody": "{\n  0:let S = this\n  1:(0) app __x0__ = (RequireInternalSlot S \"WeakSetData\")\n  1:[? __x0__]\n  2:if (! (= (typeof value) Object)) return false else 15:{}\n  3:let entries = S[\"WeakSetData\"]\n  4:let __x1__ = entries\n  4:let __x2__ = 0i\n  4:while (< __x2__ __x1__[\"length\"]) {\n    let e = __x1__[__x2__]\n    5:let __x3__ = true\n    5:__x3__ = (! (= e CONST_empty))\n    5:if __x3__ {\n      (1) app __x4__ = (SameValue e value)\n      __x3__ = (= __x4__ true)\n    } else 15:{}\n    5:if __x3__ {\n      6:(0) ??? \"Replace the element of id:{entries} whose value is id:{e} with an element whose value is const:{empty} .\"\n      7:return true\n    } else 15:{}\n    __x2__ = (+ __x2__ 1i)\n  }\n  8:return false\n}"
  }, {
    "code": ["          1. Let _S_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_S_, [[WeakSetData]]).", "          1. Let _entries_ be the List that is _S_.[[WeakSetData]].", "          1. If Type(_value_) is not Object, return *false*.", "          1. For each element _e_ of _entries_, do", "            1. If _e_ is not ~empty~ and SameValue(_e_, _value_) is *true*, return *true*.", "          1. Return *false*."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "value"
      }],
      "ref": "WeakSet[\"prototype\"][\"has\"]"
    },
    "ids": "sec-weakset.prototype.has",
    "rawBody": "{\n  0:let S = this\n  1:(0) app __x0__ = (RequireInternalSlot S \"WeakSetData\")\n  1:[? __x0__]\n  2:let entries = S[\"WeakSetData\"]\n  3:if (! (= (typeof value) Object)) return false else 15:{}\n  4:let __x1__ = entries\n  4:let __x2__ = 0i\n  4:while (< __x2__ __x1__[\"length\"]) {\n    let e = __x1__[__x2__]\n    5:let __x3__ = true\n    5:__x3__ = (! (= e CONST_empty))\n    5:if __x3__ {\n      (1) app __x4__ = (SameValue e value)\n      __x3__ = (= __x4__ true)\n    } else 15:{}\n    5:if __x3__ return true else 15:{}\n    __x2__ = (+ __x2__ 1i)\n  }\n  6:return false\n}"
  }, {
    "code": ["          1. Let _obj_ be ? OrdinaryCreateFromConstructor(_constructor_, *\"%ArrayBuffer.prototype%\"*, « [[ArrayBufferData]], [[ArrayBufferByteLength]], [[ArrayBufferDetachKey]] »).", "          1. Let _block_ be ? CreateByteDataBlock(_byteLength_).", "          1. Set _obj_.[[ArrayBufferData]] to _block_.", "          1. Set _obj_.[[ArrayBufferByteLength]] to _byteLength_.", "          1. Return _obj_."],
    "head": {
      "name": "AllocateArrayBuffer",
      "params": [{
        "kind": "Normal",
        "name": "constructor"
      }, {
        "kind": "Normal",
        "name": "byteLength"
      }]
    },
    "ids": "sec-allocatearraybuffer",
    "rawBody": "{\n  0:(0) app __x0__ = (OrdinaryCreateFromConstructor constructor \"%ArrayBuffer.prototype%\" (0) (new [\"ArrayBufferData\", \"ArrayBufferByteLength\", \"ArrayBufferDetachKey\"]))\n  0:let obj = [? __x0__]\n  1:(1) app __x1__ = (CreateByteDataBlock byteLength)\n  1:let block = [? __x1__]\n  2:obj[\"ArrayBufferData\"] = block\n  3:obj[\"ArrayBufferByteLength\"] = byteLength\n  4:return obj\n}"
  }, {
    "code": ["          1. Assert: Type(_arrayBuffer_) is Object and it has an [[ArrayBufferData]] internal slot.", "          1. If _arrayBuffer_.[[ArrayBufferData]] is *null*, return *true*.", "          1. Return *false*."],
    "head": {
      "name": "IsDetachedBuffer",
      "params": [{
        "kind": "Normal",
        "name": "arrayBuffer"
      }]
    },
    "ids": "sec-isdetachedbuffer",
    "rawBody": "{\n  1:if (= arrayBuffer[\"ArrayBufferData\"] null) return true else 0:{}\n  2:return false\n}"
  }, {
    "code": ["          1. Assert: Type(_arrayBuffer_) is Object and it has [[ArrayBufferData]], [[ArrayBufferByteLength]], and [[ArrayBufferDetachKey]] internal slots.", "          1. Assert: IsSharedArrayBuffer(_arrayBuffer_) is *false*.", "          1. If _key_ is not present, set _key_ to *undefined*.", "          1. If SameValue(_arrayBuffer_.[[ArrayBufferDetachKey]], _key_) is *false*, throw a *TypeError* exception.", "          1. Set _arrayBuffer_.[[ArrayBufferData]] to *null*.", "          1. Set _arrayBuffer_.[[ArrayBufferByteLength]] to 0.", "          1. Return NormalCompletion(*null*)."],
    "head": {
      "name": "DetachArrayBuffer",
      "params": [{
        "kind": "Normal",
        "name": "arrayBuffer"
      }, {
        "kind": "Optional",
        "name": "key"
      }]
    },
    "ids": "sec-detacharraybuffer",
    "rawBody": "{\n  1:(0) app __x0__ = (IsSharedArrayBuffer arrayBuffer)\n  1:assert (= __x0__ false)\n  2:if (= key absent) key = undefined else 0:{}\n  3:(1) app __x1__ = (SameValue arrayBuffer[\"ArrayBufferDetachKey\"] key)\n  3:if (= __x1__ false) (0) throw TypeError else 0:{}\n  4:arrayBuffer[\"ArrayBufferData\"] = null\n  5:arrayBuffer[\"ArrayBufferByteLength\"] = 0i\n  6:return null\n}"
  }, {
    "code": ["          1. Assert: Type(_srcBuffer_) is Object and it has an [[ArrayBufferData]] internal slot.", "          1. Assert: IsConstructor(_cloneConstructor_) is *true*.", "          1. Let _targetBuffer_ be ? AllocateArrayBuffer(_cloneConstructor_, _srcLength_).", "          1. If IsDetachedBuffer(_srcBuffer_) is *true*, throw a *TypeError* exception.", "          1. Let _srcBlock_ be _srcBuffer_.[[ArrayBufferData]].", "          1. Let _targetBlock_ be _targetBuffer_.[[ArrayBufferData]].", "          1. Perform CopyDataBlockBytes(_targetBlock_, 0, _srcBlock_, _srcByteOffset_, _srcLength_).", "          1. Return _targetBuffer_."],
    "head": {
      "name": "CloneArrayBuffer",
      "params": [{
        "kind": "Normal",
        "name": "srcBuffer"
      }, {
        "kind": "Normal",
        "name": "srcByteOffset"
      }, {
        "kind": "Normal",
        "name": "srcLength"
      }, {
        "kind": "Normal",
        "name": "cloneConstructor"
      }]
    },
    "ids": "sec-clonearraybuffer",
    "rawBody": "{\n  1:(0) app __x0__ = (IsConstructor cloneConstructor)\n  1:assert (= __x0__ true)\n  2:(1) app __x1__ = (AllocateArrayBuffer cloneConstructor srcLength)\n  2:let targetBuffer = [? __x1__]\n  3:(2) app __x2__ = (IsDetachedBuffer srcBuffer)\n  3:if (= __x2__ true) (0) throw TypeError else 0:{}\n  4:let srcBlock = srcBuffer[\"ArrayBufferData\"]\n  5:let targetBlock = targetBuffer[\"ArrayBufferData\"]\n  6:(3) app __x3__ = (CopyDataBlockBytes targetBlock 0i srcBlock srcByteOffset srcLength)\n  6:__x3__\n  7:return targetBuffer\n}"
  }, {
    "code": ["          1. If _type_ is ~Uint8~, ~Uint8C~, ~Uint16~, ~Uint32~, or ~BigUint64~, return *true*.", "          1. Return *false*."],
    "head": {
      "name": "IsUnsignedElementType",
      "params": [{
        "kind": "Normal",
        "name": "type"
      }]
    },
    "ids": "sec-isunsignedelementtype",
    "rawBody": "{\n  0:if (|| (|| (|| (|| (= type CONST_Uint8) (= type CONST_Uint8C)) (= type CONST_Uint16)) (= type CONST_Uint32)) (= type CONST_BigUint64)) return true else 0:{}\n  1:return false\n}"
  }, {
    "code": ["          1. If _type_ is ~Int8~, ~Uint8~, ~Int16~, ~Uint16~, ~Int32~, or ~Uint32~, return *true*.", "          1. Return *false*."],
    "head": {
      "name": "IsUnclampedIntegerElementType",
      "params": [{
        "kind": "Normal",
        "name": "type"
      }]
    },
    "ids": "sec-isunclampedintegerelementtype",
    "rawBody": "{\n  0:if (|| (|| (|| (|| (|| (= type CONST_Int8) (= type CONST_Uint8)) (= type CONST_Int16)) (= type CONST_Uint16)) (= type CONST_Int32)) (= type CONST_Uint32)) return true else 0:{}\n  1:return false\n}"
  }, {
    "code": ["          1. If _type_ is ~BigUint64~ or ~BigInt64~, return *true*.", "          1. Return *false*."],
    "head": {
      "name": "IsBigIntElementType",
      "params": [{
        "kind": "Normal",
        "name": "type"
      }]
    },
    "ids": "sec-isbigintelementtype",
    "rawBody": "{\n  0:if (|| (= type CONST_BigUint64) (= type CONST_BigInt64)) return true else 0:{}\n  1:return false\n}"
  }, {
    "code": ["          1. If ! IsUnclampedIntegerElementType(_type_) is *true*, return *true*.", "          1. If ! IsBigIntElementType(_type_) is *true* and _order_ is not ~Init~ or ~Unordered~, return *true*.", "          1. Return *false*."],
    "head": {
      "name": "IsNoTearConfiguration",
      "params": [{
        "kind": "Normal",
        "name": "type"
      }, {
        "kind": "Normal",
        "name": "order"
      }]
    },
    "ids": "sec-isnotearconfiguration",
    "rawBody": "{\n  0:(0) app __x0__ = (IsUnclampedIntegerElementType type)\n  0:if (= [! __x0__] true) return true else 0:{}\n  1:(1) app __x1__ = (IsBigIntElementType type)\n  1:if (&& (= [! __x1__] true) (! (|| (= order CONST_Init) (= order CONST_Unordered)))) return true else 0:{}\n  2:return false\n}"
  }, {
    "code": ["          1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.", "          1. If _isLittleEndian_ is *false*, reverse the order of the elements of _rawBytes_.", "          1. If _type_ is ~Float32~, then", "            1. Let _value_ be the byte elements of _rawBytes_ concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2019 binary32 value.", "            1. If _value_ is an IEEE 754-2019 binary32 NaN value, return the *NaN* Number value.", "            1. Return the Number value that corresponds to _value_.", "          1. If _type_ is ~Float64~, then", "            1. Let _value_ be the byte elements of _rawBytes_ concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2019 binary64 value.", "            1. If _value_ is an IEEE 754-2019 binary64 NaN value, return the *NaN* Number value.", "            1. Return the Number value that corresponds to _value_.", "          1. If ! IsUnsignedElementType(_type_) is *true*, then", "            1. Let _intValue_ be the byte elements of _rawBytes_ concatenated and interpreted as a bit string encoding of an unsigned little-endian binary number.", "          1. Else,", "            1. Let _intValue_ be the byte elements of _rawBytes_ concatenated and interpreted as a bit string encoding of a binary little-endian two's complement number of bit length _elementSize_ × 8.", "          1. If ! IsBigIntElementType(_type_) is *true*, return the BigInt value that corresponds to _intValue_.", "          1. Otherwise, return the Number value that corresponds to _intValue_."],
    "head": {
      "name": "RawBytesToNumeric",
      "params": [{
        "kind": "Normal",
        "name": "type"
      }, {
        "kind": "Normal",
        "name": "rawBytes"
      }, {
        "kind": "Normal",
        "name": "isLittleEndian"
      }]
    },
    "ids": "sec-rawbytestonumeric",
    "rawBody": "{\n  0:(0) ??? \"Let id:{elementSize} be the Element Size value specified in link:{table-the-typedarray-constructors} for Element Type id:{type} .\"\n  1:(1) ??? \"If id:{isLittleEndian} is value:{false} , reverse the order of the elements of id:{rawBytes} .\"\n  2:if (= type CONST_Float32) {\n    3:(2) ??? \"Let id:{value} be the byte elements of id:{rawBytes} concatenated and interpreted as a little - endian bit string encoding of an IEEE 754 - 2019 binary32 value .\"\n    4:(3) ??? \"If id:{value} is an IEEE 754 - 2019 binary32 NaN value , return the value:{NaN} Number value .\"\n    5:return value\n  } else 0:{}\n  6:if (= type CONST_Float64) {\n    7:(4) ??? \"Let id:{value} be the byte elements of id:{rawBytes} concatenated and interpreted as a little - endian bit string encoding of an IEEE 754 - 2019 binary64 value .\"\n    8:(5) ??? \"If id:{value} is an IEEE 754 - 2019 binary64 NaN value , return the value:{NaN} Number value .\"\n    9:return value\n  } else 0:{}\n  12:(0) app __x0__ = (IsUnsignedElementType type)\n  12:if (= [! __x0__] true) (6) ??? \"Let id:{intValue} be the byte elements of id:{rawBytes} concatenated and interpreted as a bit string encoding of an unsigned little - endian binary number .\" else (7) ??? \"Let id:{intValue} be the byte elements of id:{rawBytes} concatenated and interpreted as a bit string encoding of a binary little - endian two ' s complement number of bit length id:{elementSize} × 8 .\"\n  14:(8) ??? \"If ! IsBigIntElementType ( id:{type} ) is value:{true} , return the BigInt value that corresponds to id:{intValue} .\"\n  15:(9) ??? \"Otherwise , return the Number value that corresponds to id:{intValue} .\"\n}"
  }, {
    "code": ["          1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.", "          1. Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.", "          1. Let _block_ be _arrayBuffer_.[[ArrayBufferData]].", "          1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.", "          1. If IsSharedArrayBuffer(_arrayBuffer_) is *true*, then", "            1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.", "            1. Let _eventList_ be the [[EventList]] field of the element in _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().", "            1. If _isTypedArray_ is *true* and IsNoTearConfiguration(_type_, _order_) is *true*, let _noTear_ be *true*; otherwise let _noTear_ be *false*.", "            1. Let _rawValue_ be a List of length _elementSize_ whose elements are nondeterministically chosen byte values.", "            1. NOTE: In implementations, _rawValue_ is the result of a non-atomic or atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.", "            1. Let _readEvent_ be ReadSharedMemory { [[Order]]: _order_, [[NoTear]]: _noTear_, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_ }.", "            1. Append _readEvent_ to _eventList_.", "            1. Append Chosen Value Record { [[Event]]: _readEvent_, [[ChosenValue]]: _rawValue_ } to _execution_.[[ChosenValues]].", "          1. Else, let _rawValue_ be a List whose elements are bytes from _block_ at indices _byteIndex_ (inclusive) through _byteIndex_ + _elementSize_ (exclusive).", "          1. Assert: The number of elements in _rawValue_ is _elementSize_.", "          1. If _isLittleEndian_ is not present, set _isLittleEndian_ to the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.", "          1. Return RawBytesToNumeric(_type_, _rawValue_, _isLittleEndian_)."],
    "head": {
      "name": "GetValueFromBuffer",
      "params": [{
        "kind": "Normal",
        "name": "arrayBuffer"
      }, {
        "kind": "Normal",
        "name": "byteIndex"
      }, {
        "kind": "Normal",
        "name": "type"
      }, {
        "kind": "Normal",
        "name": "isTypedArray"
      }, {
        "kind": "Normal",
        "name": "order"
      }, {
        "kind": "Optional",
        "name": "isLittleEndian"
      }]
    },
    "ids": "sec-getvaluefrombuffer",
    "rawBody": "{\n  0:(0) app __x0__ = (IsDetachedBuffer arrayBuffer)\n  0:assert (= __x0__ false)\n  2:let block = arrayBuffer[\"ArrayBufferData\"]\n  3:(0) ??? \"Let id:{elementSize} be the Element Size value specified in link:{table-the-typedarray-constructors} for Element Type id:{type} .\"\n  4:(1) app __x1__ = (IsSharedArrayBuffer arrayBuffer)\n  4:if (= __x1__ true) {\n    5:let execution = AGENT[\"CandidateExecution\"]\n    6:(1) ??? \"Let id:{eventList} be the [ [ EventList ] ] field of the element in id:{execution} . [ [ EventsRecords ] ] whose [ [ AgentSignifier ] ] is AgentSignifier ( ) .\"\n    7:let __x2__ = true\n    7:__x2__ = (= isTypedArray true)\n    7:if __x2__ {\n      (2) app __x3__ = (IsNoTearConfiguration type order)\n      __x2__ = (= __x3__ true)\n    } else 9:{}\n    7:if __x2__ let noTear = true else let noTear = false\n    8:let rawValue = NumList\n    10:let readEvent = (2) (new ReadSharedMemory(\"Order\" -> order, \"NoTear\" -> noTear, \"Block\" -> block, \"ByteIndex\" -> byteIndex, \"ElementSize\" -> elementSize))\n    11:append readEvent -> eventList\n    12:append (3) (new ChosenValueRecord(\"Event\" -> readEvent, \"ChosenValue\" -> rawValue)) -> execution[\"ChosenValues\"]\n  } else 9:{}\n  13:let rawValue = NumList\n  14:assert (= rawValue[\"length\"] elementSize)\n  15:if (= isLittleEndian absent) isLittleEndian = AGENT[\"LittleEndian\"] else 9:{}\n  16:(3) app __x4__ = (RawBytesToNumeric type rawValue isLittleEndian)\n  16:return __x4__\n}"
  }, {
    "code": ["          1. If _type_ is ~Float32~, then", "            1. Let _rawBytes_ be a List whose elements are the 4 bytes that are the result of converting _value_ to IEEE 754-2019 binary32 format using roundTiesToEven mode. If _isLittleEndian_ is *false*, the bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If _value_ is *NaN*, _rawBytes_ may be set to any implementation chosen IEEE 754-2019 binary32 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable *NaN* value.", "          1. Else if _type_ is ~Float64~, then", "            1. Let _rawBytes_ be a List whose elements are the 8 bytes that are the IEEE 754-2019 binary64 format encoding of _value_. If _isLittleEndian_ is *false*, the bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If _value_ is *NaN*, _rawBytes_ may be set to any implementation chosen IEEE 754-2019 binary64 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable *NaN* value.", "          1. Else,", "            1. Let _n_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.", "            1. Let _convOp_ be the abstract operation named in the Conversion Operation column in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.", "            1. Let _intValue_ be ℝ(_convOp_(_value_)).", "            1. If _intValue_ ≥ 0, then", "              1. Let _rawBytes_ be a List whose elements are the _n_-byte binary encoding of _intValue_. If _isLittleEndian_ is *false*, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.", "            1. Else,", "              1. Let _rawBytes_ be a List whose elements are the _n_-byte binary two's complement encoding of _intValue_. If _isLittleEndian_ is *false*, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.", "          1. Return _rawBytes_."],
    "head": {
      "name": "NumericToRawBytes",
      "params": [{
        "kind": "Normal",
        "name": "type"
      }, {
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "isLittleEndian"
      }]
    },
    "ids": "sec-numerictorawbytes",
    "rawBody": "{\n  4:if (= type CONST_Float32) (0) ??? \"Let id:{rawBytes} be a List whose elements are the 4 bytes that are the result of converting id:{value} to IEEE 754 - 2019 binary32 format using roundTiesToEven mode . If id:{isLittleEndian} is value:{false} , the bytes are arranged in big endian order . Otherwise , the bytes are arranged in little endian order . If id:{value} is value:{NaN} , id:{rawBytes} may be set to any implementation chosen IEEE 754 - 2019 binary32 format Not - a - Number encoding . An implementation must always choose the same encoding for each implementation distinguishable value:{NaN} value .\" else if (= type CONST_Float64) (1) ??? \"Let id:{rawBytes} be a List whose elements are the 8 bytes that are the IEEE 754 - 2019 binary64 format encoding of id:{value} . If id:{isLittleEndian} is value:{false} , the bytes are arranged in big endian order . Otherwise , the bytes are arranged in little endian order . If id:{value} is value:{NaN} , id:{rawBytes} may be set to any implementation chosen IEEE 754 - 2019 binary64 format Not - a - Number encoding . An implementation must always choose the same encoding for each implementation distinguishable value:{NaN} value .\" else {\n    5:(2) ??? \"Let id:{n} be the Element Size value specified in link:{table-the-typedarray-constructors} for Element Type id:{type} .\"\n    6:(3) ??? \"Let id:{convOp} be the abstract operation named in the Conversion Operation column in link:{table-the-typedarray-constructors} for Element Type id:{type} .\"\n    7:(0) app __x0__ = (convOp value)\n    7:let intValue = __x0__\n    10:if (! (< intValue 0i)) (4) ??? \"Let id:{rawBytes} be a List whose elements are the id:{n} - byte binary encoding of id:{intValue} . If id:{isLittleEndian} is value:{false} , the bytes are ordered in big endian order . Otherwise , the bytes are ordered in little endian order .\" else (5) ??? \"Let id:{rawBytes} be a List whose elements are the id:{n} - byte binary two ' s complement encoding of id:{intValue} . If id:{isLittleEndian} is value:{false} , the bytes are ordered in big endian order . Otherwise , the bytes are ordered in little endian order .\"\n  }\n  12:return rawBytes\n}"
  }, {
    "code": ["          1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.", "          1. Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.", "          1. Assert: Type(_value_) is BigInt if ! IsBigIntElementType(_type_) is *true*; otherwise, Type(_value_) is Number.", "          1. Let _block_ be _arrayBuffer_.[[ArrayBufferData]].", "          1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.", "          1. If _isLittleEndian_ is not present, set _isLittleEndian_ to the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.", "          1. Let _rawBytes_ be NumericToRawBytes(_type_, _value_, _isLittleEndian_).", "          1. If IsSharedArrayBuffer(_arrayBuffer_) is *true*, then", "            1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.", "            1. Let _eventList_ be the [[EventList]] field of the element in _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().", "            1. If _isTypedArray_ is *true* and IsNoTearConfiguration(_type_, _order_) is *true*, let _noTear_ be *true*; otherwise let _noTear_ be *false*.", "            1. Append WriteSharedMemory { [[Order]]: _order_, [[NoTear]]: _noTear_, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_, [[Payload]]: _rawBytes_ } to _eventList_.", "          1. Else, store the individual bytes of _rawBytes_ into _block_, starting at _block_[_byteIndex_].", "          1. Return NormalCompletion(*undefined*)."],
    "head": {
      "name": "SetValueInBuffer",
      "params": [{
        "kind": "Normal",
        "name": "arrayBuffer"
      }, {
        "kind": "Normal",
        "name": "byteIndex"
      }, {
        "kind": "Normal",
        "name": "type"
      }, {
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "isTypedArray"
      }, {
        "kind": "Normal",
        "name": "order"
      }, {
        "kind": "Optional",
        "name": "isLittleEndian"
      }]
    },
    "ids": "sec-setvalueinbuffer",
    "rawBody": "{\n  0:(0) app __x0__ = (IsDetachedBuffer arrayBuffer)\n  0:assert (= __x0__ false)\n  3:let block = arrayBuffer[\"ArrayBufferData\"]\n  4:(0) ??? \"Let id:{elementSize} be the Element Size value specified in link:{table-the-typedarray-constructors} for Element Type id:{type} .\"\n  5:if (= isLittleEndian absent) isLittleEndian = AGENT[\"LittleEndian\"] else 2:{}\n  6:(1) app __x1__ = (NumericToRawBytes type value isLittleEndian)\n  6:let rawBytes = __x1__\n  7:(2) app __x2__ = (IsSharedArrayBuffer arrayBuffer)\n  7:if (= __x2__ true) {\n    8:let execution = AGENT[\"CandidateExecution\"]\n    9:(1) ??? \"Let id:{eventList} be the [ [ EventList ] ] field of the element in id:{execution} . [ [ EventsRecords ] ] whose [ [ AgentSignifier ] ] is AgentSignifier ( ) .\"\n    10:let __x3__ = true\n    10:__x3__ = (= isTypedArray true)\n    10:if __x3__ {\n      (3) app __x4__ = (IsNoTearConfiguration type order)\n      __x3__ = (= __x4__ true)\n    } else 2:{}\n    10:if __x3__ let noTear = true else let noTear = false\n    11:append (2) (new WriteSharedMemory(\"Order\" -> order, \"NoTear\" -> noTear, \"Block\" -> block, \"ByteIndex\" -> byteIndex, \"ElementSize\" -> elementSize, \"Payload\" -> rawBytes)) -> eventList\n  } else 2:{}\n  12:(3) ??? \"Else , store the individual bytes of id:{rawBytes} into id:{block} , starting at id:{block} [ id:{byteIndex} ] .\"\n  13:return undefined\n}"
  }, {
    "code": ["          1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.", "          1. Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.", "          1. Assert: Type(_value_) is BigInt if ! IsBigIntElementType(_type_) is *true*; otherwise, Type(_value_) is Number.", "          1. Let _block_ be _arrayBuffer_.[[ArrayBufferData]].", "          1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.", "          1. If _isLittleEndian_ is not present, set _isLittleEndian_ to the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.", "          1. Let _rawBytes_ be NumericToRawBytes(_type_, _value_, _isLittleEndian_).", "          1. If IsSharedArrayBuffer(_arrayBuffer_) is *true*, then", "            1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.", "            1. Let _eventList_ be the [[EventList]] field of the element in _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().", "            1. Let _rawBytesRead_ be a List of length _elementSize_ whose elements are nondeterministically chosen byte values.", "            1. NOTE: In implementations, _rawBytesRead_ is the result of a load-link, of a load-exclusive, or of an operand of a read-modify-write instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.", "            1. Let _rmwEvent_ be ReadModifyWriteSharedMemory { [[Order]]: ~SeqCst~, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_, [[Payload]]: _rawBytes_, [[ModifyOp]]: _op_ }.", "            1. Append _rmwEvent_ to _eventList_.", "            1. Append Chosen Value Record { [[Event]]: _rmwEvent_, [[ChosenValue]]: _rawBytesRead_ } to _execution_.[[ChosenValues]].", "          1. Else,", "            1. Let _rawBytesRead_ be a List of length _elementSize_ whose elements are the sequence of _elementSize_ bytes starting with _block_[_byteIndex_].", "            1. Let _rawBytesModified_ be _op_(_rawBytesRead_, _rawBytes_).", "            1. Store the individual bytes of _rawBytesModified_ into _block_, starting at _block_[_byteIndex_].", "          1. Return RawBytesToNumeric(_type_, _rawBytesRead_, _isLittleEndian_)."],
    "head": {
      "name": "GetModifySetValueInBuffer",
      "params": [{
        "kind": "Normal",
        "name": "arrayBuffer"
      }, {
        "kind": "Normal",
        "name": "byteIndex"
      }, {
        "kind": "Normal",
        "name": "type"
      }, {
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "op"
      }, {
        "kind": "Optional",
        "name": "isLittleEndian"
      }]
    },
    "ids": "sec-getmodifysetvalueinbuffer",
    "rawBody": "{\n  0:(0) app __x0__ = (IsDetachedBuffer arrayBuffer)\n  0:assert (= __x0__ false)\n  3:let block = arrayBuffer[\"ArrayBufferData\"]\n  4:(0) ??? \"Let id:{elementSize} be the Element Size value specified in link:{table-the-typedarray-constructors} for Element Type id:{type} .\"\n  5:if (= isLittleEndian absent) isLittleEndian = AGENT[\"LittleEndian\"] else 11:{}\n  6:(1) app __x1__ = (NumericToRawBytes type value isLittleEndian)\n  6:let rawBytes = __x1__\n  15:(2) app __x2__ = (IsSharedArrayBuffer arrayBuffer)\n  15:if (= __x2__ true) {\n    8:let execution = AGENT[\"CandidateExecution\"]\n    9:(1) ??? \"Let id:{eventList} be the [ [ EventList ] ] field of the element in id:{execution} . [ [ EventsRecords ] ] whose [ [ AgentSignifier ] ] is AgentSignifier ( ) .\"\n    10:(2) ??? \"Let id:{rawBytesRead} be a List of length id:{elementSize} whose elements are nondeterministically chosen byte values .\"\n    12:let rmwEvent = (3) (new ReadModifyWriteSharedMemory(\"Order\" -> CONST_SeqCst, \"NoTear\" -> true, \"Block\" -> block, \"ByteIndex\" -> byteIndex, \"ElementSize\" -> elementSize, \"Payload\" -> rawBytes, \"ModifyOp\" -> op))\n    13:append rmwEvent -> eventList\n    14:append (4) (new ChosenValueRecord(\"Event\" -> rmwEvent, \"ChosenValue\" -> rawBytesRead)) -> execution[\"ChosenValues\"]\n  } else {\n    16:(5) ??? \"Let id:{rawBytesRead} be a List of length id:{elementSize} whose elements are the sequence of id:{elementSize} bytes starting with id:{block} [ id:{byteIndex} ] .\"\n    17:(3) app __x3__ = (op rawBytesRead rawBytes)\n    17:let rawBytesModified = __x3__\n    18:(6) ??? \"Store the individual bytes of id:{rawBytesModified} into id:{block} , starting at id:{block} [ id:{byteIndex} ] .\"\n  }\n  19:(4) app __x4__ = (RawBytesToNumeric type rawBytesRead isLittleEndian)\n  19:return __x4__\n}"
  }, {
    "code": ["          1. If NewTarget is *undefined*, throw a *TypeError* exception.", "          1. Let _byteLength_ be ? ToIndex(_length_).", "          1. Return ? AllocateArrayBuffer(NewTarget, _byteLength_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "length"
      }],
      "ref": "ArrayBuffer"
    },
    "ids": "sec-arraybuffer-length",
    "rawBody": "{\n  0:if (= NewTarget undefined) (0) throw TypeError else 11:{}\n  1:(0) app __x0__ = (ToIndex length)\n  1:let byteLength = [? __x0__]\n  2:(1) app __x1__ = (AllocateArrayBuffer NewTarget byteLength)\n  2:return [? __x1__]\n}"
  }, {
    "code": ["          1. If Type(_arg_) is not Object, return *false*.", "          1. If _arg_ has a [[ViewedArrayBuffer]] internal slot, return *true*.", "          1. Return *false*."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "arg"
      }],
      "ref": "ArrayBuffer[\"isView\"]"
    },
    "ids": "sec-arraybuffer.isview",
    "rawBody": "{\n  0:if (! (= (typeof arg) Object)) return false else 11:{}\n  1:if (! (= arg[\"ViewedArrayBuffer\"] absent)) return true else 11:{}\n  2:return false\n}"
  }, {
    "code": ["          1. Return the *this* value."],
    "head": {
      "origParams": [],
      "ref": "getArrayBuffer[SYMBOL_species]"
    },
    "ids": "sec-get-arraybuffer-@@species",
    "rawBody": "return this"
  }, {
    "code": ["          1. Let _O_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).", "          1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.", "          1. If IsDetachedBuffer(_O_) is *true*, return *+0*<sub>𝔽</sub>.", "          1. Let _length_ be _O_.[[ArrayBufferByteLength]].", "          1. Return 𝔽(_length_)."],
    "head": {
      "origParams": [],
      "ref": "getArrayBuffer[\"prototype\"][\"byteLength\"]"
    },
    "ids": "sec-get-arraybuffer.prototype.bytelength",
    "rawBody": "{\n  0:let O = this\n  1:(0) app __x0__ = (RequireInternalSlot O \"ArrayBufferData\")\n  1:[? __x0__]\n  2:(1) app __x1__ = (IsSharedArrayBuffer O)\n  2:if (= __x1__ true) (0) throw TypeError else 11:{}\n  3:(2) app __x2__ = (IsDetachedBuffer O)\n  3:if (= __x2__ true) return 0i else 11:{}\n  4:let length = O[\"ArrayBufferByteLength\"]\n  5:return length\n}"
  }, {
    "code": ["          1. Let _O_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).", "          1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.", "          1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.", "          1. Let _len_ be _O_.[[ArrayBufferByteLength]].", "          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).", "          1. If _relativeStart_ is -∞, let _first_ be 0.", "          1. Else if _relativeStart_ < 0, let _first_ be max(_len_ + _relativeStart_, 0).", "          1. Else, let _first_ be min(_relativeStart_, _len_).", "          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).", "          1. If _relativeEnd_ is -∞, let _final_ be 0.", "          1. Else if _relativeEnd_ < 0, let _final_ be max(_len_ + _relativeEnd_, 0).", "          1. Else, let _final_ be min(_relativeEnd_, _len_).", "          1. Let _newLen_ be max(_final_ - _first_, 0).", "          1. Let _ctor_ be ? SpeciesConstructor(_O_, %ArrayBuffer%).", "          1. Let _new_ be ? Construct(_ctor_, « 𝔽(_newLen_) »).", "          1. Perform ? RequireInternalSlot(_new_, [[ArrayBufferData]]).", "          1. If IsSharedArrayBuffer(_new_) is *true*, throw a *TypeError* exception.", "          1. If IsDetachedBuffer(_new_) is *true*, throw a *TypeError* exception.", "          1. If SameValue(_new_, _O_) is *true*, throw a *TypeError* exception.", "          1. If _new_.[[ArrayBufferByteLength]] < _newLen_, throw a *TypeError* exception.", "          1. NOTE: Side-effects of the above steps may have detached _O_.", "          1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.", "          1. Let _fromBuf_ be _O_.[[ArrayBufferData]].", "          1. Let _toBuf_ be _new_.[[ArrayBufferData]].", "          1. Perform CopyDataBlockBytes(_toBuf_, 0, _fromBuf_, _first_, _newLen_).", "          1. Return _new_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "start"
      }, {
        "kind": "Normal",
        "name": "end"
      }],
      "ref": "ArrayBuffer[\"prototype\"][\"slice\"]"
    },
    "ids": "sec-arraybuffer.prototype.slice",
    "rawBody": "{\n  0:let O = this\n  1:(0) app __x0__ = (RequireInternalSlot O \"ArrayBufferData\")\n  1:[? __x0__]\n  2:(1) app __x1__ = (IsSharedArrayBuffer O)\n  2:if (= __x1__ true) (0) throw TypeError else 21:{}\n  3:(2) app __x2__ = (IsDetachedBuffer O)\n  3:if (= __x2__ true) (1) throw TypeError else 21:{}\n  4:let len = O[\"ArrayBufferByteLength\"]\n  5:(3) app __x3__ = (ToIntegerOrInfinity start)\n  5:let relativeStart = [? __x3__]\n  8:if (= relativeStart -Infinity) let first = 0i else if (< relativeStart 0i) {\n    (4) app __x4__ = (max (+ len relativeStart) 0i)\n    let first = __x4__\n  } else {\n    (5) app __x5__ = (min relativeStart len)\n    let first = __x5__\n  }\n  9:if (= end undefined) let relativeEnd = len else {\n    (6) app __x6__ = (ToIntegerOrInfinity end)\n    let relativeEnd = [? __x6__]\n  }\n  12:if (= relativeEnd -Infinity) let final = 0i else if (< relativeEnd 0i) {\n    (7) app __x7__ = (max (+ len relativeEnd) 0i)\n    let final = __x7__\n  } else {\n    (8) app __x8__ = (min relativeEnd len)\n    let final = __x8__\n  }\n  13:(9) app __x9__ = (max (- final first) 0i)\n  13:let newLen = __x9__\n  14:(10) app __x10__ = (SpeciesConstructor O INTRINSIC_ArrayBuffer)\n  14:let ctor = [? __x10__]\n  15:(11) app __x11__ = (Construct ctor (2) (new [newLen]))\n  15:let new = [? __x11__]\n  16:(12) app __x12__ = (RequireInternalSlot new \"ArrayBufferData\")\n  16:[? __x12__]\n  17:(13) app __x13__ = (IsSharedArrayBuffer new)\n  17:if (= __x13__ true) (3) throw TypeError else 21:{}\n  18:(14) app __x14__ = (IsDetachedBuffer new)\n  18:if (= __x14__ true) (4) throw TypeError else 21:{}\n  19:(15) app __x15__ = (SameValue new O)\n  19:if (= __x15__ true) (5) throw TypeError else 21:{}\n  20:if (< new[\"ArrayBufferByteLength\"] newLen) (6) throw TypeError else 21:{}\n  22:(16) app __x16__ = (IsDetachedBuffer O)\n  22:if (= __x16__ true) (7) throw TypeError else 21:{}\n  23:let fromBuf = O[\"ArrayBufferData\"]\n  24:let toBuf = new[\"ArrayBufferData\"]\n  25:(17) app __x17__ = (CopyDataBlockBytes toBuf 0i fromBuf first newLen)\n  25:__x17__\n  26:return new\n}"
  }, {
    "code": ["          1. Let _obj_ be ? OrdinaryCreateFromConstructor(_constructor_, *\"%SharedArrayBuffer.prototype%\"*, « [[ArrayBufferData]], [[ArrayBufferByteLength]] »).", "          1. Let _block_ be ? CreateSharedByteDataBlock(_byteLength_).", "          1. Set _obj_.[[ArrayBufferData]] to _block_.", "          1. Set _obj_.[[ArrayBufferByteLength]] to _byteLength_.", "          1. Return _obj_."],
    "head": {
      "name": "AllocateSharedArrayBuffer",
      "params": [{
        "kind": "Normal",
        "name": "constructor"
      }, {
        "kind": "Normal",
        "name": "byteLength"
      }]
    },
    "ids": "sec-allocatesharedarraybuffer",
    "rawBody": "{\n  0:(0) app __x0__ = (OrdinaryCreateFromConstructor constructor \"%SharedArrayBuffer.prototype%\" (0) (new [\"ArrayBufferData\", \"ArrayBufferByteLength\"]))\n  0:let obj = [? __x0__]\n  1:(1) app __x1__ = (CreateSharedByteDataBlock byteLength)\n  1:let block = [? __x1__]\n  2:obj[\"ArrayBufferData\"] = block\n  3:obj[\"ArrayBufferByteLength\"] = byteLength\n  4:return obj\n}"
  }, {
    "code": ["          1. Assert: Type(_obj_) is Object and it has an [[ArrayBufferData]] internal slot.", "          1. Let _bufferData_ be _obj_.[[ArrayBufferData]].", "          1. If _bufferData_ is *null*, return *false*.", "          1. If _bufferData_ is a Data Block, return *false*.", "          1. Assert: _bufferData_ is a Shared Data Block.", "          1. Return *true*."],
    "head": {
      "name": "IsSharedArrayBuffer",
      "params": [{
        "kind": "Normal",
        "name": "obj"
      }]
    },
    "ids": "sec-issharedarraybuffer",
    "rawBody": "{\n  1:let bufferData = obj[\"ArrayBufferData\"]\n  2:if (= bufferData null) return false else 0:{}\n  3:if (0) (is-instance-of bufferData DataBlock) return false else 0:{}\n  4:assert (1) (is-instance-of bufferData SharedDataBlock)\n  5:return true\n}"
  }, {
    "code": ["          1. If NewTarget is *undefined*, throw a *TypeError* exception.", "          1. Let _byteLength_ be ? ToIndex(_length_).", "          1. Return ? AllocateSharedArrayBuffer(NewTarget, _byteLength_)."],
    "head": {
      "origParams": [{
        "kind": "Optional",
        "name": "length"
      }],
      "ref": "SharedArrayBuffer"
    },
    "ids": "sec-sharedarraybuffer-length",
    "rawBody": "{\n  0:if (= NewTarget undefined) (0) throw TypeError else 0:{}\n  1:(0) app __x0__ = (ToIndex length)\n  1:let byteLength = [? __x0__]\n  2:(1) app __x1__ = (AllocateSharedArrayBuffer NewTarget byteLength)\n  2:return [? __x1__]\n}"
  }, {
    "code": ["          1. Return the *this* value."],
    "head": {
      "origParams": [],
      "ref": "getSharedArrayBuffer[SYMBOL_species]"
    },
    "ids": "sec-sharedarraybuffer-@@species",
    "rawBody": "return this"
  }, {
    "code": ["          1. Let _O_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).", "          1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.", "          1. Let _length_ be _O_.[[ArrayBufferByteLength]].", "          1. Return 𝔽(_length_)."],
    "head": {
      "origParams": [],
      "ref": "getSharedArrayBuffer[\"prototype\"][\"byteLength\"]"
    },
    "ids": "sec-get-sharedarraybuffer.prototype.bytelength",
    "rawBody": "{\n  0:let O = this\n  1:(0) app __x0__ = (RequireInternalSlot O \"ArrayBufferData\")\n  1:[? __x0__]\n  2:(1) app __x1__ = (IsSharedArrayBuffer O)\n  2:if (= __x1__ false) (0) throw TypeError else 0:{}\n  3:let length = O[\"ArrayBufferByteLength\"]\n  4:return length\n}"
  }, {
    "code": ["          1. Let _O_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).", "          1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.", "          1. Let _len_ be _O_.[[ArrayBufferByteLength]].", "          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).", "          1. If _relativeStart_ is -∞, let _first_ be 0.", "          1. Else if _relativeStart_ < 0, let _first_ be max(_len_ + _relativeStart_, 0).", "          1. Else, let _first_ be min(_relativeStart_, _len_).", "          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).", "          1. If _relativeEnd_ is -∞, let _final_ be 0.", "          1. Else if _relativeEnd_ < 0, let _final_ be max(_len_ + _relativeEnd_, 0).", "          1. Else, let _final_ be min(_relativeEnd_, _len_).", "          1. Let _newLen_ be max(_final_ - _first_, 0).", "          1. Let _ctor_ be ? SpeciesConstructor(_O_, %SharedArrayBuffer%).", "          1. Let _new_ be ? Construct(_ctor_, « 𝔽(_newLen_) »).", "          1. Perform ? RequireInternalSlot(_new_, [[ArrayBufferData]]).", "          1. If IsSharedArrayBuffer(_new_) is *false*, throw a *TypeError* exception.", "          1. If _new_.[[ArrayBufferData]] and _O_.[[ArrayBufferData]] are the same Shared Data Block values, throw a *TypeError* exception.", "          1. If _new_.[[ArrayBufferByteLength]] < _newLen_, throw a *TypeError* exception.", "          1. Let _fromBuf_ be _O_.[[ArrayBufferData]].", "          1. Let _toBuf_ be _new_.[[ArrayBufferData]].", "          1. Perform CopyDataBlockBytes(_toBuf_, 0, _fromBuf_, _first_, _newLen_).", "          1. Return _new_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "start"
      }, {
        "kind": "Normal",
        "name": "end"
      }],
      "ref": "SharedArrayBuffer[\"prototype\"][\"slice\"]"
    },
    "ids": "sec-sharedarraybuffer.prototype.slice",
    "rawBody": "{\n  0:let O = this\n  1:(0) app __x0__ = (RequireInternalSlot O \"ArrayBufferData\")\n  1:[? __x0__]\n  2:(1) app __x1__ = (IsSharedArrayBuffer O)\n  2:if (= __x1__ false) (0) throw TypeError else 0:{}\n  3:let len = O[\"ArrayBufferByteLength\"]\n  4:(2) app __x2__ = (ToIntegerOrInfinity start)\n  4:let relativeStart = [? __x2__]\n  7:if (= relativeStart -Infinity) let first = 0i else if (< relativeStart 0i) {\n    (3) app __x3__ = (max (+ len relativeStart) 0i)\n    let first = __x3__\n  } else {\n    (4) app __x4__ = (min relativeStart len)\n    let first = __x4__\n  }\n  8:if (= end undefined) let relativeEnd = len else {\n    (5) app __x5__ = (ToIntegerOrInfinity end)\n    let relativeEnd = [? __x5__]\n  }\n  11:if (= relativeEnd -Infinity) let final = 0i else if (< relativeEnd 0i) {\n    (6) app __x6__ = (max (+ len relativeEnd) 0i)\n    let final = __x6__\n  } else {\n    (7) app __x7__ = (min relativeEnd len)\n    let final = __x7__\n  }\n  12:(8) app __x8__ = (max (- final first) 0i)\n  12:let newLen = __x8__\n  13:(9) app __x9__ = (SpeciesConstructor O INTRINSIC_SharedArrayBuffer)\n  13:let ctor = [? __x9__]\n  14:(10) app __x10__ = (Construct ctor (1) (new [newLen]))\n  14:let new = [? __x10__]\n  15:(11) app __x11__ = (RequireInternalSlot new \"ArrayBufferData\")\n  15:[? __x11__]\n  16:(12) app __x12__ = (IsSharedArrayBuffer new)\n  16:if (= __x12__ false) (2) throw TypeError else 0:{}\n  17:if (= new[\"ArrayBufferData\"] O[\"ArrayBufferData\"]) (3) throw TypeError else 0:{}\n  18:if (< new[\"ArrayBufferByteLength\"] newLen) (4) throw TypeError else 0:{}\n  19:let fromBuf = O[\"ArrayBufferData\"]\n  20:let toBuf = new[\"ArrayBufferData\"]\n  21:(13) app __x13__ = (CopyDataBlockBytes toBuf 0i fromBuf first newLen)\n  21:__x13__\n  22:return new\n}"
  }, {
    "code": ["          1. Perform ? RequireInternalSlot(_view_, [[DataView]]).", "          1. Assert: _view_ has a [[ViewedArrayBuffer]] internal slot.", "          1. Let _getIndex_ be ? ToIndex(_requestIndex_).", "          1. Set _isLittleEndian_ to ! ToBoolean(_isLittleEndian_).", "          1. Let _buffer_ be _view_.[[ViewedArrayBuffer]].", "          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.", "          1. Let _viewOffset_ be _view_.[[ByteOffset]].", "          1. Let _viewSize_ be _view_.[[ByteLength]].", "          1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.", "          1. If _getIndex_ + _elementSize_ > _viewSize_, throw a *RangeError* exception.", "          1. Let _bufferIndex_ be _getIndex_ + _viewOffset_.", "          1. Return GetValueFromBuffer(_buffer_, _bufferIndex_, _type_, *false*, ~Unordered~, _isLittleEndian_)."],
    "head": {
      "name": "GetViewValue",
      "params": [{
        "kind": "Normal",
        "name": "view"
      }, {
        "kind": "Normal",
        "name": "requestIndex"
      }, {
        "kind": "Normal",
        "name": "isLittleEndian"
      }, {
        "kind": "Normal",
        "name": "type"
      }]
    },
    "ids": "sec-getviewvalue",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireInternalSlot view \"DataView\")\n  0:[? __x0__]\n  1:assert (! (= view[\"ViewedArrayBuffer\"] absent))\n  2:(1) app __x1__ = (ToIndex requestIndex)\n  2:let getIndex = [? __x1__]\n  3:(2) app __x2__ = (ToBoolean isLittleEndian)\n  3:isLittleEndian = [! __x2__]\n  4:let buffer = view[\"ViewedArrayBuffer\"]\n  5:(3) app __x3__ = (IsDetachedBuffer buffer)\n  5:if (= __x3__ true) (0) throw TypeError else 0:{}\n  6:let viewOffset = view[\"ByteOffset\"]\n  7:let viewSize = view[\"ByteLength\"]\n  8:(1) ??? \"Let id:{elementSize} be the Element Size value specified in link:{table-the-typedarray-constructors} for Element Type id:{type} .\"\n  9:if (< viewSize (+ getIndex elementSize)) (2) throw RangeError else 0:{}\n  10:let bufferIndex = (+ getIndex viewOffset)\n  11:(4) app __x4__ = (GetValueFromBuffer buffer bufferIndex type false CONST_Unordered isLittleEndian)\n  11:return __x4__\n}"
  }, {
    "code": ["          1. Perform ? RequireInternalSlot(_view_, [[DataView]]).", "          1. Assert: _view_ has a [[ViewedArrayBuffer]] internal slot.", "          1. Let _getIndex_ be ? ToIndex(_requestIndex_).", "          1. If ! IsBigIntElementType(_type_) is *true*, let _numberValue_ be ? ToBigInt(_value_).", "          1. Otherwise, let _numberValue_ be ? ToNumber(_value_).", "          1. Set _isLittleEndian_ to ! ToBoolean(_isLittleEndian_).", "          1. Let _buffer_ be _view_.[[ViewedArrayBuffer]].", "          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.", "          1. Let _viewOffset_ be _view_.[[ByteOffset]].", "          1. Let _viewSize_ be _view_.[[ByteLength]].", "          1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.", "          1. If _getIndex_ + _elementSize_ > _viewSize_, throw a *RangeError* exception.", "          1. Let _bufferIndex_ be _getIndex_ + _viewOffset_.", "          1. Return SetValueInBuffer(_buffer_, _bufferIndex_, _type_, _numberValue_, *false*, ~Unordered~, _isLittleEndian_)."],
    "head": {
      "name": "SetViewValue",
      "params": [{
        "kind": "Normal",
        "name": "view"
      }, {
        "kind": "Normal",
        "name": "requestIndex"
      }, {
        "kind": "Normal",
        "name": "isLittleEndian"
      }, {
        "kind": "Normal",
        "name": "type"
      }, {
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "sec-setviewvalue",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireInternalSlot view \"DataView\")\n  0:[? __x0__]\n  1:assert (! (= view[\"ViewedArrayBuffer\"] absent))\n  2:(1) app __x1__ = (ToIndex requestIndex)\n  2:let getIndex = [? __x1__]\n  4:(2) app __x2__ = (IsBigIntElementType type)\n  4:if (= [! __x2__] true) {\n    (3) app __x3__ = (ToBigInt value)\n    let numberValue = [? __x3__]\n  } else {\n    (4) app __x4__ = (ToNumber value)\n    let numberValue = [? __x4__]\n  }\n  5:(5) app __x5__ = (ToBoolean isLittleEndian)\n  5:isLittleEndian = [! __x5__]\n  6:let buffer = view[\"ViewedArrayBuffer\"]\n  7:(6) app __x6__ = (IsDetachedBuffer buffer)\n  7:if (= __x6__ true) (0) throw TypeError else 0:{}\n  8:let viewOffset = view[\"ByteOffset\"]\n  9:let viewSize = view[\"ByteLength\"]\n  10:(1) ??? \"Let id:{elementSize} be the Element Size value specified in link:{table-the-typedarray-constructors} for Element Type id:{type} .\"\n  11:if (< viewSize (+ getIndex elementSize)) (2) throw RangeError else 0:{}\n  12:let bufferIndex = (+ getIndex viewOffset)\n  13:(7) app __x7__ = (SetValueInBuffer buffer bufferIndex type numberValue false CONST_Unordered isLittleEndian)\n  13:return __x7__\n}"
  }, {
    "code": ["          1. If NewTarget is *undefined*, throw a *TypeError* exception.", "          1. Perform ? RequireInternalSlot(_buffer_, [[ArrayBufferData]]).", "          1. Let _offset_ be ? ToIndex(_byteOffset_).", "          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.", "          1. Let _bufferByteLength_ be _buffer_.[[ArrayBufferByteLength]].", "          1. If _offset_ > _bufferByteLength_, throw a *RangeError* exception.", "          1. If _byteLength_ is *undefined*, then", "            1. Let _viewByteLength_ be _bufferByteLength_ - _offset_.", "          1. Else,", "            1. Let _viewByteLength_ be ? ToIndex(_byteLength_).", "            1. If _offset_ + _viewByteLength_ > _bufferByteLength_, throw a *RangeError* exception.", "          1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%DataView.prototype%\"*, « [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], [[ByteOffset]] »).", "          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.", "          1. Set _O_.[[ViewedArrayBuffer]] to _buffer_.", "          1. Set _O_.[[ByteLength]] to _viewByteLength_.", "          1. Set _O_.[[ByteOffset]] to _offset_.", "          1. Return _O_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "buffer"
      }, {
        "kind": "Optional",
        "name": "byteOffset"
      }, {
        "kind": "Optional",
        "name": "byteLength"
      }],
      "ref": "DataView"
    },
    "ids": "sec-dataview-buffer-byteoffset-bytelength",
    "rawBody": "{\n  0:if (= NewTarget undefined) (0) throw TypeError else 0:{}\n  1:(0) app __x0__ = (RequireInternalSlot buffer \"ArrayBufferData\")\n  1:[? __x0__]\n  2:(1) app __x1__ = (ToIndex byteOffset)\n  2:let offset = [? __x1__]\n  3:(2) app __x2__ = (IsDetachedBuffer buffer)\n  3:if (= __x2__ true) (1) throw TypeError else 0:{}\n  4:let bufferByteLength = buffer[\"ArrayBufferByteLength\"]\n  5:if (< bufferByteLength offset) (2) throw RangeError else 0:{}\n  8:if (= byteLength undefined) let viewByteLength = (- bufferByteLength offset) else {\n    9:(3) app __x3__ = (ToIndex byteLength)\n    9:let viewByteLength = [? __x3__]\n    10:if (< bufferByteLength (+ offset viewByteLength)) (3) throw RangeError else 0:{}\n  }\n  11:(4) app __x4__ = (OrdinaryCreateFromConstructor NewTarget \"%DataView.prototype%\" (4) (new [\"DataView\", \"ViewedArrayBuffer\", \"ByteLength\", \"ByteOffset\"]))\n  11:let O = [? __x4__]\n  12:(5) app __x5__ = (IsDetachedBuffer buffer)\n  12:if (= __x5__ true) (5) throw TypeError else 0:{}\n  13:O[\"ViewedArrayBuffer\"] = buffer\n  14:O[\"ByteLength\"] = viewByteLength\n  15:O[\"ByteOffset\"] = offset\n  16:return O\n}"
  }, {
    "code": ["          1. Let _O_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_O_, [[DataView]]).", "          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.", "          1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].", "          1. Return _buffer_."],
    "head": {
      "origParams": [],
      "ref": "getDataView[\"prototype\"][\"buffer\"]"
    },
    "ids": "sec-get-dataview.prototype.buffer",
    "rawBody": "{\n  0:let O = this\n  1:(0) app __x0__ = (RequireInternalSlot O \"DataView\")\n  1:[? __x0__]\n  2:assert (! (= O[\"ViewedArrayBuffer\"] absent))\n  3:let buffer = O[\"ViewedArrayBuffer\"]\n  4:return buffer\n}"
  }, {
    "code": ["          1. Let _O_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_O_, [[DataView]]).", "          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.", "          1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].", "          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.", "          1. Let _size_ be _O_.[[ByteLength]].", "          1. Return 𝔽(_size_)."],
    "head": {
      "origParams": [],
      "ref": "getDataView[\"prototype\"][\"byteLength\"]"
    },
    "ids": "sec-get-dataview.prototype.bytelength",
    "rawBody": "{\n  0:let O = this\n  1:(0) app __x0__ = (RequireInternalSlot O \"DataView\")\n  1:[? __x0__]\n  2:assert (! (= O[\"ViewedArrayBuffer\"] absent))\n  3:let buffer = O[\"ViewedArrayBuffer\"]\n  4:(1) app __x1__ = (IsDetachedBuffer buffer)\n  4:if (= __x1__ true) (0) throw TypeError else 0:{}\n  5:let size = O[\"ByteLength\"]\n  6:return size\n}"
  }, {
    "code": ["          1. Let _O_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_O_, [[DataView]]).", "          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.", "          1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].", "          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.", "          1. Let _offset_ be _O_.[[ByteOffset]].", "          1. Return 𝔽(_offset_)."],
    "head": {
      "origParams": [],
      "ref": "getDataView[\"prototype\"][\"byteOffset\"]"
    },
    "ids": "sec-get-dataview.prototype.byteoffset",
    "rawBody": "{\n  0:let O = this\n  1:(0) app __x0__ = (RequireInternalSlot O \"DataView\")\n  1:[? __x0__]\n  2:assert (! (= O[\"ViewedArrayBuffer\"] absent))\n  3:let buffer = O[\"ViewedArrayBuffer\"]\n  4:(1) app __x1__ = (IsDetachedBuffer buffer)\n  4:if (= __x1__ true) (0) throw TypeError else 0:{}\n  5:let offset = O[\"ByteOffset\"]\n  6:return offset\n}"
  }, {
    "code": ["          1. If _waitable_ is not present, set _waitable_ to *false*.", "          1. Let _buffer_ be ? ValidateTypedArray(_typedArray_).", "          1. Let _typeName_ be _typedArray_.[[TypedArrayName]].", "          1. Let _type_ be the Element Type value in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _typeName_.", "          1. If _waitable_ is *true*, then", "            1. If _typeName_ is not *\"Int32Array\"* or *\"BigInt64Array\"*, throw a *TypeError* exception.", "          1. Else,", "            1. If ! IsUnclampedIntegerElementType(_type_) is *false* and ! IsBigIntElementType(_type_) is *false*, throw a *TypeError* exception.", "          1. Return _buffer_."],
    "head": {
      "name": "ValidateIntegerTypedArray",
      "params": [{
        "kind": "Normal",
        "name": "typedArray"
      }, {
        "kind": "Optional",
        "name": "waitable"
      }]
    },
    "ids": "sec-validateintegertypedarray",
    "rawBody": "{\n  0:if (= waitable absent) waitable = false else 0:{}\n  1:(0) app __x0__ = (ValidateTypedArray typedArray)\n  1:let buffer = [? __x0__]\n  2:let typeName = typedArray[\"TypedArrayName\"]\n  3:(0) ??? \"Let id:{type} be the Element Type value in link:{table-the-typedarray-constructors} for id:{typeName} .\"\n  6:if (= waitable true) if (! (|| (= typeName \"Int32Array\") (= typeName \"BigInt64Array\"))) (1) throw TypeError else 0:{} else {\n    7:let __x1__ = true\n    7:(1) app __x2__ = (IsUnclampedIntegerElementType type)\n    7:__x1__ = (= [! __x2__] false)\n    7:if __x1__ {\n      (2) app __x3__ = (IsBigIntElementType type)\n      __x1__ = (= [! __x3__] false)\n    } else 0:{}\n    7:if __x1__ (2) throw TypeError else 0:{}\n  }\n  8:return buffer\n}"
  }, {
    "code": ["          1. Assert: _typedArray_ is an Object that has a [[ViewedArrayBuffer]] internal slot.", "          1. Let _length_ be _typedArray_.[[ArrayLength]].", "          1. Let _accessIndex_ be ? ToIndex(_requestIndex_).", "          1. Assert: _accessIndex_ ≥ 0.", "          1. If _accessIndex_ ≥ _length_, throw a *RangeError* exception.", "          1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].", "          1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _arrayTypeName_.", "          1. Let _offset_ be _typedArray_.[[ByteOffset]].", "          1. Return (_accessIndex_ × _elementSize_) + _offset_."],
    "head": {
      "name": "ValidateAtomicAccess",
      "params": [{
        "kind": "Normal",
        "name": "typedArray"
      }, {
        "kind": "Normal",
        "name": "requestIndex"
      }]
    },
    "ids": "sec-validateatomicaccess",
    "rawBody": "{\n  1:let length = typedArray[\"ArrayLength\"]\n  2:(0) app __x0__ = (ToIndex requestIndex)\n  2:let accessIndex = [? __x0__]\n  3:assert (! (< accessIndex 0i))\n  4:if (! (< accessIndex length)) (0) throw RangeError else 0:{}\n  5:let arrayTypeName = typedArray[\"TypedArrayName\"]\n  6:(1) ??? \"Let id:{elementSize} be the Element Size value specified in link:{table-the-typedarray-constructors} for id:{arrayTypeName} .\"\n  7:let offset = typedArray[\"ByteOffset\"]\n  8:return (+ (* accessIndex elementSize) offset)\n}"
  }, {
    "code": ["          1. Assert: _block_ is a Shared Data Block.", "          1. Assert: _i_ and _i_ + 3 are valid byte offsets within the memory of _block_.", "          1. Assert: _i_ is divisible by 4.", "          1. Return the WaiterList that is referenced by the pair (_block_, _i_)."],
    "head": {
      "name": "GetWaiterList",
      "params": [{
        "kind": "Normal",
        "name": "block"
      }, {
        "kind": "Normal",
        "name": "i"
      }]
    },
    "ids": "sec-getwaiterlist",
    "rawBody": "{\n  0:assert (0) (is-instance-of block SharedDataBlock)\n  3:(1) ??? \"Return the WaiterList that is referenced by the pair ( id:{block} , id:{i} ) .\"\n}"
  }, {
    "code": ["          1. Assert: The calling agent is not in the critical section for any WaiterList.", "          1. Wait until no agent is in the critical section for _WL_, then enter the critical section for _WL_ (without allowing any other agent to enter).", "          1. If _WL_ has a Synchronize event, then", "            1. NOTE: A _WL_ whose critical section has been entered at least once has a Synchronize event set by LeaveCriticalSection.", "            1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.", "            1. Let _eventsRecord_ be the Agent Events Record in _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().", "            1. Let _entererEventList_ be _eventsRecord_.[[EventList]].", "            1. Let _enterEvent_ be a new Synchronize event.", "            1. Append _enterEvent_ to _entererEventList_.", "            1. Let _leaveEvent_ be the Synchronize event in _WL_.", "            1. Append (_leaveEvent_, _enterEvent_) to _eventsRecord_.[[AgentSynchronizesWith]]."],
    "head": {
      "name": "EnterCriticalSection",
      "params": [{
        "kind": "Normal",
        "name": "WL"
      }]
    },
    "ids": "sec-entercriticalsection",
    "rawBody": "{\n  1:(0) ??? \"Wait until no agent is in the critical section for id:{WL} , then enter the critical section for id:{WL} ( without allowing any other agent to enter ) .\"\n  2:(1) ??? \"If id:{WL} has a Synchronize event , then in:{} out:{}\"\n}"
  }, {
    "code": ["          1. Assert: The calling agent is in the critical section for _WL_.", "          1. Let _execution_ be the [[CandidateExecution]] field of the calling surrounding's Agent Record.", "          1. Let _eventsRecord_ be the Agent Events Record in _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().", "          1. Let _leaverEventList_ be _eventsRecord_.[[EventList]].", "          1. Let _leaveEvent_ be a new Synchronize event.", "          1. Append _leaveEvent_ to _leaverEventList_.", "          1. Set the Synchronize event in _WL_ to _leaveEvent_.", "          1. Leave the critical section for _WL_."],
    "head": {
      "name": "LeaveCriticalSection",
      "params": [{
        "kind": "Normal",
        "name": "WL"
      }]
    },
    "ids": "sec-leavecriticalsection",
    "rawBody": "{\n  1:(0) ??? \"Let id:{execution} be the [ [ CandidateExecution ] ] field of the calling surrounding ' s Agent Record .\"\n  2:(1) ??? \"Let id:{eventsRecord} be the Agent Events Record in id:{execution} . [ [ EventsRecords ] ] whose [ [ AgentSignifier ] ] is AgentSignifier ( ) .\"\n  3:let leaverEventList = eventsRecord[\"EventList\"]\n  4:(2) ??? \"Let id:{leaveEvent} be a new Synchronize event .\"\n  5:append leaveEvent -> leaverEventList\n  6:(3) ??? \"Set the Synchronize event in id:{WL} to id:{leaveEvent} .\"\n  7:(4) ??? \"Leave the critical section for id:{WL} .\"\n}"
  }, {
    "code": ["          1. Assert: The calling agent is in the critical section for _WL_.", "          1. Assert: _W_ is not on the list of waiters in any WaiterList.", "          1. Add _W_ to the end of the list of waiters in _WL_."],
    "head": {
      "name": "AddWaiter",
      "params": [{
        "kind": "Normal",
        "name": "WL"
      }, {
        "kind": "Normal",
        "name": "W"
      }]
    },
    "ids": "sec-addwaiter",
    "rawBody": "append W -> WL"
  }, {
    "code": ["          1. Assert: The calling agent is in the critical section for _WL_.", "          1. Assert: _W_ is on the list of waiters in _WL_.", "          1. Remove _W_ from the list of waiters in _WL_."],
    "head": {
      "name": "RemoveWaiter",
      "params": [{
        "kind": "Normal",
        "name": "WL"
      }, {
        "kind": "Normal",
        "name": "W"
      }]
    },
    "ids": "sec-removewaiter",
    "rawBody": "{\n  2:let __x0__ = 0i\n  2:while (< __x0__ WL[\"length\"]) if (= WL[__x0__] W) (pop WL __x0__) else __x0__ = (+ __x0__ 1i)\n}"
  }, {
    "code": ["          1. Assert: The calling agent is in the critical section for _WL_.", "          1. Let _L_ be a new empty List.", "          1. Let _S_ be a reference to the list of waiters in _WL_.", "          1. Repeat, while _c_ > 0 and _S_ is not an empty List,", "            1. Let _W_ be the first waiter in _S_.", "            1. Add _W_ to the end of _L_.", "            1. Remove _W_ from _S_.", "            1. If _c_ is finite, set _c_ to _c_ - 1.", "          1. Return _L_."],
    "head": {
      "name": "RemoveWaiters",
      "params": [{
        "kind": "Normal",
        "name": "WL"
      }, {
        "kind": "Normal",
        "name": "c"
      }]
    },
    "ids": "sec-removewaiters",
    "rawBody": "{\n  1:let L = (0) (new [])\n  2:(1) ??? \"Let id:{S} be a reference to the list of waiters in id:{WL} .\"\n  3:while (&& (< 0i c) (< 0i S[\"length\"])) {\n    4:let W = S[0i]\n    5:append W -> L\n    6:let __x0__ = 0i\n    6:while (< __x0__ S[\"length\"]) if (= S[__x0__] W) (pop S __x0__) else __x0__ = (+ __x0__ 1i)\n    7:if (! (|| (= c Infinity) (= c -Infinity))) c = (- c 1i) else 0:{}\n  }\n  8:return L\n}"
  }, {
    "code": ["          1. Assert: The calling agent is in the critical section for _WL_.", "          1. Assert: _W_ is equivalent to AgentSignifier().", "          1. Assert: _W_ is on the list of waiters in _WL_.", "          1. Assert: AgentCanSuspend() is *true*.", "          1. Perform LeaveCriticalSection(_WL_) and suspend _W_ for up to _timeout_ milliseconds, performing the combined operation in such a way that a notification that arrives after the critical section is exited but before the suspension takes effect is not lost. _W_ can notify either because the timeout expired or because it was notified explicitly by another agent calling NotifyWaiter(_WL_, _W_), and not for any other reasons at all.", "          1. Perform EnterCriticalSection(_WL_).", "          1. If _W_ was notified explicitly by another agent calling NotifyWaiter(_WL_, _W_), return *true*.", "          1. Return *false*."],
    "head": {
      "name": "SuspendAgent",
      "params": [{
        "kind": "Normal",
        "name": "WL"
      }, {
        "kind": "Normal",
        "name": "W"
      }, {
        "kind": "Normal",
        "name": "timeout"
      }]
    },
    "ids": "sec-suspendagent",
    "rawBody": "{\n  3:(0) app __x0__ = (AgentCanSuspend)\n  3:assert (= __x0__ true)\n  4:(0) ??? \"Perform LeaveCriticalSection ( id:{WL} ) and suspend id:{W} for up to id:{timeout} milliseconds , performing the combined operation in such a way that a notification that arrives after the critical section is exited but before the suspension takes effect is not lost . id:{W} can notify either because the timeout expired or because it was notified explicitly by another agent calling NotifyWaiter ( id:{WL} , id:{W} ) , and not for any other reasons at all .\"\n  5:(1) app __x1__ = (EnterCriticalSection WL)\n  5:__x1__\n  6:(1) ??? \"If id:{W} was notified explicitly by another agent calling NotifyWaiter ( id:{WL} , id:{W} ) , return value:{true} .\"\n  7:return false\n}"
  }, {
    "code": ["          1. Assert: The calling agent is in the critical section for _WL_.", "          1. Notify the agent _W_."],
    "head": {
      "name": "NotifyWaiter",
      "params": [{
        "kind": "Normal",
        "name": "WL"
      }, {
        "kind": "Normal",
        "name": "W"
      }]
    },
    "ids": "sec-notifywaiter",
    "rawBody": "(0) ??? \"Notify the agent id:{W} .\""
  }, {
    "code": ["          1. Let _buffer_ be ? ValidateIntegerTypedArray(_typedArray_).", "          1. Let _indexedPosition_ be ? ValidateAtomicAccess(_typedArray_, _index_).", "          1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].", "          1. If _typedArray_.[[ContentType]] is ~BigInt~, let _v_ be ? ToBigInt(_value_).", "          1. Otherwise, let _v_ be 𝔽(? ToIntegerOrInfinity(_value_)).", "          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.", "          1. NOTE: The above check is not redundant with the check in ValidateIntegerTypedArray because the call to ToBigInt or ToIntegerOrInfinity on the preceding lines can have arbitrary side effects, which could cause the buffer to become detached.", "          1. Let _elementType_ be the Element Type value in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _arrayTypeName_.", "          1. Return GetModifySetValueInBuffer(_buffer_, _indexedPosition_, _elementType_, _v_, _op_)."],
    "head": {
      "name": "AtomicReadModifyWrite",
      "params": [{
        "kind": "Normal",
        "name": "typedArray"
      }, {
        "kind": "Normal",
        "name": "index"
      }, {
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "op"
      }]
    },
    "ids": "sec-atomicreadmodifywrite",
    "rawBody": "{\n  0:(0) app __x0__ = (ValidateIntegerTypedArray typedArray)\n  0:let buffer = [? __x0__]\n  1:(1) app __x1__ = (ValidateAtomicAccess typedArray index)\n  1:let indexedPosition = [? __x1__]\n  2:let arrayTypeName = typedArray[\"TypedArrayName\"]\n  4:if (= typedArray[\"ContentType\"] CONST_BigInt) {\n    (2) app __x2__ = (ToBigInt value)\n    let v = [? __x2__]\n  } else {\n    (3) app __x3__ = (ToIntegerOrInfinity value)\n    let v = [? __x3__]\n  }\n  5:(4) app __x4__ = (IsDetachedBuffer buffer)\n  5:if (= __x4__ true) (0) throw TypeError else 6:{}\n  7:let elementType = CONST_Int8\n  8:(5) app __x5__ = (GetModifySetValueInBuffer buffer indexedPosition elementType v op)\n  8:return __x5__\n}"
  }, {
    "code": ["          1. Assert: _op_ is `&`, `^`, or `|`.", "          1. Assert: _xBytes_ and _yBytes_ have the same number of elements.", "          1. Let _result_ be a new empty List.", "          1. Let _i_ be 0.", "          1. For each element _xByte_ of _xBytes_, do", "            1. Let _yByte_ be _yBytes_[_i_].", "            1. If _op_ is `&`, let _resultByte_ be the result of applying the bitwise AND operation to _xByte_ and _yByte_.", "            1. Else if _op_ is `^`, let _resultByte_ be the result of applying the bitwise exclusive OR (XOR) operation to _xByte_ and _yByte_.", "            1. Else, _op_ is `|`. Let _resultByte_ be the result of applying the bitwise inclusive OR operation to _xByte_ and _yByte_.", "            1. Set _i_ to _i_ + 1.", "            1. Append _resultByte_ to the end of _result_.", "          1. Return _result_."],
    "head": {
      "name": "ByteListBitwiseOp",
      "params": [{
        "kind": "Normal",
        "name": "op"
      }, {
        "kind": "Normal",
        "name": "xBytes"
      }, {
        "kind": "Normal",
        "name": "yBytes"
      }]
    },
    "ids": "sec-bytelistbitwiseop",
    "rawBody": "{\n  0:assert (|| (|| (= op \"&\") (= op \"^\")) (= op \"|\"))\n  2:let result = (0) (new [])\n  3:let i = 0i\n  4:let __x0__ = xBytes\n  4:let __x1__ = 0i\n  4:while (< __x1__ __x0__[\"length\"]) {\n    let xByte = __x0__[__x1__]\n    5:let yByte = yBytes[i]\n    7:if (= op \"&\") let resultByte = (& xByte yByte) else if (= op \"^\") let resultByte = (^ xByte yByte) else 1:{}\n    8:(1) ??? \"Else , id:{op} is code:{|} . Let id:{resultByte} be the result of applying the bitwise inclusive OR operation to id:{xByte} and id:{yByte} .\"\n    9:i = (+ i 1i)\n    10:append resultByte -> result\n    __x1__ = (+ __x1__ 1i)\n  }\n  11:return result\n}"
  }, {
    "code": ["          1. If _xBytes_ and _yBytes_ do not have the same number of elements, return *false*.", "          1. Let _i_ be 0.", "          1. For each element _xByte_ of _xBytes_, do", "            1. Let _yByte_ be _yBytes_[_i_].", "            1. If _xByte_ ≠ _yByte_, return *false*.", "            1. Set _i_ to _i_ + 1.", "          1. Return *true*."],
    "head": {
      "name": "ByteListEqual",
      "params": [{
        "kind": "Normal",
        "name": "xBytes"
      }, {
        "kind": "Normal",
        "name": "yBytes"
      }]
    },
    "ids": "sec-bytelistequal",
    "rawBody": "{\n  0:(0) ??? \"If id:{xBytes} and id:{yBytes} do not have the same number of elements , return value:{false} .\"\n  1:let i = 0i\n  2:let __x0__ = xBytes\n  2:let __x1__ = 0i\n  2:while (< __x1__ __x0__[\"length\"]) {\n    let xByte = __x0__[__x1__]\n    3:let yByte = yBytes[i]\n    4:if (! (== xByte yByte)) return false else 1:{}\n    5:i = (+ i 1i)\n    __x1__ = (+ __x1__ 1i)\n  }\n  6:return true\n}"
  }, {
    "code": ["        1. Let _type_ be the Element Type value in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _typedArray_.[[TypedArrayName]].", "        1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.", "        1. Let _add_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures _type_ and _isLittleEndian_ and performs the following steps atomically when called:", "          1. Let _x_ be RawBytesToNumeric(_type_, _xBytes_, _isLittleEndian_).", "          1. Let _y_ be RawBytesToNumeric(_type_, _yBytes_, _isLittleEndian_).", "          1. Let _T_ be Type(_x_).", "          1. Let _sum_ be _T_::add(_x_, _y_).", "          1. Let _sumBytes_ be NumericToRawBytes(_type_, _sum_, _isLittleEndian_).", "          1. Assert: _sumBytes_, _xBytes_, and _yBytes_ have the same number of elements.", "          1. Return _sumBytes_.", "        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _add_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "typedArray"
      }, {
        "kind": "Normal",
        "name": "index"
      }, {
        "kind": "Normal",
        "name": "value"
      }],
      "ref": "Atomics[\"add\"]"
    },
    "ids": "sec-atomics.add",
    "rawBody": "{\n  0:(0) ??? \"Let id:{type} be the Element Type value in link:{table-the-typedarray-constructors} for id:{typedArray} . [ [ TypedArrayName ] ] .\"\n  1:let isLittleEndian = AGENT[\"LittleEndian\"]\n  2:(1) ??? \"Let id:{add} be a new read - modify - write modification function with parameters ( id:{xBytes} , id:{yBytes} ) that captures id:{type} and id:{isLittleEndian} and performs the following steps atomically when called : in:{} out:{}\"\n  10:(0) app __x0__ = (AtomicReadModifyWrite typedArray index value add)\n  10:return [? __x0__]\n}"
  }, {
    "code": ["        1. Let _and_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures nothing and performs the following steps atomically when called:", "          1. Return ByteListBitwiseOp(`&`, _xBytes_, _yBytes_).", "        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _and_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "typedArray"
      }, {
        "kind": "Normal",
        "name": "index"
      }, {
        "kind": "Normal",
        "name": "value"
      }],
      "ref": "Atomics[\"and\"]"
    },
    "ids": "sec-atomics.and",
    "rawBody": "{\n  0:(0) ??? \"Let id:{and} be a new read - modify - write modification function with parameters ( id:{xBytes} , id:{yBytes} ) that captures nothing and performs the following steps atomically when called : in:{} out:{}\"\n  2:(0) app __x0__ = (AtomicReadModifyWrite typedArray index value and)\n  2:return [? __x0__]\n}"
  }, {
    "code": ["        1. Let _buffer_ be ? ValidateIntegerTypedArray(_typedArray_).", "        1. Let _block_ be _buffer_.[[ArrayBufferData]].", "        1. Let _indexedPosition_ be ? ValidateAtomicAccess(_typedArray_, _index_).", "        1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].", "        1. If _typedArray_.[[ContentType]] is ~BigInt~, then", "          1. Let _expected_ be ? ToBigInt(_expectedValue_).", "          1. Let _replacement_ be ? ToBigInt(_replacementValue_).", "        1. Else,", "          1. Let _expected_ be 𝔽(? ToIntegerOrInfinity(_expectedValue_)).", "          1. Let _replacement_ be 𝔽(? ToIntegerOrInfinity(_replacementValue_)).", "        1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.", "        1. NOTE: The above check is not redundant with the check in ValidateIntegerTypedArray because the call to ToBigInt or ToIntegerOrInfinity on the preceding lines can have arbitrary side effects, which could cause the buffer to become detached.", "        1. Let _elementType_ be the Element Type value in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _arrayTypeName_.", "        1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _elementType_.", "        1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.", "        1. Let _expectedBytes_ be NumericToRawBytes(_elementType_, _expected_, _isLittleEndian_).", "        1. Let _replacementBytes_ be NumericToRawBytes(_elementType_, _replacement_, _isLittleEndian_).", "        1. If IsSharedArrayBuffer(_buffer_) is *true*, then", "          1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.", "          1. Let _eventList_ be the [[EventList]] field of the element in _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().", "          1. Let _rawBytesRead_ be a List of length _elementSize_ whose elements are nondeterministically chosen byte values.", "          1. NOTE: In implementations, _rawBytesRead_ is the result of a load-link, of a load-exclusive, or of an operand of a read-modify-write instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.", "          1. NOTE: The comparison of the expected value and the read value is performed outside of the read-modify-write modification function to avoid needlessly strong synchronization when the expected value is not equal to the read value.", "          1. If ByteListEqual(_rawBytesRead_, _expectedBytes_) is *true*, then", "            1. Let _second_ be a new read-modify-write modification function with parameters (_oldBytes_, _newBytes_) that captures nothing and performs the following steps atomically when called:", "              1. Return _newBytes_.", "            1. Let _event_ be ReadModifyWriteSharedMemory { [[Order]]: ~SeqCst~, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _indexedPosition_, [[ElementSize]]: _elementSize_, [[Payload]]: _replacementBytes_, [[ModifyOp]]: _second_ }.", "          1. Else,", "            1. Let _event_ be ReadSharedMemory { [[Order]]: ~SeqCst~, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _indexedPosition_, [[ElementSize]]: _elementSize_ }.", "          1. Append _event_ to _eventList_.", "          1. Append Chosen Value Record { [[Event]]: _event_, [[ChosenValue]]: _rawBytesRead_ } to _execution_.[[ChosenValues]].", "        1. Else,", "          1. Let _rawBytesRead_ be a List of length _elementSize_ whose elements are the sequence of _elementSize_ bytes starting with _block_[_indexedPosition_].", "          1. If ByteListEqual(_rawBytesRead_, _expectedBytes_) is *true*, then", "            1. Store the individual bytes of _replacementBytes_ into _block_, starting at _block_[_indexedPosition_].", "        1. Return RawBytesToNumeric(_elementType_, _rawBytesRead_, _isLittleEndian_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "typedArray"
      }, {
        "kind": "Normal",
        "name": "index"
      }, {
        "kind": "Normal",
        "name": "expectedValue"
      }, {
        "kind": "Normal",
        "name": "replacementValue"
      }],
      "ref": "Atomics[\"compareExchange\"]"
    },
    "ids": "sec-atomics.compareexchange",
    "rawBody": "{\n  0:(0) app __x0__ = (ValidateIntegerTypedArray typedArray)\n  0:let buffer = [? __x0__]\n  1:let block = buffer[\"ArrayBufferData\"]\n  2:(1) app __x1__ = (ValidateAtomicAccess typedArray index)\n  2:let indexedPosition = [? __x1__]\n  3:let arrayTypeName = typedArray[\"TypedArrayName\"]\n  7:if (= typedArray[\"ContentType\"] CONST_BigInt) {\n    5:(2) app __x2__ = (ToBigInt expectedValue)\n    5:let expected = [? __x2__]\n    6:(3) app __x3__ = (ToBigInt replacementValue)\n    6:let replacement = [? __x3__]\n  } else {\n    8:(4) app __x4__ = (ToIntegerOrInfinity expectedValue)\n    8:let expected = [? __x4__]\n    9:(5) app __x5__ = (ToIntegerOrInfinity replacementValue)\n    9:let replacement = [? __x5__]\n  }\n  10:(6) app __x6__ = (IsDetachedBuffer buffer)\n  10:if (= __x6__ true) (0) throw TypeError else 22:{}\n  12:let elementType = CONST_Int8\n  13:(1) ??? \"Let id:{elementSize} be the Element Size value specified in link:{table-the-typedarray-constructors} for Element Type id:{elementType} .\"\n  14:let isLittleEndian = AGENT[\"LittleEndian\"]\n  15:(7) app __x7__ = (NumericToRawBytes elementType expected isLittleEndian)\n  15:let expectedBytes = __x7__\n  16:(8) app __x8__ = (NumericToRawBytes elementType replacement isLittleEndian)\n  16:let replacementBytes = __x8__\n  31:(9) app __x9__ = (IsSharedArrayBuffer buffer)\n  31:if (= __x9__ true) {\n    18:let execution = AGENT[\"CandidateExecution\"]\n    19:(2) ??? \"Let id:{eventList} be the [ [ EventList ] ] field of the element in id:{execution} . [ [ EventsRecords ] ] whose [ [ AgentSignifier ] ] is AgentSignifier ( ) .\"\n    20:(3) ??? \"Let id:{rawBytesRead} be a List of length id:{elementSize} whose elements are nondeterministically chosen byte values .\"\n    27:(10) app __x10__ = (ByteListEqual rawBytesRead expectedBytes)\n    27:if (= __x10__ true) {\n      24:(4) ??? \"Let id:{second} be a new read - modify - write modification function with parameters ( id:{oldBytes} , id:{newBytes} ) that captures nothing and performs the following steps atomically when called : in:{} out:{}\"\n      26:let event = (5) (new ReadModifyWriteSharedMemory(\"Order\" -> CONST_SeqCst, \"NoTear\" -> true, \"Block\" -> block, \"ByteIndex\" -> indexedPosition, \"ElementSize\" -> elementSize, \"Payload\" -> replacementBytes, \"ModifyOp\" -> second))\n    } else let event = (6) (new ReadSharedMemory(\"Order\" -> CONST_SeqCst, \"NoTear\" -> true, \"Block\" -> block, \"ByteIndex\" -> indexedPosition, \"ElementSize\" -> elementSize))\n    29:append event -> eventList\n    30:append (7) (new ChosenValueRecord(\"Event\" -> event, \"ChosenValue\" -> rawBytesRead)) -> execution[\"ChosenValues\"]\n  } else {\n    32:(8) ??? \"Let id:{rawBytesRead} be a List of length id:{elementSize} whose elements are the sequence of id:{elementSize} bytes starting with id:{block} [ id:{indexedPosition} ] .\"\n    33:(11) app __x11__ = (ByteListEqual rawBytesRead expectedBytes)\n    33:if (= __x11__ true) (9) ??? \"Store the individual bytes of id:{replacementBytes} into id:{block} , starting at id:{block} [ id:{indexedPosition} ] .\" else 22:{}\n  }\n  35:(12) app __x12__ = (RawBytesToNumeric elementType rawBytesRead isLittleEndian)\n  35:return __x12__\n}"
  }, {
    "code": ["        1. Let _second_ be a new read-modify-write modification function with parameters (_oldBytes_, _newBytes_) that captures nothing and performs the following steps atomically when called:", "          1. Return _newBytes_.", "        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _second_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "typedArray"
      }, {
        "kind": "Normal",
        "name": "index"
      }, {
        "kind": "Normal",
        "name": "value"
      }],
      "ref": "Atomics[\"exchange\"]"
    },
    "ids": "sec-atomics.exchange",
    "rawBody": "{\n  0:(0) ??? \"Let id:{second} be a new read - modify - write modification function with parameters ( id:{oldBytes} , id:{newBytes} ) that captures nothing and performs the following steps atomically when called : in:{} out:{}\"\n  2:(0) app __x0__ = (AtomicReadModifyWrite typedArray index value second)\n  2:return [? __x0__]\n}"
  }, {
    "code": ["        1. Let _n_ be ? ToIntegerOrInfinity(_size_).", "        1. Let _AR_ be the Agent Record of the surrounding agent.", "        1. If _n_ = 1, return _AR_.[[IsLockFree1]].", "        1. If _n_ = 2, return _AR_.[[IsLockFree2]].", "        1. If _n_ = 4, return *true*.", "        1. If _n_ = 8, return _AR_.[[IsLockFree8]].", "        1. Return *false*."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "size"
      }],
      "ref": "Atomics[\"isLockFree\"]"
    },
    "ids": "sec-atomics.islockfree",
    "rawBody": "{\n  0:(0) app __x0__ = (ToIntegerOrInfinity size)\n  0:let n = [? __x0__]\n  1:let AR = AGENT\n  2:if (== n 1i) return AR[\"IsLockFree1\"] else 22:{}\n  3:if (== n 2i) return AR[\"IsLockFree2\"] else 22:{}\n  4:if (== n 4i) return true else 22:{}\n  5:if (== n 8i) return AR[\"IsLockFree8\"] else 22:{}\n  6:return false\n}"
  }, {
    "code": ["        1. Let _buffer_ be ? ValidateIntegerTypedArray(_typedArray_).", "        1. Let _indexedPosition_ be ? ValidateAtomicAccess(_typedArray_, _index_).", "        1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.", "        1. NOTE: The above check is not redundant with the check in ValidateIntegerTypedArray because the call to ValidateAtomicAccess on the preceding line can have arbitrary side effects, which could cause the buffer to become detached.", "        1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].", "        1. Let _elementType_ be the Element Type value in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _arrayTypeName_.", "        1. Return GetValueFromBuffer(_buffer_, _indexedPosition_, _elementType_, *true*, ~SeqCst~)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "typedArray"
      }, {
        "kind": "Normal",
        "name": "index"
      }],
      "ref": "Atomics[\"load\"]"
    },
    "ids": "sec-atomics.load",
    "rawBody": "{\n  0:(0) app __x0__ = (ValidateIntegerTypedArray typedArray)\n  0:let buffer = [? __x0__]\n  1:(1) app __x1__ = (ValidateAtomicAccess typedArray index)\n  1:let indexedPosition = [? __x1__]\n  2:(2) app __x2__ = (IsDetachedBuffer buffer)\n  2:if (= __x2__ true) (0) throw TypeError else 3:{}\n  4:let arrayTypeName = typedArray[\"TypedArrayName\"]\n  5:let elementType = CONST_Int8\n  6:(3) app __x3__ = (GetValueFromBuffer buffer indexedPosition elementType true CONST_SeqCst)\n  6:return __x3__\n}"
  }, {
    "code": ["        1. Let _or_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures nothing and performs the following steps atomically when called:", "          1. Return ByteListBitwiseOp(`|`, _xBytes_, _yBytes_).", "        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _or_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "typedArray"
      }, {
        "kind": "Normal",
        "name": "index"
      }, {
        "kind": "Normal",
        "name": "value"
      }],
      "ref": "Atomics[\"or\"]"
    },
    "ids": "sec-atomics.or",
    "rawBody": "{\n  0:(0) ??? \"Let id:{or} be a new read - modify - write modification function with parameters ( id:{xBytes} , id:{yBytes} ) that captures nothing and performs the following steps atomically when called : in:{} out:{}\"\n  2:(0) app __x0__ = (AtomicReadModifyWrite typedArray index value or)\n  2:return [? __x0__]\n}"
  }, {
    "code": ["        1. Let _buffer_ be ? ValidateIntegerTypedArray(_typedArray_).", "        1. Let _indexedPosition_ be ? ValidateAtomicAccess(_typedArray_, _index_).", "        1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].", "        1. If _arrayTypeName_ is *\"BigUint64Array\"* or *\"BigInt64Array\"*, let _v_ be ? ToBigInt(_value_).", "        1. Otherwise, let _v_ be 𝔽(? ToIntegerOrInfinity(_value_)).", "        1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.", "        1. NOTE: The above check is not redundant with the check in ValidateIntegerTypedArray because the call to ToBigInt or ToIntegerOrInfinity on the preceding lines can have arbitrary side effects, which could cause the buffer to become detached.", "        1. Let _elementType_ be the Element Type value in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _arrayTypeName_.", "        1. Perform SetValueInBuffer(_buffer_, _indexedPosition_, _elementType_, _v_, *true*, ~SeqCst~).", "        1. Return _v_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "typedArray"
      }, {
        "kind": "Normal",
        "name": "index"
      }, {
        "kind": "Normal",
        "name": "value"
      }],
      "ref": "Atomics[\"store\"]"
    },
    "ids": "sec-atomics.store",
    "rawBody": "{\n  0:(0) app __x0__ = (ValidateIntegerTypedArray typedArray)\n  0:let buffer = [? __x0__]\n  1:(1) app __x1__ = (ValidateAtomicAccess typedArray index)\n  1:let indexedPosition = [? __x1__]\n  2:let arrayTypeName = typedArray[\"TypedArrayName\"]\n  4:if (|| (= arrayTypeName \"BigUint64Array\") (= arrayTypeName \"BigInt64Array\")) {\n    (2) app __x2__ = (ToBigInt value)\n    let v = [? __x2__]\n  } else {\n    (3) app __x3__ = (ToIntegerOrInfinity value)\n    let v = [? __x3__]\n  }\n  5:(4) app __x4__ = (IsDetachedBuffer buffer)\n  5:if (= __x4__ true) (0) throw TypeError else 6:{}\n  7:let elementType = CONST_Int8\n  8:(5) app __x5__ = (SetValueInBuffer buffer indexedPosition elementType v true CONST_SeqCst)\n  8:__x5__\n  9:return v\n}"
  }, {
    "code": ["        1. Let _type_ be the Element Type value in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _typedArray_.[[TypedArrayName]].", "        1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.", "        1. Let _subtract_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures _type_ and _isLittleEndian_ and performs the following steps atomically when called:", "          1. Let _x_ be RawBytesToNumeric(_type_, _xBytes_, _isLittleEndian_).", "          1. Let _y_ be RawBytesToNumeric(_type_, _yBytes_, _isLittleEndian_).", "          1. Let _T_ be Type(_x_).", "          1. Let _difference_ be _T_::subtract(_x_, _y_).", "          1. Let _differenceBytes_ be NumericToRawBytes(_type_, _difference_, _isLittleEndian_).", "          1. Assert: _differenceBytes_, _xBytes_, and _yBytes_ have the same number of elements.", "          1. Return _differenceBytes_.", "        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _subtract_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "typedArray"
      }, {
        "kind": "Normal",
        "name": "index"
      }, {
        "kind": "Normal",
        "name": "value"
      }],
      "ref": "Atomics[\"sub\"]"
    },
    "ids": "sec-atomics.sub",
    "rawBody": "{\n  0:(0) ??? \"Let id:{type} be the Element Type value in link:{table-the-typedarray-constructors} for id:{typedArray} . [ [ TypedArrayName ] ] .\"\n  1:let isLittleEndian = AGENT[\"LittleEndian\"]\n  2:(1) ??? \"Let id:{subtract} be a new read - modify - write modification function with parameters ( id:{xBytes} , id:{yBytes} ) that captures id:{type} and id:{isLittleEndian} and performs the following steps atomically when called : in:{} out:{}\"\n  10:(0) app __x0__ = (AtomicReadModifyWrite typedArray index value subtract)\n  10:return [? __x0__]\n}"
  }, {
    "code": ["        1. Let _buffer_ be ? ValidateIntegerTypedArray(_typedArray_, *true*).", "        1. If IsSharedArrayBuffer(_buffer_) is *false*, throw a *TypeError* exception.", "        1. Let _indexedPosition_ be ? ValidateAtomicAccess(_typedArray_, _index_).", "        1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].", "        1. If _arrayTypeName_ is *\"BigInt64Array\"*, let _v_ be ? ToBigInt64(_value_).", "        1. Otherwise, let _v_ be ? ToInt32(_value_).", "        1. Let _q_ be ? ToNumber(_timeout_).", "        1. If _q_ is *NaN* or *+∞*<sub>𝔽</sub>, let _t_ be +∞; else if _q_ is *-∞*<sub>𝔽</sub>, let _t_ be 0; else let _t_ be max(ℝ(_q_), 0).", "        1. Let _B_ be AgentCanSuspend().", "        1. If _B_ is *false*, throw a *TypeError* exception.", "        1. Let _block_ be _buffer_.[[ArrayBufferData]].", "        1. Let _WL_ be GetWaiterList(_block_, _indexedPosition_).", "        1. Perform EnterCriticalSection(_WL_).", "        1. Let _elementType_ be the Element Type value in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _arrayTypeName_.", "        1. Let _w_ be ! GetValueFromBuffer(_buffer_, _indexedPosition_, _elementType_, *true*, ~SeqCst~).", "        1. If _v_ ≠ _w_, then", "          1. Perform LeaveCriticalSection(_WL_).", "          1. Return the String *\"not-equal\"*.", "        1. Let _W_ be AgentSignifier().", "        1. Perform AddWaiter(_WL_, _W_).", "        1. Let _notified_ be SuspendAgent(_WL_, _W_, _t_).", "        1. If _notified_ is *true*, then", "          1. Assert: _W_ is not on the list of waiters in _WL_.", "        1. Else,", "          1. Perform RemoveWaiter(_WL_, _W_).", "        1. Perform LeaveCriticalSection(_WL_).", "        1. If _notified_ is *true*, return the String *\"ok\"*.", "        1. Return the String *\"timed-out\"*."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "typedArray"
      }, {
        "kind": "Normal",
        "name": "index"
      }, {
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "timeout"
      }],
      "ref": "Atomics[\"wait\"]"
    },
    "ids": "sec-atomics.wait",
    "rawBody": "{\n  0:(0) app __x0__ = (ValidateIntegerTypedArray typedArray true)\n  0:let buffer = [? __x0__]\n  1:(1) app __x1__ = (IsSharedArrayBuffer buffer)\n  1:if (= __x1__ false) (0) throw TypeError else 22:{}\n  2:(2) app __x2__ = (ValidateAtomicAccess typedArray index)\n  2:let indexedPosition = [? __x2__]\n  3:let arrayTypeName = typedArray[\"TypedArrayName\"]\n  5:if (= arrayTypeName \"BigInt64Array\") {\n    (3) app __x3__ = (ToBigInt64 value)\n    let v = [? __x3__]\n  } else {\n    (4) app __x4__ = (ToInt32 value)\n    let v = [? __x4__]\n  }\n  6:(5) app __x5__ = (ToNumber timeout)\n  6:let q = [? __x5__]\n  7:if (|| (= q NaN) (= q Infinity)) let t = Infinity else if (= q -Infinity) let t = 0i else {\n    (6) app __x6__ = (max q 0i)\n    let t = __x6__\n  }\n  8:(7) app __x7__ = (AgentCanSuspend)\n  8:let B = __x7__\n  9:if (= B false) (1) throw TypeError else 22:{}\n  10:let block = buffer[\"ArrayBufferData\"]\n  11:(8) app __x8__ = (GetWaiterList block indexedPosition)\n  11:let WL = __x8__\n  12:(9) app __x9__ = (EnterCriticalSection WL)\n  12:__x9__\n  13:let elementType = CONST_Int8\n  14:(10) app __x10__ = (GetValueFromBuffer buffer indexedPosition elementType true CONST_SeqCst)\n  14:let w = [! __x10__]\n  15:if (! (== v w)) {\n    16:(11) app __x11__ = (LeaveCriticalSection WL)\n    16:__x11__\n    17:return \"not-equal\"\n  } else 22:{}\n  18:(12) app __x12__ = (AgentSignifier)\n  18:let W = __x12__\n  19:(13) app __x13__ = (AddWaiter WL W)\n  19:__x13__\n  20:(14) app __x14__ = (SuspendAgent WL W t)\n  20:let notified = __x14__\n  23:if (= notified true) {} else {\n    24:(15) app __x15__ = (RemoveWaiter WL W)\n    24:__x15__\n  }\n  25:(16) app __x16__ = (LeaveCriticalSection WL)\n  25:__x16__\n  26:if (= notified true) return \"ok\" else 22:{}\n  27:return \"timed-out\"\n}"
  }, {
    "code": ["        1. Let _buffer_ be ? ValidateIntegerTypedArray(_typedArray_, *true*).", "        1. Let _indexedPosition_ be ? ValidateAtomicAccess(_typedArray_, _index_).", "        1. If _count_ is *undefined*, let _c_ be +∞.", "        1. Else,", "          1. Let _intCount_ be ? ToIntegerOrInfinity(_count_).", "          1. Let _c_ be max(_intCount_, 0).", "        1. Let _block_ be _buffer_.[[ArrayBufferData]].", "        1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].", "        1. If IsSharedArrayBuffer(_buffer_) is *false*, return *+0*<sub>𝔽</sub>.", "        1. Let _WL_ be GetWaiterList(_block_, _indexedPosition_).", "        1. Let _n_ be 0.", "        1. Perform EnterCriticalSection(_WL_).", "        1. Let _S_ be RemoveWaiters(_WL_, _c_).", "        1. Repeat, while _S_ is not an empty List,", "          1. Let _W_ be the first agent in _S_.", "          1. Remove _W_ from the front of _S_.", "          1. Perform NotifyWaiter(_WL_, _W_).", "          1. Set _n_ to _n_ + 1.", "        1. Perform LeaveCriticalSection(_WL_).", "        1. Return 𝔽(_n_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "typedArray"
      }, {
        "kind": "Normal",
        "name": "index"
      }, {
        "kind": "Normal",
        "name": "count"
      }],
      "ref": "Atomics[\"notify\"]"
    },
    "ids": "sec-atomics.notify",
    "rawBody": "{\n  0:(0) app __x0__ = (ValidateIntegerTypedArray typedArray true)\n  0:let buffer = [? __x0__]\n  1:(1) app __x1__ = (ValidateAtomicAccess typedArray index)\n  1:let indexedPosition = [? __x1__]\n  3:if (= count undefined) let c = Infinity else {\n    4:(2) app __x2__ = (ToIntegerOrInfinity count)\n    4:let intCount = [? __x2__]\n    5:(3) app __x3__ = (max intCount 0i)\n    5:let c = __x3__\n  }\n  6:let block = buffer[\"ArrayBufferData\"]\n  7:let arrayTypeName = typedArray[\"TypedArrayName\"]\n  8:(4) app __x4__ = (IsSharedArrayBuffer buffer)\n  8:if (= __x4__ false) return 0i else 22:{}\n  9:(5) app __x5__ = (GetWaiterList block indexedPosition)\n  9:let WL = __x5__\n  10:let n = 0i\n  11:(6) app __x6__ = (EnterCriticalSection WL)\n  11:__x6__\n  12:(7) app __x7__ = (RemoveWaiters WL c)\n  12:let S = __x7__\n  13:while (< 0i S[\"length\"]) {\n    14:let W = S[0i]\n    15:(pop S 0i)\n    16:(8) app __x8__ = (NotifyWaiter WL W)\n    16:__x8__\n    17:n = (+ n 1i)\n  }\n  18:(9) app __x9__ = (LeaveCriticalSection WL)\n  18:__x9__\n  19:return n\n}"
  }, {
    "code": ["        1. Let _xor_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures nothing and performs the following steps atomically when called:", "          1. Return ByteListBitwiseOp(`^`, _xBytes_, _yBytes_).", "        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _xor_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "typedArray"
      }, {
        "kind": "Normal",
        "name": "index"
      }, {
        "kind": "Normal",
        "name": "value"
      }],
      "ref": "Atomics[\"xor\"]"
    },
    "ids": "sec-atomics.xor",
    "rawBody": "{\n  0:(0) ??? \"Let id:{xor} be a new read - modify - write modification function with parameters ( id:{xBytes} , id:{yBytes} ) that captures nothing and performs the following steps atomically when called : in:{} out:{}\"\n  2:(0) app __x0__ = (AtomicReadModifyWrite typedArray index value xor)\n  2:return [? __x0__]\n}"
  }, {
    "code": ["        1. Let _jsonString_ be ? ToString(_text_).", "        1. [id=\"step-json-parse-validate\"] Parse ! StringToCodePoints(_jsonString_) as a JSON text as specified in ECMA-404. Throw a *SyntaxError* exception if it is not a valid JSON text as defined in that specification.", "        1. Let _scriptString_ be the string-concatenation of *\"(\"*, _jsonString_, and *\");\"*.", "        1. Let _script_ be ParseText(! StringToCodePoints(_scriptString_), |Script|).", "        1. Assert: _script_ is a Parse Node.", "        1. Let _completion_ be the result of evaluating _script_. The extended PropertyDefinitionEvaluation semantics defined in <emu-xref href=\"#sec-__proto__-property-names-in-object-initializers\"></emu-xref> must not be used during the evaluation.", "        1. Let _unfiltered_ be _completion_.[[Value]].", "        1. [id=\"step-json-parse-assert-type\"] Assert: _unfiltered_ is either a String, Number, Boolean, Null, or an Object that is defined by either an |ArrayLiteral| or an |ObjectLiteral|.", "        1. If IsCallable(_reviver_) is *true*, then", "          1. Let _root_ be ! OrdinaryObjectCreate(%Object.prototype%).", "          1. Let _rootName_ be the empty String.", "          1. Perform ! CreateDataPropertyOrThrow(_root_, _rootName_, _unfiltered_).", "          1. Return ? InternalizeJSONProperty(_root_, _rootName_, _reviver_).", "        1. Else,", "          1. Return _unfiltered_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "text"
      }, {
        "kind": "Optional",
        "name": "reviver"
      }],
      "ref": "JSON[\"parse\"]"
    },
    "ids": "sec-json.parse",
    "rawBody": "{\n  0:(0) app __x0__ = (ToString text)\n  0:let jsonString = [? __x0__]\n  1:(0) ??? \"Parse ! StringToCodePoints ( id:{jsonString} ) as a JSON text as specified in ECMA - 404 . Throw a value:{SyntaxError} exception if it is not a valid JSON text as defined in that specification .\"\n  2:let scriptString = (+ (+ \"(\" jsonString) \");\")\n  3:(1) app __x1__ = (StringToCodePoints scriptString)\n  3:let script = [! __x1__]\n  5:(1) ??? \"Let id:{completion} be the result of evaluating id:{script} . The extended PropertyDefinitionEvaluation semantics defined in link:{sec-__proto__-property-names-in-object-initializers} must not be used during the evaluation .\"\n  6:let unfiltered = completion[\"Value\"]\n  13:(2) app __x2__ = (IsCallable reviver)\n  13:if (= __x2__ true) {\n    9:(3) app __x3__ = (OrdinaryObjectCreate INTRINSIC_Object_prototype)\n    9:let root = [! __x3__]\n    10:let rootName = \"\"\n    11:(4) app __x4__ = (CreateDataPropertyOrThrow root rootName unfiltered)\n    11:[! __x4__]\n    12:(5) app __x5__ = (InternalizeJSONProperty root rootName reviver)\n    12:return [? __x5__]\n  } else return unfiltered\n}"
  }, {
    "code": ["          1. Let _val_ be ? Get(_holder_, _name_).", "          1. If Type(_val_) is Object, then", "            1. Let _isArray_ be ? IsArray(_val_).", "            1. If _isArray_ is *true*, then", "              1. Let _I_ be 0.", "              1. Let _len_ be ? LengthOfArrayLike(_val_).", "              1. Repeat, while _I_ < _len_,", "                1. Let _prop_ be ! ToString(𝔽(_I_)).", "                1. Let _newElement_ be ? InternalizeJSONProperty(_val_, _prop_, _reviver_).", "                1. If _newElement_ is *undefined*, then", "                  1. Perform ? _val_.[[Delete]](_prop_).", "                1. Else,", "                  1. Perform ? CreateDataProperty(_val_, _prop_, _newElement_).", "                1. Set _I_ to _I_ + 1.", "            1. Else,", "              1. Let _keys_ be ? EnumerableOwnPropertyNames(_val_, ~key~).", "              1. For each String _P_ of _keys_, do", "                1. Let _newElement_ be ? InternalizeJSONProperty(_val_, _P_, _reviver_).", "                1. If _newElement_ is *undefined*, then", "                  1. Perform ? _val_.[[Delete]](_P_).", "                1. Else,", "                  1. Perform ? CreateDataProperty(_val_, _P_, _newElement_).", "          1. Return ? Call(_reviver_, _holder_, « _name_, _val_ »)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "holder"
      }, {
        "kind": "Normal",
        "name": "name"
      }, {
        "kind": "Normal",
        "name": "reviver"
      }],
      "ref": "InternalizeJSONProperty"
    },
    "ids": "sec-internalizejsonproperty",
    "rawBody": "{\n  0:(0) app __x0__ = (Get holder name)\n  0:let val = [? __x0__]\n  1:if (= (typeof val) Object) {\n    2:(1) app __x1__ = (IsArray val)\n    2:let isArray = [? __x1__]\n    14:if (= isArray true) {\n      4:let I = 0i\n      5:(2) app __x2__ = (LengthOfArrayLike val)\n      5:let len = [? __x2__]\n      6:while (< I len) {\n        7:(3) app __x3__ = (ToString I)\n        7:let prop = [! __x3__]\n        8:(4) app __x4__ = (InternalizeJSONProperty val prop reviver)\n        8:let newElement = [? __x4__]\n        11:if (= newElement undefined) {\n          10:(5) app __x5__ = (val[\"Delete\"] val prop)\n          10:[? __x5__]\n        } else {\n          12:(6) app __x6__ = (CreateDataProperty val prop newElement)\n          12:[? __x6__]\n        }\n        13:I = (+ I 1i)\n      }\n    } else {\n      15:(7) app __x7__ = (EnumerableOwnPropertyNames val CONST_key)\n      15:let keys = [? __x7__]\n      16:let __x8__ = keys\n      16:let __x9__ = 0i\n      16:while (< __x9__ __x8__[\"length\"]) {\n        let P = __x8__[__x9__]\n        17:(8) app __x10__ = (InternalizeJSONProperty val P reviver)\n        17:let newElement = [? __x10__]\n        20:if (= newElement undefined) {\n          19:(9) app __x11__ = (val[\"Delete\"] val P)\n          19:[? __x11__]\n        } else {\n          21:(10) app __x12__ = (CreateDataProperty val P newElement)\n          21:[? __x12__]\n        }\n        __x9__ = (+ __x9__ 1i)\n      }\n    }\n  } else 7:{}\n  22:(11) app __x13__ = (Call reviver holder (0) (new [name, val]))\n  22:return [? __x13__]\n}"
  }, {
    "code": ["        1. Let _stack_ be a new empty List.", "        1. Let _indent_ be the empty String.", "        1. Let _PropertyList_ and _ReplacerFunction_ be *undefined*.", "        1. If Type(_replacer_) is Object, then", "          1. If IsCallable(_replacer_) is *true*, then", "            1. Set _ReplacerFunction_ to _replacer_.", "          1. Else,", "            1. Let _isArray_ be ? IsArray(_replacer_).", "            1. If _isArray_ is *true*, then", "              1. Set _PropertyList_ to a new empty List.", "              1. Let _len_ be ? LengthOfArrayLike(_replacer_).", "              1. Let _k_ be 0.", "              1. Repeat, while _k_ < _len_,", "                1. Let _prop_ be ! ToString(𝔽(_k_)).", "                1. Let _v_ be ? Get(_replacer_, _prop_).", "                1. Let _item_ be *undefined*.", "                1. If Type(_v_) is String, set _item_ to _v_.", "                1. Else if Type(_v_) is Number, set _item_ to ! ToString(_v_).", "                1. Else if Type(_v_) is Object, then", "                  1. If _v_ has a [[StringData]] or [[NumberData]] internal slot, set _item_ to ? ToString(_v_).", "                1. If _item_ is not *undefined* and _item_ is not currently an element of _PropertyList_, then", "                  1. Append _item_ to the end of _PropertyList_.", "                1. Set _k_ to _k_ + 1.", "        1. If Type(_space_) is Object, then", "          1. If _space_ has a [[NumberData]] internal slot, then", "            1. Set _space_ to ? ToNumber(_space_).", "          1. Else if _space_ has a [[StringData]] internal slot, then", "            1. Set _space_ to ? ToString(_space_).", "        1. If Type(_space_) is Number, then", "          1. Let _spaceMV_ be ! ToIntegerOrInfinity(_space_).", "          1. Set _spaceMV_ to min(10, _spaceMV_).", "          1. If _spaceMV_ < 1, let _gap_ be the empty String; otherwise let _gap_ be the String value containing _spaceMV_ occurrences of the code unit 0x0020 (SPACE).", "        1. Else if Type(_space_) is String, then", "          1. If the length of _space_ is 10 or less, let _gap_ be _space_; otherwise let _gap_ be the substring of _space_ from 0 to 10.", "        1. Else,", "          1. Let _gap_ be the empty String.", "        1. Let _wrapper_ be ! OrdinaryObjectCreate(%Object.prototype%).", "        1. Perform ! CreateDataPropertyOrThrow(_wrapper_, the empty String, _value_).", "        1. Let _state_ be the Record { [[ReplacerFunction]]: _ReplacerFunction_, [[Stack]]: _stack_, [[Indent]]: _indent_, [[Gap]]: _gap_, [[PropertyList]]: _PropertyList_ }.", "        1. Return ? SerializeJSONProperty(_state_, the empty String, _wrapper_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Optional",
        "name": "replacer"
      }, {
        "kind": "Optional",
        "name": "space"
      }],
      "ref": "JSON[\"stringify\"]"
    },
    "ids": "sec-json.stringify",
    "rawBody": "{\n  0:let stack = (0) (new [])\n  1:let indent = \"\"\n  2:let PropertyList = undefined\n  2:let ReplacerFunction = undefined\n  3:if (= (typeof replacer) Object) {\n    6:(0) app __x0__ = (IsCallable replacer)\n    6:if (= __x0__ true) ReplacerFunction = replacer else {\n      7:(1) app __x1__ = (IsArray replacer)\n      7:let isArray = [? __x1__]\n      8:if (= isArray true) {\n        9:PropertyList = (1) (new [])\n        10:(2) app __x2__ = (LengthOfArrayLike replacer)\n        10:let len = [? __x2__]\n        11:let k = 0i\n        12:while (< k len) {\n          13:(3) app __x3__ = (ToString k)\n          13:let prop = [! __x3__]\n          14:(4) app __x4__ = (Get replacer prop)\n          14:let v = [? __x4__]\n          15:let item = undefined\n          18:if (= (typeof v) String) item = v else if (= (typeof v) Number) {\n            (5) app __x5__ = (ToString v)\n            item = [! __x5__]\n          } else if (= (typeof v) Object) (2) ??? \"If id:{v} has a [ [ StringData ] ] or [ [ NumberData ] ] internal slot , set id:{item} to ? ToString ( id:{v} ) .\" else 7:{}\n          20:(3) ??? \"If id:{item} is not value:{undefined} and id:{item} is not currently an element of id:{PropertyList} , then in:{} out:{}\"\n          22:k = (+ k 1i)\n        }\n      } else 7:{}\n    }\n  } else 7:{}\n  23:if (= (typeof space) Object) if (! (= space[\"NumberData\"] absent)) {\n    25:(6) app __x6__ = (ToNumber space)\n    25:space = [? __x6__]\n  } else if (! (= space[\"StringData\"] absent)) {\n    27:(7) app __x7__ = (ToString space)\n    27:space = [? __x7__]\n  } else 7:{} else 7:{}\n  34:if (= (typeof space) Number) {\n    29:(8) app __x8__ = (ToIntegerOrInfinity space)\n    29:let spaceMV = [! __x8__]\n    30:(9) app __x9__ = (min 10i spaceMV)\n    30:spaceMV = __x9__\n    31:(4) ??? \"If id:{spaceMV} < 1 , let id:{gap} be the empty String ; otherwise let id:{gap} be the String value containing id:{spaceMV} occurrences of the code unit 0x0020 ( SPACE ) .\"\n  } else if (= (typeof space) String) (5) ??? \"If the length of id:{space} is 10 or less , let id:{gap} be id:{space} ; otherwise let id:{gap} be the substring of id:{space} from 0 to 10 .\" else let gap = \"\"\n  36:(10) app __x10__ = (OrdinaryObjectCreate INTRINSIC_Object_prototype)\n  36:let wrapper = [! __x10__]\n  37:(11) app __x11__ = (CreateDataPropertyOrThrow wrapper \"\" value)\n  37:[! __x11__]\n  38:let state = (6) (new Record(\"ReplacerFunction\" -> ReplacerFunction, \"Stack\" -> stack, \"Indent\" -> indent, \"Gap\" -> gap, \"PropertyList\" -> PropertyList))\n  39:(12) app __x12__ = (SerializeJSONProperty state \"\" wrapper)\n  39:return [? __x12__]\n}"
  }, {
    "code": ["          1. Let _value_ be ? Get(_holder_, _key_).", "          1. If Type(_value_) is Object or BigInt, then", "            1. Let _toJSON_ be ? GetV(_value_, *\"toJSON\"*).", "            1. If IsCallable(_toJSON_) is *true*, then", "              1. Set _value_ to ? Call(_toJSON_, _value_, « _key_ »).", "          1. If _state_.[[ReplacerFunction]] is not *undefined*, then", "            1. Set _value_ to ? Call(_state_.[[ReplacerFunction]], _holder_, « _key_, _value_ »).", "          1. If Type(_value_) is Object, then", "            1. If _value_ has a [[NumberData]] internal slot, then", "              1. Set _value_ to ? ToNumber(_value_).", "            1. Else if _value_ has a [[StringData]] internal slot, then", "              1. Set _value_ to ? ToString(_value_).", "            1. Else if _value_ has a [[BooleanData]] internal slot, then", "              1. Set _value_ to _value_.[[BooleanData]].", "            1. Else if _value_ has a [[BigIntData]] internal slot, then", "              1. Set _value_ to _value_.[[BigIntData]].", "          1. If _value_ is *null*, return *\"null\"*.", "          1. If _value_ is *true*, return *\"true\"*.", "          1. If _value_ is *false*, return *\"false\"*.", "          1. If Type(_value_) is String, return QuoteJSONString(_value_).", "          1. If Type(_value_) is Number, then", "            1. If _value_ is finite, return ! ToString(_value_).", "            1. Return *\"null\"*.", "          1. If Type(_value_) is BigInt, throw a *TypeError* exception.", "          1. If Type(_value_) is Object and IsCallable(_value_) is *false*, then", "            1. Let _isArray_ be ? IsArray(_value_).", "            1. If _isArray_ is *true*, return ? SerializeJSONArray(_state_, _value_).", "            1. Return ? SerializeJSONObject(_state_, _value_).", "          1. Return *undefined*."],
    "head": {
      "name": "SerializeJSONProperty",
      "params": [{
        "kind": "Normal",
        "name": "state"
      }, {
        "kind": "Normal",
        "name": "key"
      }, {
        "kind": "Normal",
        "name": "holder"
      }]
    },
    "ids": "sec-serializejsonproperty",
    "rawBody": "{\n  0:(0) app __x0__ = (Get holder key)\n  0:let value = [? __x0__]\n  1:if (|| (= (typeof value) Object) (= (typeof value) BigInt)) {\n    2:(1) app __x1__ = (GetV value \"toJSON\")\n    2:let toJSON = [? __x1__]\n    3:(2) app __x2__ = (IsCallable toJSON)\n    3:if (= __x2__ true) {\n      4:(3) app __x3__ = (Call toJSON value (0) (new [key]))\n      4:value = [? __x3__]\n    } else 7:{}\n  } else 7:{}\n  5:if (! (= state[\"ReplacerFunction\"] undefined)) {\n    6:(4) app __x4__ = (Call state[\"ReplacerFunction\"] holder (1) (new [key, value]))\n    6:value = [? __x4__]\n  } else 7:{}\n  7:if (= (typeof value) Object) if (! (= value[\"NumberData\"] absent)) {\n    9:(5) app __x5__ = (ToNumber value)\n    9:value = [? __x5__]\n  } else if (! (= value[\"StringData\"] absent)) {\n    11:(6) app __x6__ = (ToString value)\n    11:value = [? __x6__]\n  } else if (! (= value[\"BooleanData\"] absent)) value = value[\"BooleanData\"] else if (! (= value[\"BigIntData\"] absent)) value = value[\"BigIntData\"] else 7:{} else 7:{}\n  16:if (= value null) return \"null\" else 7:{}\n  17:if (= value true) return \"true\" else 7:{}\n  18:if (= value false) return \"false\" else 7:{}\n  19:if (= (typeof value) String) {\n    (7) app __x7__ = (QuoteJSONString value)\n    return __x7__\n  } else 7:{}\n  20:if (= (typeof value) Number) {\n    21:if (! (|| (= value Infinity) (= value -Infinity))) {\n      (8) app __x8__ = (ToString value)\n      return [! __x8__]\n    } else 7:{}\n    22:return \"null\"\n  } else 7:{}\n  23:if (= (typeof value) BigInt) (2) throw TypeError else 7:{}\n  24:let __x9__ = true\n  24:__x9__ = (= (typeof value) Object)\n  24:if __x9__ {\n    (9) app __x10__ = (IsCallable value)\n    __x9__ = (= __x10__ false)\n  } else 7:{}\n  24:if __x9__ {\n    25:(10) app __x11__ = (IsArray value)\n    25:let isArray = [? __x11__]\n    26:if (= isArray true) {\n      (11) app __x12__ = (SerializeJSONArray state value)\n      return [? __x12__]\n    } else 7:{}\n    27:(12) app __x13__ = (SerializeJSONObject state value)\n    27:return [? __x13__]\n  } else 7:{}\n  28:return undefined\n}"
  }, {
    "code": ["          1. Let _product_ be the String value consisting solely of the code unit 0x0022 (QUOTATION MARK).", "          1. For each code point _C_ of ! StringToCodePoints(_value_), do", "            1. If _C_ is listed in the “Code Point” column of <emu-xref href=\"#table-json-single-character-escapes\"></emu-xref>, then", "              1. Set _product_ to the string-concatenation of _product_ and the escape sequence for _C_ as specified in the “Escape Sequence” column of the corresponding row.", "            1. Else if _C_ has a numeric value less than 0x0020 (SPACE), or if _C_ has the same numeric value as a <emu-xref href=\"#leading-surrogate\"></emu-xref> or <emu-xref href=\"#trailing-surrogate\"></emu-xref>, then", "              1. Let _unit_ be the code unit whose numeric value is that of _C_.", "              1. Set _product_ to the string-concatenation of _product_ and UnicodeEscape(_unit_).", "            1. Else,", "              1. Set _product_ to the string-concatenation of _product_ and ! UTF16EncodeCodePoint(_C_).", "          1. Set _product_ to the string-concatenation of _product_ and the code unit 0x0022 (QUOTATION MARK).", "          1. Return _product_."],
    "head": {
      "name": "QuoteJSONString",
      "params": [{
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "sec-quotejsonstring",
    "rawBody": "{\n  0:let product = \"\\\"\"\n  1:(0) app __x0__ = (StringToCodePoints value)\n  1:let __x1__ = [! __x0__]\n  1:let __x2__ = 0i\n  1:while (< __x2__ __x1__[\"length\"]) {\n    let C = __x1__[__x2__]\n    2:(0) ??? \"If id:{C} is listed in the “ Code Point ” column of link:{table-json-single-character-escapes} , then in:{} out:{}\"\n    4:(1) ??? \"Else if id:{C} has a numeric value less than 0x0020 ( SPACE ) , or if id:{C} has the same numeric value as a link:{leading-surrogate} or link:{trailing-surrogate} , then in:{} out:{}\"\n    7:(2) ??? \"Else , in:{} out:{}\"\n    __x2__ = (+ __x2__ 1i)\n  }\n  9:product = (+ product \"\\\"\")\n  10:return product\n}"
  }, {
    "code": ["          1. Let _n_ be the numeric value of _C_.", "          1. Assert: _n_ ≤ 0xFFFF.", "          1. Return the string-concatenation of:", "            * the code unit 0x005C (REVERSE SOLIDUS)", "            * *\"u\"*", "            * the String representation of _n_, formatted as a four-digit lowercase hexadecimal number, padded to the left with zeroes if necessary"],
    "head": {
      "name": "UnicodeEscape",
      "params": [{
        "kind": "Normal",
        "name": "C"
      }]
    },
    "ids": "sec-unicodeescape",
    "rawBody": "{\n  0:(0) ??? \"Let id:{n} be the numeric value of id:{C} .\"\n  1:assert (! (< 65535i n))\n  2:return (+ (+ \"\\\\\" \"u\") (1) ??? \"StringOp\")\n}"
  }, {
    "code": ["          1. If _state_.[[Stack]] contains _value_, throw a *TypeError* exception because the structure is cyclical.", "          1. Append _value_ to _state_.[[Stack]].", "          1. Let _stepback_ be _state_.[[Indent]].", "          1. Set _state_.[[Indent]] to the string-concatenation of _state_.[[Indent]] and _state_.[[Gap]].", "          1. If _state_.[[PropertyList]] is not *undefined*, then", "            1. Let _K_ be _state_.[[PropertyList]].", "          1. Else,", "            1. Let _K_ be ? EnumerableOwnPropertyNames(_value_, ~key~).", "          1. Let _partial_ be a new empty List.", "          1. For each element _P_ of _K_, do", "            1. Let _strP_ be ? SerializeJSONProperty(_state_, _P_, _value_).", "            1. If _strP_ is not *undefined*, then", "              1. Let _member_ be QuoteJSONString(_P_).", "              1. Set _member_ to the string-concatenation of _member_ and *\":\"*.", "              1. If _state_.[[Gap]] is not the empty String, then", "                1. Set _member_ to the string-concatenation of _member_ and the code unit 0x0020 (SPACE).", "              1. Set _member_ to the string-concatenation of _member_ and _strP_.", "              1. Append _member_ to _partial_.", "          1. If _partial_ is empty, then", "            1. Let _final_ be *\"{}\"*.", "          1. Else,", "            1. If _state_.[[Gap]] is the empty String, then", "              1. Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with the code unit 0x002C (COMMA). A comma is not inserted either before the first String or after the last String.", "              1. Let _final_ be the string-concatenation of *\"{\"*, _properties_, and *\"}\"*.", "            1. Else,", "              1. Let _separator_ be the string-concatenation of the code unit 0x002C (COMMA), the code unit 0x000A (LINE FEED), and _state_.[[Indent]].", "              1. Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with _separator_. The _separator_ String is not inserted either before the first String or after the last String.", "              1. Let _final_ be the string-concatenation of *\"{\"*, the code unit 0x000A (LINE FEED), _state_.[[Indent]], _properties_, the code unit 0x000A (LINE FEED), _stepback_, and *\"}\"*.", "          1. Remove the last element of _state_.[[Stack]].", "          1. Set _state_.[[Indent]] to _stepback_.", "          1. Return _final_."],
    "head": {
      "name": "SerializeJSONObject",
      "params": [{
        "kind": "Normal",
        "name": "state"
      }, {
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "sec-serializejsonobject",
    "rawBody": "{\n  0:if (contains state[\"Stack\"] value) (0) throw TypeError else 7:{}\n  1:append value -> state[\"Stack\"]\n  2:let stepback = state[\"Indent\"]\n  3:state[\"Indent\"] = (+ state[\"Indent\"] state[\"Gap\"])\n  6:if (! (= state[\"PropertyList\"] undefined)) let K = state[\"PropertyList\"] else {\n    7:(0) app __x0__ = (EnumerableOwnPropertyNames value CONST_key)\n    7:let K = [? __x0__]\n  }\n  8:let partial = (1) (new [])\n  9:let __x1__ = K\n  9:let __x2__ = 0i\n  9:while (< __x2__ __x1__[\"length\"]) {\n    let P = __x1__[__x2__]\n    10:(1) app __x3__ = (SerializeJSONProperty state P value)\n    10:let strP = [? __x3__]\n    11:if (! (= strP undefined)) {\n      12:(2) app __x4__ = (QuoteJSONString P)\n      12:let member = __x4__\n      13:member = (+ member \":\")\n      14:if (! (= state[\"Gap\"] \"\")) member = (+ member \" \") else 7:{}\n      16:member = (+ member strP)\n      17:append member -> partial\n    } else 7:{}\n    __x2__ = (+ __x2__ 1i)\n  }\n  20:if (= partial[\"length\"] 0i) let final = \"{}\" else if (= state[\"Gap\"] \"\") {\n    22:(2) ??? \"Let id:{properties} be the String value formed by concatenating all the element Strings of id:{partial} with each adjacent pair of Strings separated with the code unit 0x002C ( COMMA ) . A comma is not inserted either before the first String or after the last String .\"\n    23:let final = (+ (+ \"{\" properties) \"}\")\n  } else {\n    25:let separator = (+ (+ \",\" \"\\n\") state[\"Indent\"])\n    26:(3) ??? \"Let id:{properties} be the String value formed by concatenating all the element Strings of id:{partial} with each adjacent pair of Strings separated with id:{separator} . The id:{separator} String is not inserted either before the first String or after the last String .\"\n    27:let final = (+ (+ (+ (+ (+ (+ \"{\" \"\\n\") state[\"Indent\"]) properties) \"\\n\") stepback) \"}\")\n  }\n  28:(4) ??? \"Remove the last element of id:{state} . [ [ Stack ] ] .\"\n  29:state[\"Indent\"] = stepback\n  30:return final\n}"
  }, {
    "code": ["          1. If _state_.[[Stack]] contains _value_, throw a *TypeError* exception because the structure is cyclical.", "          1. Append _value_ to _state_.[[Stack]].", "          1. Let _stepback_ be _state_.[[Indent]].", "          1. Set _state_.[[Indent]] to the string-concatenation of _state_.[[Indent]] and _state_.[[Gap]].", "          1. Let _partial_ be a new empty List.", "          1. Let _len_ be ? LengthOfArrayLike(_value_).", "          1. Let _index_ be 0.", "          1. Repeat, while _index_ < _len_,", "            1. Let _strP_ be ? SerializeJSONProperty(_state_, ! ToString(𝔽(_index_)), _value_).", "            1. If _strP_ is *undefined*, then", "              1. Append *\"null\"* to _partial_.", "            1. Else,", "              1. Append _strP_ to _partial_.", "            1. Set _index_ to _index_ + 1.", "          1. If _partial_ is empty, then", "            1. Let _final_ be *\"[]\"*.", "          1. Else,", "            1. If _state_.[[Gap]] is the empty String, then", "              1. Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with the code unit 0x002C (COMMA). A comma is not inserted either before the first String or after the last String.", "              1. Let _final_ be the string-concatenation of *\"[\"*, _properties_, and *\"]\"*.", "            1. Else,", "              1. Let _separator_ be the string-concatenation of the code unit 0x002C (COMMA), the code unit 0x000A (LINE FEED), and _state_.[[Indent]].", "              1. Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with _separator_. The _separator_ String is not inserted either before the first String or after the last String.", "              1. Let _final_ be the string-concatenation of *\"[\"*, the code unit 0x000A (LINE FEED), _state_.[[Indent]], _properties_, the code unit 0x000A (LINE FEED), _stepback_, and *\"]\"*.", "          1. Remove the last element of _state_.[[Stack]].", "          1. Set _state_.[[Indent]] to _stepback_.", "          1. Return _final_."],
    "head": {
      "name": "SerializeJSONArray",
      "params": [{
        "kind": "Normal",
        "name": "state"
      }, {
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "sec-serializejsonarray",
    "rawBody": "{\n  0:if (contains state[\"Stack\"] value) (0) throw TypeError else 7:{}\n  1:append value -> state[\"Stack\"]\n  2:let stepback = state[\"Indent\"]\n  3:state[\"Indent\"] = (+ state[\"Indent\"] state[\"Gap\"])\n  4:let partial = (1) (new [])\n  5:(0) app __x0__ = (LengthOfArrayLike value)\n  5:let len = [? __x0__]\n  6:let index = 0i\n  7:while (< index len) {\n    8:(1) app __x1__ = (ToString index)\n    8:(2) app __x2__ = (SerializeJSONProperty state [! __x1__] value)\n    8:let strP = [? __x2__]\n    11:if (= strP undefined) append \"null\" -> partial else append strP -> partial\n    13:index = (+ index 1i)\n  }\n  16:if (= partial[\"length\"] 0i) let final = \"[]\" else if (= state[\"Gap\"] \"\") {\n    18:(2) ??? \"Let id:{properties} be the String value formed by concatenating all the element Strings of id:{partial} with each adjacent pair of Strings separated with the code unit 0x002C ( COMMA ) . A comma is not inserted either before the first String or after the last String .\"\n    19:let final = (+ (+ \"[\" properties) \"]\")\n  } else {\n    21:let separator = (+ (+ \",\" \"\\n\") state[\"Indent\"])\n    22:(3) ??? \"Let id:{properties} be the String value formed by concatenating all the element Strings of id:{partial} with each adjacent pair of Strings separated with id:{separator} . The id:{separator} String is not inserted either before the first String or after the last String .\"\n    23:let final = (+ (+ (+ (+ (+ (+ \"[\" \"\\n\") state[\"Indent\"]) properties) \"\\n\") stepback) \"]\")\n  }\n  24:(4) ??? \"Remove the last element of id:{state} . [ [ Stack ] ] .\"\n  25:state[\"Indent\"] = stepback\n  26:return final\n}"
  }, {
    "code": ["          1. If NewTarget is *undefined*, throw a *TypeError* exception.", "          1. If Type(_target_) is not Object, throw a *TypeError* exception.", "          1. Let _weakRef_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%WeakRef.prototype%\"*, « [[WeakRefTarget]] »).", "          1. Perform ! AddToKeptObjects(_target_).", "          1. Set _weakRef_.[[WeakRefTarget]] to _target_.", "          1. Return _weakRef_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "target"
      }],
      "ref": "WeakRef"
    },
    "ids": "sec-weak-ref-target",
    "rawBody": "{\n  0:if (= NewTarget undefined) (0) throw TypeError else 7:{}\n  1:if (! (= (typeof target) Object)) (1) throw TypeError else 7:{}\n  2:(0) app __x0__ = (OrdinaryCreateFromConstructor NewTarget \"%WeakRef.prototype%\" (2) (new [\"WeakRefTarget\"]))\n  2:let weakRef = [? __x0__]\n  3:(1) app __x1__ = (AddToKeptObjects target)\n  3:[! __x1__]\n  4:weakRef[\"WeakRefTarget\"] = target\n  5:return weakRef\n}"
  }, {
    "code": ["          1. Let _weakRef_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_weakRef_, [[WeakRefTarget]]).", "          1. Return ! WeakRefDeref(_weakRef_)."],
    "head": {
      "origParams": [],
      "ref": "WeakRef[\"prototype\"][\"deref\"]"
    },
    "ids": "sec-weak-ref.prototype.deref",
    "rawBody": "{\n  0:let weakRef = this\n  1:(0) app __x0__ = (RequireInternalSlot weakRef \"WeakRefTarget\")\n  1:[? __x0__]\n  2:(1) app __x1__ = (WeakRefDeref weakRef)\n  2:return [! __x1__]\n}"
  }, {
    "code": ["          1. Let _target_ be _weakRef_.[[WeakRefTarget]].", "          1. If _target_ is not ~empty~, then", "            1. Perform ! AddToKeptObjects(_target_).", "            1. Return _target_.", "          1. Return *undefined*."],
    "head": {
      "name": "WeakRefDeref",
      "params": [{
        "kind": "Normal",
        "name": "weakRef"
      }]
    },
    "ids": "sec-weakrefderef",
    "rawBody": "{\n  0:let target = weakRef[\"WeakRefTarget\"]\n  1:if (! (= target CONST_empty)) {\n    2:(0) app __x0__ = (AddToKeptObjects target)\n    2:[! __x0__]\n    3:return target\n  } else 7:{}\n  4:return undefined\n}"
  }, {
    "code": ["          1. If NewTarget is *undefined*, throw a *TypeError* exception.", "          1. If IsCallable(_cleanupCallback_) is *false*, throw a *TypeError* exception.", "          1. Let _finalizationRegistry_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%FinalizationRegistry.prototype%\"*, « [[Realm]], [[CleanupCallback]], [[Cells]] »).", "          1. Let _fn_ be the active function object.", "          1. Set _finalizationRegistry_.[[Realm]] to _fn_.[[Realm]].", "          1. Set _finalizationRegistry_.[[CleanupCallback]] to _cleanupCallback_.", "          1. Set _finalizationRegistry_.[[Cells]] to a new empty List.", "          1. Return _finalizationRegistry_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "cleanupCallback"
      }],
      "ref": "FinalizationRegistry"
    },
    "ids": "sec-finalization-registry-cleanup-callback",
    "rawBody": "{\n  0:if (= NewTarget undefined) (0) throw TypeError else 7:{}\n  1:(0) app __x0__ = (IsCallable cleanupCallback)\n  1:if (= __x0__ false) (1) throw TypeError else 7:{}\n  2:(1) app __x1__ = (OrdinaryCreateFromConstructor NewTarget \"%FinalizationRegistry.prototype%\" (2) (new [\"Realm\", \"CleanupCallback\", \"Cells\"]))\n  2:let finalizationRegistry = [? __x1__]\n  3:let fn = CONTEXT[\"Function\"]\n  4:finalizationRegistry[\"Realm\"] = fn[\"Realm\"]\n  5:finalizationRegistry[\"CleanupCallback\"] = cleanupCallback\n  6:finalizationRegistry[\"Cells\"] = (3) (new [])\n  7:return finalizationRegistry\n}"
  }, {
    "code": ["          1. Let _finalizationRegistry_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_finalizationRegistry_, [[Cells]]).", "          1. If Type(_target_) is not Object, throw a *TypeError* exception.", "          1. If SameValue(_target_, _heldValue_) is *true*, throw a *TypeError* exception.", "          1. If Type(_unregisterToken_) is not Object, then", "            1. If _unregisterToken_ is not *undefined*, throw a *TypeError* exception.", "            1. Set _unregisterToken_ to ~empty~.", "          1. Let _cell_ be the Record { [[WeakRefTarget]]: _target_, [[HeldValue]]: _heldValue_, [[UnregisterToken]]: _unregisterToken_ }.", "          1. Append _cell_ to _finalizationRegistry_.[[Cells]].", "          1. Return *undefined*."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "target"
      }, {
        "kind": "Normal",
        "name": "heldValue"
      }, {
        "kind": "Optional",
        "name": "unregisterToken"
      }],
      "ref": "FinalizationRegistry[\"prototype\"][\"register\"]"
    },
    "ids": "sec-finalization-registry.prototype.register",
    "rawBody": "{\n  0:let finalizationRegistry = this\n  1:(0) app __x0__ = (RequireInternalSlot finalizationRegistry \"Cells\")\n  1:[? __x0__]\n  2:if (! (= (typeof target) Object)) (0) throw TypeError else 7:{}\n  3:(1) app __x1__ = (SameValue target heldValue)\n  3:if (= __x1__ true) (1) throw TypeError else 7:{}\n  4:if (! (= (typeof unregisterToken) Object)) {\n    5:if (! (= unregisterToken undefined)) (2) throw TypeError else 7:{}\n    6:unregisterToken = CONST_empty\n  } else 7:{}\n  7:let cell = (3) (new Record(\"WeakRefTarget\" -> target, \"HeldValue\" -> heldValue, \"UnregisterToken\" -> unregisterToken))\n  8:append cell -> finalizationRegistry[\"Cells\"]\n  9:return undefined\n}"
  }, {
    "code": ["          1. Let _finalizationRegistry_ be the *this* value.", "          1. Perform ? RequireInternalSlot(_finalizationRegistry_, [[Cells]]).", "          1. If Type(_unregisterToken_) is not Object, throw a *TypeError* exception.", "          1. Let _removed_ be *false*.", "          1. For each Record { [[WeakRefTarget]], [[HeldValue]], [[UnregisterToken]] } _cell_ of _finalizationRegistry_.[[Cells]], do", "            1. If _cell_.[[UnregisterToken]] is not ~empty~ and SameValue(_cell_.[[UnregisterToken]], _unregisterToken_) is *true*, then", "              1. Remove _cell_ from _finalizationRegistry_.[[Cells]].", "              1. Set _removed_ to *true*.", "          1. Return _removed_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "unregisterToken"
      }],
      "ref": "FinalizationRegistry[\"prototype\"][\"unregister\"]"
    },
    "ids": "sec-finalization-registry.prototype.unregister",
    "rawBody": "{\n  0:let finalizationRegistry = this\n  1:(0) app __x0__ = (RequireInternalSlot finalizationRegistry \"Cells\")\n  1:[? __x0__]\n  2:if (! (= (typeof unregisterToken) Object)) (0) throw TypeError else 7:{}\n  3:let removed = false\n  4:let __x1__ = finalizationRegistry[\"Cells\"]\n  4:let __x2__ = 0i\n  4:while (< __x2__ __x1__[\"length\"]) {\n    let cell = __x1__[__x2__]\n    5:let __x3__ = true\n    5:__x3__ = (! (= cell[\"UnregisterToken\"] CONST_empty))\n    5:if __x3__ {\n      (1) app __x4__ = (SameValue cell[\"UnregisterToken\"] unregisterToken)\n      __x3__ = (= __x4__ true)\n    } else 7:{}\n    5:if __x3__ {\n      6:(1) ??? \"Remove id:{cell} from id:{finalizationRegistry} . [ [ Cells ] ] .\"\n      7:removed = true\n    } else 7:{}\n    __x2__ = (+ __x2__ 1i)\n  }\n  8:return removed\n}"
  }, {
    "code": ["          1. Let _asyncIterator_ be ! OrdinaryObjectCreate(%AsyncFromSyncIteratorPrototype%, « [[SyncIteratorRecord]] »).", "          1. Set _asyncIterator_.[[SyncIteratorRecord]] to _syncIteratorRecord_.", "          1. Let _nextMethod_ be ! Get(_asyncIterator_, *\"next\"*).", "          1. Let _iteratorRecord_ be the Record { [[Iterator]]: _asyncIterator_, [[NextMethod]]: _nextMethod_, [[Done]]: *false* }.", "          1. Return _iteratorRecord_."],
    "head": {
      "name": "CreateAsyncFromSyncIterator",
      "params": [{
        "kind": "Normal",
        "name": "syncIteratorRecord"
      }]
    },
    "ids": "sec-createasyncfromsynciterator",
    "rawBody": "{\n  0:(0) app __x0__ = (OrdinaryObjectCreate INTRINSIC_AsyncFromSyncIteratorPrototype (0) (new [\"SyncIteratorRecord\"]))\n  0:let asyncIterator = [! __x0__]\n  1:asyncIterator[\"SyncIteratorRecord\"] = syncIteratorRecord\n  2:(1) app __x1__ = (Get asyncIterator \"next\")\n  2:let nextMethod = [! __x1__]\n  3:let iteratorRecord = (1) (new Record(\"Iterator\" -> asyncIterator, \"NextMethod\" -> nextMethod, \"Done\" -> false))\n  4:return iteratorRecord\n}"
  }, {
    "code": ["          1. Let _done_ be IteratorComplete(_result_).", "          1. IfAbruptRejectPromise(_done_, _promiseCapability_).", "          1. Let _value_ be IteratorValue(_result_).", "          1. IfAbruptRejectPromise(_value_, _promiseCapability_).", "          1. Let _valueWrapper_ be PromiseResolve(%Promise%, _value_).", "          1. IfAbruptRejectPromise(_valueWrapper_, _promiseCapability_).", "          1. Let _steps_ be the algorithm steps defined in <emu-xref href=\"#sec-async-from-sync-iterator-value-unwrap-functions\" title></emu-xref>.", "          1. Let _length_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#sec-async-from-sync-iterator-value-unwrap-functions\" title></emu-xref>.", "          1. Let _onFulfilled_ be ! CreateBuiltinFunction(_steps_, _length_, *\"\"*, « [[Done]] »).", "          1. Set _onFulfilled_.[[Done]] to _done_.", "          1. Perform ! PerformPromiseThen(_valueWrapper_, _onFulfilled_, *undefined*, _promiseCapability_).", "          1. Return _promiseCapability_.[[Promise]]."],
    "head": {
      "name": "AsyncFromSyncIteratorContinuation",
      "params": [{
        "kind": "Normal",
        "name": "result"
      }, {
        "kind": "Normal",
        "name": "promiseCapability"
      }]
    },
    "ids": "sec-asyncfromsynciteratorcontinuation",
    "rawBody": "{\n  0:(0) app __x0__ = (IteratorComplete result)\n  0:let done = __x0__\n  1:if (is-completion done) if (= done[\"Type\"] CONST_normal) done = done[\"Value\"] else {\n    (1) app __x1__ = (Call promiseCapability[\"Reject\"] undefined (0) (new [done[\"Value\"]]))\n    if (&& (is-completion __x1__) (! (= __x1__[\"Type\"] CONST_normal))) return __x1__ else 7:{}\n    return promiseCapability[\"Promise\"]\n  } else 7:{}\n  1:done\n  2:(2) app __x2__ = (IteratorValue result)\n  2:let value = __x2__\n  3:if (is-completion value) if (= value[\"Type\"] CONST_normal) value = value[\"Value\"] else {\n    (3) app __x3__ = (Call promiseCapability[\"Reject\"] undefined (1) (new [value[\"Value\"]]))\n    if (&& (is-completion __x3__) (! (= __x3__[\"Type\"] CONST_normal))) return __x3__ else 7:{}\n    return promiseCapability[\"Promise\"]\n  } else 7:{}\n  3:value\n  4:(4) app __x4__ = (PromiseResolve INTRINSIC_Promise value)\n  4:let valueWrapper = __x4__\n  5:if (is-completion valueWrapper) if (= valueWrapper[\"Type\"] CONST_normal) valueWrapper = valueWrapper[\"Value\"] else {\n    (5) app __x5__ = (Call promiseCapability[\"Reject\"] undefined (2) (new [valueWrapper[\"Value\"]]))\n    if (&& (is-completion __x5__) (! (= __x5__[\"Type\"] CONST_normal))) return __x5__ else 7:{}\n    return promiseCapability[\"Promise\"]\n  } else 7:{}\n  5:valueWrapper\n  6:(3) ??? \"Let id:{steps} be the algorithm steps defined in link:{sec-async-from-sync-iterator-value-unwrap-functions} .\"\n  7:(4) ??? \"Let id:{length} be the number of non - optional parameters of the function definition in link:{sec-async-from-sync-iterator-value-unwrap-functions} .\"\n  8:(6) app __x6__ = (CreateBuiltinFunction steps length \"\" (5) (new [\"Done\"]))\n  8:let onFulfilled = [! __x6__]\n  9:onFulfilled[\"Done\"] = done\n  10:(7) app __x7__ = (PerformPromiseThen valueWrapper onFulfilled undefined promiseCapability)\n  10:[! __x7__]\n  11:return promiseCapability[\"Promise\"]\n}"
  }, {
    "code": ["            1. IfAbruptRejectPromise(_value_, _capability_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "capability"
      }],
      "ref": "IfAbruptRejectPromise"
    },
    "ids": "sec-ifabruptrejectpromise",
    "rawBody": "{\n  0:if (is-completion value) if (= value[\"Type\"] CONST_normal) value = value[\"Value\"] else {\n    (0) app __x0__ = (Call capability[\"Reject\"] undefined (0) (new [value[\"Value\"]]))\n    if (&& (is-completion __x0__) (! (= __x0__[\"Type\"] CONST_normal))) return __x0__ else 7:{}\n    return capability[\"Promise\"]\n  } else 7:{}\n  0:value\n}"
  }, {
    "code": ["            1. If _value_ is an abrupt completion, then", "              1. Perform ? Call(_capability_.[[Reject]], *undefined*, « _value_.[[Value]] »).", "              1. Return _capability_.[[Promise]].", "            1. Else if _value_ is a Completion Record, set _value_ to _value_.[[Value]]."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "capability"
      }],
      "ref": "IfAbruptRejectPromise"
    },
    "ids": "sec-ifabruptrejectpromise",
    "rawBody": "{\n  3:(0) app __x0__ = (IsAbruptCompletion value)\n  3:if __x0__ {\n    1:(1) app __x1__ = (Call capability[\"Reject\"] undefined (0) (new [value[\"Value\"]]))\n    1:[? __x1__]\n    2:return capability[\"Promise\"]\n  } else if (is-completion value) value = value[\"Value\"] else 7:{}\n}"
  }, {
    "code": ["          1. Let _alreadyResolved_ be the Record { [[Value]]: *false* }.", "          1. Let _stepsResolve_ be the algorithm steps defined in <emu-xref href=\"#sec-promise-resolve-functions\" title></emu-xref>.", "          1. Let _lengthResolve_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#sec-promise-resolve-functions\" title></emu-xref>.", "          1. Let _resolve_ be ! CreateBuiltinFunction(_stepsResolve_, _lengthResolve_, *\"\"*, « [[Promise]], [[AlreadyResolved]] »).", "          1. Set _resolve_.[[Promise]] to _promise_.", "          1. Set _resolve_.[[AlreadyResolved]] to _alreadyResolved_.", "          1. Let _stepsReject_ be the algorithm steps defined in <emu-xref href=\"#sec-promise-reject-functions\" title></emu-xref>.", "          1. Let _lengthReject_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#sec-promise-reject-functions\" title></emu-xref>.", "          1. Let _reject_ be ! CreateBuiltinFunction(_stepsReject_, _lengthReject_, *\"\"*, « [[Promise]], [[AlreadyResolved]] »).", "          1. Set _reject_.[[Promise]] to _promise_.", "          1. Set _reject_.[[AlreadyResolved]] to _alreadyResolved_.", "          1. Return the Record { [[Resolve]]: _resolve_, [[Reject]]: _reject_ }."],
    "head": {
      "name": "CreateResolvingFunctions",
      "params": [{
        "kind": "Normal",
        "name": "promise"
      }]
    },
    "ids": "sec-createresolvingfunctions",
    "rawBody": "{\n  0:let alreadyResolved = (0) (new Record(\"Value\" -> false))\n  1:(1) ??? \"Let id:{stepsResolve} be the algorithm steps defined in link:{sec-promise-resolve-functions} .\"\n  2:(2) ??? \"Let id:{lengthResolve} be the number of non - optional parameters of the function definition in link:{sec-promise-resolve-functions} .\"\n  3:(0) app __x0__ = (CreateBuiltinFunction stepsResolve lengthResolve \"\" (3) (new [\"Promise\", \"AlreadyResolved\"]))\n  3:let resolve = [! __x0__]\n  4:resolve[\"Promise\"] = promise\n  5:resolve[\"AlreadyResolved\"] = alreadyResolved\n  6:(4) ??? \"Let id:{stepsReject} be the algorithm steps defined in link:{sec-promise-reject-functions} .\"\n  7:(5) ??? \"Let id:{lengthReject} be the number of non - optional parameters of the function definition in link:{sec-promise-reject-functions} .\"\n  8:(1) app __x1__ = (CreateBuiltinFunction stepsReject lengthReject \"\" (6) (new [\"Promise\", \"AlreadyResolved\"]))\n  8:let reject = [! __x1__]\n  9:reject[\"Promise\"] = promise\n  10:reject[\"AlreadyResolved\"] = alreadyResolved\n  11:return (7) (new Record(\"Resolve\" -> resolve, \"Reject\" -> reject))\n}"
  }, {
    "code": ["            1. Let _F_ be the active function object.", "            1. Assert: _F_ has a [[Promise]] internal slot whose value is an Object.", "            1. Let _promise_ be _F_.[[Promise]].", "            1. Let _alreadyResolved_ be _F_.[[AlreadyResolved]].", "            1. If _alreadyResolved_.[[Value]] is *true*, return *undefined*.", "            1. Set _alreadyResolved_.[[Value]] to *true*.", "            1. Return RejectPromise(_promise_, _reason_)."],
    "head": {
      "name": "PromiseRejectFunctions",
      "params": []
    },
    "ids": "sec-promise-reject-functions",
    "rawBody": "{\n  0:let F = CONTEXT[\"Function\"]\n  2:let promise = F[\"Promise\"]\n  3:let alreadyResolved = F[\"AlreadyResolved\"]\n  4:if (= alreadyResolved[\"Value\"] true) return undefined else 1:{}\n  5:alreadyResolved[\"Value\"] = true\n  6:(0) app __x0__ = (RejectPromise promise reason)\n  6:return __x0__\n}"
  }, {
    "code": ["            1. Let _F_ be the active function object.", "            1. Assert: _F_ has a [[Promise]] internal slot whose value is an Object.", "            1. Let _promise_ be _F_.[[Promise]].", "            1. Let _alreadyResolved_ be _F_.[[AlreadyResolved]].", "            1. If _alreadyResolved_.[[Value]] is *true*, return *undefined*.", "            1. Set _alreadyResolved_.[[Value]] to *true*.", "            1. If SameValue(_resolution_, _promise_) is *true*, then", "              1. Let _selfResolutionError_ be a newly created *TypeError* object.", "              1. Return RejectPromise(_promise_, _selfResolutionError_).", "            1. If Type(_resolution_) is not Object, then", "              1. Return FulfillPromise(_promise_, _resolution_).", "            1. Let _then_ be Get(_resolution_, *\"then\"*).", "            1. If _then_ is an abrupt completion, then", "              1. Return RejectPromise(_promise_, _then_.[[Value]]).", "            1. Let _thenAction_ be _then_.[[Value]].", "            1. If IsCallable(_thenAction_) is *false*, then", "              1. Return FulfillPromise(_promise_, _resolution_).", "            1. Let _thenJobCallback_ be HostMakeJobCallback(_thenAction_).", "            1. Let _job_ be NewPromiseResolveThenableJob(_promise_, _resolution_, _thenJobCallback_).", "            1. Perform HostEnqueuePromiseJob(_job_.[[Job]], _job_.[[Realm]]).", "            1. Return *undefined*."],
    "head": {
      "name": "PromiseResolveFunctions",
      "params": []
    },
    "ids": "sec-promise-resolve-functions",
    "rawBody": "{\n  0:let F = CONTEXT[\"Function\"]\n  2:let promise = F[\"Promise\"]\n  3:let alreadyResolved = F[\"AlreadyResolved\"]\n  4:if (= alreadyResolved[\"Value\"] true) return undefined else 1:{}\n  5:alreadyResolved[\"Value\"] = true\n  6:(0) app __x0__ = (SameValue resolution promise)\n  6:if (= __x0__ true) {\n    7:let selfResolutionError = (0) (new OrdinaryObject())\n    8:(1) app __x1__ = (RejectPromise promise selfResolutionError)\n    8:return __x1__\n  } else 1:{}\n  9:if (! (= (typeof resolution) Object)) {\n    10:(2) app __x2__ = (FulfillPromise promise resolution)\n    10:return __x2__\n  } else 1:{}\n  11:(3) app __x3__ = (Get resolution \"then\")\n  11:let then = __x3__\n  12:(4) app __x4__ = (IsAbruptCompletion then)\n  12:if __x4__ {\n    13:(5) app __x5__ = (RejectPromise promise then[\"Value\"])\n    13:return __x5__\n  } else 1:{}\n  14:let thenAction = then[\"Value\"]\n  15:(6) app __x6__ = (IsCallable thenAction)\n  15:if (= __x6__ false) {\n    16:(7) app __x7__ = (FulfillPromise promise resolution)\n    16:return __x7__\n  } else 1:{}\n  17:(8) app __x8__ = (HostMakeJobCallback thenAction)\n  17:let thenJobCallback = __x8__\n  18:(9) app __x9__ = (NewPromiseResolveThenableJob promise resolution thenJobCallback)\n  18:let job = __x9__\n  19:(10) app __x10__ = (HostEnqueuePromiseJob job[\"Job\"] job[\"Realm\"])\n  19:__x10__\n  20:return undefined\n}"
  }, {
    "code": ["          1. Assert: The value of _promise_.[[PromiseState]] is ~pending~.", "          1. Let _reactions_ be _promise_.[[PromiseFulfillReactions]].", "          1. Set _promise_.[[PromiseResult]] to _value_.", "          1. Set _promise_.[[PromiseFulfillReactions]] to *undefined*.", "          1. Set _promise_.[[PromiseRejectReactions]] to *undefined*.", "          1. Set _promise_.[[PromiseState]] to ~fulfilled~.", "          1. Return TriggerPromiseReactions(_reactions_, _value_)."],
    "head": {
      "name": "FulfillPromise",
      "params": [{
        "kind": "Normal",
        "name": "promise"
      }, {
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "sec-fulfillpromise",
    "rawBody": "{\n  0:assert (= promise[\"PromiseState\"] CONST_pending)\n  1:let reactions = promise[\"PromiseFulfillReactions\"]\n  2:promise[\"PromiseResult\"] = value\n  3:promise[\"PromiseFulfillReactions\"] = undefined\n  4:promise[\"PromiseRejectReactions\"] = undefined\n  5:promise[\"PromiseState\"] = CONST_fulfilled\n  6:(0) app __x0__ = (TriggerPromiseReactions reactions value)\n  6:return __x0__\n}"
  }, {
    "code": ["          1. If IsConstructor(_C_) is *false*, throw a *TypeError* exception.", "          1. NOTE: _C_ is assumed to be a constructor function that supports the parameter conventions of the Promise constructor (see <emu-xref href=\"#sec-promise-executor\"></emu-xref>).", "          1. Let _promiseCapability_ be the PromiseCapability Record { [[Promise]]: *undefined*, [[Resolve]]: *undefined*, [[Reject]]: *undefined* }.", "          1. Let _steps_ be the algorithm steps defined in <emu-xref href=\"#sec-getcapabilitiesexecutor-functions\" title></emu-xref>.", "          1. Let _length_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#sec-getcapabilitiesexecutor-functions\" title></emu-xref>.", "          1. Let _executor_ be ! CreateBuiltinFunction(_steps_, _length_, *\"\"*, « [[Capability]] »).", "          1. Set _executor_.[[Capability]] to _promiseCapability_.", "          1. Let _promise_ be ? Construct(_C_, « _executor_ »).", "          1. If IsCallable(_promiseCapability_.[[Resolve]]) is *false*, throw a *TypeError* exception.", "          1. If IsCallable(_promiseCapability_.[[Reject]]) is *false*, throw a *TypeError* exception.", "          1. Set _promiseCapability_.[[Promise]] to _promise_.", "          1. Return _promiseCapability_."],
    "head": {
      "name": "NewPromiseCapability",
      "params": [{
        "kind": "Normal",
        "name": "C"
      }]
    },
    "ids": "sec-newpromisecapability",
    "rawBody": "{\n  0:(0) app __x0__ = (IsConstructor C)\n  0:if (= __x0__ false) (0) throw TypeError else 1:{}\n  2:let promiseCapability = (1) (new PromiseCapabilityRecord(\"Promise\" -> undefined, \"Resolve\" -> undefined, \"Reject\" -> undefined))\n  3:(2) ??? \"Let id:{steps} be the algorithm steps defined in link:{sec-getcapabilitiesexecutor-functions} .\"\n  4:(3) ??? \"Let id:{length} be the number of non - optional parameters of the function definition in link:{sec-getcapabilitiesexecutor-functions} .\"\n  5:(1) app __x1__ = (CreateBuiltinFunction steps length \"\" (4) (new [\"Capability\"]))\n  5:let executor = [! __x1__]\n  6:executor[\"Capability\"] = promiseCapability\n  7:(2) app __x2__ = (Construct C (5) (new [executor]))\n  7:let promise = [? __x2__]\n  8:(3) app __x3__ = (IsCallable promiseCapability[\"Resolve\"])\n  8:if (= __x3__ false) (6) throw TypeError else 1:{}\n  9:(4) app __x4__ = (IsCallable promiseCapability[\"Reject\"])\n  9:if (= __x4__ false) (7) throw TypeError else 1:{}\n  10:promiseCapability[\"Promise\"] = promise\n  11:return promiseCapability\n}"
  }, {
    "code": ["            1. Let _F_ be the active function object.", "            1. Assert: _F_ has a [[Capability]] internal slot whose value is a PromiseCapability Record.", "            1. Let _promiseCapability_ be _F_.[[Capability]].", "            1. If _promiseCapability_.[[Resolve]] is not *undefined*, throw a *TypeError* exception.", "            1. If _promiseCapability_.[[Reject]] is not *undefined*, throw a *TypeError* exception.", "            1. Set _promiseCapability_.[[Resolve]] to _resolve_.", "            1. Set _promiseCapability_.[[Reject]] to _reject_.", "            1. Return *undefined*."],
    "head": {
      "origParams": [],
      "ref": "GetCapabilitiesExecutorFunctions"
    },
    "ids": "sec-getcapabilitiesexecutor-functions",
    "rawBody": "{\n  0:let F = CONTEXT[\"Function\"]\n  2:let promiseCapability = F[\"Capability\"]\n  3:if (! (= promiseCapability[\"Resolve\"] undefined)) (0) throw TypeError else 1:{}\n  4:if (! (= promiseCapability[\"Reject\"] undefined)) (1) throw TypeError else 1:{}\n  5:promiseCapability[\"Resolve\"] = resolve\n  6:promiseCapability[\"Reject\"] = reject\n  7:return undefined\n}"
  }, {
    "code": ["          1. If Type(_x_) is not Object, return *false*.", "          1. If _x_ does not have a [[PromiseState]] internal slot, return *false*.", "          1. Return *true*."],
    "head": {
      "name": "IsPromise",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }]
    },
    "ids": "sec-ispromise",
    "rawBody": "{\n  0:if (! (= (typeof x) Object)) return false else 1:{}\n  1:if (= x[\"PromiseState\"] absent) return false else 1:{}\n  2:return true\n}"
  }, {
    "code": ["          1. Assert: The value of _promise_.[[PromiseState]] is ~pending~.", "          1. Let _reactions_ be _promise_.[[PromiseRejectReactions]].", "          1. Set _promise_.[[PromiseResult]] to _reason_.", "          1. Set _promise_.[[PromiseFulfillReactions]] to *undefined*.", "          1. Set _promise_.[[PromiseRejectReactions]] to *undefined*.", "          1. Set _promise_.[[PromiseState]] to ~rejected~.", "          1. If _promise_.[[PromiseIsHandled]] is *false*, perform HostPromiseRejectionTracker(_promise_, *\"reject\"*).", "          1. Return TriggerPromiseReactions(_reactions_, _reason_)."],
    "head": {
      "name": "RejectPromise",
      "params": [{
        "kind": "Normal",
        "name": "promise"
      }, {
        "kind": "Normal",
        "name": "reason"
      }]
    },
    "ids": "sec-rejectpromise",
    "rawBody": "{\n  0:assert (= promise[\"PromiseState\"] CONST_pending)\n  1:let reactions = promise[\"PromiseRejectReactions\"]\n  2:promise[\"PromiseResult\"] = reason\n  3:promise[\"PromiseFulfillReactions\"] = undefined\n  4:promise[\"PromiseRejectReactions\"] = undefined\n  5:promise[\"PromiseState\"] = CONST_rejected\n  6:if (= promise[\"PromiseIsHandled\"] false) {\n    (0) app __x0__ = (HostPromiseRejectionTracker promise \"reject\")\n    __x0__\n  } else 1:{}\n  7:(1) app __x1__ = (TriggerPromiseReactions reactions reason)\n  7:return __x1__\n}"
  }, {
    "code": ["          1. For each element _reaction_ of _reactions_, do", "            1. Let _job_ be NewPromiseReactionJob(_reaction_, _argument_).", "            1. Perform HostEnqueuePromiseJob(_job_.[[Job]], _job_.[[Realm]]).", "          1. Return *undefined*."],
    "head": {
      "name": "TriggerPromiseReactions",
      "params": [{
        "kind": "Normal",
        "name": "reactions"
      }, {
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "sec-triggerpromisereactions",
    "rawBody": "{\n  0:let __x0__ = reactions\n  0:let __x1__ = 0i\n  0:while (< __x1__ __x0__[\"length\"]) {\n    let reaction = __x0__[__x1__]\n    1:(0) app __x2__ = (NewPromiseReactionJob reaction argument)\n    1:let job = __x2__\n    2:(1) app __x3__ = (HostEnqueuePromiseJob job[\"Job\"] job[\"Realm\"])\n    2:__x3__\n    __x1__ = (+ __x1__ 1i)\n  }\n  3:return undefined\n}"
  }, {
    "code": ["          1. Let _job_ be a new Job Abstract Closure with no parameters that captures _reaction_ and _argument_ and performs the following steps when called:", "            1. Assert: _reaction_ is a PromiseReaction Record.", "            1. Let _promiseCapability_ be _reaction_.[[Capability]].", "            1. Let _type_ be _reaction_.[[Type]].", "            1. Let _handler_ be _reaction_.[[Handler]].", "            1. If _handler_ is ~empty~, then", "              1. If _type_ is ~Fulfill~, let _handlerResult_ be NormalCompletion(_argument_).", "              1. Else,", "                1. Assert: _type_ is ~Reject~.", "                1. Let _handlerResult_ be ThrowCompletion(_argument_).", "            1. Else, let _handlerResult_ be HostCallJobCallback(_handler_, *undefined*, « _argument_ »).", "            1. If _promiseCapability_ is *undefined*, then", "              1. Assert: _handlerResult_ is not an abrupt completion.", "              1. Return NormalCompletion(~empty~).", "            1. Assert: _promiseCapability_ is a PromiseCapability Record.", "            1. If _handlerResult_ is an abrupt completion, then", "              1. Let _status_ be Call(_promiseCapability_.[[Reject]], *undefined*, « _handlerResult_.[[Value]] »).", "            1. Else,", "              1. Let _status_ be Call(_promiseCapability_.[[Resolve]], *undefined*, « _handlerResult_.[[Value]] »).", "            1. Return Completion(_status_).", "          1. Let _handlerRealm_ be *null*.", "          1. If _reaction_.[[Handler]] is not ~empty~, then", "            1. Let _getHandlerRealmResult_ be GetFunctionRealm(_reaction_.[[Handler]].[[Callback]]).", "            1. If _getHandlerRealmResult_ is a normal completion, set _handlerRealm_ to _getHandlerRealmResult_.[[Value]].", "            1. Else, set _handlerRealm_ to the current Realm Record.", "            1. NOTE: _handlerRealm_ is never *null* unless the handler is *undefined*. When the handler is a revoked Proxy and no ECMAScript code runs, _handlerRealm_ is used to create error objects.", "          1. Return the Record { [[Job]]: _job_, [[Realm]]: _handlerRealm_ }."],
    "head": {
      "name": "NewPromiseReactionJob",
      "params": [{
        "kind": "Normal",
        "name": "reaction"
      }, {
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "sec-newpromisereactionjob",
    "rawBody": "{\n  0:(0) ??? \"Let id:{job} be a new Job Abstract Closure with no parameters that captures id:{reaction} and id:{argument} and performs the following steps when called : in:{} out:{}\"\n  20:let handlerRealm = null\n  21:if (! (= reaction[\"Handler\"] CONST_empty)) {\n    22:(0) app __x0__ = (GetFunctionRealm reaction[\"Handler\"][\"Callback\"])\n    22:let getHandlerRealmResult = __x0__\n    24:if (&& (is-completion getHandlerRealmResult) (= getHandlerRealmResult[\"Type\"] CONST_normal)) handlerRealm = getHandlerRealmResult[\"Value\"] else handlerRealm = REALM\n  } else 25:{}\n  26:return (1) (new Record(\"Job\" -> job, \"Realm\" -> handlerRealm))\n}"
  }, {
    "code": ["          1. Let _job_ be a new Job Abstract Closure with no parameters that captures _promiseToResolve_, _thenable_, and _then_ and performs the following steps when called:", "            1. Let _resolvingFunctions_ be CreateResolvingFunctions(_promiseToResolve_).", "            1. Let _thenCallResult_ be HostCallJobCallback(_then_, _thenable_, « _resolvingFunctions_.[[Resolve]], _resolvingFunctions_.[[Reject]] »).", "            1. If _thenCallResult_ is an abrupt completion, then", "              1. Let _status_ be Call(_resolvingFunctions_.[[Reject]], *undefined*, « _thenCallResult_.[[Value]] »).", "              1. Return Completion(_status_).", "            1. Return Completion(_thenCallResult_).", "          1. Let _getThenRealmResult_ be GetFunctionRealm(_then_.[[Callback]]).", "          1. If _getThenRealmResult_ is a normal completion, let _thenRealm_ be _getThenRealmResult_.[[Value]].", "          1. Else, let _thenRealm_ be the current Realm Record.", "          1. NOTE: _thenRealm_ is never *null*. When _then_.[[Callback]] is a revoked Proxy and no code runs, _thenRealm_ is used to create error objects.", "          1. Return the Record { [[Job]]: _job_, [[Realm]]: _thenRealm_ }."],
    "head": {
      "name": "NewPromiseResolveThenableJob",
      "params": [{
        "kind": "Normal",
        "name": "promiseToResolve"
      }, {
        "kind": "Normal",
        "name": "thenable"
      }, {
        "kind": "Normal",
        "name": "then"
      }]
    },
    "ids": "sec-newpromiseresolvethenablejob",
    "rawBody": "{\n  0:(0) ??? \"Let id:{job} be a new Job Abstract Closure with no parameters that captures id:{promiseToResolve} , id:{thenable} , and id:{then} and performs the following steps when called : in:{} out:{}\"\n  7:(0) app __x0__ = (GetFunctionRealm then[\"Callback\"])\n  7:let getThenRealmResult = __x0__\n  9:if (&& (is-completion getThenRealmResult) (= getThenRealmResult[\"Type\"] CONST_normal)) let thenRealm = getThenRealmResult[\"Value\"] else let thenRealm = REALM\n  11:return (1) (new Record(\"Job\" -> job, \"Realm\" -> thenRealm))\n}"
  }, {
    "code": ["          1. If NewTarget is *undefined*, throw a *TypeError* exception.", "          1. If IsCallable(_executor_) is *false*, throw a *TypeError* exception.", "          1. Let _promise_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Promise.prototype%\"*, « [[PromiseState]], [[PromiseResult]], [[PromiseFulfillReactions]], [[PromiseRejectReactions]], [[PromiseIsHandled]] »).", "          1. Set _promise_.[[PromiseState]] to ~pending~.", "          1. Set _promise_.[[PromiseFulfillReactions]] to a new empty List.", "          1. Set _promise_.[[PromiseRejectReactions]] to a new empty List.", "          1. Set _promise_.[[PromiseIsHandled]] to *false*.", "          1. Let _resolvingFunctions_ be CreateResolvingFunctions(_promise_).", "          1. Let _completion_ be Call(_executor_, *undefined*, « _resolvingFunctions_.[[Resolve]], _resolvingFunctions_.[[Reject]] »).", "          1. If _completion_ is an abrupt completion, then", "            1. Perform ? Call(_resolvingFunctions_.[[Reject]], *undefined*, « _completion_.[[Value]] »).", "          1. Return _promise_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "executor"
      }],
      "ref": "Promise"
    },
    "ids": "sec-promise-executor",
    "rawBody": "{\n  0:if (= NewTarget undefined) (0) throw TypeError else 10:{}\n  1:(0) app __x0__ = (IsCallable executor)\n  1:if (= __x0__ false) (1) throw TypeError else 10:{}\n  2:(1) app __x1__ = (OrdinaryCreateFromConstructor NewTarget \"%Promise.prototype%\" (2) (new [\"PromiseState\", \"PromiseResult\", \"PromiseFulfillReactions\", \"PromiseRejectReactions\", \"PromiseIsHandled\"]))\n  2:let promise = [? __x1__]\n  3:promise[\"PromiseState\"] = CONST_pending\n  4:promise[\"PromiseFulfillReactions\"] = (3) (new [])\n  5:promise[\"PromiseRejectReactions\"] = (4) (new [])\n  6:promise[\"PromiseIsHandled\"] = false\n  7:(2) app __x2__ = (CreateResolvingFunctions promise)\n  7:let resolvingFunctions = __x2__\n  8:(3) app __x3__ = (Call executor undefined (5) (new [resolvingFunctions[\"Resolve\"], resolvingFunctions[\"Reject\"]]))\n  8:let completion = __x3__\n  9:(4) app __x4__ = (IsAbruptCompletion completion)\n  9:if __x4__ {\n    10:(5) app __x5__ = (Call resolvingFunctions[\"Reject\"] undefined (6) (new [completion[\"Value\"]]))\n    10:[? __x5__]\n  } else 10:{}\n  11:return promise\n}"
  }, {
    "code": ["          1. Let _C_ be the *this* value.", "          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).", "          1. Let _promiseResolve_ be GetPromiseResolve(_C_).", "          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_).", "          1. Let _iteratorRecord_ be GetIterator(_iterable_).", "          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_).", "          1. Let _result_ be PerformPromiseAll(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_).", "          1. If _result_ is an abrupt completion, then", "            1. If _iteratorRecord_.[[Done]] is *false*, set _result_ to IteratorClose(_iteratorRecord_, _result_).", "            1. IfAbruptRejectPromise(_result_, _promiseCapability_).", "          1. Return Completion(_result_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "iterable"
      }],
      "ref": "Promise[\"all\"]"
    },
    "ids": "sec-promise.all",
    "rawBody": "{\n  0:let C = this\n  1:(0) app __x0__ = (NewPromiseCapability C)\n  1:let promiseCapability = [? __x0__]\n  2:(1) app __x1__ = (GetPromiseResolve C)\n  2:let promiseResolve = __x1__\n  3:if (is-completion promiseResolve) if (= promiseResolve[\"Type\"] CONST_normal) promiseResolve = promiseResolve[\"Value\"] else {\n    (2) app __x2__ = (Call promiseCapability[\"Reject\"] undefined (0) (new [promiseResolve[\"Value\"]]))\n    if (&& (is-completion __x2__) (! (= __x2__[\"Type\"] CONST_normal))) return __x2__ else 10:{}\n    return promiseCapability[\"Promise\"]\n  } else 10:{}\n  3:promiseResolve\n  4:(3) app __x3__ = (GetIterator iterable)\n  4:let iteratorRecord = __x3__\n  5:if (is-completion iteratorRecord) if (= iteratorRecord[\"Type\"] CONST_normal) iteratorRecord = iteratorRecord[\"Value\"] else {\n    (4) app __x4__ = (Call promiseCapability[\"Reject\"] undefined (1) (new [iteratorRecord[\"Value\"]]))\n    if (&& (is-completion __x4__) (! (= __x4__[\"Type\"] CONST_normal))) return __x4__ else 10:{}\n    return promiseCapability[\"Promise\"]\n  } else 10:{}\n  5:iteratorRecord\n  6:(5) app __x5__ = (PerformPromiseAll iteratorRecord C promiseCapability promiseResolve)\n  6:let result = __x5__\n  7:(6) app __x6__ = (IsAbruptCompletion result)\n  7:if __x6__ {\n    8:if (= iteratorRecord[\"Done\"] false) {\n      (7) app __x7__ = (IteratorClose iteratorRecord result)\n      result = __x7__\n    } else 10:{}\n    9:if (is-completion result) if (= result[\"Type\"] CONST_normal) result = result[\"Value\"] else {\n      (8) app __x8__ = (Call promiseCapability[\"Reject\"] undefined (2) (new [result[\"Value\"]]))\n      if (&& (is-completion __x8__) (! (= __x8__[\"Type\"] CONST_normal))) return __x8__ else 10:{}\n      return promiseCapability[\"Promise\"]\n    } else 10:{}\n    9:result\n  } else 10:{}\n  10:return result\n}"
  }, {
    "code": ["            1. Assert: IsConstructor(_promiseConstructor_) is *true*.", "            1. Let _promiseResolve_ be ? Get(_promiseConstructor_, *\"resolve\"*).", "            1. If IsCallable(_promiseResolve_) is *false*, throw a *TypeError* exception.", "            1. Return _promiseResolve_."],
    "head": {
      "name": "GetPromiseResolve",
      "params": [{
        "kind": "Normal",
        "name": "promiseConstructor"
      }]
    },
    "ids": "sec-getpromiseresolve",
    "rawBody": "{\n  0:(0) app __x0__ = (IsConstructor promiseConstructor)\n  0:assert (= __x0__ true)\n  1:(1) app __x1__ = (Get promiseConstructor \"resolve\")\n  1:let promiseResolve = [? __x1__]\n  2:(2) app __x2__ = (IsCallable promiseResolve)\n  2:if (= __x2__ false) (0) throw TypeError else 10:{}\n  3:return promiseResolve\n}"
  }, {
    "code": ["            1. Assert: IsConstructor(_constructor_) is *true*.", "            1. Assert: IsCallable(_promiseResolve_) is *true*.", "            1. Let _values_ be a new empty List.", "            1. Let _remainingElementsCount_ be the Record { [[Value]]: 1 }.", "            1. Let _index_ be 0.", "            1. Repeat,", "              1. Let _next_ be IteratorStep(_iteratorRecord_).", "              1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.", "              1. ReturnIfAbrupt(_next_).", "              1. If _next_ is *false*, then", "                1. Set _iteratorRecord_.[[Done]] to *true*.", "                1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.", "                1. If _remainingElementsCount_.[[Value]] is 0, then", "                  1. Let _valuesArray_ be ! CreateArrayFromList(_values_).", "                  1. Perform ? Call(_resultCapability_.[[Resolve]], *undefined*, « _valuesArray_ »).", "                1. Return _resultCapability_.[[Promise]].", "              1. Let _nextValue_ be IteratorValue(_next_).", "              1. If _nextValue_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.", "              1. ReturnIfAbrupt(_nextValue_).", "              1. Append *undefined* to _values_.", "              1. Let _nextPromise_ be ? Call(_promiseResolve_, _constructor_, « _nextValue_ »).", "              1. Let _steps_ be the algorithm steps defined in <emu-xref href=\"#sec-promise.all-resolve-element-functions\" title></emu-xref>.", "              1. Let _length_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#sec-promise.all-resolve-element-functions\" title></emu-xref>.", "              1. Let _onFulfilled_ be ! CreateBuiltinFunction(_steps_, _length_, *\"\"*, « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] »).", "              1. Set _onFulfilled_.[[AlreadyCalled]] to *false*.", "              1. Set _onFulfilled_.[[Index]] to _index_.", "              1. Set _onFulfilled_.[[Values]] to _values_.", "              1. Set _onFulfilled_.[[Capability]] to _resultCapability_.", "              1. Set _onFulfilled_.[[RemainingElements]] to _remainingElementsCount_.", "              1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] + 1.", "              1. Perform ? Invoke(_nextPromise_, *\"then\"*, « _onFulfilled_, _resultCapability_.[[Reject]] »).", "              1. Set _index_ to _index_ + 1."],
    "head": {
      "name": "PerformPromiseAll",
      "params": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }, {
        "kind": "Normal",
        "name": "constructor"
      }, {
        "kind": "Normal",
        "name": "resultCapability"
      }, {
        "kind": "Normal",
        "name": "promiseResolve"
      }]
    },
    "ids": "sec-performpromiseall",
    "rawBody": "{\n  0:(0) app __x0__ = (IsConstructor constructor)\n  0:assert (= __x0__ true)\n  1:(1) app __x1__ = (IsCallable promiseResolve)\n  1:assert (= __x1__ true)\n  2:let values = (0) (new [])\n  3:let remainingElementsCount = (1) (new Record(\"Value\" -> 1i))\n  4:let index = 0i\n  5:while true {\n    6:(2) app __x2__ = (IteratorStep iteratorRecord)\n    6:let next = __x2__\n    7:(3) app __x3__ = (IsAbruptCompletion next)\n    7:if __x3__ iteratorRecord[\"Done\"] = true else 10:{}\n    8:[? next]\n    9:if (= next false) {\n      10:iteratorRecord[\"Done\"] = true\n      11:remainingElementsCount[\"Value\"] = (- remainingElementsCount[\"Value\"] 1i)\n      12:if (= remainingElementsCount[\"Value\"] 0i) {\n        13:(4) app __x4__ = (CreateArrayFromList values)\n        13:let valuesArray = [! __x4__]\n        14:(5) app __x5__ = (Call resultCapability[\"Resolve\"] undefined (2) (new [valuesArray]))\n        14:[? __x5__]\n      } else 10:{}\n      15:return resultCapability[\"Promise\"]\n    } else 10:{}\n    16:(6) app __x6__ = (IteratorValue next)\n    16:let nextValue = __x6__\n    17:(7) app __x7__ = (IsAbruptCompletion nextValue)\n    17:if __x7__ iteratorRecord[\"Done\"] = true else 10:{}\n    18:[? nextValue]\n    19:append undefined -> values\n    20:(8) app __x8__ = (Call promiseResolve constructor (3) (new [nextValue]))\n    20:let nextPromise = [? __x8__]\n    21:(4) ??? \"Let id:{steps} be the algorithm steps defined in link:{sec-promise.all-resolve-element-functions} .\"\n    22:(5) ??? \"Let id:{length} be the number of non - optional parameters of the function definition in link:{sec-promise.all-resolve-element-functions} .\"\n    23:(9) app __x9__ = (CreateBuiltinFunction steps length \"\" (6) (new [\"AlreadyCalled\", \"Index\", \"Values\", \"Capability\", \"RemainingElements\"]))\n    23:let onFulfilled = [! __x9__]\n    24:onFulfilled[\"AlreadyCalled\"] = false\n    25:onFulfilled[\"Index\"] = index\n    26:onFulfilled[\"Values\"] = values\n    27:onFulfilled[\"Capability\"] = resultCapability\n    28:onFulfilled[\"RemainingElements\"] = remainingElementsCount\n    29:remainingElementsCount[\"Value\"] = (+ remainingElementsCount[\"Value\"] 1i)\n    30:(10) app __x10__ = (Invoke nextPromise \"then\" (7) (new [onFulfilled, resultCapability[\"Reject\"]]))\n    30:[? __x10__]\n    31:index = (+ index 1i)\n  }\n}"
  }, {
    "code": ["          1. Let _C_ be the *this* value.", "          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).", "          1. Let _promiseResolve_ be GetPromiseResolve(_C_).", "          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_).", "          1. Let _iteratorRecord_ be GetIterator(_iterable_).", "          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_).", "          1. Let _result_ be PerformPromiseAllSettled(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_).", "          1. If _result_ is an abrupt completion, then", "            1. If _iteratorRecord_.[[Done]] is *false*, set _result_ to IteratorClose(_iteratorRecord_, _result_).", "            1. IfAbruptRejectPromise(_result_, _promiseCapability_).", "          1. Return Completion(_result_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "iterable"
      }],
      "ref": "Promise[\"allSettled\"]"
    },
    "ids": "sec-promise.allsettled",
    "rawBody": "{\n  0:let C = this\n  1:(0) app __x0__ = (NewPromiseCapability C)\n  1:let promiseCapability = [? __x0__]\n  2:(1) app __x1__ = (GetPromiseResolve C)\n  2:let promiseResolve = __x1__\n  3:if (is-completion promiseResolve) if (= promiseResolve[\"Type\"] CONST_normal) promiseResolve = promiseResolve[\"Value\"] else {\n    (2) app __x2__ = (Call promiseCapability[\"Reject\"] undefined (0) (new [promiseResolve[\"Value\"]]))\n    if (&& (is-completion __x2__) (! (= __x2__[\"Type\"] CONST_normal))) return __x2__ else 10:{}\n    return promiseCapability[\"Promise\"]\n  } else 10:{}\n  3:promiseResolve\n  4:(3) app __x3__ = (GetIterator iterable)\n  4:let iteratorRecord = __x3__\n  5:if (is-completion iteratorRecord) if (= iteratorRecord[\"Type\"] CONST_normal) iteratorRecord = iteratorRecord[\"Value\"] else {\n    (4) app __x4__ = (Call promiseCapability[\"Reject\"] undefined (1) (new [iteratorRecord[\"Value\"]]))\n    if (&& (is-completion __x4__) (! (= __x4__[\"Type\"] CONST_normal))) return __x4__ else 10:{}\n    return promiseCapability[\"Promise\"]\n  } else 10:{}\n  5:iteratorRecord\n  6:(5) app __x5__ = (PerformPromiseAllSettled iteratorRecord C promiseCapability promiseResolve)\n  6:let result = __x5__\n  7:(6) app __x6__ = (IsAbruptCompletion result)\n  7:if __x6__ {\n    8:if (= iteratorRecord[\"Done\"] false) {\n      (7) app __x7__ = (IteratorClose iteratorRecord result)\n      result = __x7__\n    } else 10:{}\n    9:if (is-completion result) if (= result[\"Type\"] CONST_normal) result = result[\"Value\"] else {\n      (8) app __x8__ = (Call promiseCapability[\"Reject\"] undefined (2) (new [result[\"Value\"]]))\n      if (&& (is-completion __x8__) (! (= __x8__[\"Type\"] CONST_normal))) return __x8__ else 10:{}\n      return promiseCapability[\"Promise\"]\n    } else 10:{}\n    9:result\n  } else 10:{}\n  10:return result\n}"
  }, {
    "code": ["            1. Assert: ! IsConstructor(_constructor_) is *true*.", "            1. Assert: IsCallable(_promiseResolve_) is *true*.", "            1. Let _values_ be a new empty List.", "            1. Let _remainingElementsCount_ be the Record { [[Value]]: 1 }.", "            1. Let _index_ be 0.", "            1. Repeat,", "              1. Let _next_ be IteratorStep(_iteratorRecord_).", "              1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.", "              1. ReturnIfAbrupt(_next_).", "              1. If _next_ is *false*, then", "                1. Set _iteratorRecord_.[[Done]] to *true*.", "                1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.", "                1. If _remainingElementsCount_.[[Value]] is 0, then", "                  1. Let _valuesArray_ be ! CreateArrayFromList(_values_).", "                  1. Perform ? Call(_resultCapability_.[[Resolve]], *undefined*, « _valuesArray_ »).", "                1. Return _resultCapability_.[[Promise]].", "              1. Let _nextValue_ be IteratorValue(_next_).", "              1. If _nextValue_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.", "              1. ReturnIfAbrupt(_nextValue_).", "              1. Append *undefined* to _values_.", "              1. Let _nextPromise_ be ? Call(_promiseResolve_, _constructor_, « _nextValue_ »).", "              1. Let _stepsFulfilled_ be the algorithm steps defined in <emu-xref href=\"#sec-promise.allsettled-resolve-element-functions\" title></emu-xref>.", "              1. Let _lengthFulfilled_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#sec-promise.allsettled-resolve-element-functions\" title></emu-xref>.", "              1. Let _onFulfilled_ be ! CreateBuiltinFunction(_stepsFulfilled_, _lengthFulfilled_, *\"\"*, « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] »).", "              1. Let _alreadyCalled_ be the Record { [[Value]]: *false* }.", "              1. Set _onFulfilled_.[[AlreadyCalled]] to _alreadyCalled_.", "              1. Set _onFulfilled_.[[Index]] to _index_.", "              1. Set _onFulfilled_.[[Values]] to _values_.", "              1. Set _onFulfilled_.[[Capability]] to _resultCapability_.", "              1. Set _onFulfilled_.[[RemainingElements]] to _remainingElementsCount_.", "              1. Let _stepsRejected_ be the algorithm steps defined in <emu-xref href=\"#sec-promise.allsettled-reject-element-functions\" title></emu-xref>.", "              1. Let _lengthRejected_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#sec-promise.allsettled-reject-element-functions\" title></emu-xref>.", "              1. Let _onRejected_ be ! CreateBuiltinFunction(_stepsRejected_, _lengthRejected_, *\"\"*, « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] »).", "              1. Set _onRejected_.[[AlreadyCalled]] to _alreadyCalled_.", "              1. Set _onRejected_.[[Index]] to _index_.", "              1. Set _onRejected_.[[Values]] to _values_.", "              1. Set _onRejected_.[[Capability]] to _resultCapability_.", "              1. Set _onRejected_.[[RemainingElements]] to _remainingElementsCount_.", "              1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] + 1.", "              1. Perform ? Invoke(_nextPromise_, *\"then\"*, « _onFulfilled_, _onRejected_ »).", "              1. Set _index_ to _index_ + 1."],
    "head": {
      "name": "PerformPromiseAllSettled",
      "params": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }, {
        "kind": "Normal",
        "name": "constructor"
      }, {
        "kind": "Normal",
        "name": "resultCapability"
      }, {
        "kind": "Normal",
        "name": "promiseResolve"
      }]
    },
    "ids": "sec-performpromiseallsettled",
    "rawBody": "{\n  0:(0) app __x0__ = (IsConstructor constructor)\n  0:assert (= [! __x0__] true)\n  1:(1) app __x1__ = (IsCallable promiseResolve)\n  1:assert (= __x1__ true)\n  2:let values = (0) (new [])\n  3:let remainingElementsCount = (1) (new Record(\"Value\" -> 1i))\n  4:let index = 0i\n  5:while true {\n    6:(2) app __x2__ = (IteratorStep iteratorRecord)\n    6:let next = __x2__\n    7:(3) app __x3__ = (IsAbruptCompletion next)\n    7:if __x3__ iteratorRecord[\"Done\"] = true else 10:{}\n    8:[? next]\n    9:if (= next false) {\n      10:iteratorRecord[\"Done\"] = true\n      11:remainingElementsCount[\"Value\"] = (- remainingElementsCount[\"Value\"] 1i)\n      12:if (= remainingElementsCount[\"Value\"] 0i) {\n        13:(4) app __x4__ = (CreateArrayFromList values)\n        13:let valuesArray = [! __x4__]\n        14:(5) app __x5__ = (Call resultCapability[\"Resolve\"] undefined (2) (new [valuesArray]))\n        14:[? __x5__]\n      } else 10:{}\n      15:return resultCapability[\"Promise\"]\n    } else 10:{}\n    16:(6) app __x6__ = (IteratorValue next)\n    16:let nextValue = __x6__\n    17:(7) app __x7__ = (IsAbruptCompletion nextValue)\n    17:if __x7__ iteratorRecord[\"Done\"] = true else 10:{}\n    18:[? nextValue]\n    19:append undefined -> values\n    20:(8) app __x8__ = (Call promiseResolve constructor (3) (new [nextValue]))\n    20:let nextPromise = [? __x8__]\n    21:(4) ??? \"Let id:{stepsFulfilled} be the algorithm steps defined in link:{sec-promise.allsettled-resolve-element-functions} .\"\n    22:(5) ??? \"Let id:{lengthFulfilled} be the number of non - optional parameters of the function definition in link:{sec-promise.allsettled-resolve-element-functions} .\"\n    23:(9) app __x9__ = (CreateBuiltinFunction stepsFulfilled lengthFulfilled \"\" (6) (new [\"AlreadyCalled\", \"Index\", \"Values\", \"Capability\", \"RemainingElements\"]))\n    23:let onFulfilled = [! __x9__]\n    24:let alreadyCalled = (7) (new Record(\"Value\" -> false))\n    25:onFulfilled[\"AlreadyCalled\"] = alreadyCalled\n    26:onFulfilled[\"Index\"] = index\n    27:onFulfilled[\"Values\"] = values\n    28:onFulfilled[\"Capability\"] = resultCapability\n    29:onFulfilled[\"RemainingElements\"] = remainingElementsCount\n    30:(8) ??? \"Let id:{stepsRejected} be the algorithm steps defined in link:{sec-promise.allsettled-reject-element-functions} .\"\n    31:(9) ??? \"Let id:{lengthRejected} be the number of non - optional parameters of the function definition in link:{sec-promise.allsettled-reject-element-functions} .\"\n    32:(10) app __x10__ = (CreateBuiltinFunction stepsRejected lengthRejected \"\" (10) (new [\"AlreadyCalled\", \"Index\", \"Values\", \"Capability\", \"RemainingElements\"]))\n    32:let onRejected = [! __x10__]\n    33:onRejected[\"AlreadyCalled\"] = alreadyCalled\n    34:onRejected[\"Index\"] = index\n    35:onRejected[\"Values\"] = values\n    36:onRejected[\"Capability\"] = resultCapability\n    37:onRejected[\"RemainingElements\"] = remainingElementsCount\n    38:remainingElementsCount[\"Value\"] = (+ remainingElementsCount[\"Value\"] 1i)\n    39:(11) app __x11__ = (Invoke nextPromise \"then\" (11) (new [onFulfilled, onRejected]))\n    39:[? __x11__]\n    40:index = (+ index 1i)\n  }\n}"
  }, {
    "code": ["          1. Let _C_ be the *this* value.", "          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).", "          1. Let _promiseResolve_ be GetPromiseResolve(_C_).", "          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_).", "          1. Let _iteratorRecord_ be GetIterator(_iterable_).", "          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_).", "          1. Let _result_ be PerformPromiseAny(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_).", "          1. If _result_ is an abrupt completion, then", "            1. If _iteratorRecord_.[[Done]] is *false*, set _result_ to IteratorClose(_iteratorRecord_, _result_).", "            1. IfAbruptRejectPromise(_result_, _promiseCapability_).", "          1. Return Completion(_result_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "iterable"
      }],
      "ref": "Promise[\"any\"]"
    },
    "ids": "sec-promise.any",
    "rawBody": "{\n  0:let C = this\n  1:(0) app __x0__ = (NewPromiseCapability C)\n  1:let promiseCapability = [? __x0__]\n  2:(1) app __x1__ = (GetPromiseResolve C)\n  2:let promiseResolve = __x1__\n  3:if (is-completion promiseResolve) if (= promiseResolve[\"Type\"] CONST_normal) promiseResolve = promiseResolve[\"Value\"] else {\n    (2) app __x2__ = (Call promiseCapability[\"Reject\"] undefined (0) (new [promiseResolve[\"Value\"]]))\n    if (&& (is-completion __x2__) (! (= __x2__[\"Type\"] CONST_normal))) return __x2__ else 10:{}\n    return promiseCapability[\"Promise\"]\n  } else 10:{}\n  3:promiseResolve\n  4:(3) app __x3__ = (GetIterator iterable)\n  4:let iteratorRecord = __x3__\n  5:if (is-completion iteratorRecord) if (= iteratorRecord[\"Type\"] CONST_normal) iteratorRecord = iteratorRecord[\"Value\"] else {\n    (4) app __x4__ = (Call promiseCapability[\"Reject\"] undefined (1) (new [iteratorRecord[\"Value\"]]))\n    if (&& (is-completion __x4__) (! (= __x4__[\"Type\"] CONST_normal))) return __x4__ else 10:{}\n    return promiseCapability[\"Promise\"]\n  } else 10:{}\n  5:iteratorRecord\n  6:(5) app __x5__ = (PerformPromiseAny iteratorRecord C promiseCapability promiseResolve)\n  6:let result = __x5__\n  7:(6) app __x6__ = (IsAbruptCompletion result)\n  7:if __x6__ {\n    8:if (= iteratorRecord[\"Done\"] false) {\n      (7) app __x7__ = (IteratorClose iteratorRecord result)\n      result = __x7__\n    } else 10:{}\n    9:if (is-completion result) if (= result[\"Type\"] CONST_normal) result = result[\"Value\"] else {\n      (8) app __x8__ = (Call promiseCapability[\"Reject\"] undefined (2) (new [result[\"Value\"]]))\n      if (&& (is-completion __x8__) (! (= __x8__[\"Type\"] CONST_normal))) return __x8__ else 10:{}\n      return promiseCapability[\"Promise\"]\n    } else 10:{}\n    9:result\n  } else 10:{}\n  10:return result\n}"
  }, {
    "code": ["            1. Assert: ! IsConstructor(_constructor_) is *true*.", "            1. Assert: ! IsCallable(_promiseResolve_) is *true*.", "            1. Let _errors_ be a new empty List.", "            1. Let _remainingElementsCount_ be the Record { [[Value]]: 1 }.", "            1. Let _index_ be 0.", "            1. Repeat,", "              1. Let _next_ be IteratorStep(_iteratorRecord_).", "              1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.", "              1. ReturnIfAbrupt(_next_).", "              1. If _next_ is *false*, then", "                1. Set _iteratorRecord_.[[Done]] to *true*.", "                1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.", "                1. If _remainingElementsCount_.[[Value]] is 0, then", "                  1. Let _error_ be a newly created `AggregateError` object.", "                  1. Perform ! DefinePropertyOrThrow(_error_, *\"errors\"*, PropertyDescriptor { [[Configurable]]: *true*, [[Enumerable]]: *false*, [[Writable]]: *true*, [[Value]]: ! CreateArrayFromList(_errors_) }).", "                  1. Return ThrowCompletion(_error_).", "                1. Return _resultCapability_.[[Promise]].", "              1. Let _nextValue_ be IteratorValue(_next_).", "              1. If _nextValue_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.", "              1. ReturnIfAbrupt(_nextValue_).", "              1. Append *undefined* to _errors_.", "              1. Let _nextPromise_ be ? Call(_promiseResolve_, _constructor_, « _nextValue_ »).", "              1. Let _stepsRejected_ be the algorithm steps defined in <emu-xref href=\"#sec-promise.any-reject-element-functions\" title></emu-xref>.", "              1. Let _lengthRejected_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#sec-promise.any-reject-element-functions\" title></emu-xref>.", "              1. Let _onRejected_ be ! CreateBuiltinFunction(_stepsRejected_, _lengthRejected_, *\"\"*, « [[AlreadyCalled]], [[Index]], [[Errors]], [[Capability]], [[RemainingElements]] »).", "              1. Set _onRejected_.[[AlreadyCalled]] to *false*.", "              1. Set _onRejected_.[[Index]] to _index_.", "              1. Set _onRejected_.[[Errors]] to _errors_.", "              1. Set _onRejected_.[[Capability]] to _resultCapability_.", "              1. Set _onRejected_.[[RemainingElements]] to _remainingElementsCount_.", "              1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] + 1.", "              1. Perform ? Invoke(_nextPromise_, *\"then\"*, « _resultCapability_.[[Resolve]], _onRejected_ »).", "              1. Set _index_ to _index_ + 1."],
    "head": {
      "name": "PerformPromiseAny",
      "params": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }, {
        "kind": "Normal",
        "name": "constructor"
      }, {
        "kind": "Normal",
        "name": "resultCapability"
      }, {
        "kind": "Normal",
        "name": "promiseResolve"
      }]
    },
    "ids": "sec-performpromiseany",
    "rawBody": "{\n  0:(0) app __x0__ = (IsConstructor constructor)\n  0:assert (= [! __x0__] true)\n  1:(1) app __x1__ = (IsCallable promiseResolve)\n  1:assert (= [! __x1__] true)\n  2:let errors = (0) (new [])\n  3:let remainingElementsCount = (1) (new Record(\"Value\" -> 1i))\n  4:let index = 0i\n  5:while true {\n    6:(2) app __x2__ = (IteratorStep iteratorRecord)\n    6:let next = __x2__\n    7:(3) app __x3__ = (IsAbruptCompletion next)\n    7:if __x3__ iteratorRecord[\"Done\"] = true else 10:{}\n    8:[? next]\n    9:if (= next false) {\n      10:iteratorRecord[\"Done\"] = true\n      11:remainingElementsCount[\"Value\"] = (- remainingElementsCount[\"Value\"] 1i)\n      12:if (= remainingElementsCount[\"Value\"] 0i) {\n        13:(2) ??? \"Let id:{error} be a newly created code:{AggregateError} object .\"\n        14:(4) app __x4__ = (CreateArrayFromList errors)\n        14:(5) app __x5__ = (DefinePropertyOrThrow error \"errors\" (3) (new PropertyDescriptor(\"Configurable\" -> true, \"Enumerable\" -> false, \"Writable\" -> true, \"Value\" -> [! __x4__])))\n        14:[! __x5__]\n        15:(6) app __x6__ = (ThrowCompletion error)\n        15:return __x6__\n      } else 10:{}\n      16:return resultCapability[\"Promise\"]\n    } else 10:{}\n    17:(7) app __x7__ = (IteratorValue next)\n    17:let nextValue = __x7__\n    18:(8) app __x8__ = (IsAbruptCompletion nextValue)\n    18:if __x8__ iteratorRecord[\"Done\"] = true else 10:{}\n    19:[? nextValue]\n    20:append undefined -> errors\n    21:(9) app __x9__ = (Call promiseResolve constructor (4) (new [nextValue]))\n    21:let nextPromise = [? __x9__]\n    22:(5) ??? \"Let id:{stepsRejected} be the algorithm steps defined in link:{sec-promise.any-reject-element-functions} .\"\n    23:(6) ??? \"Let id:{lengthRejected} be the number of non - optional parameters of the function definition in link:{sec-promise.any-reject-element-functions} .\"\n    24:(10) app __x10__ = (CreateBuiltinFunction stepsRejected lengthRejected \"\" (7) (new [\"AlreadyCalled\", \"Index\", \"Errors\", \"Capability\", \"RemainingElements\"]))\n    24:let onRejected = [! __x10__]\n    25:onRejected[\"AlreadyCalled\"] = false\n    26:onRejected[\"Index\"] = index\n    27:onRejected[\"Errors\"] = errors\n    28:onRejected[\"Capability\"] = resultCapability\n    29:onRejected[\"RemainingElements\"] = remainingElementsCount\n    30:remainingElementsCount[\"Value\"] = (+ remainingElementsCount[\"Value\"] 1i)\n    31:(11) app __x11__ = (Invoke nextPromise \"then\" (8) (new [resultCapability[\"Resolve\"], onRejected]))\n    31:[? __x11__]\n    32:index = (+ index 1i)\n  }\n}"
  }, {
    "code": ["          1. Let _C_ be the *this* value.", "          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).", "          1. Let _promiseResolve_ be GetPromiseResolve(_C_).", "          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_).", "          1. Let _iteratorRecord_ be GetIterator(_iterable_).", "          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_).", "          1. Let _result_ be PerformPromiseRace(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_).", "          1. If _result_ is an abrupt completion, then", "            1. If _iteratorRecord_.[[Done]] is *false*, set _result_ to IteratorClose(_iteratorRecord_, _result_).", "            1. IfAbruptRejectPromise(_result_, _promiseCapability_).", "          1. Return Completion(_result_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "iterable"
      }],
      "ref": "Promise[\"race\"]"
    },
    "ids": "sec-promise.race",
    "rawBody": "{\n  0:let C = this\n  1:(0) app __x0__ = (NewPromiseCapability C)\n  1:let promiseCapability = [? __x0__]\n  2:(1) app __x1__ = (GetPromiseResolve C)\n  2:let promiseResolve = __x1__\n  3:if (is-completion promiseResolve) if (= promiseResolve[\"Type\"] CONST_normal) promiseResolve = promiseResolve[\"Value\"] else {\n    (2) app __x2__ = (Call promiseCapability[\"Reject\"] undefined (0) (new [promiseResolve[\"Value\"]]))\n    if (&& (is-completion __x2__) (! (= __x2__[\"Type\"] CONST_normal))) return __x2__ else 10:{}\n    return promiseCapability[\"Promise\"]\n  } else 10:{}\n  3:promiseResolve\n  4:(3) app __x3__ = (GetIterator iterable)\n  4:let iteratorRecord = __x3__\n  5:if (is-completion iteratorRecord) if (= iteratorRecord[\"Type\"] CONST_normal) iteratorRecord = iteratorRecord[\"Value\"] else {\n    (4) app __x4__ = (Call promiseCapability[\"Reject\"] undefined (1) (new [iteratorRecord[\"Value\"]]))\n    if (&& (is-completion __x4__) (! (= __x4__[\"Type\"] CONST_normal))) return __x4__ else 10:{}\n    return promiseCapability[\"Promise\"]\n  } else 10:{}\n  5:iteratorRecord\n  6:(5) app __x5__ = (PerformPromiseRace iteratorRecord C promiseCapability promiseResolve)\n  6:let result = __x5__\n  7:(6) app __x6__ = (IsAbruptCompletion result)\n  7:if __x6__ {\n    8:if (= iteratorRecord[\"Done\"] false) {\n      (7) app __x7__ = (IteratorClose iteratorRecord result)\n      result = __x7__\n    } else 10:{}\n    9:if (is-completion result) if (= result[\"Type\"] CONST_normal) result = result[\"Value\"] else {\n      (8) app __x8__ = (Call promiseCapability[\"Reject\"] undefined (2) (new [result[\"Value\"]]))\n      if (&& (is-completion __x8__) (! (= __x8__[\"Type\"] CONST_normal))) return __x8__ else 10:{}\n      return promiseCapability[\"Promise\"]\n    } else 10:{}\n    9:result\n  } else 10:{}\n  10:return result\n}"
  }, {
    "code": ["            1. Assert: IsConstructor(_constructor_) is *true*.", "            1. Assert: IsCallable(_promiseResolve_) is *true*.", "            1. Repeat,", "              1. Let _next_ be IteratorStep(_iteratorRecord_).", "              1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.", "              1. ReturnIfAbrupt(_next_).", "              1. If _next_ is *false*, then", "                1. Set _iteratorRecord_.[[Done]] to *true*.", "                1. Return _resultCapability_.[[Promise]].", "              1. Let _nextValue_ be IteratorValue(_next_).", "              1. If _nextValue_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.", "              1. ReturnIfAbrupt(_nextValue_).", "              1. Let _nextPromise_ be ? Call(_promiseResolve_, _constructor_, « _nextValue_ »).", "              1. Perform ? Invoke(_nextPromise_, *\"then\"*, « _resultCapability_.[[Resolve]], _resultCapability_.[[Reject]] »)."],
    "head": {
      "name": "PerformPromiseRace",
      "params": [{
        "kind": "Normal",
        "name": "iteratorRecord"
      }, {
        "kind": "Normal",
        "name": "constructor"
      }, {
        "kind": "Normal",
        "name": "resultCapability"
      }, {
        "kind": "Normal",
        "name": "promiseResolve"
      }]
    },
    "ids": "sec-performpromiserace",
    "rawBody": "{\n  0:(0) app __x0__ = (IsConstructor constructor)\n  0:assert (= __x0__ true)\n  1:(1) app __x1__ = (IsCallable promiseResolve)\n  1:assert (= __x1__ true)\n  2:while true {\n    3:(2) app __x2__ = (IteratorStep iteratorRecord)\n    3:let next = __x2__\n    4:(3) app __x3__ = (IsAbruptCompletion next)\n    4:if __x3__ iteratorRecord[\"Done\"] = true else 10:{}\n    5:[? next]\n    6:if (= next false) {\n      7:iteratorRecord[\"Done\"] = true\n      8:return resultCapability[\"Promise\"]\n    } else 10:{}\n    9:(4) app __x4__ = (IteratorValue next)\n    9:let nextValue = __x4__\n    10:(5) app __x5__ = (IsAbruptCompletion nextValue)\n    10:if __x5__ iteratorRecord[\"Done\"] = true else 10:{}\n    11:[? nextValue]\n    12:(6) app __x6__ = (Call promiseResolve constructor (0) (new [nextValue]))\n    12:let nextPromise = [? __x6__]\n    13:(7) app __x7__ = (Invoke nextPromise \"then\" (1) (new [resultCapability[\"Resolve\"], resultCapability[\"Reject\"]]))\n    13:[? __x7__]\n  }\n}"
  }, {
    "code": ["          1. Let _C_ be the *this* value.", "          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).", "          1. Perform ? Call(_promiseCapability_.[[Reject]], *undefined*, « _r_ »).", "          1. Return _promiseCapability_.[[Promise]]."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "r"
      }],
      "ref": "Promise[\"reject\"]"
    },
    "ids": "sec-promise.reject",
    "rawBody": "{\n  0:let C = this\n  1:(0) app __x0__ = (NewPromiseCapability C)\n  1:let promiseCapability = [? __x0__]\n  2:(1) app __x1__ = (Call promiseCapability[\"Reject\"] undefined (0) (new [r]))\n  2:[? __x1__]\n  3:return promiseCapability[\"Promise\"]\n}"
  }, {
    "code": ["          1. Let _C_ be the *this* value.", "          1. If Type(_C_) is not Object, throw a *TypeError* exception.", "          1. Return ? PromiseResolve(_C_, _x_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "x"
      }],
      "ref": "Promise[\"resolve\"]"
    },
    "ids": "sec-promise.resolve",
    "rawBody": "{\n  0:let C = this\n  1:if (! (= (typeof C) Object)) (0) throw TypeError else 10:{}\n  2:(0) app __x0__ = (PromiseResolve C x)\n  2:return [? __x0__]\n}"
  }, {
    "code": ["            1. Assert: Type(_C_) is Object.", "            1. If IsPromise(_x_) is *true*, then", "              1. Let _xConstructor_ be ? Get(_x_, *\"constructor\"*).", "              1. If SameValue(_xConstructor_, _C_) is *true*, return _x_.", "            1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).", "            1. Perform ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _x_ »).", "            1. Return _promiseCapability_.[[Promise]]."],
    "head": {
      "name": "PromiseResolve",
      "params": [{
        "kind": "Normal",
        "name": "C"
      }, {
        "kind": "Normal",
        "name": "x"
      }]
    },
    "ids": "sec-promise-resolve",
    "rawBody": "{\n  0:assert (= (typeof C) Object)\n  1:(0) app __x0__ = (IsPromise x)\n  1:if (= __x0__ true) {\n    2:(1) app __x1__ = (Get x \"constructor\")\n    2:let xConstructor = [? __x1__]\n    3:(2) app __x2__ = (SameValue xConstructor C)\n    3:if (= __x2__ true) return x else 10:{}\n  } else 10:{}\n  4:(3) app __x3__ = (NewPromiseCapability C)\n  4:let promiseCapability = [? __x3__]\n  5:(4) app __x4__ = (Call promiseCapability[\"Resolve\"] undefined (0) (new [x]))\n  5:[? __x4__]\n  6:return promiseCapability[\"Promise\"]\n}"
  }, {
    "code": ["          1. Return the *this* value."],
    "head": {
      "origParams": [],
      "ref": "getPromise[SYMBOL_species]"
    },
    "ids": "sec-get-promise-@@species",
    "rawBody": "return this"
  }, {
    "code": ["          1. Let _promise_ be the *this* value.", "          1. Return ? Invoke(_promise_, *\"then\"*, « *undefined*, _onRejected_ »)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "onRejected"
      }],
      "ref": "Promise[\"prototype\"][\"catch\"]"
    },
    "ids": "sec-promise.prototype.catch",
    "rawBody": "{\n  0:let promise = this\n  1:(0) app __x0__ = (Invoke promise \"then\" (0) (new [undefined, onRejected]))\n  1:return [? __x0__]\n}"
  }, {
    "code": ["          1. Let _promise_ be the *this* value.", "          1. If Type(_promise_) is not Object, throw a *TypeError* exception.", "          1. Let _C_ be ? SpeciesConstructor(_promise_, %Promise%).", "          1. Assert: IsConstructor(_C_) is *true*.", "          1. If IsCallable(_onFinally_) is *false*, then", "            1. Let _thenFinally_ be _onFinally_.", "            1. Let _catchFinally_ be _onFinally_.", "          1. Else,", "            1. Let _stepsThenFinally_ be the algorithm steps defined in <emu-xref href=\"#sec-thenfinallyfunctions\" title></emu-xref>.", "            1. Let _lengthThenFinally_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#sec-thenfinallyfunctions\" title></emu-xref>.", "            1. Let _thenFinally_ be ! CreateBuiltinFunction(_stepsThenFinally_, _lengthThenFinally_, *\"\"*, « [[Constructor]], [[OnFinally]] »).", "            1. Set _thenFinally_.[[Constructor]] to _C_.", "            1. Set _thenFinally_.[[OnFinally]] to _onFinally_.", "            1. Let _stepsCatchFinally_ be the algorithm steps defined in <emu-xref href=\"#sec-catchfinallyfunctions\" title></emu-xref>.", "            1. Let _lengthCatchFinally_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#sec-catchfinallyfunctions\" title></emu-xref>.", "            1. Let _catchFinally_ be ! CreateBuiltinFunction(_stepsCatchFinally_, _lengthCatchFinally_, *\"\"*, « [[Constructor]], [[OnFinally]] »).", "            1. Set _catchFinally_.[[Constructor]] to _C_.", "            1. Set _catchFinally_.[[OnFinally]] to _onFinally_.", "          1. Return ? Invoke(_promise_, *\"then\"*, « _thenFinally_, _catchFinally_ »)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "onFinally"
      }],
      "ref": "Promise[\"prototype\"][\"finally\"]"
    },
    "ids": "sec-promise.prototype.finally",
    "rawBody": "{\n  0:let promise = this\n  1:if (! (= (typeof promise) Object)) (0) throw TypeError else 10:{}\n  2:(0) app __x0__ = (SpeciesConstructor promise INTRINSIC_Promise)\n  2:let C = [? __x0__]\n  3:(1) app __x1__ = (IsConstructor C)\n  3:assert (= __x1__ true)\n  7:(2) app __x2__ = (IsCallable onFinally)\n  7:if (= __x2__ false) {\n    5:let thenFinally = onFinally\n    6:let catchFinally = onFinally\n  } else {\n    8:(1) ??? \"Let id:{stepsThenFinally} be the algorithm steps defined in link:{sec-thenfinallyfunctions} .\"\n    9:(2) ??? \"Let id:{lengthThenFinally} be the number of non - optional parameters of the function definition in link:{sec-thenfinallyfunctions} .\"\n    10:(3) app __x3__ = (CreateBuiltinFunction stepsThenFinally lengthThenFinally \"\" (3) (new [\"Constructor\", \"OnFinally\"]))\n    10:let thenFinally = [! __x3__]\n    11:thenFinally[\"Constructor\"] = C\n    12:thenFinally[\"OnFinally\"] = onFinally\n    13:(4) ??? \"Let id:{stepsCatchFinally} be the algorithm steps defined in link:{sec-catchfinallyfunctions} .\"\n    14:(5) ??? \"Let id:{lengthCatchFinally} be the number of non - optional parameters of the function definition in link:{sec-catchfinallyfunctions} .\"\n    15:(4) app __x4__ = (CreateBuiltinFunction stepsCatchFinally lengthCatchFinally \"\" (6) (new [\"Constructor\", \"OnFinally\"]))\n    15:let catchFinally = [! __x4__]\n    16:catchFinally[\"Constructor\"] = C\n    17:catchFinally[\"OnFinally\"] = onFinally\n  }\n  18:(5) app __x5__ = (Invoke promise \"then\" (7) (new [thenFinally, catchFinally]))\n  18:return [? __x5__]\n}"
  }, {
    "code": ["            1. Let _F_ be the active function object.", "            1. Let _onFinally_ be _F_.[[OnFinally]].", "            1. Assert: IsCallable(_onFinally_) is *true*.", "            1. Let _result_ be ? Call(_onFinally_, *undefined*).", "            1. Let _C_ be _F_.[[Constructor]].", "            1. Assert: IsConstructor(_C_) is *true*.", "            1. Let _promise_ be ? PromiseResolve(_C_, _result_).", "            1. Let _valueThunk_ be equivalent to a function that returns _value_.", "            1. Return ? Invoke(_promise_, *\"then\"*, « _valueThunk_ »)."],
    "head": {
      "name": "ThenFinallyFunctions",
      "params": []
    },
    "ids": "sec-thenfinallyfunctions",
    "rawBody": "{\n  0:let F = CONTEXT[\"Function\"]\n  1:let onFinally = F[\"OnFinally\"]\n  2:(0) app __x0__ = (IsCallable onFinally)\n  2:assert (= __x0__ true)\n  3:(1) app __x1__ = (Call onFinally undefined)\n  3:let result = [? __x1__]\n  4:let C = F[\"Constructor\"]\n  5:(2) app __x2__ = (IsConstructor C)\n  5:assert (= __x2__ true)\n  6:(3) app __x3__ = (PromiseResolve C result)\n  6:let promise = [? __x3__]\n  7:(0) ??? \"Let id:{valueThunk} be equivalent to a function that returns id:{value} .\"\n  8:(4) app __x4__ = (Invoke promise \"then\" (1) (new [valueThunk]))\n  8:return [? __x4__]\n}"
  }, {
    "code": ["            1. Let _F_ be the active function object.", "            1. Let _onFinally_ be _F_.[[OnFinally]].", "            1. Assert: IsCallable(_onFinally_) is *true*.", "            1. Let _result_ be ? Call(_onFinally_, *undefined*).", "            1. Let _C_ be _F_.[[Constructor]].", "            1. Assert: IsConstructor(_C_) is *true*.", "            1. Let _promise_ be ? PromiseResolve(_C_, _result_).", "            1. Let _thrower_ be equivalent to a function that throws _reason_.", "            1. Return ? Invoke(_promise_, *\"then\"*, « _thrower_ »)."],
    "head": {
      "name": "CatchFinallyFunctions",
      "params": []
    },
    "ids": "sec-catchfinallyfunctions",
    "rawBody": "{\n  0:let F = CONTEXT[\"Function\"]\n  1:let onFinally = F[\"OnFinally\"]\n  2:(0) app __x0__ = (IsCallable onFinally)\n  2:assert (= __x0__ true)\n  3:(1) app __x1__ = (Call onFinally undefined)\n  3:let result = [? __x1__]\n  4:let C = F[\"Constructor\"]\n  5:(2) app __x2__ = (IsConstructor C)\n  5:assert (= __x2__ true)\n  6:(3) app __x3__ = (PromiseResolve C result)\n  6:let promise = [? __x3__]\n  7:(0) ??? \"Let id:{thrower} be equivalent to a function that throws id:{reason} .\"\n  8:(4) app __x4__ = (Invoke promise \"then\" (1) (new [thrower]))\n  8:return [? __x4__]\n}"
  }, {
    "code": ["          1. Let _promise_ be the *this* value.", "          1. If IsPromise(_promise_) is *false*, throw a *TypeError* exception.", "          1. Let _C_ be ? SpeciesConstructor(_promise_, %Promise%).", "          1. Let _resultCapability_ be ? NewPromiseCapability(_C_).", "          1. Return PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_, _resultCapability_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "onFulfilled"
      }, {
        "kind": "Normal",
        "name": "onRejected"
      }],
      "ref": "Promise[\"prototype\"][\"then\"]"
    },
    "ids": "sec-promise.prototype.then",
    "rawBody": "{\n  0:let promise = this\n  1:(0) app __x0__ = (IsPromise promise)\n  1:if (= __x0__ false) (0) throw TypeError else 10:{}\n  2:(1) app __x1__ = (SpeciesConstructor promise INTRINSIC_Promise)\n  2:let C = [? __x1__]\n  3:(2) app __x2__ = (NewPromiseCapability C)\n  3:let resultCapability = [? __x2__]\n  4:(3) app __x3__ = (PerformPromiseThen promise onFulfilled onRejected resultCapability)\n  4:return __x3__\n}"
  }, {
    "code": ["            1. Assert: IsPromise(_promise_) is *true*.", "            1. If _resultCapability_ is not present, then", "              1. Set _resultCapability_ to *undefined*.", "            1. If IsCallable(_onFulfilled_) is *false*, then", "              1. Let _onFulfilledJobCallback_ be ~empty~.", "            1. Else,", "              1. Let _onFulfilledJobCallback_ be HostMakeJobCallback(_onFulfilled_).", "            1. If IsCallable(_onRejected_) is *false*, then", "              1. Let _onRejectedJobCallback_ be ~empty~.", "            1. Else,", "              1. Let _onRejectedJobCallback_ be HostMakeJobCallback(_onRejected_).", "            1. Let _fulfillReaction_ be the PromiseReaction { [[Capability]]: _resultCapability_, [[Type]]: ~Fulfill~, [[Handler]]: _onFulfilledJobCallback_ }.", "            1. Let _rejectReaction_ be the PromiseReaction { [[Capability]]: _resultCapability_, [[Type]]: ~Reject~, [[Handler]]: _onRejectedJobCallback_ }.", "            1. If _promise_.[[PromiseState]] is ~pending~, then", "              1. Append _fulfillReaction_ as the last element of the List that is _promise_.[[PromiseFulfillReactions]].", "              1. Append _rejectReaction_ as the last element of the List that is _promise_.[[PromiseRejectReactions]].", "            1. Else if _promise_.[[PromiseState]] is ~fulfilled~, then", "              1. Let _value_ be _promise_.[[PromiseResult]].", "              1. Let _fulfillJob_ be NewPromiseReactionJob(_fulfillReaction_, _value_).", "              1. Perform HostEnqueuePromiseJob(_fulfillJob_.[[Job]], _fulfillJob_.[[Realm]]).", "            1. Else,", "              1. Assert: The value of _promise_.[[PromiseState]] is ~rejected~.", "              1. Let _reason_ be _promise_.[[PromiseResult]].", "              1. If _promise_.[[PromiseIsHandled]] is *false*, perform HostPromiseRejectionTracker(_promise_, *\"handle\"*).", "              1. Let _rejectJob_ be NewPromiseReactionJob(_rejectReaction_, _reason_).", "              1. Perform HostEnqueuePromiseJob(_rejectJob_.[[Job]], _rejectJob_.[[Realm]]).", "            1. Set _promise_.[[PromiseIsHandled]] to *true*.", "            1. If _resultCapability_ is *undefined*, then", "              1. Return *undefined*.", "            1. Else,", "              1. Return _resultCapability_.[[Promise]]."],
    "head": {
      "name": "PerformPromiseThen",
      "params": [{
        "kind": "Normal",
        "name": "promise"
      }, {
        "kind": "Normal",
        "name": "onFulfilled"
      }, {
        "kind": "Normal",
        "name": "onRejected"
      }, {
        "kind": "Optional",
        "name": "resultCapability"
      }]
    },
    "ids": "sec-performpromisethen",
    "rawBody": "{\n  0:(0) app __x0__ = (IsPromise promise)\n  0:assert (= __x0__ true)\n  1:if (= resultCapability absent) resultCapability = undefined else 10:{}\n  5:(1) app __x1__ = (IsCallable onFulfilled)\n  5:if (= __x1__ false) let onFulfilledJobCallback = CONST_empty else {\n    6:(2) app __x2__ = (HostMakeJobCallback onFulfilled)\n    6:let onFulfilledJobCallback = __x2__\n  }\n  9:(3) app __x3__ = (IsCallable onRejected)\n  9:if (= __x3__ false) let onRejectedJobCallback = CONST_empty else {\n    10:(4) app __x4__ = (HostMakeJobCallback onRejected)\n    10:let onRejectedJobCallback = __x4__\n  }\n  11:let fulfillReaction = (0) (new PromiseReaction(\"Capability\" -> resultCapability, \"Type\" -> CONST_Fulfill, \"Handler\" -> onFulfilledJobCallback))\n  12:let rejectReaction = (1) (new PromiseReaction(\"Capability\" -> resultCapability, \"Type\" -> CONST_Reject, \"Handler\" -> onRejectedJobCallback))\n  20:if (= promise[\"PromiseState\"] CONST_pending) {\n    14:append fulfillReaction -> promise[\"PromiseFulfillReactions\"]\n    15:append rejectReaction -> promise[\"PromiseRejectReactions\"]\n  } else if (= promise[\"PromiseState\"] CONST_fulfilled) {\n    17:let value = promise[\"PromiseResult\"]\n    18:(5) app __x5__ = (NewPromiseReactionJob fulfillReaction value)\n    18:let fulfillJob = __x5__\n    19:(6) app __x6__ = (HostEnqueuePromiseJob fulfillJob[\"Job\"] fulfillJob[\"Realm\"])\n    19:__x6__\n  } else {\n    21:assert (= promise[\"PromiseState\"] CONST_rejected)\n    22:let reason = promise[\"PromiseResult\"]\n    23:if (= promise[\"PromiseIsHandled\"] false) {\n      (7) app __x7__ = (HostPromiseRejectionTracker promise \"handle\")\n      __x7__\n    } else 10:{}\n    24:(8) app __x8__ = (NewPromiseReactionJob rejectReaction reason)\n    24:let rejectJob = __x8__\n    25:(9) app __x9__ = (HostEnqueuePromiseJob rejectJob[\"Job\"] rejectJob[\"Realm\"])\n    25:__x9__\n  }\n  26:promise[\"PromiseIsHandled\"] = true\n  29:if (= resultCapability undefined) return undefined else return resultCapability[\"Promise\"]\n}"
  }, {
    "code": ["          1. Let _C_ be the active function object.", "          1. Let _args_ be the _argumentsList_ that was passed to this function by [[Call]] or [[Construct]].", "          1. Return ? CreateDynamicFunction(_C_, NewTarget, ~generator~, _args_)."],
    "head": {
      "origParams": [],
      "ref": "GeneratorFunction"
    },
    "ids": "sec-generatorfunction",
    "rawBody": "{\n  0:let C = CONTEXT[\"Function\"]\n  1:let args = argumentsList\n  2:(0) app __x0__ = (CreateDynamicFunction C NewTarget CONST_generator args)\n  2:return [? __x0__]\n}"
  }, {
    "code": ["          1. Let _C_ be the active function object.", "          1. Let _args_ be the _argumentsList_ that was passed to this function by [[Call]] or [[Construct]].", "          1. Return ? CreateDynamicFunction(_C_, NewTarget, ~asyncGenerator~, _args_)."],
    "head": {
      "origParams": [],
      "ref": "AsyncGeneratorFunction"
    },
    "ids": "sec-asyncgeneratorfunction",
    "rawBody": "{\n  0:let C = CONTEXT[\"Function\"]\n  1:let args = argumentsList\n  2:(0) app __x0__ = (CreateDynamicFunction C NewTarget CONST_asyncGenerator args)\n  2:return [? __x0__]\n}"
  }, {
    "code": ["          1. Let _g_ be the *this* value.", "          1. Return ? GeneratorResume(_g_, _value_, ~empty~)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "value"
      }],
      "ref": "Generator[\"prototype\"][\"next\"]"
    },
    "ids": "sec-generator.prototype.next",
    "rawBody": "{\n  0:let g = this\n  1:(0) app __x0__ = (GeneratorResume g value CONST_empty)\n  1:return [? __x0__]\n}"
  }, {
    "code": ["          1. Let _g_ be the *this* value.", "          1. Let _C_ be Completion { [[Type]]: ~return~, [[Value]]: _value_, [[Target]]: ~empty~ }.", "          1. Return ? GeneratorResumeAbrupt(_g_, _C_, ~empty~)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "value"
      }],
      "ref": "Generator[\"prototype\"][\"return\"]"
    },
    "ids": "sec-generator.prototype.return",
    "rawBody": "{\n  0:let g = this\n  1:let C = (0) (new Completion(\"Type\" -> CONST_return, \"Value\" -> value, \"Target\" -> CONST_empty))\n  2:(0) app __x0__ = (GeneratorResumeAbrupt g C CONST_empty)\n  2:return [? __x0__]\n}"
  }, {
    "code": ["          1. Let _g_ be the *this* value.", "          1. Let _C_ be ThrowCompletion(_exception_).", "          1. Return ? GeneratorResumeAbrupt(_g_, _C_, ~empty~)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "exception"
      }],
      "ref": "Generator[\"prototype\"][\"throw\"]"
    },
    "ids": "sec-generator.prototype.throw",
    "rawBody": "{\n  0:let g = this\n  1:(0) app __x0__ = (ThrowCompletion exception)\n  1:let C = __x0__\n  2:(1) app __x1__ = (GeneratorResumeAbrupt g C CONST_empty)\n  2:return [? __x1__]\n}"
  }, {
    "code": ["          1. Assert: The value of _generator_.[[GeneratorState]] is *undefined*.", "          1. Let _genContext_ be the running execution context.", "          1. Set the Generator component of _genContext_ to _generator_.", "          1. Set the code evaluation state of _genContext_ such that when evaluation is resumed for that execution context the following steps will be performed:", "            1. If _generatorBody_ is a Parse Node, then", "              1. Let _result_ be the result of evaluating _generatorBody_.", "            1. Else,", "              1. Assert: _generatorBody_ is an Abstract Closure with no parameters.", "              1. Let _result_ be _generatorBody_().", "            1. Assert: If we return here, the generator either threw an exception or performed either an implicit or explicit return.", "            1. Remove _genContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.", "            1. Set _generator_.[[GeneratorState]] to ~completed~.", "            1. Once a generator enters the ~completed~ state it never leaves it and its associated execution context is never resumed. Any execution state associated with _generator_ can be discarded at this point.", "            1. If _result_.[[Type]] is ~normal~, let _resultValue_ be *undefined*.", "            1. Else if _result_.[[Type]] is ~return~, let _resultValue_ be _result_.[[Value]].", "            1. Else,", "              1. Assert: _result_.[[Type]] is ~throw~.", "              1. Return Completion(_result_).", "            1. Return CreateIterResultObject(_resultValue_, *true*).", "          1. Set _generator_.[[GeneratorContext]] to _genContext_.", "          1. Set _generator_.[[GeneratorState]] to ~suspendedStart~.", "          1. Return NormalCompletion(*undefined*)."],
    "head": {
      "name": "GeneratorStart",
      "params": [{
        "kind": "Normal",
        "name": "generator"
      }, {
        "kind": "Normal",
        "name": "generatorBody"
      }]
    },
    "ids": "sec-generatorstart",
    "rawBody": "{\n  0:assert (= generator[\"GeneratorState\"] undefined)\n  1:let genContext = CONTEXT\n  2:genContext[\"Generator\"] = generator\n  3:(0) ??? \"Set the code evaluation state of id:{genContext} such that when evaluation is resumed for that execution context the following steps will be performed : in:{} out:{}\"\n  19:generator[\"GeneratorContext\"] = genContext\n  20:generator[\"GeneratorState\"] = CONST_suspendedStart\n  21:return undefined\n}"
  }, {
    "code": ["          1. Perform ? RequireInternalSlot(_generator_, [[GeneratorState]]).", "          1. Perform ? RequireInternalSlot(_generator_, [[GeneratorBrand]]).", "          1. If _generator_.[[GeneratorBrand]] is not the same value as _generatorBrand_, throw a *TypeError* exception.", "          1. Assert: _generator_ also has a [[GeneratorContext]] internal slot.", "          1. Let _state_ be _generator_.[[GeneratorState]].", "          1. If _state_ is ~executing~, throw a *TypeError* exception.", "          1. Return _state_."],
    "head": {
      "name": "GeneratorValidate",
      "params": [{
        "kind": "Normal",
        "name": "generator"
      }, {
        "kind": "Normal",
        "name": "generatorBrand"
      }]
    },
    "ids": "sec-generatorvalidate",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireInternalSlot generator \"GeneratorState\")\n  0:[? __x0__]\n  1:(1) app __x1__ = (RequireInternalSlot generator \"GeneratorBrand\")\n  1:[? __x1__]\n  2:if (! (= generator[\"GeneratorBrand\"] generatorBrand)) (0) throw TypeError else 3:{}\n  4:let state = generator[\"GeneratorState\"]\n  5:if (= state CONST_executing) (1) throw TypeError else 3:{}\n  6:return state\n}"
  }, {
    "code": ["          1. Let _state_ be ? GeneratorValidate(_generator_, _generatorBrand_).", "          1. If _state_ is ~completed~, return CreateIterResultObject(*undefined*, *true*).", "          1. Assert: _state_ is either ~suspendedStart~ or ~suspendedYield~.", "          1. Let _genContext_ be _generator_.[[GeneratorContext]].", "          1. Let _methodContext_ be the running execution context.", "          1. Suspend _methodContext_.", "          1. Set _generator_.[[GeneratorState]] to ~executing~.", "          1. Push _genContext_ onto the execution context stack; _genContext_ is now the running execution context.", "          1. Resume the suspended evaluation of _genContext_ using NormalCompletion(_value_) as the result of the operation that suspended it. Let _result_ be the value returned by the resumed computation.", "          1. Assert: When we return here, _genContext_ has already been removed from the execution context stack and _methodContext_ is the currently running execution context.", "          1. Return Completion(_result_)."],
    "head": {
      "name": "GeneratorResume",
      "params": [{
        "kind": "Normal",
        "name": "generator"
      }, {
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "generatorBrand"
      }]
    },
    "ids": "sec-generatorresume",
    "rawBody": "{\n  0:(0) app __x0__ = (GeneratorValidate generator generatorBrand)\n  0:let state = [? __x0__]\n  1:if (= state CONST_completed) {\n    (1) app __x1__ = (CreateIterResultObject undefined true)\n    return __x1__\n  } else 9:{}\n  2:assert (|| (= state CONST_suspendedStart) (= state CONST_suspendedYield))\n  3:let genContext = generator[\"GeneratorContext\"]\n  4:let methodContext = CONTEXT\n  5:CONTEXT = null\n  6:generator[\"GeneratorState\"] = CONST_executing\n  7:append genContext -> EXECUTION_STACK\n  7:CONTEXT = EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)]\n  8:(0) ??? \"Resume the suspended evaluation of id:{genContext} using NormalCompletion ( id:{value} ) as the result of the operation that suspended it . Let id:{result} be the value returned by the resumed computation .\"\n  10:return result\n}"
  }, {
    "code": ["          1. Let _state_ be ? GeneratorValidate(_generator_, _generatorBrand_).", "          1. If _state_ is ~suspendedStart~, then", "            1. Set _generator_.[[GeneratorState]] to ~completed~.", "            1. Once a generator enters the ~completed~ state it never leaves it and its associated execution context is never resumed. Any execution state associated with _generator_ can be discarded at this point.", "            1. Set _state_ to ~completed~.", "          1. If _state_ is ~completed~, then", "            1. If _abruptCompletion_.[[Type]] is ~return~, then", "              1. Return CreateIterResultObject(_abruptCompletion_.[[Value]], *true*).", "            1. Return Completion(_abruptCompletion_).", "          1. Assert: _state_ is ~suspendedYield~.", "          1. Let _genContext_ be _generator_.[[GeneratorContext]].", "          1. Let _methodContext_ be the running execution context.", "          1. Suspend _methodContext_.", "          1. Set _generator_.[[GeneratorState]] to ~executing~.", "          1. Push _genContext_ onto the execution context stack; _genContext_ is now the running execution context.", "          1. Resume the suspended evaluation of _genContext_ using _abruptCompletion_ as the result of the operation that suspended it. Let _result_ be the completion record returned by the resumed computation.", "          1. Assert: When we return here, _genContext_ has already been removed from the execution context stack and _methodContext_ is the currently running execution context.", "          1. Return Completion(_result_)."],
    "head": {
      "name": "GeneratorResumeAbrupt",
      "params": [{
        "kind": "Normal",
        "name": "generator"
      }, {
        "kind": "Normal",
        "name": "abruptCompletion"
      }, {
        "kind": "Normal",
        "name": "generatorBrand"
      }]
    },
    "ids": "sec-generatorresumeabrupt",
    "rawBody": "{\n  0:(0) app __x0__ = (GeneratorValidate generator generatorBrand)\n  0:let state = [? __x0__]\n  1:if (= state CONST_suspendedStart) {\n    2:generator[\"GeneratorState\"] = CONST_completed\n    4:state = CONST_completed\n  } else 16:{}\n  5:if (= state CONST_completed) {\n    6:if (= abruptCompletion[\"Type\"] CONST_return) {\n      7:(1) app __x1__ = (CreateIterResultObject abruptCompletion[\"Value\"] true)\n      7:return __x1__\n    } else 16:{}\n    8:return abruptCompletion\n  } else 16:{}\n  9:assert (= state CONST_suspendedYield)\n  10:let genContext = generator[\"GeneratorContext\"]\n  11:let methodContext = CONTEXT\n  12:CONTEXT = null\n  13:generator[\"GeneratorState\"] = CONST_executing\n  14:append genContext -> EXECUTION_STACK\n  14:CONTEXT = EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)]\n  15:(0) ??? \"Resume the suspended evaluation of id:{genContext} using id:{abruptCompletion} as the result of the operation that suspended it . Let id:{result} be the completion record returned by the resumed computation .\"\n  17:return result\n}"
  }, {
    "code": ["          1. Let _genContext_ be the running execution context.", "          1. If _genContext_ does not have a Generator component, return ~non-generator~.", "          1. Let _generator_ be the Generator component of _genContext_.", "          1. If _generator_ has an [[AsyncGeneratorState]] internal slot, return ~async~.", "          1. Else, return ~sync~."],
    "head": {
      "name": "GetGeneratorKind",
      "params": []
    },
    "ids": "sec-getgeneratorkind",
    "rawBody": "{\n  0:let genContext = CONTEXT\n  1:if (= genContext[\"Generator\"] absent) return CONST_nonDASHgenerator else 16:{}\n  2:let generator = genContext[\"Generator\"]\n  4:if (! (= generator[\"AsyncGeneratorState\"] absent)) return CONST_async else return CONST_sync\n}"
  }, {
    "code": ["          1. Assert: _iterNextObj_ is an Object that implements the <i>IteratorResult</i> interface.", "          1. Let _genContext_ be the running execution context.", "          1. Assert: _genContext_ is the execution context of a generator.", "          1. Let _generator_ be the value of the Generator component of _genContext_.", "          1. Assert: GetGeneratorKind() is ~sync~.", "          1. Set _generator_.[[GeneratorState]] to ~suspendedYield~.", "          1. Remove _genContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.", "          1. Set the code evaluation state of _genContext_ such that when evaluation is resumed with a Completion _resumptionValue_ the following steps will be performed:", "            1. Return _resumptionValue_.", "            1. NOTE: This returns to the evaluation of the |YieldExpression| that originally called this abstract operation.", "          1. Return NormalCompletion(_iterNextObj_).", "          1. NOTE: This returns to the evaluation of the operation that had most previously resumed evaluation of _genContext_."],
    "head": {
      "name": "GeneratorYield",
      "params": [{
        "kind": "Normal",
        "name": "iterNextObj"
      }]
    },
    "ids": "sec-generatoryield",
    "rawBody": "{\n  1:let genContext = CONTEXT\n  3:let generator = genContext[\"Generator\"]\n  4:(0) app __x0__ = (GetGeneratorKind)\n  4:assert (= __x0__ CONST_sync)\n  5:generator[\"GeneratorState\"] = CONST_suspendedYield\n  6:if (= EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)] genContext) {\n    let __x1__ = (- EXECUTION_STACK[\"length\"] 1i)\n    (pop EXECUTION_STACK __x1__)\n  } else {}\n  6:CONTEXT = EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)]\n  7:(0) ??? \"Set the code evaluation state of id:{genContext} such that when evaluation is resumed with a Completion id:{resumptionValue} the following steps will be performed : in:{} out:{}\"\n  10:return iterNextObj\n}"
  }, {
    "code": ["          1. Let _generatorKind_ be ! GetGeneratorKind().", "          1. If _generatorKind_ is ~async~, return ? AsyncGeneratorYield(_value_).", "          1. Otherwise, return ? GeneratorYield(! CreateIterResultObject(_value_, *false*))."],
    "head": {
      "name": "Yield",
      "params": [{
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "sec-yield",
    "rawBody": "{\n  0:(0) app __x0__ = (GetGeneratorKind)\n  0:let generatorKind = [! __x0__]\n  2:if (= generatorKind CONST_async) {\n    (1) app __x1__ = (AsyncGeneratorYield value)\n    return [? __x1__]\n  } else {\n    (2) app __x2__ = (CreateIterResultObject value false)\n    (3) app __x3__ = (GeneratorYield [! __x2__])\n    return [? __x3__]\n  }\n}"
  }, {
    "code": ["          1. NOTE: _closure_ can contain uses of the Yield shorthand to yield an IteratorResult object.", "          1. Let _internalSlotsList_ be « [[GeneratorState]], [[GeneratorContext]], [[GeneratorBrand]] ».", "          1. Let _generator_ be ! OrdinaryObjectCreate(_generatorPrototype_, _internalSlotsList_).", "          1. Set _generator_.[[GeneratorBrand]] to _generatorBrand_.", "          1. Set _generator_.[[GeneratorState]] to *undefined*.", "          1. Perform ! GeneratorStart(_generator_, _closure_).", "          1. Return _generator_."],
    "head": {
      "name": "CreateIteratorFromClosure",
      "params": [{
        "kind": "Normal",
        "name": "closure"
      }, {
        "kind": "Normal",
        "name": "generatorBrand"
      }, {
        "kind": "Normal",
        "name": "generatorPrototype"
      }]
    },
    "ids": "sec-createiteratorfromclosure",
    "rawBody": "{\n  1:let internalSlotsList = (0) (new [\"GeneratorState\", \"GeneratorContext\", \"GeneratorBrand\"])\n  2:(0) app __x0__ = (OrdinaryObjectCreate generatorPrototype internalSlotsList)\n  2:let generator = [! __x0__]\n  3:generator[\"GeneratorBrand\"] = generatorBrand\n  4:generator[\"GeneratorState\"] = undefined\n  5:(1) app __x1__ = (GeneratorStart generator closure)\n  5:[! __x1__]\n  6:return generator\n}"
  }, {
    "code": ["          1. Let _generator_ be the *this* value.", "          1. Let _completion_ be NormalCompletion(_value_).", "          1. Return ! AsyncGeneratorEnqueue(_generator_, _completion_, ~empty~)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "value"
      }],
      "ref": "AsyncGenerator[\"prototype\"][\"next\"]"
    },
    "ids": "sec-asyncgenerator-prototype-next",
    "rawBody": "{\n  0:let generator = this\n  1:(0) app __x0__ = (NormalCompletion value)\n  1:let completion = __x0__\n  2:(1) app __x1__ = (AsyncGeneratorEnqueue generator completion CONST_empty)\n  2:return [! __x1__]\n}"
  }, {
    "code": ["          1. Let _generator_ be the *this* value.", "          1. Let _completion_ be Completion { [[Type]]: ~return~, [[Value]]: _value_, [[Target]]: ~empty~ }.", "          1. Return ! AsyncGeneratorEnqueue(_generator_, _completion_, ~empty~)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "value"
      }],
      "ref": "AsyncGenerator[\"prototype\"][\"return\"]"
    },
    "ids": "sec-asyncgenerator-prototype-return",
    "rawBody": "{\n  0:let generator = this\n  1:let completion = (0) (new Completion(\"Type\" -> CONST_return, \"Value\" -> value, \"Target\" -> CONST_empty))\n  2:(0) app __x0__ = (AsyncGeneratorEnqueue generator completion CONST_empty)\n  2:return [! __x0__]\n}"
  }, {
    "code": ["          1. Let _generator_ be the *this* value.", "          1. Let _completion_ be ThrowCompletion(_exception_).", "          1. Return ! AsyncGeneratorEnqueue(_generator_, _completion_, ~empty~)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "exception"
      }],
      "ref": "AsyncGenerator[\"prototype\"][\"throw\"]"
    },
    "ids": "sec-asyncgenerator-prototype-throw",
    "rawBody": "{\n  0:let generator = this\n  1:(0) app __x0__ = (ThrowCompletion exception)\n  1:let completion = __x0__\n  2:(1) app __x1__ = (AsyncGeneratorEnqueue generator completion CONST_empty)\n  2:return [! __x1__]\n}"
  }, {
    "code": ["          1. Assert: _generator_ is an AsyncGenerator instance.", "          1. Assert: _generator_.[[AsyncGeneratorState]] is *undefined*.", "          1. Let _genContext_ be the running execution context.", "          1. Set the Generator component of _genContext_ to _generator_.", "          1. Set the code evaluation state of _genContext_ such that when evaluation is resumed for that execution context the following steps will be performed:", "            1. If _generatorBody_ is a Parse Node, then", "              1. Let _result_ be the result of evaluating _generatorBody_.", "            1. Else,", "              1. Assert: _generatorBody_ is an Abstract Closure with no parameters.", "              1. Let _result_ be _generatorBody_().", "            1. Assert: If we return here, the async generator either threw an exception or performed either an implicit or explicit return.", "            1. Remove _genContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.", "            1. Set _generator_.[[AsyncGeneratorState]] to ~completed~.", "            1. If _result_ is a normal completion, let _resultValue_ be *undefined*.", "            1. Else,", "              1. Let _resultValue_ be _result_.[[Value]].", "              1. If _result_.[[Type]] is not ~return~, then", "                1. Return ! AsyncGeneratorReject(_generator_, _resultValue_).", "            1. Return ! AsyncGeneratorResolve(_generator_, _resultValue_, *true*).", "          1. Set _generator_.[[AsyncGeneratorContext]] to _genContext_.", "          1. Set _generator_.[[AsyncGeneratorState]] to ~suspendedStart~.", "          1. Set _generator_.[[AsyncGeneratorQueue]] to a new empty List.", "          1. Return *undefined*."],
    "head": {
      "name": "AsyncGeneratorStart",
      "params": [{
        "kind": "Normal",
        "name": "generator"
      }, {
        "kind": "Normal",
        "name": "generatorBody"
      }]
    },
    "ids": "sec-asyncgeneratorstart",
    "rawBody": "{\n  1:assert (= generator[\"AsyncGeneratorState\"] undefined)\n  2:let genContext = CONTEXT\n  3:genContext[\"Generator\"] = generator\n  4:(0) ??? \"Set the code evaluation state of id:{genContext} such that when evaluation is resumed for that execution context the following steps will be performed : in:{} out:{}\"\n  19:generator[\"AsyncGeneratorContext\"] = genContext\n  20:generator[\"AsyncGeneratorState\"] = CONST_suspendedStart\n  21:generator[\"AsyncGeneratorQueue\"] = (1) (new [])\n  22:return undefined\n}"
  }, {
    "code": ["          1. Perform ? RequireInternalSlot(_generator_, [[AsyncGeneratorContext]]).", "          1. Perform ? RequireInternalSlot(_generator_, [[AsyncGeneratorState]]).", "          1. Perform ? RequireInternalSlot(_generator_, [[AsyncGeneratorQueue]]).", "          1. If _generator_.[[GeneratorBrand]] is not the same value as _generatorBrand_, throw a *TypeError* exception."],
    "head": {
      "name": "AsyncGeneratorValidate",
      "params": [{
        "kind": "Normal",
        "name": "generator"
      }, {
        "kind": "Normal",
        "name": "generatorBrand"
      }]
    },
    "ids": "sec-asyncgeneratorvalidate",
    "rawBody": "{\n  0:(0) app __x0__ = (RequireInternalSlot generator \"AsyncGeneratorContext\")\n  0:[? __x0__]\n  1:(1) app __x1__ = (RequireInternalSlot generator \"AsyncGeneratorState\")\n  1:[? __x1__]\n  2:(2) app __x2__ = (RequireInternalSlot generator \"AsyncGeneratorQueue\")\n  2:[? __x2__]\n  3:if (! (= generator[\"GeneratorBrand\"] generatorBrand)) (0) throw TypeError else 10:{}\n}"
  }, {
    "code": ["          1. Assert: _generator_ is an AsyncGenerator instance.", "          1. Let _queue_ be _generator_.[[AsyncGeneratorQueue]].", "          1. Assert: _queue_ is not an empty List.", "          1. Let _next_ be the first element of _queue_.", "          1. Remove the first element from _queue_.", "          1. Let _promiseCapability_ be _next_.[[Capability]].", "          1. Let _iteratorResult_ be ! CreateIterResultObject(_value_, _done_).", "          1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _iteratorResult_ »).", "          1. Perform ! AsyncGeneratorResumeNext(_generator_).", "          1. Return *undefined*."],
    "head": {
      "name": "AsyncGeneratorResolve",
      "params": [{
        "kind": "Normal",
        "name": "generator"
      }, {
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "done"
      }]
    },
    "ids": "sec-asyncgeneratorresolve",
    "rawBody": "{\n  1:let queue = generator[\"AsyncGeneratorQueue\"]\n  2:assert (< 0i queue[\"length\"])\n  3:let next = queue[0i]\n  4:let __x0__ = (pop queue 0i)\n  5:let promiseCapability = next[\"Capability\"]\n  6:(0) app __x1__ = (CreateIterResultObject value done)\n  6:let iteratorResult = [! __x1__]\n  7:(1) app __x2__ = (Call promiseCapability[\"Resolve\"] undefined (0) (new [iteratorResult]))\n  7:[! __x2__]\n  8:(2) app __x3__ = (AsyncGeneratorResumeNext generator)\n  8:[! __x3__]\n  9:return undefined\n}"
  }, {
    "code": ["          1. Assert: _generator_ is an AsyncGenerator instance.", "          1. Let _queue_ be _generator_.[[AsyncGeneratorQueue]].", "          1. Assert: _queue_ is not an empty List.", "          1. Let _next_ be the first element of _queue_.", "          1. Remove the first element from _queue_.", "          1. Let _promiseCapability_ be _next_.[[Capability]].", "          1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _exception_ »).", "          1. Perform ! AsyncGeneratorResumeNext(_generator_).", "          1. Return *undefined*."],
    "head": {
      "name": "AsyncGeneratorReject",
      "params": [{
        "kind": "Normal",
        "name": "generator"
      }, {
        "kind": "Normal",
        "name": "exception"
      }]
    },
    "ids": "sec-asyncgeneratorreject",
    "rawBody": "{\n  1:let queue = generator[\"AsyncGeneratorQueue\"]\n  2:assert (< 0i queue[\"length\"])\n  3:let next = queue[0i]\n  4:let __x0__ = (pop queue 0i)\n  5:let promiseCapability = next[\"Capability\"]\n  6:(0) app __x1__ = (Call promiseCapability[\"Reject\"] undefined (0) (new [exception]))\n  6:[! __x1__]\n  7:(1) app __x2__ = (AsyncGeneratorResumeNext generator)\n  7:[! __x2__]\n  8:return undefined\n}"
  }, {
    "code": ["          1. Assert: _generator_ is an AsyncGenerator instance.", "          1. Let _state_ be _generator_.[[AsyncGeneratorState]].", "          1. Assert: _state_ is not ~executing~.", "          1. If _state_ is ~awaiting-return~, return *undefined*.", "          1. Let _queue_ be _generator_.[[AsyncGeneratorQueue]].", "          1. If _queue_ is an empty List, return *undefined*.", "          1. Let _next_ be the value of the first element of _queue_.", "          1. Assert: _next_ is an AsyncGeneratorRequest record.", "          1. Let _completion_ be _next_.[[Completion]].", "          1. If _completion_ is an abrupt completion, then", "            1. If _state_ is ~suspendedStart~, then", "              1. Set _generator_.[[AsyncGeneratorState]] to ~completed~.", "              1. Set _state_ to ~completed~.", "            1. If _state_ is ~completed~, then", "              1. If _completion_.[[Type]] is ~return~, then", "                1. Set _generator_.[[AsyncGeneratorState]] to ~awaiting-return~.", "                1. Let _promise_ be ? PromiseResolve(%Promise%, _completion_.[[Value]]).", "                1. Let _stepsFulfilled_ be the algorithm steps defined in <emu-xref href=\"#async-generator-resume-next-return-processor-fulfilled\" title></emu-xref>.", "                1. Let _lengthFulfilled_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#async-generator-resume-next-return-processor-fulfilled\" title></emu-xref>.", "                1. Let _onFulfilled_ be ! CreateBuiltinFunction(_stepsFulfilled_, _lengthFulfilled_, *\"\"*, « [[Generator]] »).", "                1. Set _onFulfilled_.[[Generator]] to _generator_.", "                1. Let _stepsRejected_ be the algorithm steps defined in <emu-xref href=\"#async-generator-resume-next-return-processor-rejected\" title></emu-xref>.", "                1. Let _lengthRejected_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#async-generator-resume-next-return-processor-rejected\" title></emu-xref>.", "                1. Let _onRejected_ be ! CreateBuiltinFunction(_stepsRejected_, _lengthRejected_, *\"\"*, « [[Generator]] »).", "                1. Set _onRejected_.[[Generator]] to _generator_.", "                1. Perform ! PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_).", "                1. Return *undefined*.", "              1. Else,", "                1. Assert: _completion_.[[Type]] is ~throw~.", "                1. Perform ! AsyncGeneratorReject(_generator_, _completion_.[[Value]]).", "                1. Return *undefined*.", "          1. Else if _state_ is ~completed~, return ! AsyncGeneratorResolve(_generator_, *undefined*, *true*).", "          1. Assert: _state_ is either ~suspendedStart~ or ~suspendedYield~.", "          1. Let _genContext_ be _generator_.[[AsyncGeneratorContext]].", "          1. Let _callerContext_ be the running execution context.", "          1. Suspend _callerContext_.", "          1. Set _generator_.[[AsyncGeneratorState]] to ~executing~.", "          1. Push _genContext_ onto the execution context stack; _genContext_ is now the running execution context.", "          1. Resume the suspended evaluation of _genContext_ using _completion_ as the result of the operation that suspended it. Let _result_ be the completion record returned by the resumed computation.", "          1. Assert: _result_ is never an abrupt completion.", "          1. Assert: When we return here, _genContext_ has already been removed from the execution context stack and _callerContext_ is the currently running execution context.", "          1. Return *undefined*."],
    "head": {
      "name": "AsyncGeneratorResumeNext",
      "params": [{
        "kind": "Normal",
        "name": "generator"
      }]
    },
    "ids": "sec-asyncgeneratorresumenext",
    "rawBody": "{\n  1:let state = generator[\"AsyncGeneratorState\"]\n  2:assert (! (= state CONST_executing))\n  3:if (= state CONST_awaitingDASHreturn) return undefined else 40:{}\n  4:let queue = generator[\"AsyncGeneratorQueue\"]\n  5:if (= queue[\"length\"] 0i) return undefined else 40:{}\n  6:let next = queue[0i]\n  8:let completion = next[\"Completion\"]\n  31:(0) app __x0__ = (IsAbruptCompletion completion)\n  31:if __x0__ {\n    10:if (= state CONST_suspendedStart) {\n      11:generator[\"AsyncGeneratorState\"] = CONST_completed\n      12:state = CONST_completed\n    } else 40:{}\n    13:if (= state CONST_completed) if (= completion[\"Type\"] CONST_return) {\n      15:generator[\"AsyncGeneratorState\"] = CONST_awaitingDASHreturn\n      16:(1) app __x1__ = (PromiseResolve INTRINSIC_Promise completion[\"Value\"])\n      16:let promise = [? __x1__]\n      17:(0) ??? \"Let id:{stepsFulfilled} be the algorithm steps defined in link:{async-generator-resume-next-return-processor-fulfilled} .\"\n      18:(1) ??? \"Let id:{lengthFulfilled} be the number of non - optional parameters of the function definition in link:{async-generator-resume-next-return-processor-fulfilled} .\"\n      19:(2) app __x2__ = (CreateBuiltinFunction stepsFulfilled lengthFulfilled \"\" (2) (new [\"Generator\"]))\n      19:let onFulfilled = [! __x2__]\n      20:onFulfilled[\"Generator\"] = generator\n      21:(3) ??? \"Let id:{stepsRejected} be the algorithm steps defined in link:{async-generator-resume-next-return-processor-rejected} .\"\n      22:(4) ??? \"Let id:{lengthRejected} be the number of non - optional parameters of the function definition in link:{async-generator-resume-next-return-processor-rejected} .\"\n      23:(3) app __x3__ = (CreateBuiltinFunction stepsRejected lengthRejected \"\" (5) (new [\"Generator\"]))\n      23:let onRejected = [! __x3__]\n      24:onRejected[\"Generator\"] = generator\n      25:(4) app __x4__ = (PerformPromiseThen promise onFulfilled onRejected)\n      25:[! __x4__]\n      26:return undefined\n    } else {\n      28:assert (= completion[\"Type\"] CONST_throw)\n      29:(5) app __x5__ = (AsyncGeneratorReject generator completion[\"Value\"])\n      29:[! __x5__]\n      30:return undefined\n    } else 40:{}\n  } else if (= state CONST_completed) {\n    (6) app __x6__ = (AsyncGeneratorResolve generator undefined true)\n    return [! __x6__]\n  } else 40:{}\n  32:assert (|| (= state CONST_suspendedStart) (= state CONST_suspendedYield))\n  33:let genContext = generator[\"AsyncGeneratorContext\"]\n  34:let callerContext = CONTEXT\n  35:CONTEXT = null\n  36:generator[\"AsyncGeneratorState\"] = CONST_executing\n  37:append genContext -> EXECUTION_STACK\n  37:CONTEXT = EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)]\n  38:(6) ??? \"Resume the suspended evaluation of id:{genContext} using id:{completion} as the result of the operation that suspended it . Let id:{result} be the completion record returned by the resumed computation .\"\n  41:return undefined\n}"
  }, {
    "code": ["            1. Let _F_ be the active function object.", "            1. Set _F_.[[Generator]].[[AsyncGeneratorState]] to ~completed~.", "            1. Return ! AsyncGeneratorResolve(_F_.[[Generator]], _value_, *true*)."],
    "head": {
      "origParams": [],
      "ref": "AsyncGeneratorResumeNextReturnProcessorFulfilledFunctions"
    },
    "ids": "async-generator-resume-next-return-processor-fulfilled",
    "rawBody": "{\n  0:let F = CONTEXT[\"Function\"]\n  1:F[\"Generator\"][\"AsyncGeneratorState\"] = CONST_completed\n  2:(0) app __x0__ = (AsyncGeneratorResolve F[\"Generator\"] value true)\n  2:return [! __x0__]\n}"
  }, {
    "code": ["            1. Let _F_ be the active function object.", "            1. Set _F_.[[Generator]].[[AsyncGeneratorState]] to ~completed~.", "            1. Return ! AsyncGeneratorReject(_F_.[[Generator]], _reason_)."],
    "head": {
      "origParams": [],
      "ref": "AsyncGeneratorResumeNextReturnProcessorRejectedFunctions"
    },
    "ids": "async-generator-resume-next-return-processor-rejected",
    "rawBody": "{\n  0:let F = CONTEXT[\"Function\"]\n  1:F[\"Generator\"][\"AsyncGeneratorState\"] = CONST_completed\n  2:(0) app __x0__ = (AsyncGeneratorReject F[\"Generator\"] reason)\n  2:return [! __x0__]\n}"
  }, {
    "code": ["          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).", "          1. Let _check_ be AsyncGeneratorValidate(_generator_, _generatorBrand_).", "          1. If _check_ is an abrupt completion, then", "            1. Let _badGeneratorError_ be a newly created *TypeError* object.", "            1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _badGeneratorError_ »).", "            1. Return _promiseCapability_.[[Promise]].", "          1. Let _queue_ be _generator_.[[AsyncGeneratorQueue]].", "          1. Let _request_ be AsyncGeneratorRequest { [[Completion]]: _completion_, [[Capability]]: _promiseCapability_ }.", "          1. Append _request_ to the end of _queue_.", "          1. Let _state_ be _generator_.[[AsyncGeneratorState]].", "          1. If _state_ is not ~executing~, then", "            1. Perform ! AsyncGeneratorResumeNext(_generator_).", "          1. Return _promiseCapability_.[[Promise]]."],
    "head": {
      "name": "AsyncGeneratorEnqueue",
      "params": [{
        "kind": "Normal",
        "name": "generator"
      }, {
        "kind": "Normal",
        "name": "completion"
      }, {
        "kind": "Normal",
        "name": "generatorBrand"
      }]
    },
    "ids": "sec-asyncgeneratorenqueue",
    "rawBody": "{\n  0:(0) app __x0__ = (NewPromiseCapability INTRINSIC_Promise)\n  0:let promiseCapability = [! __x0__]\n  1:(1) app __x1__ = (AsyncGeneratorValidate generator generatorBrand)\n  1:let check = __x1__\n  2:(2) app __x2__ = (IsAbruptCompletion check)\n  2:if __x2__ {\n    3:let badGeneratorError = (0) (new OrdinaryObject())\n    4:(3) app __x3__ = (Call promiseCapability[\"Reject\"] undefined (1) (new [badGeneratorError]))\n    4:[! __x3__]\n    5:return promiseCapability[\"Promise\"]\n  } else 40:{}\n  6:let queue = generator[\"AsyncGeneratorQueue\"]\n  7:let request = (2) (new AsyncGeneratorRequest(\"Completion\" -> completion, \"Capability\" -> promiseCapability))\n  8:append request -> queue\n  9:let state = generator[\"AsyncGeneratorState\"]\n  10:if (! (= state CONST_executing)) {\n    11:(4) app __x4__ = (AsyncGeneratorResumeNext generator)\n    11:[! __x4__]\n  } else 40:{}\n  12:return promiseCapability[\"Promise\"]\n}"
  }, {
    "code": ["          1. Let _genContext_ be the running execution context.", "          1. Assert: _genContext_ is the execution context of a generator.", "          1. Let _generator_ be the value of the Generator component of _genContext_.", "          1. Assert: GetGeneratorKind() is ~async~.", "          1. Set _value_ to ? Await(_value_).", "          1. Set _generator_.[[AsyncGeneratorState]] to ~suspendedYield~.", "          1. Remove _genContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.", "          1. Set the code evaluation state of _genContext_ such that when evaluation is resumed with a Completion _resumptionValue_ the following steps will be performed:", "            1. If _resumptionValue_.[[Type]] is not ~return~, return Completion(_resumptionValue_).", "            1. Let _awaited_ be Await(_resumptionValue_.[[Value]]).", "            1. If _awaited_.[[Type]] is ~throw~, return Completion(_awaited_).", "            1. Assert: _awaited_.[[Type]] is ~normal~.", "            1. Return Completion { [[Type]]: ~return~, [[Value]]: _awaited_.[[Value]], [[Target]]: ~empty~ }.", "            1. NOTE: When one of the above steps returns, it returns to the evaluation of the |YieldExpression| production that originally called this abstract operation.", "          1. Return ! AsyncGeneratorResolve(_generator_, _value_, *false*).", "          1. NOTE: This returns to the evaluation of the operation that had most previously resumed evaluation of _genContext_."],
    "head": {
      "name": "AsyncGeneratorYield",
      "params": [{
        "kind": "Normal",
        "name": "value"
      }]
    },
    "ids": "sec-asyncgeneratoryield",
    "rawBody": "{\n  0:let genContext = CONTEXT\n  2:let generator = genContext[\"Generator\"]\n  3:(0) app __x0__ = (GetGeneratorKind)\n  3:assert (= __x0__ CONST_async)\n  4:(1) app __x1__ = (Await value)\n  4:value = [? __x1__]\n  5:generator[\"AsyncGeneratorState\"] = CONST_suspendedYield\n  6:if (= EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)] genContext) {\n    let __x2__ = (- EXECUTION_STACK[\"length\"] 1i)\n    (pop EXECUTION_STACK __x2__)\n  } else {}\n  6:CONTEXT = EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)]\n  7:(0) ??? \"Set the code evaluation state of id:{genContext} such that when evaluation is resumed with a Completion id:{resumptionValue} the following steps will be performed : in:{} out:{}\"\n  14:(2) app __x3__ = (AsyncGeneratorResolve generator value false)\n  14:return [! __x3__]\n}"
  }, {
    "code": ["          1. NOTE: _closure_ can contain uses of the Await shorthand and uses of the Yield shorthand to yield an IteratorResult object.", "          1. Let _internalSlotsList_ be « [[AsyncGeneratorState]], [[AsyncGeneratorContext]], [[AsyncGeneratorQueue]], [[GeneratorBrand]] ».", "          1. Let _generator_ be ! OrdinaryObjectCreate(_generatorPrototype_, _internalSlotsList_).", "          1. Set _generator_.[[GeneratorBrand]] to _generatorBrand_.", "          1. Set _generator_.[[AsyncGeneratorState]] to *undefined*.", "          1. Perform ! AsyncGeneratorStart(_generator_, _closure_).", "          1. Return _generator_."],
    "head": {
      "name": "CreateAsyncIteratorFromClosure",
      "params": [{
        "kind": "Normal",
        "name": "closure"
      }, {
        "kind": "Normal",
        "name": "generatorBrand"
      }, {
        "kind": "Normal",
        "name": "generatorPrototype"
      }]
    },
    "ids": "sec-createasynciteratorfromclosure",
    "rawBody": "{\n  1:let internalSlotsList = (0) (new [\"AsyncGeneratorState\", \"AsyncGeneratorContext\", \"AsyncGeneratorQueue\", \"GeneratorBrand\"])\n  2:(0) app __x0__ = (OrdinaryObjectCreate generatorPrototype internalSlotsList)\n  2:let generator = [! __x0__]\n  3:generator[\"GeneratorBrand\"] = generatorBrand\n  4:generator[\"AsyncGeneratorState\"] = undefined\n  5:(1) app __x1__ = (AsyncGeneratorStart generator closure)\n  5:[! __x1__]\n  6:return generator\n}"
  }, {
    "code": ["          1. Let _C_ be the active function object.", "          1. Let _args_ be the _argumentsList_ that was passed to this function by [[Call]] or [[Construct]].", "          1. Return CreateDynamicFunction(_C_, NewTarget, ~async~, _args_)."],
    "head": {
      "origParams": [],
      "ref": "AsyncFunction"
    },
    "ids": "sec-async-function-constructor-arguments",
    "rawBody": "{\n  0:let C = CONTEXT[\"Function\"]\n  1:let args = argumentsList\n  2:(0) app __x0__ = (CreateDynamicFunction C NewTarget CONST_async args)\n  2:return __x0__\n}"
  }, {
    "code": ["          1. Let _runningContext_ be the running execution context.", "          1. Let _asyncContext_ be a copy of _runningContext_.", "          1. NOTE: Copying the execution state is required for the step below to resume its execution. It is ill-defined to resume a currently executing context.", "          1. Set the code evaluation state of _asyncContext_ such that when evaluation is resumed for that execution context the following steps will be performed:", "            1. Let _result_ be the result of evaluating _asyncFunctionBody_.", "            1. Assert: If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.", "            1. Remove _asyncContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.", "            1. If _result_.[[Type]] is ~normal~, then", "              1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « *undefined* »).", "            1. Else if _result_.[[Type]] is ~return~, then", "              1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _result_.[[Value]] »).", "            1. Else,", "              1. Assert: _result_.[[Type]] is ~throw~.", "              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _result_.[[Value]] »).", "            1. [id=\"step-asyncfunctionstart-return-undefined\"] Return.", "          1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.", "          1. Resume the suspended evaluation of _asyncContext_. Let _result_ be the value returned by the resumed computation.", "          1. Assert: When we return here, _asyncContext_ has already been removed from the execution context stack and _runningContext_ is the currently running execution context.", "          1. Assert: _result_ is a normal completion with a value of *undefined*. The possible sources of completion values are Await or, if the async function doesn't await anything, step <emu-xref href=\"#step-asyncfunctionstart-return-undefined\"></emu-xref> above.", "          1. Return."],
    "head": {
      "name": "AsyncFunctionStart",
      "params": [{
        "kind": "Normal",
        "name": "promiseCapability"
      }, {
        "kind": "Normal",
        "name": "asyncFunctionBody"
      }]
    },
    "ids": "sec-async-functions-abstract-operations-async-function-start",
    "rawBody": "{\n  0:let runningContext = CONTEXT\n  1:let asyncContext = (0) (copy-obj runningContext)\n  3:(1) ??? \"Set the code evaluation state of id:{asyncContext} such that when evaluation is resumed for that execution context the following steps will be performed : in:{} out:{}\"\n  15:append asyncContext -> EXECUTION_STACK\n  15:CONTEXT = EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)]\n  16:(2) ??? \"Resume the suspended evaluation of id:{asyncContext} . Let id:{result} be the value returned by the resumed computation .\"\n  19:return undefined\n}"
  }, {
    "code": ["        1. If IsCallable(_target_) is *false*, throw a *TypeError* exception.", "        1. Let _args_ be ? CreateListFromArrayLike(_argumentsList_).", "        1. Perform PrepareForTailCall().", "        1. Return ? Call(_target_, _thisArgument_, _args_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "target"
      }, {
        "kind": "Normal",
        "name": "thisArgument"
      }, {
        "kind": "Normal",
        "name": "argumentsList"
      }],
      "ref": "Reflect[\"apply\"]"
    },
    "ids": "sec-reflect.apply",
    "rawBody": "{\n  0:(0) app __x0__ = (IsCallable target)\n  0:if (= __x0__ false) (0) throw TypeError else 18:{}\n  1:(1) app __x1__ = (CreateListFromArrayLike argumentsList)\n  1:let args = [? __x1__]\n  2:(2) app __x2__ = (PrepareForTailCall)\n  2:__x2__\n  3:(3) app __x3__ = (Call target thisArgument args)\n  3:return [? __x3__]\n}"
  }, {
    "code": ["        1. If IsConstructor(_target_) is *false*, throw a *TypeError* exception.", "        1. If _newTarget_ is not present, set _newTarget_ to _target_.", "        1. Else if IsConstructor(_newTarget_) is *false*, throw a *TypeError* exception.", "        1. Let _args_ be ? CreateListFromArrayLike(_argumentsList_).", "        1. Return ? Construct(_target_, _args_, _newTarget_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "target"
      }, {
        "kind": "Normal",
        "name": "argumentsList"
      }, {
        "kind": "Optional",
        "name": "newTarget"
      }],
      "ref": "Reflect[\"construct\"]"
    },
    "ids": "sec-reflect.construct",
    "rawBody": "{\n  0:(0) app __x0__ = (IsConstructor target)\n  0:if (= __x0__ false) (0) throw TypeError else 18:{}\n  2:if (= newTarget absent) newTarget = target else {\n    (1) app __x1__ = (IsConstructor newTarget)\n    if (= __x1__ false) (1) throw TypeError else 18:{}\n  }\n  3:(2) app __x2__ = (CreateListFromArrayLike argumentsList)\n  3:let args = [? __x2__]\n  4:(3) app __x3__ = (Construct target args newTarget)\n  4:return [? __x3__]\n}"
  }, {
    "code": ["        1. If Type(_target_) is not Object, throw a *TypeError* exception.", "        1. Let _key_ be ? ToPropertyKey(_propertyKey_).", "        1. Let _desc_ be ? ToPropertyDescriptor(_attributes_).", "        1. Return ? _target_.[[DefineOwnProperty]](_key_, _desc_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "target"
      }, {
        "kind": "Normal",
        "name": "propertyKey"
      }, {
        "kind": "Normal",
        "name": "attributes"
      }],
      "ref": "Reflect[\"defineProperty\"]"
    },
    "ids": "sec-reflect.defineproperty",
    "rawBody": "{\n  0:if (! (= (typeof target) Object)) (0) throw TypeError else 18:{}\n  1:(0) app __x0__ = (ToPropertyKey propertyKey)\n  1:let key = [? __x0__]\n  2:(1) app __x1__ = (ToPropertyDescriptor attributes)\n  2:let desc = [? __x1__]\n  3:(2) app __x2__ = (target[\"DefineOwnProperty\"] target key desc)\n  3:return [? __x2__]\n}"
  }, {
    "code": ["        1. If Type(_target_) is not Object, throw a *TypeError* exception.", "        1. Let _key_ be ? ToPropertyKey(_propertyKey_).", "        1. Return ? _target_.[[Delete]](_key_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "target"
      }, {
        "kind": "Normal",
        "name": "propertyKey"
      }],
      "ref": "Reflect[\"deleteProperty\"]"
    },
    "ids": "sec-reflect.deleteproperty",
    "rawBody": "{\n  0:if (! (= (typeof target) Object)) (0) throw TypeError else 18:{}\n  1:(0) app __x0__ = (ToPropertyKey propertyKey)\n  1:let key = [? __x0__]\n  2:(1) app __x1__ = (target[\"Delete\"] target key)\n  2:return [? __x1__]\n}"
  }, {
    "code": ["        1. If Type(_target_) is not Object, throw a *TypeError* exception.", "        1. Let _key_ be ? ToPropertyKey(_propertyKey_).", "        1. If _receiver_ is not present, then", "          1. Set _receiver_ to _target_.", "        1. Return ? _target_.[[Get]](_key_, _receiver_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "target"
      }, {
        "kind": "Normal",
        "name": "propertyKey"
      }, {
        "kind": "Optional",
        "name": "receiver"
      }],
      "ref": "Reflect[\"get\"]"
    },
    "ids": "sec-reflect.get",
    "rawBody": "{\n  0:if (! (= (typeof target) Object)) (0) throw TypeError else 18:{}\n  1:(0) app __x0__ = (ToPropertyKey propertyKey)\n  1:let key = [? __x0__]\n  2:if (= receiver absent) receiver = target else 18:{}\n  4:(1) app __x1__ = (target[\"Get\"] target key receiver)\n  4:return [? __x1__]\n}"
  }, {
    "code": ["        1. If Type(_target_) is not Object, throw a *TypeError* exception.", "        1. Let _key_ be ? ToPropertyKey(_propertyKey_).", "        1. Let _desc_ be ? _target_.[[GetOwnProperty]](_key_).", "        1. Return FromPropertyDescriptor(_desc_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "target"
      }, {
        "kind": "Normal",
        "name": "propertyKey"
      }],
      "ref": "Reflect[\"getOwnPropertyDescriptor\"]"
    },
    "ids": "sec-reflect.getownpropertydescriptor",
    "rawBody": "{\n  0:if (! (= (typeof target) Object)) (0) throw TypeError else 18:{}\n  1:(0) app __x0__ = (ToPropertyKey propertyKey)\n  1:let key = [? __x0__]\n  2:(1) app __x1__ = (target[\"GetOwnProperty\"] target key)\n  2:let desc = [? __x1__]\n  3:(2) app __x2__ = (FromPropertyDescriptor desc)\n  3:return __x2__\n}"
  }, {
    "code": ["        1. If Type(_target_) is not Object, throw a *TypeError* exception.", "        1. Return ? _target_.[[GetPrototypeOf]]()."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "target"
      }],
      "ref": "Reflect[\"getPrototypeOf\"]"
    },
    "ids": "sec-reflect.getprototypeof",
    "rawBody": "{\n  0:if (! (= (typeof target) Object)) (0) throw TypeError else 18:{}\n  1:(0) app __x0__ = (target[\"GetPrototypeOf\"] target)\n  1:return [? __x0__]\n}"
  }, {
    "code": ["        1. If Type(_target_) is not Object, throw a *TypeError* exception.", "        1. Let _key_ be ? ToPropertyKey(_propertyKey_).", "        1. Return ? _target_.[[HasProperty]](_key_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "target"
      }, {
        "kind": "Normal",
        "name": "propertyKey"
      }],
      "ref": "Reflect[\"has\"]"
    },
    "ids": "sec-reflect.has",
    "rawBody": "{\n  0:if (! (= (typeof target) Object)) (0) throw TypeError else 18:{}\n  1:(0) app __x0__ = (ToPropertyKey propertyKey)\n  1:let key = [? __x0__]\n  2:(1) app __x1__ = (target[\"HasProperty\"] target key)\n  2:return [? __x1__]\n}"
  }, {
    "code": ["        1. If Type(_target_) is not Object, throw a *TypeError* exception.", "        1. Return ? _target_.[[IsExtensible]]()."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "target"
      }],
      "ref": "Reflect[\"isExtensible\"]"
    },
    "ids": "sec-reflect.isextensible",
    "rawBody": "{\n  0:if (! (= (typeof target) Object)) (0) throw TypeError else 18:{}\n  1:(0) app __x0__ = (target[\"IsExtensible\"] target)\n  1:return [? __x0__]\n}"
  }, {
    "code": ["        1. If Type(_target_) is not Object, throw a *TypeError* exception.", "        1. Let _keys_ be ? _target_.[[OwnPropertyKeys]]().", "        1. Return CreateArrayFromList(_keys_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "target"
      }],
      "ref": "Reflect[\"ownKeys\"]"
    },
    "ids": "sec-reflect.ownkeys",
    "rawBody": "{\n  0:if (! (= (typeof target) Object)) (0) throw TypeError else 18:{}\n  1:(0) app __x0__ = (target[\"OwnPropertyKeys\"] target)\n  1:let keys = [? __x0__]\n  2:(1) app __x1__ = (CreateArrayFromList keys)\n  2:return __x1__\n}"
  }, {
    "code": ["        1. If Type(_target_) is not Object, throw a *TypeError* exception.", "        1. Return ? _target_.[[PreventExtensions]]()."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "target"
      }],
      "ref": "Reflect[\"preventExtensions\"]"
    },
    "ids": "sec-reflect.preventextensions",
    "rawBody": "{\n  0:if (! (= (typeof target) Object)) (0) throw TypeError else 18:{}\n  1:(0) app __x0__ = (target[\"PreventExtensions\"] target)\n  1:return [? __x0__]\n}"
  }, {
    "code": ["        1. If Type(_target_) is not Object, throw a *TypeError* exception.", "        1. Let _key_ be ? ToPropertyKey(_propertyKey_).", "        1. If _receiver_ is not present, then", "          1. Set _receiver_ to _target_.", "        1. Return ? _target_.[[Set]](_key_, _V_, _receiver_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "target"
      }, {
        "kind": "Normal",
        "name": "propertyKey"
      }, {
        "kind": "Normal",
        "name": "V"
      }, {
        "kind": "Optional",
        "name": "receiver"
      }],
      "ref": "Reflect[\"set\"]"
    },
    "ids": "sec-reflect.set",
    "rawBody": "{\n  0:if (! (= (typeof target) Object)) (0) throw TypeError else 18:{}\n  1:(0) app __x0__ = (ToPropertyKey propertyKey)\n  1:let key = [? __x0__]\n  2:if (= receiver absent) receiver = target else 18:{}\n  4:(1) app __x1__ = (target[\"Set\"] target key V receiver)\n  4:return [? __x1__]\n}"
  }, {
    "code": ["        1. If Type(_target_) is not Object, throw a *TypeError* exception.", "        1. If Type(_proto_) is not Object and _proto_ is not *null*, throw a *TypeError* exception.", "        1. Return ? _target_.[[SetPrototypeOf]](_proto_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "target"
      }, {
        "kind": "Normal",
        "name": "proto"
      }],
      "ref": "Reflect[\"setPrototypeOf\"]"
    },
    "ids": "sec-reflect.setprototypeof",
    "rawBody": "{\n  0:if (! (= (typeof target) Object)) (0) throw TypeError else 18:{}\n  1:if (&& (! (= (typeof proto) Object)) (! (= proto null))) (1) throw TypeError else 18:{}\n  2:(0) app __x0__ = (target[\"SetPrototypeOf\"] target proto)\n  2:return [? __x0__]\n}"
  }, {
    "code": ["          1. If NewTarget is *undefined*, throw a *TypeError* exception.", "          1. Return ? ProxyCreate(_target_, _handler_)."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "target"
      }, {
        "kind": "Normal",
        "name": "handler"
      }],
      "ref": "Proxy"
    },
    "ids": "sec-proxy-target-handler",
    "rawBody": "{\n  0:if (= NewTarget undefined) (0) throw TypeError else 18:{}\n  1:(0) app __x0__ = (ProxyCreate target handler)\n  1:return [? __x0__]\n}"
  }, {
    "code": ["          1. Let _p_ be ? ProxyCreate(_target_, _handler_).", "          1. Let _steps_ be the algorithm steps defined in <emu-xref href=\"#sec-proxy-revocation-functions\" title></emu-xref>.", "          1. Let _length_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#sec-proxy-revocation-functions\" title></emu-xref>.", "          1. Let _revoker_ be ! CreateBuiltinFunction(_steps_, _length_, *\"\"*, « [[RevocableProxy]] »).", "          1. Set _revoker_.[[RevocableProxy]] to _p_.", "          1. Let _result_ be ! OrdinaryObjectCreate(%Object.prototype%).", "          1. Perform ! CreateDataPropertyOrThrow(_result_, *\"proxy\"*, _p_).", "          1. Perform ! CreateDataPropertyOrThrow(_result_, *\"revoke\"*, _revoker_).", "          1. Return _result_."],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "target"
      }, {
        "kind": "Normal",
        "name": "handler"
      }],
      "ref": "Proxy[\"revocable\"]"
    },
    "ids": "sec-proxy.revocable",
    "rawBody": "{\n  0:(0) app __x0__ = (ProxyCreate target handler)\n  0:let p = [? __x0__]\n  1:(0) ??? \"Let id:{steps} be the algorithm steps defined in link:{sec-proxy-revocation-functions} .\"\n  2:(1) ??? \"Let id:{length} be the number of non - optional parameters of the function definition in link:{sec-proxy-revocation-functions} .\"\n  3:(1) app __x1__ = (CreateBuiltinFunction steps length \"\" (2) (new [\"RevocableProxy\"]))\n  3:let revoker = [! __x1__]\n  4:revoker[\"RevocableProxy\"] = p\n  5:(2) app __x2__ = (OrdinaryObjectCreate INTRINSIC_Object_prototype)\n  5:let result = [! __x2__]\n  6:(3) app __x3__ = (CreateDataPropertyOrThrow result \"proxy\" p)\n  6:[! __x3__]\n  7:(4) app __x4__ = (CreateDataPropertyOrThrow result \"revoke\" revoker)\n  7:[! __x4__]\n  8:return result\n}"
  }, {
    "code": ["            1. Let _F_ be the active function object.", "            1. Let _p_ be _F_.[[RevocableProxy]].", "            1. If _p_ is *null*, return *undefined*.", "            1. Set _F_.[[RevocableProxy]] to *null*.", "            1. Assert: _p_ is a Proxy object.", "            1. Set _p_.[[ProxyTarget]] to *null*.", "            1. Set _p_.[[ProxyHandler]] to *null*.", "            1. Return *undefined*."],
    "head": {
      "origParams": [],
      "ref": "ProxyRevocationFunctions"
    },
    "ids": "sec-proxy-revocation-functions",
    "rawBody": "{\n  0:let F = CONTEXT[\"Function\"]\n  1:let p = F[\"RevocableProxy\"]\n  2:if (= p null) return undefined else 4:{}\n  3:F[\"RevocableProxy\"] = null\n  5:p[\"ProxyTarget\"] = null\n  6:p[\"ProxyHandler\"] = null\n  7:return undefined\n}"
  }, {
    "code": ["        1. Let _events_ be an empty Set.", "        1. For each Agent Events Record _aer_ of _execution_.[[EventsRecords]], do", "          1. For each event _E_ of _aer_.[[EventList]], do", "            1. Add _E_ to _events_.", "        1. Return _events_."],
    "head": {
      "name": "EventSet",
      "params": [{
        "kind": "Normal",
        "name": "execution"
      }]
    },
    "ids": "sec-event-set",
    "rawBody": "{\n  0:let events = (0) (new [])\n  1:let __x0__ = execution[\"EventsRecords\"]\n  1:let __x1__ = 0i\n  1:while (< __x1__ __x0__[\"length\"]) {\n    let aer = __x0__[__x1__]\n    2:let __x2__ = aer[\"EventList\"]\n    2:let __x3__ = 0i\n    2:while (< __x3__ __x2__[\"length\"]) {\n      let E = __x2__[__x3__]\n      3:append E -> events\n      __x3__ = (+ __x3__ 1i)\n    }\n    __x1__ = (+ __x1__ 1i)\n  }\n  4:return events\n}"
  }, {
    "code": ["        1. Let _events_ be an empty Set.", "        1. For each event _E_ of EventSet(_execution_), do", "          1. If _E_ is a ReadSharedMemory, WriteSharedMemory, or ReadModifyWriteSharedMemory event, add _E_ to _events_.", "        1. Return _events_."],
    "head": {
      "name": "SharedDataBlockEventSet",
      "params": [{
        "kind": "Normal",
        "name": "execution"
      }]
    },
    "ids": "sec-sharedatablockeventset",
    "rawBody": "{\n  0:let events = (0) (new [])\n  1:(0) app __x0__ = (EventSet execution)\n  1:let __x1__ = __x0__\n  1:let __x2__ = 0i\n  1:while (< __x2__ __x1__[\"length\"]) {\n    let E = __x1__[__x2__]\n    2:if (|| (|| (1) (is-instance-of E ReadSharedMemory) (2) (is-instance-of E WriteSharedMemory)) (3) (is-instance-of E ReadModifyWriteSharedMemory)) append E -> events else 4:{}\n    __x2__ = (+ __x2__ 1i)\n  }\n  3:return events\n}"
  }, {
    "code": ["        1. Let _events_ be an empty Set.", "        1. For each event _E_ of EventSet(_execution_), do", "          1. If _E_ is not in SharedDataBlockEventSet(_execution_), add _E_ to _events_.", "        1. Return _events_."],
    "head": {
      "name": "HostEventSet",
      "params": [{
        "kind": "Normal",
        "name": "execution"
      }]
    },
    "ids": "sec-hosteventset",
    "rawBody": "{\n  0:let events = (0) (new [])\n  1:(0) app __x0__ = (EventSet execution)\n  1:let __x1__ = __x0__\n  1:let __x2__ = 0i\n  1:while (< __x2__ __x1__[\"length\"]) {\n    let E = __x1__[__x2__]\n    2:(1) app __x3__ = (SharedDataBlockEventSet execution)\n    2:if (! (contains __x3__ E)) append E -> events else 4:{}\n    __x2__ = (+ __x2__ 1i)\n  }\n  3:return events\n}"
  }, {
    "code": ["        1. Let _byteLocation_ be _byteIndex_.", "        1. Let _bytesRead_ be a new empty List.", "        1. For each element _W_ of _Ws_, do", "          1. Assert: _W_ has _byteLocation_ in its range.", "          1. Let _payloadIndex_ be _byteLocation_ - _W_.[[ByteIndex]].", "          1. If _W_ is a WriteSharedMemory event, then", "            1. Let _byte_ be _W_.[[Payload]][_payloadIndex_].", "          1. Else,", "            1. Assert: _W_ is a ReadModifyWriteSharedMemory event.", "            1. Let _bytes_ be ValueOfReadEvent(_execution_, _W_).", "            1. Let _bytesModified_ be _W_.[[ModifyOp]](_bytes_, _W_.[[Payload]]).", "            1. Let _byte_ be _bytesModified_[_payloadIndex_].", "          1. Append _byte_ to _bytesRead_.", "          1. Set _byteLocation_ to _byteLocation_ + 1.", "        1. Return _bytesRead_."],
    "head": {
      "name": "ComposeWriteEventBytes",
      "params": [{
        "kind": "Normal",
        "name": "execution"
      }, {
        "kind": "Normal",
        "name": "byteIndex"
      }, {
        "kind": "Normal",
        "name": "Ws"
      }]
    },
    "ids": "sec-composewriteeventbytes",
    "rawBody": "{\n  0:let byteLocation = byteIndex\n  1:let bytesRead = (0) (new [])\n  2:let __x0__ = Ws\n  2:let __x1__ = 0i\n  2:while (< __x1__ __x0__[\"length\"]) {\n    let W = __x0__[__x1__]\n    4:let payloadIndex = (- byteLocation W[\"ByteIndex\"])\n    7:if (1) (is-instance-of W WriteSharedMemory) let byte = W[\"Payload\"][payloadIndex] else {\n      8:assert (2) (is-instance-of W ReadModifyWriteSharedMemory)\n      9:(0) app __x2__ = (ValueOfReadEvent execution W)\n      9:let bytes = __x2__\n      10:(1) app __x3__ = (W[\"ModifyOp\"] W bytes W[\"Payload\"])\n      10:let bytesModified = __x3__\n      11:let byte = bytesModified[payloadIndex]\n    }\n    12:append byte -> bytesRead\n    13:byteLocation = (+ byteLocation 1i)\n    __x1__ = (+ __x1__ 1i)\n  }\n  14:return bytesRead\n}"
  }, {
    "code": ["        1. Assert: _R_ is a ReadSharedMemory or ReadModifyWriteSharedMemory event.", "        1. Let _Ws_ be _execution_.[[ReadsBytesFrom]](_R_).", "        1. Assert: _Ws_ is a List of WriteSharedMemory or ReadModifyWriteSharedMemory events with length equal to _R_.[[ElementSize]].", "        1. Return ComposeWriteEventBytes(_execution_, _R_.[[ByteIndex]], _Ws_)."],
    "head": {
      "name": "ValueOfReadEvent",
      "params": [{
        "kind": "Normal",
        "name": "execution"
      }, {
        "kind": "Normal",
        "name": "R"
      }]
    },
    "ids": "sec-valueofreadevent",
    "rawBody": "{\n  0:assert (|| (0) (is-instance-of R ReadSharedMemory) (1) (is-instance-of R ReadModifyWriteSharedMemory))\n  1:(0) app __x0__ = (execution[\"ReadsBytesFrom\"] execution R)\n  1:let Ws = __x0__\n  3:(1) app __x1__ = (ComposeWriteEventBytes execution R[\"ByteIndex\"] Ws)\n  3:return __x1__\n}"
  }, {
    "code": ["        1. For each ReadSharedMemory or ReadModifyWriteSharedMemory event _R_ of SharedDataBlockEventSet(_execution_), do", "          1. Let _chosenValueRecord_ be the element of _execution_.[[ChosenValues]] whose [[Event]] field is _R_.", "          1. Let _chosenValue_ be _chosenValueRecord_.[[ChosenValue]].", "          1. Let _readValue_ be ValueOfReadEvent(_execution_, _R_).", "          1. Let _chosenLen_ be the number of elements of _chosenValue_.", "          1. Let _readLen_ be the number of elements of _readValue_.", "          1. If _chosenLen_ ≠ _readLen_, then", "            1. Return *false*.", "          1. If _chosenValue_[_i_] ≠ _readValue_[_i_] for any integer value _i_ in the range 0 through _chosenLen_, exclusive, then", "            1. Return *false*.", "        1. Return *true*."],
    "head": {
      "name": "ValidChosenReads",
      "params": []
    },
    "ids": "sec-valid-chosen-reads",
    "rawBody": "{\n  0:(0) app __x0__ = (SharedDataBlockEventSet execution)\n  0:let __x1__ = __x0__\n  0:let __x2__ = 0i\n  0:while (< __x2__ __x1__[\"length\"]) {\n    let R = __x1__[__x2__]\n    1:(0) ??? \"Let id:{chosenValueRecord} be the element of id:{execution} . [ [ ChosenValues ] ] whose [ [ Event ] ] field is id:{R} .\"\n    2:let chosenValue = chosenValueRecord[\"ChosenValue\"]\n    3:(1) app __x3__ = (ValueOfReadEvent execution R)\n    3:let readValue = __x3__\n    4:let chosenLen = chosenValue[\"length\"]\n    5:let readLen = readValue[\"length\"]\n    6:if (! (== chosenLen readLen)) return false else 2:{}\n    8:(1) ??? \"If id:{chosenValue} [ id:{i} ] ≠ id:{readValue} [ id:{i} ] for any integer value id:{i} in the range 0 through id:{chosenLen} , exclusive , then in:{} out:{}\"\n    __x2__ = (+ __x2__ 1i)\n  }\n  10:return true\n}"
  }, {
    "code": ["        1. For each ReadSharedMemory or ReadModifyWriteSharedMemory event _R_ of SharedDataBlockEventSet(_execution_), do", "          1. Let _Ws_ be _execution_.[[ReadsBytesFrom]](_R_).", "          1. Let _byteLocation_ be _R_.[[ByteIndex]].", "          1. For each element _W_ of _Ws_, do", "            1. If (_R_, _W_) is in _execution_.[[HappensBefore]], then", "              1. Return *false*.", "            1. If there is a WriteSharedMemory or ReadModifyWriteSharedMemory event _V_ that has _byteLocation_ in its range such that the pairs (_W_, _V_) and (_V_, _R_) are in _execution_.[[HappensBefore]], then", "              1. Return *false*.", "            1. Set _byteLocation_ to _byteLocation_ + 1.", "        1. Return *true*."],
    "head": {
      "name": "CoherentReads",
      "params": []
    },
    "ids": "sec-coherent-reads",
    "rawBody": "{\n  0:(0) app __x0__ = (SharedDataBlockEventSet execution)\n  0:let __x1__ = __x0__\n  0:let __x2__ = 0i\n  0:while (< __x2__ __x1__[\"length\"]) {\n    let R = __x1__[__x2__]\n    1:(1) app __x3__ = (execution[\"ReadsBytesFrom\"] execution R)\n    1:let Ws = __x3__\n    2:let byteLocation = R[\"ByteIndex\"]\n    3:let __x4__ = Ws\n    3:let __x5__ = 0i\n    3:while (< __x5__ __x4__[\"length\"]) {\n      let W = __x4__[__x5__]\n      4:if (contains execution[\"HappensBefore\"] (0) (new [R, W])) return false else 2:{}\n      6:(1) ??? \"If there is a WriteSharedMemory or ReadModifyWriteSharedMemory event id:{V} that has id:{byteLocation} in its range such that the pairs ( id:{W} , id:{V} ) and ( id:{V} , id:{R} ) are in id:{execution} . [ [ HappensBefore ] ] , then in:{} out:{}\"\n      8:byteLocation = (+ byteLocation 1i)\n      __x5__ = (+ __x5__ 1i)\n    }\n    __x2__ = (+ __x2__ 1i)\n  }\n  9:return true\n}"
  }, {
    "code": ["        1. For each ReadSharedMemory or ReadModifyWriteSharedMemory event _R_ of SharedDataBlockEventSet(_execution_), do", "          1. If _R_.[[NoTear]] is *true*, then", "            1. Assert: The remainder of dividing _R_.[[ByteIndex]] by _R_.[[ElementSize]] is 0.", "            1. For each event _W_ such that (_R_, _W_) is in _execution_.[[ReadsFrom]] and _W_.[[NoTear]] is *true*, do", "              1. If _R_ and _W_ have equal ranges, and there is an event _V_ such that _V_ and _W_ have equal ranges, _V_.[[NoTear]] is *true*, _W_ is not _V_, and (_R_, _V_) is in _execution_.[[ReadsFrom]], then", "                1. Return *false*.", "        1. Return *true*."],
    "head": {
      "name": "TearFreeReads",
      "params": []
    },
    "ids": "sec-tear-free-aligned-reads",
    "rawBody": "{\n  0:(0) app __x0__ = (SharedDataBlockEventSet execution)\n  0:let __x1__ = __x0__\n  0:let __x2__ = 0i\n  0:while (< __x2__ __x1__[\"length\"]) {\n    let R = __x1__[__x2__]\n    1:if (= R[\"NoTear\"] true) {\n      2:assert (= (% R[\"ByteIndex\"] R[\"ElementSize\"]) 0i)\n      3:(0) ??? \"For each event id:{W} such that ( id:{R} , id:{W} ) is in id:{execution} . [ [ ReadsFrom ] ] and id:{W} . [ [ NoTear ] ] is value:{true} , do in:{} out:{}\"\n    } else 2:{}\n    __x2__ = (+ __x2__ 1i)\n  }\n  6:return true\n}"
  }, {
    "code": ["      1. If _E_ is not _D_, then", "        1. If the pairs (_E_, _D_) and (_D_, _E_) are not in _execution_.[[HappensBefore]], then", "          1. If _E_ and _D_ are both WriteSharedMemory or ReadModifyWriteSharedMemory events and _E_ and _D_ do not have disjoint ranges, then", "            1. Return *true*.", "          1. If either (_E_, _D_) or (_D_, _E_) is in _execution_.[[ReadsFrom]], then", "            1. Return *true*.", "      1. Return *false*."],
    "head": {
      "name": "Races",
      "params": []
    },
    "ids": "sec-races",
    "rawBody": "{\n  0:if (! (= E D)) (0) ??? \"If the pairs ( id:{E} , id:{D} ) and ( id:{D} , id:{E} ) are not in id:{execution} . [ [ HappensBefore ] ] , then in:{} out:{}\" else 2:{}\n  6:return false\n}"
  }, {
    "code": ["      1. If _E_ and _D_ are in a race in _execution_, then", "        1. If _E_.[[Order]] is not ~SeqCst~ or _D_.[[Order]] is not ~SeqCst~, then", "          1. Return *true*.", "        1. If _E_ and _D_ have overlapping ranges, then", "          1. Return *true*.", "      1. Return *false*."],
    "head": {
      "name": "DataRaces",
      "params": []
    },
    "ids": "sec-data-races",
    "rawBody": "{\n  0:(0) ??? \"If id:{E} and id:{D} are in a race in id:{execution} , then in:{} out:{}\"\n  5:return false\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if the SV of |UnicodeEscapeSequence| is none of *\"$\"*, or *\"_\"*, or ! UTF16EncodeCodePoint(_cp_) for some Unicode code point _cp_ matched by the |UnicodeIDStart| lexical grammar production.", "          </li>"],
    "head": {
      "idx": 3,
      "methodName": "EarlyErrors",
      "prod": "IdentifierStart",
      "rhs": {
        "tokens": [{
          "term": "\\"
        }, {
          "args": [],
          "name": "UnicodeEscapeSequence",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-identifier-names-static-semantics-early-errors",
    "rawBody": "(0) ??? \"It is a Syntax Error if the SV of nt:{UnicodeEscapeSequence} is none of value:{\\\"$\\\"} , or value:{\\\"_\\\"} , or ! UTF16EncodeCodePoint ( id:{cp} ) for some Unicode code point id:{cp} matched by the nt:{UnicodeIDStart} lexical grammar production .\""
  }, {
    "code": ["          <li>", "            It is a Syntax Error if the SV of |UnicodeEscapeSequence| is none of *\"$\"*, *\"_\"*, ! UTF16EncodeCodePoint(<ZWNJ>), ! UTF16EncodeCodePoint(<ZWJ>), or ! UTF16EncodeCodePoint(_cp_) for some Unicode code point _cp_ that would be matched by the |UnicodeIDContinue| lexical grammar production.", "          </li>"],
    "head": {
      "idx": 2,
      "methodName": "EarlyErrors",
      "prod": "IdentifierPart",
      "rhs": {
        "tokens": [{
          "term": "\\"
        }, {
          "args": [],
          "name": "UnicodeEscapeSequence",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-identifier-names-static-semantics-early-errors",
    "rawBody": "(0) ??? \"It is a Syntax Error if the SV of nt:{UnicodeEscapeSequence} is none of value:{\\\"$\\\"} , value:{\\\"_\\\"} , ! UTF16EncodeCodePoint ( < ZWNJ > ) , ! UTF16EncodeCodePoint ( < ZWJ > ) , or ! UTF16EncodeCodePoint ( id:{cp} ) for some Unicode code point id:{cp} that would be matched by the nt:{UnicodeIDContinue} lexical grammar production .\""
  }, {
    "code": ["          <li>", "            It is a Syntax Error if |IdentifierPart| contains a Unicode escape sequence.", "          </li>"],
    "head": {
      "idx": 1,
      "methodName": "EarlyErrors",
      "prod": "RegularExpressionFlags",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RegularExpressionFlags",
          "optional": false
        }, {
          "args": [],
          "name": "IdentifierPart",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-literals-regular-expression-literals-static-semantics-early-errors",
    "rawBody": "(0) ??? \"It is a Syntax Error if nt:{IdentifierPart} contains a Unicode escape sequence .\""
  }, {
    "code": ["        <li>", "          It is a Syntax Error if the code matched by this production is contained in strict mode code and the StringValue of |Identifier| is *\"arguments\"* or *\"eval\"*.", "        </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "BindingIdentifier",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Identifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-identifiers-static-semantics-early-errors",
    "rawBody": "{\n  0:let __x0__ = true\n  0:__x0__ = true\n  0:if __x0__ {\n    (0) access __x1__ = (Identifier \"StringValue\")\n    __x0__ = (|| (= __x1__ \"arguments\") (= __x1__ \"eval\"))\n  } else 2:{}\n  0:if __x0__ (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if the code matched by this production is contained in strict mode code.", "        </li>"],
    "head": {
      "idx": 1,
      "methodName": "EarlyErrors",
      "prod": "IdentifierReference",
      "rhs": {
        "tokens": [{
          "term": "yield"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-identifiers-static-semantics-early-errors",
    "rawBody": "if true (0) throw SyntaxError else 2:{}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if the code matched by this production is contained in strict mode code.", "        </li>"],
    "head": {
      "idx": 1,
      "methodName": "EarlyErrors",
      "prod": "BindingIdentifier",
      "rhs": {
        "tokens": [{
          "term": "yield"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-identifiers-static-semantics-early-errors",
    "rawBody": "if true (0) throw SyntaxError else 2:{}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if the code matched by this production is contained in strict mode code.", "        </li>"],
    "head": {
      "idx": 1,
      "methodName": "EarlyErrors",
      "prod": "LabelIdentifier",
      "rhs": {
        "tokens": [{
          "term": "yield"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-identifiers-static-semantics-early-errors",
    "rawBody": "if true (0) throw SyntaxError else 2:{}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if the goal symbol of the syntactic grammar is |Module|.", "        </li>"],
    "head": {
      "idx": 2,
      "methodName": "EarlyErrors",
      "prod": "IdentifierReference",
      "rhs": {
        "tokens": [{
          "term": "await"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-identifiers-static-semantics-early-errors",
    "rawBody": "{\n  0:let __x0__ = false\n  0:if (= absent (parse-syntax this \"Module\" (0) (new []))) __x0__ = true else 2:{}\n  0:if __x0__ (1) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if the goal symbol of the syntactic grammar is |Module|.", "        </li>"],
    "head": {
      "idx": 2,
      "methodName": "EarlyErrors",
      "prod": "BindingIdentifier",
      "rhs": {
        "tokens": [{
          "term": "await"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-identifiers-static-semantics-early-errors",
    "rawBody": "{\n  0:let __x0__ = false\n  0:if (= absent (parse-syntax this \"Module\" (0) (new []))) __x0__ = true else 2:{}\n  0:if __x0__ (1) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if the goal symbol of the syntactic grammar is |Module|.", "        </li>"],
    "head": {
      "idx": 2,
      "methodName": "EarlyErrors",
      "prod": "LabelIdentifier",
      "rhs": {
        "tokens": [{
          "term": "await"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-identifiers-static-semantics-early-errors",
    "rawBody": "{\n  0:let __x0__ = false\n  0:if (= absent (parse-syntax this \"Module\" (0) (new []))) __x0__ = true else 2:{}\n  0:if __x0__ (1) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if this production has a <sub>[Yield]</sub> parameter.", "        </li>"],
    "head": {
      "idx": 1,
      "methodName": "EarlyErrors",
      "prod": "BindingIdentifier",
      "rhs": {
        "tokens": [{
          "term": "yield"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-identifiers-static-semantics-early-errors",
    "rawBody": "(0) ??? \"It is a Syntax Error if this production has a sub:{[ Yield ]} parameter .\""
  }, {
    "code": ["        <li>", "          It is a Syntax Error if this production has an <sub>[Await]</sub> parameter.", "        </li>"],
    "head": {
      "idx": 2,
      "methodName": "EarlyErrors",
      "prod": "BindingIdentifier",
      "rhs": {
        "tokens": [{
          "term": "await"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-identifiers-static-semantics-early-errors",
    "rawBody": "(0) ??? \"It is a Syntax Error if this production has an sub:{[ Await ]} parameter .\""
  }, {
    "code": ["        <li>", "          It is a Syntax Error if this production has a <sub>[Yield]</sub> parameter and StringValue of |Identifier| is *\"yield\"*.", "        </li>", "        <li>", "          It is a Syntax Error if this production has an <sub>[Await]</sub> parameter and StringValue of |Identifier| is *\"await\"*.", "        </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "IdentifierReference",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Identifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-identifiers-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) ??? \"It is a Syntax Error if this production has a sub:{[ Yield ]} parameter and StringValue of nt:{Identifier} is value:{\\\"yield\\\"} .\"\n  1:(1) ??? \"It is a Syntax Error if this production has an sub:{[ Await ]} parameter and StringValue of nt:{Identifier} is value:{\\\"await\\\"} .\"\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if this production has a <sub>[Yield]</sub> parameter and StringValue of |Identifier| is *\"yield\"*.", "        </li>", "        <li>", "          It is a Syntax Error if this production has an <sub>[Await]</sub> parameter and StringValue of |Identifier| is *\"await\"*.", "        </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "BindingIdentifier",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Identifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-identifiers-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) ??? \"It is a Syntax Error if this production has a sub:{[ Yield ]} parameter and StringValue of nt:{Identifier} is value:{\\\"yield\\\"} .\"\n  1:(1) ??? \"It is a Syntax Error if this production has an sub:{[ Await ]} parameter and StringValue of nt:{Identifier} is value:{\\\"await\\\"} .\"\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if this production has a <sub>[Yield]</sub> parameter and StringValue of |Identifier| is *\"yield\"*.", "        </li>", "        <li>", "          It is a Syntax Error if this production has an <sub>[Await]</sub> parameter and StringValue of |Identifier| is *\"await\"*.", "        </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "LabelIdentifier",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Identifier",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-identifiers-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) ??? \"It is a Syntax Error if this production has a sub:{[ Yield ]} parameter and StringValue of nt:{Identifier} is value:{\\\"yield\\\"} .\"\n  1:(1) ??? \"It is a Syntax Error if this production has an sub:{[ Await ]} parameter and StringValue of nt:{Identifier} is value:{\\\"await\\\"} .\"\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if this phrase is contained in strict mode code and the StringValue of |IdentifierName| is: *\"implements\"*, *\"interface\"*, *\"let\"*, *\"package\"*, *\"private\"*, *\"protected\"*, *\"public\"*, *\"static\"*, or *\"yield\"*.", "        </li>", "        <li>", "          It is a Syntax Error if the goal symbol of the syntactic grammar is |Module| and the StringValue of |IdentifierName| is *\"await\"*.", "        </li>", "        <li>", "          It is a Syntax Error if StringValue of |IdentifierName| is the same String value as the StringValue of any |ReservedWord| except for `yield` or `await`.", "        </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "Identifier",
      "rhs": {
        "tokens": [{
          "base": {
            "args": [],
            "name": "IdentifierName",
            "optional": false
          },
          "cases": [{
            "args": [],
            "name": "ReservedWord",
            "optional": false
          }]
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-identifiers-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) ??? \"It is a Syntax Error if this phrase is contained in strict mode code and the StringValue of nt:{IdentifierName} is : value:{\\\"implements\\\"} , value:{\\\"interface\\\"} , value:{\\\"let\\\"} , value:{\\\"package\\\"} , value:{\\\"private\\\"} , value:{\\\"protected\\\"} , value:{\\\"public\\\"} , value:{\\\"static\\\"} , or value:{\\\"yield\\\"} .\"\n  1:let __x0__ = true\n  1:let __x1__ = false\n  1:if (= absent (parse-syntax this \"Module\" (1) (new []))) __x1__ = true else 2:{}\n  1:__x0__ = __x1__\n  1:if __x0__ {\n    (0) access __x2__ = (IdentifierName \"StringValue\")\n    __x0__ = (= __x2__ \"await\")\n  } else 2:{}\n  1:if __x0__ (2) throw SyntaxError else 2:{}\n  2:(3) ??? \"It is a Syntax Error if StringValue of nt:{IdentifierName} is the same String value as the StringValue of any nt:{ReservedWord} except for code:{yield} or code:{await} .\"\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if HasDirectSuper of |MethodDefinition| is *true*.", "          </li>"],
    "head": {
      "idx": 3,
      "methodName": "EarlyErrors",
      "prod": "PropertyDefinition",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MethodDefinition",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-object-initializer-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (MethodDefinition \"HasDirectSuper\")\n  0:if (= __x0__ true) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            Always throw a Syntax Error if code matches this production.", "          </li>"],
    "head": {
      "idx": 1,
      "methodName": "EarlyErrors",
      "prod": "PropertyDefinition",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CoverInitializedName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-object-initializer-static-semantics-early-errors",
    "rawBody": "if true (0) throw SyntaxError else 2:{}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if IsValidRegularExpressionLiteral(|RegularExpressionLiteral|) is *false*.", "          </li>"],
    "head": {
      "idx": 10,
      "methodName": "EarlyErrors",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "RegularExpressionLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-primary-expression-regular-expression-literals-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) app __x0__ = (IsValidRegularExpressionLiteral RegularExpressionLiteral)\n  0:if (= __x0__ false) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if the <sub>[Tagged]</sub> parameter was not set and |NoSubstitutionTemplate| Contains |NotEscapeSequence|.", "          </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "TemplateLiteral",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "NoSubstitutionTemplate",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-template-early-errors",
    "rawBody": "(0) ??? \"It is a Syntax Error if the sub:{[ Tagged ]} parameter was not set and nt:{NoSubstitutionTemplate} Contains nt:{NotEscapeSequence} .\""
  }, {
    "code": ["          <li>", "            It is a Syntax Error if the number of elements in the result of TemplateStrings of |TemplateLiteral| with argument *false* is greater than 2<sup>32</sup> - 1.", "          </li>"],
    "head": {
      "idx": 1,
      "methodName": "EarlyErrors",
      "prod": "TemplateLiteral",
      "rhs": {
        "tokens": [{
          "args": ["?Yield", "?Await", "?Tagged"],
          "name": "SubstitutionTemplate",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-template-early-errors",
    "rawBody": "(0) ??? \"It is a Syntax Error if the number of elements in the result of TemplateStrings of nt:{TemplateLiteral} with argument value:{false} is greater than 2 sup:{32} - 1 .\""
  }, {
    "code": ["          <li>", "            It is a Syntax Error if the <sub>[Tagged]</sub> parameter was not set and |TemplateHead| Contains |NotEscapeSequence|.", "          </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "SubstitutionTemplate",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "TemplateHead",
          "optional": false
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": false
        }, {
          "args": ["?Yield", "?Await", "?Tagged"],
          "name": "TemplateSpans",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-template-early-errors",
    "rawBody": "(0) ??? \"It is a Syntax Error if the sub:{[ Tagged ]} parameter was not set and nt:{TemplateHead} Contains nt:{NotEscapeSequence} .\""
  }, {
    "code": ["          <li>", "            It is a Syntax Error if the <sub>[Tagged]</sub> parameter was not set and |TemplateTail| Contains |NotEscapeSequence|.", "          </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "TemplateSpans",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "TemplateTail",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-template-early-errors",
    "rawBody": "(0) ??? \"It is a Syntax Error if the sub:{[ Tagged ]} parameter was not set and nt:{TemplateTail} Contains nt:{NotEscapeSequence} .\""
  }, {
    "code": ["          <li>", "            It is a Syntax Error if the <sub>[Tagged]</sub> parameter was not set and |TemplateMiddle| Contains |NotEscapeSequence|.", "          </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "TemplateMiddleList",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "TemplateMiddle",
          "optional": false
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-template-early-errors",
    "rawBody": "(0) ??? \"It is a Syntax Error if the sub:{[ Tagged ]} parameter was not set and nt:{TemplateMiddle} Contains nt:{NotEscapeSequence} .\""
  }, {
    "code": ["          <li>", "            It is a Syntax Error if the <sub>[Tagged]</sub> parameter was not set and |TemplateMiddle| Contains |NotEscapeSequence|.", "          </li>"],
    "head": {
      "idx": 1,
      "methodName": "EarlyErrors",
      "prod": "TemplateMiddleList",
      "rhs": {
        "tokens": [{
          "args": ["?Yield", "?Await", "?Tagged"],
          "name": "TemplateMiddleList",
          "optional": false
        }, {
          "args": [],
          "name": "TemplateMiddle",
          "optional": false
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-static-semantics-template-early-errors",
    "rawBody": "(0) ??? \"It is a Syntax Error if the sub:{[ Tagged ]} parameter was not set and nt:{TemplateMiddle} Contains nt:{NotEscapeSequence} .\""
  }, {
    "code": ["          <li>", "            It is a Syntax Error if |CoverParenthesizedExpressionAndArrowParameterList| is not covering a |ParenthesizedExpression|.", "          </li>", "          <li>", "            All Early Error rules for |ParenthesizedExpression| and its derived productions also apply to CoveredParenthesizedExpression of |CoverParenthesizedExpressionAndArrowParameterList|.", "          </li>"],
    "head": {
      "idx": 12,
      "methodName": "EarlyErrors",
      "prod": "PrimaryExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CoverParenthesizedExpressionAndArrowParameterList",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-grouping-operator-static-semantics-early-errors",
    "rawBody": "{\n  0:let __x0__ = false\n  0:if (= absent (parse-syntax CoverParenthesizedExpressionAndArrowParameterList \"ParenthesizedExpression\" (0) (new []))) __x0__ = true else 2:{}\n  0:if __x0__ (1) throw SyntaxError else 2:{}\n  1:(2) ??? \"All Early Error rules for nt:{ParenthesizedExpression} and its derived productions also apply to CoveredParenthesizedExpression of nt:{CoverParenthesizedExpressionAndArrowParameterList} .\"\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if any code matches this production.", "          </li>"],
    "head": {
      "idx": 3,
      "methodName": "EarlyErrors",
      "prod": "OptionalChain",
      "rhs": {
        "tokens": [{
          "term": "?."
        }, {
          "args": [],
          "name": "TemplateLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-left-hand-side-expressions-static-semantics-early-errors",
    "rawBody": "if true (0) throw SyntaxError else 2:{}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if any code matches this production.", "          </li>"],
    "head": {
      "idx": 7,
      "methodName": "EarlyErrors",
      "prod": "OptionalChain",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "OptionalChain",
          "optional": false
        }, {
          "args": [],
          "name": "TemplateLiteral",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-left-hand-side-expressions-static-semantics-early-errors",
    "rawBody": "if true (0) throw SyntaxError else 2:{}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if the syntactic goal symbol is not |Module|.", "          </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "ImportMeta",
      "rhs": {
        "tokens": [{
          "term": "import"
        }, {
          "term": "."
        }, {
          "term": "meta"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-left-hand-side-expressions-static-semantics-early-errors",
    "rawBody": "{\n  0:let __x0__ = false\n  0:if (= absent (parse-syntax this \"Module\" (0) (new []))) __x0__ = true else 2:{}\n  0:if __x0__ (1) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is an early Syntax Error if AssignmentTargetType of |LeftHandSideExpression| is not ~simple~.", "        </li>"],
    "head": {
      "idx": 1,
      "methodName": "EarlyErrors",
      "prod": "UpdateExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "++"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-update-expressions-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (LeftHandSideExpression \"AssignmentTargetType\")\n  0:if (! (= __x0__ CONST_simple)) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is an early Syntax Error if AssignmentTargetType of |LeftHandSideExpression| is not ~simple~.", "        </li>"],
    "head": {
      "idx": 2,
      "methodName": "EarlyErrors",
      "prod": "UpdateExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "--"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-update-expressions-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (LeftHandSideExpression \"AssignmentTargetType\")\n  0:if (! (= __x0__ CONST_simple)) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is an early Syntax Error if AssignmentTargetType of |UnaryExpression| is not ~simple~.", "        </li>"],
    "head": {
      "idx": 3,
      "methodName": "EarlyErrors",
      "prod": "UpdateExpression",
      "rhs": {
        "tokens": [{
          "term": "++"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-update-expressions-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (UnaryExpression \"AssignmentTargetType\")\n  0:if (! (= __x0__ CONST_simple)) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is an early Syntax Error if AssignmentTargetType of |UnaryExpression| is not ~simple~.", "        </li>"],
    "head": {
      "idx": 4,
      "methodName": "EarlyErrors",
      "prod": "UpdateExpression",
      "rhs": {
        "tokens": [{
          "term": "--"
        }, {
          "args": [],
          "name": "UnaryExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-update-expressions-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (UnaryExpression \"AssignmentTargetType\")\n  0:if (! (= __x0__ CONST_simple)) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if |LeftHandSideExpression| is not covering an |AssignmentPattern|.", "        </li>", "        <li>", "          All Early Error rules for |AssignmentPattern| and its derived productions also apply to the |AssignmentPattern| that is covered by |LeftHandSideExpression|.", "        </li>"],
    "head": {
      "name": "EarlyErrors",
      "params": []
    },
    "ids": "sec-assignment-operators-static-semantics-early-errors",
    "rawBody": "{\n  0:let __x0__ = false\n  0:if (= absent (parse-syntax LeftHandSideExpression \"AssignmentPattern\" (0) (new []))) __x0__ = true else 2:{}\n  0:if __x0__ (1) throw SyntaxError else 2:{}\n  1:(2) ??? \"All Early Error rules for nt:{AssignmentPattern} and its derived productions also apply to the nt:{AssignmentPattern} that is covered by nt:{LeftHandSideExpression} .\"\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if AssignmentTargetType of |LeftHandSideExpression| is not ~simple~.", "        </li>"],
    "head": {
      "name": "EarlyErrors",
      "params": []
    },
    "ids": "sec-assignment-operators-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (LeftHandSideExpression \"AssignmentTargetType\")\n  0:if (! (= __x0__ CONST_simple)) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if AssignmentTargetType of |LeftHandSideExpression| is not ~simple~.", "        </li>"],
    "head": {
      "idx": 5,
      "methodName": "EarlyErrors",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "args": [],
          "name": "AssignmentOperator",
          "optional": false
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-assignment-operators-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (LeftHandSideExpression \"AssignmentTargetType\")\n  0:if (! (= __x0__ CONST_simple)) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if AssignmentTargetType of |LeftHandSideExpression| is not ~simple~.", "        </li>"],
    "head": {
      "idx": 6,
      "methodName": "EarlyErrors",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "&&="
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-assignment-operators-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (LeftHandSideExpression \"AssignmentTargetType\")\n  0:if (! (= __x0__ CONST_simple)) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if AssignmentTargetType of |LeftHandSideExpression| is not ~simple~.", "        </li>"],
    "head": {
      "idx": 7,
      "methodName": "EarlyErrors",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "||="
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-assignment-operators-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (LeftHandSideExpression \"AssignmentTargetType\")\n  0:if (! (= __x0__ CONST_simple)) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if AssignmentTargetType of |LeftHandSideExpression| is not ~simple~.", "        </li>"],
    "head": {
      "idx": 8,
      "methodName": "EarlyErrors",
      "prod": "AssignmentExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "??="
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-assignment-operators-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (LeftHandSideExpression \"AssignmentTargetType\")\n  0:if (! (= __x0__ CONST_simple)) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if AssignmentTargetType of |IdentifierReference| is not ~simple~.", "          </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "AssignmentProperty",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "IdentifierReference",
          "optional": false
        }, {
          "args": [],
          "name": "Initializer",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-destructuring-assignment-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (IdentifierReference \"AssignmentTargetType\")\n  0:if (! (= __x0__ CONST_simple)) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.", "          </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "AssignmentRestProperty",
      "rhs": {
        "tokens": [{
          "term": "..."
        }, {
          "args": [],
          "name": "DestructuringAssignmentTarget",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-destructuring-assignment-static-semantics-early-errors",
    "rawBody": "if (|| (0) (is-instance-of DestructuringAssignmentTarget ArrayLiteral) (1) (is-instance-of DestructuringAssignmentTarget ObjectLiteral)) (2) throw SyntaxError else 2:{}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if |LeftHandSideExpression| is not covering an |AssignmentPattern|.", "          </li>", "          <li>", "            All Early Error rules for |AssignmentPattern| and its derived productions also apply to the |AssignmentPattern| that is covered by |LeftHandSideExpression|.", "          </li>"],
    "head": {
      "name": "EarlyErrors",
      "params": []
    },
    "ids": "sec-destructuring-assignment-static-semantics-early-errors",
    "rawBody": "{\n  0:let __x0__ = false\n  0:if (= absent (parse-syntax LeftHandSideExpression \"AssignmentPattern\" (0) (new []))) __x0__ = true else 2:{}\n  0:if __x0__ (1) throw SyntaxError else 2:{}\n  1:(2) ??? \"All Early Error rules for nt:{AssignmentPattern} and its derived productions also apply to the nt:{AssignmentPattern} that is covered by nt:{LeftHandSideExpression} .\"\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if AssignmentTargetType of |LeftHandSideExpression| is not ~simple~.", "          </li>"],
    "head": {
      "name": "EarlyErrors",
      "params": []
    },
    "ids": "sec-destructuring-assignment-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (LeftHandSideExpression \"AssignmentTargetType\")\n  0:if (! (= __x0__ CONST_simple)) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if the LexicallyDeclaredNames of |StatementList| contains any duplicate entries.", "        </li>", "        <li>", "          It is a Syntax Error if any element of the LexicallyDeclaredNames of |StatementList| also occurs in the VarDeclaredNames of |StatementList|.", "        </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "Block",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "StatementList",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-block-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (StatementList \"LexicallyDeclaredNames\")\n  0:(1) app __x1__ = (IsDuplicate __x0__)\n  0:if __x1__ (0) throw SyntaxError else 2:{}\n  1:(2) access __x2__ = (StatementList \"LexicallyDeclaredNames\")\n  1:(3) access __x3__ = (StatementList \"VarDeclaredNames\")\n  1:let __x4__ = __x2__\n  1:let __x5__ = __x3__\n  1:let __x6__ = 0i\n  1:let __x7__ = 0i\n  1:let __x8__ = false\n  1:while (< __x6__ __x4__[\"length\"]) {\n    __x7__ = 0i\n    while (< __x7__ __x5__[\"length\"]) if (= __x4__[__x6__] __x5__[__x7__]) __x8__ = true else 2:{}\n  }\n  1:if __x8__ (1) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if the BoundNames of |BindingList| contains *\"let\"*.", "          </li>", "          <li>", "            It is a Syntax Error if the BoundNames of |BindingList| contains any duplicate entries.", "          </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "LexicalDeclaration",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LetOrConst",
          "optional": false
        }, {
          "args": [],
          "name": "BindingList",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-let-and-const-declarations-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (BindingList \"BoundNames\")\n  0:if (contains __x0__ \"let\") (0) throw SyntaxError else 2:{}\n  1:(1) access __x1__ = (BindingList \"BoundNames\")\n  1:(2) app __x2__ = (IsDuplicate __x1__)\n  1:if __x2__ (1) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if |Initializer| is not present and IsConstantDeclaration of the |LexicalDeclaration| containing this |LexicalBinding| is *true*.", "          </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "LexicalBinding",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "args": [],
          "name": "Initializer",
          "optional": true
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-let-and-const-declarations-static-semantics-early-errors",
    "rawBody": "(0) ??? \"It is a Syntax Error if nt:{Initializer} is not present and IsConstantDeclaration of the nt:{LexicalDeclaration} containing this nt:{LexicalBinding} is value:{true} .\""
  }, {
    "code": ["        <li>", "          It is a Syntax Error if IsLabelledFunction(|Statement|) is *true*.", "        </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "IfStatement",
      "rhs": {
        "tokens": [{
          "term": "if"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }, {
          "term": "else"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-if-statement-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) app __x0__ = (IsLabelledFunction Statement)\n  0:if (= __x0__ true) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if IsLabelledFunction(|Statement|) is *true*.", "        </li>"],
    "head": {
      "idx": 1,
      "methodName": "EarlyErrors",
      "prod": "IfStatement",
      "rhs": {
        "tokens": [{
          "term": "if"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-if-statement-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) app __x0__ = (IsLabelledFunction Statement)\n  0:if (= __x0__ true) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if IsLabelledFunction(|Statement|) is *true*.", "          </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "DoWhileStatement",
      "rhs": {
        "tokens": [{
          "term": "do"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }, {
          "term": "while"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-do-while-statement-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) app __x0__ = (IsLabelledFunction Statement)\n  0:if (= __x0__ true) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if IsLabelledFunction(|Statement|) is *true*.", "          </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "WhileStatement",
      "rhs": {
        "tokens": [{
          "term": "while"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-while-statement-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) app __x0__ = (IsLabelledFunction Statement)\n  0:if (= __x0__ true) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if IsLabelledFunction(|Statement|) is *true*.", "          </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "ForStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 7,
      "withParams": []
    },
    "ids": "sec-for-statement-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) app __x0__ = (IsLabelledFunction Statement)\n  0:if (= __x0__ true) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if IsLabelledFunction(|Statement|) is *true*.", "          </li>"],
    "head": {
      "idx": 1,
      "methodName": "EarlyErrors",
      "prod": "ForStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "VariableDeclarationList",
          "optional": false
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 3,
      "withParams": []
    },
    "ids": "sec-for-statement-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) app __x0__ = (IsLabelledFunction Statement)\n  0:if (= __x0__ true) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if IsLabelledFunction(|Statement|) is *true*.", "          </li>"],
    "head": {
      "idx": 2,
      "methodName": "EarlyErrors",
      "prod": "ForStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LexicalDeclaration",
          "optional": false
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 3,
      "withParams": []
    },
    "ids": "sec-for-statement-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) app __x0__ = (IsLabelledFunction Statement)\n  0:if (= __x0__ true) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if any element of the BoundNames of |LexicalDeclaration| also occurs in the VarDeclaredNames of |Statement|.", "          </li>"],
    "head": {
      "idx": 2,
      "methodName": "EarlyErrors",
      "prod": "ForStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LexicalDeclaration",
          "optional": false
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": [],
          "name": "Expression",
          "optional": true
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 3,
      "withParams": []
    },
    "ids": "sec-for-statement-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (LexicalDeclaration \"BoundNames\")\n  0:(1) access __x1__ = (Statement \"VarDeclaredNames\")\n  0:let __x2__ = __x0__\n  0:let __x3__ = __x1__\n  0:let __x4__ = 0i\n  0:let __x5__ = 0i\n  0:let __x6__ = false\n  0:while (< __x4__ __x2__[\"length\"]) {\n    __x5__ = 0i\n    while (< __x5__ __x3__[\"length\"]) if (= __x2__[__x4__] __x3__[__x5__]) __x6__ = true else 2:{}\n  }\n  0:if __x6__ (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if IsLabelledFunction(|Statement|) is *true*.", "          </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-for-in-and-for-of-statements-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) app __x0__ = (IsLabelledFunction Statement)\n  0:if (= __x0__ true) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if IsLabelledFunction(|Statement|) is *true*.", "          </li>"],
    "head": {
      "idx": 1,
      "methodName": "EarlyErrors",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "ForBinding",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-for-in-and-for-of-statements-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) app __x0__ = (IsLabelledFunction Statement)\n  0:if (= __x0__ true) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if IsLabelledFunction(|Statement|) is *true*.", "          </li>"],
    "head": {
      "idx": 2,
      "methodName": "EarlyErrors",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "ForDeclaration",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-for-in-and-for-of-statements-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) app __x0__ = (IsLabelledFunction Statement)\n  0:if (= __x0__ true) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if IsLabelledFunction(|Statement|) is *true*.", "          </li>"],
    "head": {
      "idx": 3,
      "methodName": "EarlyErrors",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-for-in-and-for-of-statements-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) app __x0__ = (IsLabelledFunction Statement)\n  0:if (= __x0__ true) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if IsLabelledFunction(|Statement|) is *true*.", "          </li>"],
    "head": {
      "idx": 4,
      "methodName": "EarlyErrors",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "ForBinding",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-for-in-and-for-of-statements-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) app __x0__ = (IsLabelledFunction Statement)\n  0:if (= __x0__ true) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if IsLabelledFunction(|Statement|) is *true*.", "          </li>"],
    "head": {
      "idx": 5,
      "methodName": "EarlyErrors",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "ForDeclaration",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-for-in-and-for-of-statements-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) app __x0__ = (IsLabelledFunction Statement)\n  0:if (= __x0__ true) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if IsLabelledFunction(|Statement|) is *true*.", "          </li>"],
    "head": {
      "idx": 6,
      "methodName": "EarlyErrors",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "await"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-for-in-and-for-of-statements-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) app __x0__ = (IsLabelledFunction Statement)\n  0:if (= __x0__ true) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if IsLabelledFunction(|Statement|) is *true*.", "          </li>"],
    "head": {
      "idx": 7,
      "methodName": "EarlyErrors",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "await"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": [],
          "name": "ForBinding",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-for-in-and-for-of-statements-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) app __x0__ = (IsLabelledFunction Statement)\n  0:if (= __x0__ true) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if IsLabelledFunction(|Statement|) is *true*.", "          </li>"],
    "head": {
      "idx": 8,
      "methodName": "EarlyErrors",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "await"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "ForDeclaration",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-for-in-and-for-of-statements-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) app __x0__ = (IsLabelledFunction Statement)\n  0:if (= __x0__ true) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if |LeftHandSideExpression| is not covering an |AssignmentPattern|.", "          </li>", "          <li>", "            All Early Error rules for |AssignmentPattern| and its derived productions also apply to the |AssignmentPattern| that is covered by |LeftHandSideExpression|.", "          </li>"],
    "head": {
      "name": "EarlyErrors",
      "params": []
    },
    "ids": "sec-for-in-and-for-of-statements-static-semantics-early-errors",
    "rawBody": "{\n  0:let __x0__ = false\n  0:if (= absent (parse-syntax LeftHandSideExpression \"AssignmentPattern\" (0) (new []))) __x0__ = true else 2:{}\n  0:if __x0__ (1) throw SyntaxError else 2:{}\n  1:(2) ??? \"All Early Error rules for nt:{AssignmentPattern} and its derived productions also apply to the nt:{AssignmentPattern} that is covered by nt:{LeftHandSideExpression} .\"\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if AssignmentTargetType of |LeftHandSideExpression| is not ~simple~.", "          </li>"],
    "head": {
      "name": "EarlyErrors",
      "params": []
    },
    "ids": "sec-for-in-and-for-of-statements-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (LeftHandSideExpression \"AssignmentTargetType\")\n  0:if (! (= __x0__ CONST_simple)) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if the BoundNames of |ForDeclaration| contains *\"let\"*.", "          </li>", "          <li>", "            It is a Syntax Error if any element of the BoundNames of |ForDeclaration| also occurs in the VarDeclaredNames of |Statement|.", "          </li>", "          <li>", "            It is a Syntax Error if the BoundNames of |ForDeclaration| contains any duplicate entries.", "          </li>"],
    "head": {
      "idx": 2,
      "methodName": "EarlyErrors",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "ForDeclaration",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-for-in-and-for-of-statements-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (ForDeclaration \"BoundNames\")\n  0:if (contains __x0__ \"let\") (0) throw SyntaxError else 2:{}\n  1:(1) access __x1__ = (ForDeclaration \"BoundNames\")\n  1:(2) access __x2__ = (Statement \"VarDeclaredNames\")\n  1:let __x3__ = __x1__\n  1:let __x4__ = __x2__\n  1:let __x5__ = 0i\n  1:let __x6__ = 0i\n  1:let __x7__ = false\n  1:while (< __x5__ __x3__[\"length\"]) {\n    __x6__ = 0i\n    while (< __x6__ __x4__[\"length\"]) if (= __x3__[__x5__] __x4__[__x6__]) __x7__ = true else 2:{}\n  }\n  1:if __x7__ (1) throw SyntaxError else 2:{}\n  2:(3) access __x8__ = (ForDeclaration \"BoundNames\")\n  2:(4) app __x9__ = (IsDuplicate __x8__)\n  2:if __x9__ (2) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if the BoundNames of |ForDeclaration| contains *\"let\"*.", "          </li>", "          <li>", "            It is a Syntax Error if any element of the BoundNames of |ForDeclaration| also occurs in the VarDeclaredNames of |Statement|.", "          </li>", "          <li>", "            It is a Syntax Error if the BoundNames of |ForDeclaration| contains any duplicate entries.", "          </li>"],
    "head": {
      "idx": 5,
      "methodName": "EarlyErrors",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "ForDeclaration",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-for-in-and-for-of-statements-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (ForDeclaration \"BoundNames\")\n  0:if (contains __x0__ \"let\") (0) throw SyntaxError else 2:{}\n  1:(1) access __x1__ = (ForDeclaration \"BoundNames\")\n  1:(2) access __x2__ = (Statement \"VarDeclaredNames\")\n  1:let __x3__ = __x1__\n  1:let __x4__ = __x2__\n  1:let __x5__ = 0i\n  1:let __x6__ = 0i\n  1:let __x7__ = false\n  1:while (< __x5__ __x3__[\"length\"]) {\n    __x6__ = 0i\n    while (< __x6__ __x4__[\"length\"]) if (= __x3__[__x5__] __x4__[__x6__]) __x7__ = true else 2:{}\n  }\n  1:if __x7__ (1) throw SyntaxError else 2:{}\n  2:(3) access __x8__ = (ForDeclaration \"BoundNames\")\n  2:(4) app __x9__ = (IsDuplicate __x8__)\n  2:if __x9__ (2) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if the BoundNames of |ForDeclaration| contains *\"let\"*.", "          </li>", "          <li>", "            It is a Syntax Error if any element of the BoundNames of |ForDeclaration| also occurs in the VarDeclaredNames of |Statement|.", "          </li>", "          <li>", "            It is a Syntax Error if the BoundNames of |ForDeclaration| contains any duplicate entries.", "          </li>"],
    "head": {
      "idx": 8,
      "methodName": "EarlyErrors",
      "prod": "ForInOfStatement",
      "rhs": {
        "tokens": [{
          "term": "for"
        }, {
          "term": "await"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "ForDeclaration",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": [],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-for-in-and-for-of-statements-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (ForDeclaration \"BoundNames\")\n  0:if (contains __x0__ \"let\") (0) throw SyntaxError else 2:{}\n  1:(1) access __x1__ = (ForDeclaration \"BoundNames\")\n  1:(2) access __x2__ = (Statement \"VarDeclaredNames\")\n  1:let __x3__ = __x1__\n  1:let __x4__ = __x2__\n  1:let __x5__ = 0i\n  1:let __x6__ = 0i\n  1:let __x7__ = false\n  1:while (< __x5__ __x3__[\"length\"]) {\n    __x6__ = 0i\n    while (< __x6__ __x4__[\"length\"]) if (= __x3__[__x5__] __x4__[__x6__]) __x7__ = true else 2:{}\n  }\n  1:if __x7__ (1) throw SyntaxError else 2:{}\n  2:(3) access __x8__ = (ForDeclaration \"BoundNames\")\n  2:(4) app __x9__ = (IsDuplicate __x8__)\n  2:if __x9__ (2) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if this |ContinueStatement| is not nested, directly or indirectly (but not crossing function boundaries), within an |IterationStatement|.", "        </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "ContinueStatement",
      "rhs": {
        "tokens": [{
          "term": "continue"
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-continue-statement-static-semantics-early-errors",
    "rawBody": "{\n  0:let __x0__ = false\n  0:if (= absent (parse-syntax ContinueStatement \"IterationStatement\" (0) (new []))) __x0__ = true else 2:{}\n  0:if __x0__ (1) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if this |ContinueStatement| is not nested, directly or indirectly (but not crossing function boundaries), within an |IterationStatement|.", "        </li>"],
    "head": {
      "idx": 1,
      "methodName": "EarlyErrors",
      "prod": "ContinueStatement",
      "rhs": {
        "tokens": [{
          "term": "continue"
        }, {
          "args": [],
          "name": "LabelIdentifier",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-continue-statement-static-semantics-early-errors",
    "rawBody": "{\n  0:let __x0__ = false\n  0:if (= absent (parse-syntax ContinueStatement \"IterationStatement\" (0) (new []))) __x0__ = true else 2:{}\n  0:if __x0__ (1) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if this |BreakStatement| is not nested, directly or indirectly (but not crossing function boundaries), within an |IterationStatement| or a |SwitchStatement|.", "        </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "BreakStatement",
      "rhs": {
        "tokens": [{
          "term": "break"
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-break-statement-static-semantics-early-errors",
    "rawBody": "(0) ??? \"It is a Syntax Error if this nt:{BreakStatement} is not nested , directly or indirectly ( but not crossing function boundaries ) , within an nt:{IterationStatement} or a nt:{SwitchStatement} .\""
  }, {
    "code": ["        <li>", "          It is a Syntax Error if the code that matches this production is contained in strict mode code.", "        </li>", "        <li>", "          It is a Syntax Error if IsLabelledFunction(|Statement|) is *true*.", "        </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "WithStatement",
      "rhs": {
        "tokens": [{
          "term": "with"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Statement",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-with-statement-static-semantics-early-errors",
    "rawBody": "{\n  0:if true (0) throw SyntaxError else 2:{}\n  1:(0) app __x0__ = (IsLabelledFunction Statement)\n  1:if (= __x0__ true) (1) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if the LexicallyDeclaredNames of |CaseBlock| contains any duplicate entries.", "        </li>", "        <li>", "          It is a Syntax Error if any element of the LexicallyDeclaredNames of |CaseBlock| also occurs in the VarDeclaredNames of |CaseBlock|.", "        </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "SwitchStatement",
      "rhs": {
        "tokens": [{
          "term": "switch"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "CaseBlock",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-switch-statement-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (CaseBlock \"LexicallyDeclaredNames\")\n  0:(1) app __x1__ = (IsDuplicate __x0__)\n  0:if __x1__ (0) throw SyntaxError else 2:{}\n  1:(2) access __x2__ = (CaseBlock \"LexicallyDeclaredNames\")\n  1:(3) access __x3__ = (CaseBlock \"VarDeclaredNames\")\n  1:let __x4__ = __x2__\n  1:let __x5__ = __x3__\n  1:let __x6__ = 0i\n  1:let __x7__ = 0i\n  1:let __x8__ = false\n  1:while (< __x6__ __x4__[\"length\"]) {\n    __x7__ = 0i\n    while (< __x7__ __x5__[\"length\"]) if (= __x4__[__x6__] __x5__[__x7__]) __x8__ = true else 2:{}\n  }\n  1:if __x8__ (1) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if any source text matches this rule.", "        </li>"],
    "head": {
      "idx": 1,
      "methodName": "EarlyErrors",
      "prod": "LabelledItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FunctionDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-labelled-statements-static-semantics-early-errors",
    "rawBody": "if true (0) throw SyntaxError else 2:{}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if BoundNames of |CatchParameter| contains any duplicate elements.", "        </li>", "        <li>", "          It is a Syntax Error if any element of the BoundNames of |CatchParameter| also occurs in the LexicallyDeclaredNames of |Block|.", "        </li>", "        <li>", "          It is a Syntax Error if any element of the BoundNames of |CatchParameter| also occurs in the VarDeclaredNames of |Block|.", "        </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "Catch",
      "rhs": {
        "tokens": [{
          "term": "catch"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "CatchParameter",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": [],
          "name": "Block",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-try-statement-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (CatchParameter \"BoundNames\")\n  0:(1) app __x1__ = (IsDuplicate __x0__)\n  0:if __x1__ (0) throw SyntaxError else 2:{}\n  1:(2) access __x2__ = (CatchParameter \"BoundNames\")\n  1:(3) access __x3__ = (Block \"LexicallyDeclaredNames\")\n  1:let __x4__ = __x2__\n  1:let __x5__ = __x3__\n  1:let __x6__ = 0i\n  1:let __x7__ = 0i\n  1:let __x8__ = false\n  1:while (< __x6__ __x4__[\"length\"]) {\n    __x7__ = 0i\n    while (< __x7__ __x5__[\"length\"]) if (= __x4__[__x6__] __x5__[__x7__]) __x8__ = true else 2:{}\n  }\n  1:if __x8__ (1) throw SyntaxError else 2:{}\n  2:(4) access __x9__ = (CatchParameter \"BoundNames\")\n  2:(5) access __x10__ = (Block \"VarDeclaredNames\")\n  2:let __x11__ = __x9__\n  2:let __x12__ = __x10__\n  2:let __x13__ = 0i\n  2:let __x14__ = 0i\n  2:let __x15__ = false\n  2:while (< __x13__ __x11__[\"length\"]) {\n    __x14__ = 0i\n    while (< __x14__ __x12__[\"length\"]) if (= __x11__[__x13__] __x12__[__x14__]) __x15__ = true else 2:{}\n  }\n  2:if __x15__ (2) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if BoundNames of |FormalParameters| contains any duplicate elements.", "        </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "UniqueFormalParameters",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-parameter-lists-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (FormalParameters \"BoundNames\")\n  0:(1) app __x1__ = (IsDuplicate __x0__)\n  0:if __x1__ (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if IsSimpleParameterList of |FormalParameterList| is *false* and BoundNames of |FormalParameterList| contains any duplicate elements.", "        </li>"],
    "head": {
      "idx": 2,
      "methodName": "EarlyErrors",
      "prod": "FormalParameters",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FormalParameterList",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-parameter-lists-static-semantics-early-errors",
    "rawBody": "{\n  0:let __x0__ = true\n  0:(0) access __x1__ = (FormalParameterList \"IsSimpleParameterList\")\n  0:__x0__ = (= __x1__ false)\n  0:if __x0__ {\n    (1) access __x2__ = (FormalParameterList \"BoundNames\")\n    (2) app __x3__ = (IsDuplicate __x2__)\n    __x0__ = __x3__\n  } else 2:{}\n  0:if __x0__ (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          If the source code matching |FormalParameters| is strict mode code, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied.", "        </li>", "        <li>", "          If |BindingIdentifier| is present and the source code matching |BindingIdentifier| is strict mode code, it is a Syntax Error if the StringValue of |BindingIdentifier| is *\"eval\"* or *\"arguments\"*.", "        </li>", "        <li>", "          It is a Syntax Error if FunctionBodyContainsUseStrict of |FunctionBody| is *true* and IsSimpleParameterList of |FormalParameters| is *false*.", "        </li>", "        <li>", "          It is a Syntax Error if any element of the BoundNames of |FormalParameters| also occurs in the LexicallyDeclaredNames of |FunctionBody|.", "        </li>", "        <li>", "          It is a Syntax Error if |FormalParameters| Contains |SuperProperty| is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if |FunctionBody| Contains |SuperProperty| is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if |FormalParameters| Contains |SuperCall| is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if |FunctionBody| Contains |SuperCall| is *true*.", "        </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "FunctionDeclaration",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-function-definitions-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) ??? \"If the source code matching nt:{FormalParameters} is strict mode code , the Early Error rules for grammar:{UniqueFormalParameters0, [FormalParameters]} are applied .\"\n  1:if (&& (! (= BindingIdentifier absent)) true) {\n    (0) access __x0__ = (BindingIdentifier \"StringValue\")\n    if (|| (= __x0__ \"eval\") (= __x0__ \"arguments\")) (1) throw SyntaxError else 2:{}\n  } else 2:{}\n  2:let __x1__ = true\n  2:(1) access __x2__ = (FunctionBody \"FunctionBodyContainsUseStrict\")\n  2:__x1__ = (= __x2__ true)\n  2:if __x1__ {\n    (2) access __x3__ = (FormalParameters \"IsSimpleParameterList\")\n    __x1__ = (= __x3__ false)\n  } else 2:{}\n  2:if __x1__ (2) throw SyntaxError else 2:{}\n  3:(3) access __x4__ = (FormalParameters \"BoundNames\")\n  3:(4) access __x5__ = (FunctionBody \"LexicallyDeclaredNames\")\n  3:let __x6__ = __x4__\n  3:let __x7__ = __x5__\n  3:let __x8__ = 0i\n  3:let __x9__ = 0i\n  3:let __x10__ = false\n  3:while (< __x8__ __x6__[\"length\"]) {\n    __x9__ = 0i\n    while (< __x9__ __x7__[\"length\"]) if (= __x6__[__x8__] __x7__[__x9__]) __x10__ = true else 2:{}\n  }\n  3:if __x10__ (3) throw SyntaxError else 2:{}\n  4:(5) access __x11__ = (FormalParameters \"Contains\" \"SuperProperty\")\n  4:if (= __x11__ true) (4) throw SyntaxError else 2:{}\n  5:(6) access __x12__ = (FunctionBody \"Contains\" \"SuperProperty\")\n  5:if (= __x12__ true) (5) throw SyntaxError else 2:{}\n  6:(7) access __x13__ = (FormalParameters \"Contains\" \"SuperCall\")\n  6:if (= __x13__ true) (6) throw SyntaxError else 2:{}\n  7:(8) access __x14__ = (FunctionBody \"Contains\" \"SuperCall\")\n  7:if (= __x14__ true) (7) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          If the source code matching |FormalParameters| is strict mode code, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied.", "        </li>", "        <li>", "          If |BindingIdentifier| is present and the source code matching |BindingIdentifier| is strict mode code, it is a Syntax Error if the StringValue of |BindingIdentifier| is *\"eval\"* or *\"arguments\"*.", "        </li>", "        <li>", "          It is a Syntax Error if FunctionBodyContainsUseStrict of |FunctionBody| is *true* and IsSimpleParameterList of |FormalParameters| is *false*.", "        </li>", "        <li>", "          It is a Syntax Error if any element of the BoundNames of |FormalParameters| also occurs in the LexicallyDeclaredNames of |FunctionBody|.", "        </li>", "        <li>", "          It is a Syntax Error if |FormalParameters| Contains |SuperProperty| is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if |FunctionBody| Contains |SuperProperty| is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if |FormalParameters| Contains |SuperCall| is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if |FunctionBody| Contains |SuperCall| is *true*.", "        </li>"],
    "head": {
      "idx": 1,
      "methodName": "EarlyErrors",
      "prod": "FunctionDeclaration",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-function-definitions-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) ??? \"If the source code matching nt:{FormalParameters} is strict mode code , the Early Error rules for grammar:{UniqueFormalParameters0, [FormalParameters]} are applied .\"\n  1:if (&& (! (= BindingIdentifier absent)) true) {\n    (0) access __x0__ = (BindingIdentifier \"StringValue\")\n    if (|| (= __x0__ \"eval\") (= __x0__ \"arguments\")) (1) throw SyntaxError else 2:{}\n  } else 2:{}\n  2:let __x1__ = true\n  2:(1) access __x2__ = (FunctionBody \"FunctionBodyContainsUseStrict\")\n  2:__x1__ = (= __x2__ true)\n  2:if __x1__ {\n    (2) access __x3__ = (FormalParameters \"IsSimpleParameterList\")\n    __x1__ = (= __x3__ false)\n  } else 2:{}\n  2:if __x1__ (2) throw SyntaxError else 2:{}\n  3:(3) access __x4__ = (FormalParameters \"BoundNames\")\n  3:(4) access __x5__ = (FunctionBody \"LexicallyDeclaredNames\")\n  3:let __x6__ = __x4__\n  3:let __x7__ = __x5__\n  3:let __x8__ = 0i\n  3:let __x9__ = 0i\n  3:let __x10__ = false\n  3:while (< __x8__ __x6__[\"length\"]) {\n    __x9__ = 0i\n    while (< __x9__ __x7__[\"length\"]) if (= __x6__[__x8__] __x7__[__x9__]) __x10__ = true else 2:{}\n  }\n  3:if __x10__ (3) throw SyntaxError else 2:{}\n  4:(5) access __x11__ = (FormalParameters \"Contains\" \"SuperProperty\")\n  4:if (= __x11__ true) (4) throw SyntaxError else 2:{}\n  5:(6) access __x12__ = (FunctionBody \"Contains\" \"SuperProperty\")\n  5:if (= __x12__ true) (5) throw SyntaxError else 2:{}\n  6:(7) access __x13__ = (FormalParameters \"Contains\" \"SuperCall\")\n  6:if (= __x13__ true) (6) throw SyntaxError else 2:{}\n  7:(8) access __x14__ = (FunctionBody \"Contains\" \"SuperCall\")\n  7:if (= __x14__ true) (7) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          If the source code matching |FormalParameters| is strict mode code, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied.", "        </li>", "        <li>", "          If |BindingIdentifier| is present and the source code matching |BindingIdentifier| is strict mode code, it is a Syntax Error if the StringValue of |BindingIdentifier| is *\"eval\"* or *\"arguments\"*.", "        </li>", "        <li>", "          It is a Syntax Error if FunctionBodyContainsUseStrict of |FunctionBody| is *true* and IsSimpleParameterList of |FormalParameters| is *false*.", "        </li>", "        <li>", "          It is a Syntax Error if any element of the BoundNames of |FormalParameters| also occurs in the LexicallyDeclaredNames of |FunctionBody|.", "        </li>", "        <li>", "          It is a Syntax Error if |FormalParameters| Contains |SuperProperty| is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if |FunctionBody| Contains |SuperProperty| is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if |FormalParameters| Contains |SuperCall| is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if |FunctionBody| Contains |SuperCall| is *true*.", "        </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "FunctionExpression",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": true
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-function-definitions-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) ??? \"If the source code matching nt:{FormalParameters} is strict mode code , the Early Error rules for grammar:{UniqueFormalParameters0, [FormalParameters]} are applied .\"\n  1:if (&& (! (= BindingIdentifier absent)) true) {\n    (0) access __x0__ = (BindingIdentifier \"StringValue\")\n    if (|| (= __x0__ \"eval\") (= __x0__ \"arguments\")) (1) throw SyntaxError else 2:{}\n  } else 2:{}\n  2:let __x1__ = true\n  2:(1) access __x2__ = (FunctionBody \"FunctionBodyContainsUseStrict\")\n  2:__x1__ = (= __x2__ true)\n  2:if __x1__ {\n    (2) access __x3__ = (FormalParameters \"IsSimpleParameterList\")\n    __x1__ = (= __x3__ false)\n  } else 2:{}\n  2:if __x1__ (2) throw SyntaxError else 2:{}\n  3:(3) access __x4__ = (FormalParameters \"BoundNames\")\n  3:(4) access __x5__ = (FunctionBody \"LexicallyDeclaredNames\")\n  3:let __x6__ = __x4__\n  3:let __x7__ = __x5__\n  3:let __x8__ = 0i\n  3:let __x9__ = 0i\n  3:let __x10__ = false\n  3:while (< __x8__ __x6__[\"length\"]) {\n    __x9__ = 0i\n    while (< __x9__ __x7__[\"length\"]) if (= __x6__[__x8__] __x7__[__x9__]) __x10__ = true else 2:{}\n  }\n  3:if __x10__ (3) throw SyntaxError else 2:{}\n  4:(5) access __x11__ = (FormalParameters \"Contains\" \"SuperProperty\")\n  4:if (= __x11__ true) (4) throw SyntaxError else 2:{}\n  5:(6) access __x12__ = (FunctionBody \"Contains\" \"SuperProperty\")\n  5:if (= __x12__ true) (5) throw SyntaxError else 2:{}\n  6:(7) access __x13__ = (FormalParameters \"Contains\" \"SuperCall\")\n  6:if (= __x13__ true) (6) throw SyntaxError else 2:{}\n  7:(8) access __x14__ = (FunctionBody \"Contains\" \"SuperCall\")\n  7:if (= __x14__ true) (7) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if the LexicallyDeclaredNames of |FunctionStatementList| contains any duplicate entries.", "        </li>", "        <li>", "          It is a Syntax Error if any element of the LexicallyDeclaredNames of |FunctionStatementList| also occurs in the VarDeclaredNames of |FunctionStatementList|.", "        </li>", "        <li>", "          It is a Syntax Error if ContainsDuplicateLabels of |FunctionStatementList| with argument « » is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if ContainsUndefinedBreakTarget of |FunctionStatementList| with argument « » is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if ContainsUndefinedContinueTarget of |FunctionStatementList| with arguments « » and « » is *true*.", "        </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "FunctionBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "FunctionStatementList",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-function-definitions-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (FunctionStatementList \"LexicallyDeclaredNames\")\n  0:(1) app __x1__ = (IsDuplicate __x0__)\n  0:if __x1__ (0) throw SyntaxError else 2:{}\n  1:(2) access __x2__ = (FunctionStatementList \"LexicallyDeclaredNames\")\n  1:(3) access __x3__ = (FunctionStatementList \"VarDeclaredNames\")\n  1:let __x4__ = __x2__\n  1:let __x5__ = __x3__\n  1:let __x6__ = 0i\n  1:let __x7__ = 0i\n  1:let __x8__ = false\n  1:while (< __x6__ __x4__[\"length\"]) {\n    __x7__ = 0i\n    while (< __x7__ __x5__[\"length\"]) if (= __x4__[__x6__] __x5__[__x7__]) __x8__ = true else 2:{}\n  }\n  1:if __x8__ (1) throw SyntaxError else 2:{}\n  2:(4) access __x9__ = (FunctionStatementList \"ContainsDuplicateLabels\" (2) (new []))\n  2:if (= __x9__ true) (3) throw SyntaxError else 2:{}\n  3:(5) access __x10__ = (FunctionStatementList \"ContainsUndefinedBreakTarget\" (4) (new []))\n  3:if (= __x10__ true) (5) throw SyntaxError else 2:{}\n  4:(6) access __x11__ = (FunctionStatementList \"ContainsUndefinedContinueTarget\" (6) (new []) (7) (new []))\n  4:if (= __x11__ true) (8) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if |ArrowParameters| Contains |YieldExpression| is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if |ArrowParameters| Contains |AwaitExpression| is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if ConciseBodyContainsUseStrict of |ConciseBody| is *true* and IsSimpleParameterList of |ArrowParameters| is *false*.", "        </li>", "        <li>", "          It is a Syntax Error if any element of the BoundNames of |ArrowParameters| also occurs in the LexicallyDeclaredNames of |ConciseBody|.", "        </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "ArrowFunction",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ArrowParameters",
          "optional": false
        }, {
          "term": "=>"
        }, {
          "args": [],
          "name": "ConciseBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-arrow-function-definitions-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (ArrowParameters \"Contains\" \"YieldExpression\")\n  0:if (= __x0__ true) (0) throw SyntaxError else 2:{}\n  1:(1) access __x1__ = (ArrowParameters \"Contains\" \"AwaitExpression\")\n  1:if (= __x1__ true) (1) throw SyntaxError else 2:{}\n  2:let __x2__ = true\n  2:(2) access __x3__ = (ConciseBody \"ConciseBodyContainsUseStrict\")\n  2:__x2__ = (= __x3__ true)\n  2:if __x2__ {\n    (3) access __x4__ = (ArrowParameters \"IsSimpleParameterList\")\n    __x2__ = (= __x4__ false)\n  } else 2:{}\n  2:if __x2__ (2) throw SyntaxError else 2:{}\n  3:(4) access __x5__ = (ArrowParameters \"BoundNames\")\n  3:(5) access __x6__ = (ConciseBody \"LexicallyDeclaredNames\")\n  3:let __x7__ = __x5__\n  3:let __x8__ = __x6__\n  3:let __x9__ = 0i\n  3:let __x10__ = 0i\n  3:let __x11__ = false\n  3:while (< __x9__ __x7__[\"length\"]) {\n    __x10__ = 0i\n    while (< __x10__ __x8__[\"length\"]) if (= __x7__[__x9__] __x8__[__x10__]) __x11__ = true else 2:{}\n  }\n  3:if __x11__ (3) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if |CoverParenthesizedExpressionAndArrowParameterList| is not covering an |ArrowFormalParameters|.", "        </li>", "        <li>", "          All early error rules for |ArrowFormalParameters| and its derived productions also apply to CoveredFormalsList of |CoverParenthesizedExpressionAndArrowParameterList|.", "        </li>"],
    "head": {
      "idx": 1,
      "methodName": "EarlyErrors",
      "prod": "ArrowParameters",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CoverParenthesizedExpressionAndArrowParameterList",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-arrow-function-definitions-static-semantics-early-errors",
    "rawBody": "{\n  0:let __x0__ = false\n  0:if (= absent (parse-syntax CoverParenthesizedExpressionAndArrowParameterList \"ArrowFormalParameters\" (0) (new []))) __x0__ = true else 2:{}\n  0:if __x0__ (1) throw SyntaxError else 2:{}\n  1:(2) ??? \"All early error rules for nt:{ArrowFormalParameters} and its derived productions also apply to CoveredFormalsList of nt:{CoverParenthesizedExpressionAndArrowParameterList} .\"\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if FunctionBodyContainsUseStrict of |FunctionBody| is *true* and IsSimpleParameterList of |UniqueFormalParameters| is *false*.", "        </li>", "        <li>", "          It is a Syntax Error if any element of the BoundNames of |UniqueFormalParameters| also occurs in the LexicallyDeclaredNames of |FunctionBody|.", "        </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "MethodDefinition",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-method-definitions-static-semantics-early-errors",
    "rawBody": "{\n  0:let __x0__ = true\n  0:(0) access __x1__ = (FunctionBody \"FunctionBodyContainsUseStrict\")\n  0:__x0__ = (= __x1__ true)\n  0:if __x0__ {\n    (1) access __x2__ = (UniqueFormalParameters \"IsSimpleParameterList\")\n    __x0__ = (= __x2__ false)\n  } else 2:{}\n  0:if __x0__ (0) throw SyntaxError else 2:{}\n  1:(2) access __x3__ = (UniqueFormalParameters \"BoundNames\")\n  1:(3) access __x4__ = (FunctionBody \"LexicallyDeclaredNames\")\n  1:let __x5__ = __x3__\n  1:let __x6__ = __x4__\n  1:let __x7__ = 0i\n  1:let __x8__ = 0i\n  1:let __x9__ = false\n  1:while (< __x7__ __x5__[\"length\"]) {\n    __x8__ = 0i\n    while (< __x8__ __x6__[\"length\"]) if (= __x5__[__x7__] __x6__[__x8__]) __x9__ = true else 2:{}\n  }\n  1:if __x9__ (1) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if BoundNames of |PropertySetParameterList| contains any duplicate elements.", "        </li>", "        <li>", "          It is a Syntax Error if FunctionBodyContainsUseStrict of |FunctionBody| is *true* and IsSimpleParameterList of |PropertySetParameterList| is *false*.", "        </li>", "        <li>", "          It is a Syntax Error if any element of the BoundNames of |PropertySetParameterList| also occurs in the LexicallyDeclaredNames of |FunctionBody|.", "        </li>"],
    "head": {
      "idx": 5,
      "methodName": "EarlyErrors",
      "prod": "MethodDefinition",
      "rhs": {
        "tokens": [{
          "term": "set"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "PropertySetParameterList",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-method-definitions-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (PropertySetParameterList \"BoundNames\")\n  0:(1) app __x1__ = (IsDuplicate __x0__)\n  0:if __x1__ (0) throw SyntaxError else 2:{}\n  1:let __x2__ = true\n  1:(2) access __x3__ = (FunctionBody \"FunctionBodyContainsUseStrict\")\n  1:__x2__ = (= __x3__ true)\n  1:if __x2__ {\n    (3) access __x4__ = (PropertySetParameterList \"IsSimpleParameterList\")\n    __x2__ = (= __x4__ false)\n  } else 2:{}\n  1:if __x2__ (1) throw SyntaxError else 2:{}\n  2:(4) access __x5__ = (PropertySetParameterList \"BoundNames\")\n  2:(5) access __x6__ = (FunctionBody \"LexicallyDeclaredNames\")\n  2:let __x7__ = __x5__\n  2:let __x8__ = __x6__\n  2:let __x9__ = 0i\n  2:let __x10__ = 0i\n  2:let __x11__ = false\n  2:while (< __x9__ __x7__[\"length\"]) {\n    __x10__ = 0i\n    while (< __x10__ __x8__[\"length\"]) if (= __x7__[__x9__] __x8__[__x10__]) __x11__ = true else 2:{}\n  }\n  2:if __x11__ (2) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if HasDirectSuper of |GeneratorMethod| is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if |UniqueFormalParameters| Contains |YieldExpression| is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if FunctionBodyContainsUseStrict of |GeneratorBody| is *true* and IsSimpleParameterList of |UniqueFormalParameters| is *false*.", "        </li>", "        <li>", "          It is a Syntax Error if any element of the BoundNames of |UniqueFormalParameters| also occurs in the LexicallyDeclaredNames of |GeneratorBody|.", "        </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "GeneratorMethod",
      "rhs": {
        "tokens": [{
          "term": "*"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-generator-function-definitions-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (GeneratorMethod \"HasDirectSuper\")\n  0:if (= __x0__ true) (0) throw SyntaxError else 2:{}\n  1:(1) access __x1__ = (UniqueFormalParameters \"Contains\" \"YieldExpression\")\n  1:if (= __x1__ true) (1) throw SyntaxError else 2:{}\n  2:let __x2__ = true\n  2:(2) access __x3__ = (GeneratorBody \"FunctionBodyContainsUseStrict\")\n  2:__x2__ = (= __x3__ true)\n  2:if __x2__ {\n    (3) access __x4__ = (UniqueFormalParameters \"IsSimpleParameterList\")\n    __x2__ = (= __x4__ false)\n  } else 2:{}\n  2:if __x2__ (2) throw SyntaxError else 2:{}\n  3:(4) access __x5__ = (UniqueFormalParameters \"BoundNames\")\n  3:(5) access __x6__ = (GeneratorBody \"LexicallyDeclaredNames\")\n  3:let __x7__ = __x5__\n  3:let __x8__ = __x6__\n  3:let __x9__ = 0i\n  3:let __x10__ = 0i\n  3:let __x11__ = false\n  3:while (< __x9__ __x7__[\"length\"]) {\n    __x10__ = 0i\n    while (< __x10__ __x8__[\"length\"]) if (= __x7__[__x9__] __x8__[__x10__]) __x11__ = true else 2:{}\n  }\n  3:if __x11__ (3) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          If the source code matching |FormalParameters| is strict mode code, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied.", "        </li>", "        <li>", "          If |BindingIdentifier| is present and the source code matching |BindingIdentifier| is strict mode code, it is a Syntax Error if the StringValue of |BindingIdentifier| is *\"eval\"* or *\"arguments\"*.", "        </li>", "        <li>", "          It is a Syntax Error if FunctionBodyContainsUseStrict of |GeneratorBody| is *true* and IsSimpleParameterList of |FormalParameters| is *false*.", "        </li>", "        <li>", "          It is a Syntax Error if any element of the BoundNames of |FormalParameters| also occurs in the LexicallyDeclaredNames of |GeneratorBody|.", "        </li>", "        <li>", "          It is a Syntax Error if |FormalParameters| Contains |YieldExpression| is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if |FormalParameters| Contains |SuperProperty| is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if |GeneratorBody| Contains |SuperProperty| is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if |FormalParameters| Contains |SuperCall| is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if |GeneratorBody| Contains |SuperCall| is *true*.", "        </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "GeneratorDeclaration",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-generator-function-definitions-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) ??? \"If the source code matching nt:{FormalParameters} is strict mode code , the Early Error rules for grammar:{UniqueFormalParameters0, [FormalParameters]} are applied .\"\n  1:if (&& (! (= BindingIdentifier absent)) true) {\n    (0) access __x0__ = (BindingIdentifier \"StringValue\")\n    if (|| (= __x0__ \"eval\") (= __x0__ \"arguments\")) (1) throw SyntaxError else 2:{}\n  } else 2:{}\n  2:let __x1__ = true\n  2:(1) access __x2__ = (GeneratorBody \"FunctionBodyContainsUseStrict\")\n  2:__x1__ = (= __x2__ true)\n  2:if __x1__ {\n    (2) access __x3__ = (FormalParameters \"IsSimpleParameterList\")\n    __x1__ = (= __x3__ false)\n  } else 2:{}\n  2:if __x1__ (2) throw SyntaxError else 2:{}\n  3:(3) access __x4__ = (FormalParameters \"BoundNames\")\n  3:(4) access __x5__ = (GeneratorBody \"LexicallyDeclaredNames\")\n  3:let __x6__ = __x4__\n  3:let __x7__ = __x5__\n  3:let __x8__ = 0i\n  3:let __x9__ = 0i\n  3:let __x10__ = false\n  3:while (< __x8__ __x6__[\"length\"]) {\n    __x9__ = 0i\n    while (< __x9__ __x7__[\"length\"]) if (= __x6__[__x8__] __x7__[__x9__]) __x10__ = true else 2:{}\n  }\n  3:if __x10__ (3) throw SyntaxError else 2:{}\n  4:(5) access __x11__ = (FormalParameters \"Contains\" \"YieldExpression\")\n  4:if (= __x11__ true) (4) throw SyntaxError else 2:{}\n  5:(6) access __x12__ = (FormalParameters \"Contains\" \"SuperProperty\")\n  5:if (= __x12__ true) (5) throw SyntaxError else 2:{}\n  6:(7) access __x13__ = (GeneratorBody \"Contains\" \"SuperProperty\")\n  6:if (= __x13__ true) (6) throw SyntaxError else 2:{}\n  7:(8) access __x14__ = (FormalParameters \"Contains\" \"SuperCall\")\n  7:if (= __x14__ true) (7) throw SyntaxError else 2:{}\n  8:(9) access __x15__ = (GeneratorBody \"Contains\" \"SuperCall\")\n  8:if (= __x15__ true) (8) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          If the source code matching |FormalParameters| is strict mode code, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied.", "        </li>", "        <li>", "          If |BindingIdentifier| is present and the source code matching |BindingIdentifier| is strict mode code, it is a Syntax Error if the StringValue of |BindingIdentifier| is *\"eval\"* or *\"arguments\"*.", "        </li>", "        <li>", "          It is a Syntax Error if FunctionBodyContainsUseStrict of |GeneratorBody| is *true* and IsSimpleParameterList of |FormalParameters| is *false*.", "        </li>", "        <li>", "          It is a Syntax Error if any element of the BoundNames of |FormalParameters| also occurs in the LexicallyDeclaredNames of |GeneratorBody|.", "        </li>", "        <li>", "          It is a Syntax Error if |FormalParameters| Contains |YieldExpression| is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if |FormalParameters| Contains |SuperProperty| is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if |GeneratorBody| Contains |SuperProperty| is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if |FormalParameters| Contains |SuperCall| is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if |GeneratorBody| Contains |SuperCall| is *true*.", "        </li>"],
    "head": {
      "idx": 1,
      "methodName": "EarlyErrors",
      "prod": "GeneratorDeclaration",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "*"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-generator-function-definitions-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) ??? \"If the source code matching nt:{FormalParameters} is strict mode code , the Early Error rules for grammar:{UniqueFormalParameters0, [FormalParameters]} are applied .\"\n  1:if (&& (! (= BindingIdentifier absent)) true) {\n    (0) access __x0__ = (BindingIdentifier \"StringValue\")\n    if (|| (= __x0__ \"eval\") (= __x0__ \"arguments\")) (1) throw SyntaxError else 2:{}\n  } else 2:{}\n  2:let __x1__ = true\n  2:(1) access __x2__ = (GeneratorBody \"FunctionBodyContainsUseStrict\")\n  2:__x1__ = (= __x2__ true)\n  2:if __x1__ {\n    (2) access __x3__ = (FormalParameters \"IsSimpleParameterList\")\n    __x1__ = (= __x3__ false)\n  } else 2:{}\n  2:if __x1__ (2) throw SyntaxError else 2:{}\n  3:(3) access __x4__ = (FormalParameters \"BoundNames\")\n  3:(4) access __x5__ = (GeneratorBody \"LexicallyDeclaredNames\")\n  3:let __x6__ = __x4__\n  3:let __x7__ = __x5__\n  3:let __x8__ = 0i\n  3:let __x9__ = 0i\n  3:let __x10__ = false\n  3:while (< __x8__ __x6__[\"length\"]) {\n    __x9__ = 0i\n    while (< __x9__ __x7__[\"length\"]) if (= __x6__[__x8__] __x7__[__x9__]) __x10__ = true else 2:{}\n  }\n  3:if __x10__ (3) throw SyntaxError else 2:{}\n  4:(5) access __x11__ = (FormalParameters \"Contains\" \"YieldExpression\")\n  4:if (= __x11__ true) (4) throw SyntaxError else 2:{}\n  5:(6) access __x12__ = (FormalParameters \"Contains\" \"SuperProperty\")\n  5:if (= __x12__ true) (5) throw SyntaxError else 2:{}\n  6:(7) access __x13__ = (GeneratorBody \"Contains\" \"SuperProperty\")\n  6:if (= __x13__ true) (6) throw SyntaxError else 2:{}\n  7:(8) access __x14__ = (FormalParameters \"Contains\" \"SuperCall\")\n  7:if (= __x14__ true) (7) throw SyntaxError else 2:{}\n  8:(9) access __x15__ = (GeneratorBody \"Contains\" \"SuperCall\")\n  8:if (= __x15__ true) (8) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          If the source code matching |FormalParameters| is strict mode code, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied.", "        </li>", "        <li>", "          If |BindingIdentifier| is present and the source code matching |BindingIdentifier| is strict mode code, it is a Syntax Error if the StringValue of |BindingIdentifier| is *\"eval\"* or *\"arguments\"*.", "        </li>", "        <li>", "          It is a Syntax Error if FunctionBodyContainsUseStrict of |GeneratorBody| is *true* and IsSimpleParameterList of |FormalParameters| is *false*.", "        </li>", "        <li>", "          It is a Syntax Error if any element of the BoundNames of |FormalParameters| also occurs in the LexicallyDeclaredNames of |GeneratorBody|.", "        </li>", "        <li>", "          It is a Syntax Error if |FormalParameters| Contains |YieldExpression| is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if |FormalParameters| Contains |SuperProperty| is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if |GeneratorBody| Contains |SuperProperty| is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if |FormalParameters| Contains |SuperCall| is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if |GeneratorBody| Contains |SuperCall| is *true*.", "        </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "GeneratorExpression",
      "rhs": {
        "tokens": [{
          "term": "function"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": true
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-generator-function-definitions-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) ??? \"If the source code matching nt:{FormalParameters} is strict mode code , the Early Error rules for grammar:{UniqueFormalParameters0, [FormalParameters]} are applied .\"\n  1:if (&& (! (= BindingIdentifier absent)) true) {\n    (0) access __x0__ = (BindingIdentifier \"StringValue\")\n    if (|| (= __x0__ \"eval\") (= __x0__ \"arguments\")) (1) throw SyntaxError else 2:{}\n  } else 2:{}\n  2:let __x1__ = true\n  2:(1) access __x2__ = (GeneratorBody \"FunctionBodyContainsUseStrict\")\n  2:__x1__ = (= __x2__ true)\n  2:if __x1__ {\n    (2) access __x3__ = (FormalParameters \"IsSimpleParameterList\")\n    __x1__ = (= __x3__ false)\n  } else 2:{}\n  2:if __x1__ (2) throw SyntaxError else 2:{}\n  3:(3) access __x4__ = (FormalParameters \"BoundNames\")\n  3:(4) access __x5__ = (GeneratorBody \"LexicallyDeclaredNames\")\n  3:let __x6__ = __x4__\n  3:let __x7__ = __x5__\n  3:let __x8__ = 0i\n  3:let __x9__ = 0i\n  3:let __x10__ = false\n  3:while (< __x8__ __x6__[\"length\"]) {\n    __x9__ = 0i\n    while (< __x9__ __x7__[\"length\"]) if (= __x6__[__x8__] __x7__[__x9__]) __x10__ = true else 2:{}\n  }\n  3:if __x10__ (3) throw SyntaxError else 2:{}\n  4:(5) access __x11__ = (FormalParameters \"Contains\" \"YieldExpression\")\n  4:if (= __x11__ true) (4) throw SyntaxError else 2:{}\n  5:(6) access __x12__ = (FormalParameters \"Contains\" \"SuperProperty\")\n  5:if (= __x12__ true) (5) throw SyntaxError else 2:{}\n  6:(7) access __x13__ = (GeneratorBody \"Contains\" \"SuperProperty\")\n  6:if (= __x13__ true) (6) throw SyntaxError else 2:{}\n  7:(8) access __x14__ = (FormalParameters \"Contains\" \"SuperCall\")\n  7:if (= __x14__ true) (7) throw SyntaxError else 2:{}\n  8:(9) access __x15__ = (GeneratorBody \"Contains\" \"SuperCall\")\n  8:if (= __x15__ true) (8) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>It is a Syntax Error if HasDirectSuper of |AsyncGeneratorMethod| is *true*.</li>", "        <li>It is a Syntax Error if |UniqueFormalParameters| Contains |YieldExpression| is *true*.</li>", "        <li>It is a Syntax Error if |UniqueFormalParameters| Contains |AwaitExpression| is *true*.</li>", "        <li>It is a Syntax Error if FunctionBodyContainsUseStrict of |AsyncGeneratorBody| is *true* and IsSimpleParameterList of |UniqueFormalParameters| is *false*.</li>", "        <li>It is a Syntax Error if any element of the BoundNames of |UniqueFormalParameters| also occurs in the LexicallyDeclaredNames of |AsyncGeneratorBody|.</li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "AsyncGeneratorMethod",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-async-generator-function-definitions-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (AsyncGeneratorMethod \"HasDirectSuper\")\n  0:if (= __x0__ true) (0) throw SyntaxError else 2:{}\n  1:(1) access __x1__ = (UniqueFormalParameters \"Contains\" \"YieldExpression\")\n  1:if (= __x1__ true) (1) throw SyntaxError else 2:{}\n  2:(2) access __x2__ = (UniqueFormalParameters \"Contains\" \"AwaitExpression\")\n  2:if (= __x2__ true) (2) throw SyntaxError else 2:{}\n  3:let __x3__ = true\n  3:(3) access __x4__ = (AsyncGeneratorBody \"FunctionBodyContainsUseStrict\")\n  3:__x3__ = (= __x4__ true)\n  3:if __x3__ {\n    (4) access __x5__ = (UniqueFormalParameters \"IsSimpleParameterList\")\n    __x3__ = (= __x5__ false)\n  } else 2:{}\n  3:if __x3__ (3) throw SyntaxError else 2:{}\n  4:(5) access __x6__ = (UniqueFormalParameters \"BoundNames\")\n  4:(6) access __x7__ = (AsyncGeneratorBody \"LexicallyDeclaredNames\")\n  4:let __x8__ = __x6__\n  4:let __x9__ = __x7__\n  4:let __x10__ = 0i\n  4:let __x11__ = 0i\n  4:let __x12__ = false\n  4:while (< __x10__ __x8__[\"length\"]) {\n    __x11__ = 0i\n    while (< __x11__ __x9__[\"length\"]) if (= __x8__[__x10__] __x9__[__x11__]) __x12__ = true else 2:{}\n  }\n  4:if __x12__ (4) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>If the source code matching |FormalParameters| is strict mode code, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied.</li>", "        <li>If |BindingIdentifier| is present and the source code matching |BindingIdentifier| is strict mode code, it is a Syntax Error if the StringValue of |BindingIdentifier| is *\"eval\"* or *\"arguments\"*.</li>", "        <li>It is a Syntax Error if FunctionBodyContainsUseStrict of |AsyncGeneratorBody| is *true* and IsSimpleParameterList of |FormalParameters| is *false*.</li>", "        <li>It is a Syntax Error if any element of the BoundNames of |FormalParameters| also occurs in the LexicallyDeclaredNames of |AsyncGeneratorBody|.</li>", "        <li>It is a Syntax Error if |FormalParameters| Contains |YieldExpression| is *true*.</li>", "        <li>It is a Syntax Error if |FormalParameters| Contains |AwaitExpression| is *true*.</li>", "        <li>It is a Syntax Error if |FormalParameters| Contains |SuperProperty| is *true*.</li>", "        <li>It is a Syntax Error if |AsyncGeneratorBody| Contains |SuperProperty| is *true*.</li>", "        <li>It is a Syntax Error if |FormalParameters| Contains |SuperCall| is *true*.</li>", "        <li>It is a Syntax Error if |AsyncGeneratorBody| Contains |SuperCall| is *true*.</li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "AsyncGeneratorDeclaration",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-async-generator-function-definitions-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) ??? \"If the source code matching nt:{FormalParameters} is strict mode code , the Early Error rules for grammar:{UniqueFormalParameters0, [FormalParameters]} are applied .\"\n  1:if (&& (! (= BindingIdentifier absent)) true) {\n    (0) access __x0__ = (BindingIdentifier \"StringValue\")\n    if (|| (= __x0__ \"eval\") (= __x0__ \"arguments\")) (1) throw SyntaxError else 2:{}\n  } else 2:{}\n  2:let __x1__ = true\n  2:(1) access __x2__ = (AsyncGeneratorBody \"FunctionBodyContainsUseStrict\")\n  2:__x1__ = (= __x2__ true)\n  2:if __x1__ {\n    (2) access __x3__ = (FormalParameters \"IsSimpleParameterList\")\n    __x1__ = (= __x3__ false)\n  } else 2:{}\n  2:if __x1__ (2) throw SyntaxError else 2:{}\n  3:(3) access __x4__ = (FormalParameters \"BoundNames\")\n  3:(4) access __x5__ = (AsyncGeneratorBody \"LexicallyDeclaredNames\")\n  3:let __x6__ = __x4__\n  3:let __x7__ = __x5__\n  3:let __x8__ = 0i\n  3:let __x9__ = 0i\n  3:let __x10__ = false\n  3:while (< __x8__ __x6__[\"length\"]) {\n    __x9__ = 0i\n    while (< __x9__ __x7__[\"length\"]) if (= __x6__[__x8__] __x7__[__x9__]) __x10__ = true else 2:{}\n  }\n  3:if __x10__ (3) throw SyntaxError else 2:{}\n  4:(5) access __x11__ = (FormalParameters \"Contains\" \"YieldExpression\")\n  4:if (= __x11__ true) (4) throw SyntaxError else 2:{}\n  5:(6) access __x12__ = (FormalParameters \"Contains\" \"AwaitExpression\")\n  5:if (= __x12__ true) (5) throw SyntaxError else 2:{}\n  6:(7) access __x13__ = (FormalParameters \"Contains\" \"SuperProperty\")\n  6:if (= __x13__ true) (6) throw SyntaxError else 2:{}\n  7:(8) access __x14__ = (AsyncGeneratorBody \"Contains\" \"SuperProperty\")\n  7:if (= __x14__ true) (7) throw SyntaxError else 2:{}\n  8:(9) access __x15__ = (FormalParameters \"Contains\" \"SuperCall\")\n  8:if (= __x15__ true) (8) throw SyntaxError else 2:{}\n  9:(10) access __x16__ = (AsyncGeneratorBody \"Contains\" \"SuperCall\")\n  9:if (= __x16__ true) (9) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>If the source code matching |FormalParameters| is strict mode code, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied.</li>", "        <li>If |BindingIdentifier| is present and the source code matching |BindingIdentifier| is strict mode code, it is a Syntax Error if the StringValue of |BindingIdentifier| is *\"eval\"* or *\"arguments\"*.</li>", "        <li>It is a Syntax Error if FunctionBodyContainsUseStrict of |AsyncGeneratorBody| is *true* and IsSimpleParameterList of |FormalParameters| is *false*.</li>", "        <li>It is a Syntax Error if any element of the BoundNames of |FormalParameters| also occurs in the LexicallyDeclaredNames of |AsyncGeneratorBody|.</li>", "        <li>It is a Syntax Error if |FormalParameters| Contains |YieldExpression| is *true*.</li>", "        <li>It is a Syntax Error if |FormalParameters| Contains |AwaitExpression| is *true*.</li>", "        <li>It is a Syntax Error if |FormalParameters| Contains |SuperProperty| is *true*.</li>", "        <li>It is a Syntax Error if |AsyncGeneratorBody| Contains |SuperProperty| is *true*.</li>", "        <li>It is a Syntax Error if |FormalParameters| Contains |SuperCall| is *true*.</li>", "        <li>It is a Syntax Error if |AsyncGeneratorBody| Contains |SuperCall| is *true*.</li>"],
    "head": {
      "idx": 1,
      "methodName": "EarlyErrors",
      "prod": "AsyncGeneratorDeclaration",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "*"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-async-generator-function-definitions-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) ??? \"If the source code matching nt:{FormalParameters} is strict mode code , the Early Error rules for grammar:{UniqueFormalParameters0, [FormalParameters]} are applied .\"\n  1:if (&& (! (= BindingIdentifier absent)) true) {\n    (0) access __x0__ = (BindingIdentifier \"StringValue\")\n    if (|| (= __x0__ \"eval\") (= __x0__ \"arguments\")) (1) throw SyntaxError else 2:{}\n  } else 2:{}\n  2:let __x1__ = true\n  2:(1) access __x2__ = (AsyncGeneratorBody \"FunctionBodyContainsUseStrict\")\n  2:__x1__ = (= __x2__ true)\n  2:if __x1__ {\n    (2) access __x3__ = (FormalParameters \"IsSimpleParameterList\")\n    __x1__ = (= __x3__ false)\n  } else 2:{}\n  2:if __x1__ (2) throw SyntaxError else 2:{}\n  3:(3) access __x4__ = (FormalParameters \"BoundNames\")\n  3:(4) access __x5__ = (AsyncGeneratorBody \"LexicallyDeclaredNames\")\n  3:let __x6__ = __x4__\n  3:let __x7__ = __x5__\n  3:let __x8__ = 0i\n  3:let __x9__ = 0i\n  3:let __x10__ = false\n  3:while (< __x8__ __x6__[\"length\"]) {\n    __x9__ = 0i\n    while (< __x9__ __x7__[\"length\"]) if (= __x6__[__x8__] __x7__[__x9__]) __x10__ = true else 2:{}\n  }\n  3:if __x10__ (3) throw SyntaxError else 2:{}\n  4:(5) access __x11__ = (FormalParameters \"Contains\" \"YieldExpression\")\n  4:if (= __x11__ true) (4) throw SyntaxError else 2:{}\n  5:(6) access __x12__ = (FormalParameters \"Contains\" \"AwaitExpression\")\n  5:if (= __x12__ true) (5) throw SyntaxError else 2:{}\n  6:(7) access __x13__ = (FormalParameters \"Contains\" \"SuperProperty\")\n  6:if (= __x13__ true) (6) throw SyntaxError else 2:{}\n  7:(8) access __x14__ = (AsyncGeneratorBody \"Contains\" \"SuperProperty\")\n  7:if (= __x14__ true) (7) throw SyntaxError else 2:{}\n  8:(9) access __x15__ = (FormalParameters \"Contains\" \"SuperCall\")\n  8:if (= __x15__ true) (8) throw SyntaxError else 2:{}\n  9:(10) access __x16__ = (AsyncGeneratorBody \"Contains\" \"SuperCall\")\n  9:if (= __x16__ true) (9) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>If the source code matching |FormalParameters| is strict mode code, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied.</li>", "        <li>If |BindingIdentifier| is present and the source code matching |BindingIdentifier| is strict mode code, it is a Syntax Error if the StringValue of |BindingIdentifier| is *\"eval\"* or *\"arguments\"*.</li>", "        <li>It is a Syntax Error if FunctionBodyContainsUseStrict of |AsyncGeneratorBody| is *true* and IsSimpleParameterList of |FormalParameters| is *false*.</li>", "        <li>It is a Syntax Error if any element of the BoundNames of |FormalParameters| also occurs in the LexicallyDeclaredNames of |AsyncGeneratorBody|.</li>", "        <li>It is a Syntax Error if |FormalParameters| Contains |YieldExpression| is *true*.</li>", "        <li>It is a Syntax Error if |FormalParameters| Contains |AwaitExpression| is *true*.</li>", "        <li>It is a Syntax Error if |FormalParameters| Contains |SuperProperty| is *true*.</li>", "        <li>It is a Syntax Error if |AsyncGeneratorBody| Contains |SuperProperty| is *true*.</li>", "        <li>It is a Syntax Error if |FormalParameters| Contains |SuperCall| is *true*.</li>", "        <li>It is a Syntax Error if |AsyncGeneratorBody| Contains |SuperCall| is *true*.</li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "AsyncGeneratorExpression",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "*"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": true
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-async-generator-function-definitions-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) ??? \"If the source code matching nt:{FormalParameters} is strict mode code , the Early Error rules for grammar:{UniqueFormalParameters0, [FormalParameters]} are applied .\"\n  1:if (&& (! (= BindingIdentifier absent)) true) {\n    (0) access __x0__ = (BindingIdentifier \"StringValue\")\n    if (|| (= __x0__ \"eval\") (= __x0__ \"arguments\")) (1) throw SyntaxError else 2:{}\n  } else 2:{}\n  2:let __x1__ = true\n  2:(1) access __x2__ = (AsyncGeneratorBody \"FunctionBodyContainsUseStrict\")\n  2:__x1__ = (= __x2__ true)\n  2:if __x1__ {\n    (2) access __x3__ = (FormalParameters \"IsSimpleParameterList\")\n    __x1__ = (= __x3__ false)\n  } else 2:{}\n  2:if __x1__ (2) throw SyntaxError else 2:{}\n  3:(3) access __x4__ = (FormalParameters \"BoundNames\")\n  3:(4) access __x5__ = (AsyncGeneratorBody \"LexicallyDeclaredNames\")\n  3:let __x6__ = __x4__\n  3:let __x7__ = __x5__\n  3:let __x8__ = 0i\n  3:let __x9__ = 0i\n  3:let __x10__ = false\n  3:while (< __x8__ __x6__[\"length\"]) {\n    __x9__ = 0i\n    while (< __x9__ __x7__[\"length\"]) if (= __x6__[__x8__] __x7__[__x9__]) __x10__ = true else 2:{}\n  }\n  3:if __x10__ (3) throw SyntaxError else 2:{}\n  4:(5) access __x11__ = (FormalParameters \"Contains\" \"YieldExpression\")\n  4:if (= __x11__ true) (4) throw SyntaxError else 2:{}\n  5:(6) access __x12__ = (FormalParameters \"Contains\" \"AwaitExpression\")\n  5:if (= __x12__ true) (5) throw SyntaxError else 2:{}\n  6:(7) access __x13__ = (FormalParameters \"Contains\" \"SuperProperty\")\n  6:if (= __x13__ true) (6) throw SyntaxError else 2:{}\n  7:(8) access __x14__ = (AsyncGeneratorBody \"Contains\" \"SuperProperty\")\n  7:if (= __x14__ true) (7) throw SyntaxError else 2:{}\n  8:(9) access __x15__ = (FormalParameters \"Contains\" \"SuperCall\")\n  8:if (= __x15__ true) (8) throw SyntaxError else 2:{}\n  9:(10) access __x16__ = (AsyncGeneratorBody \"Contains\" \"SuperCall\")\n  9:if (= __x16__ true) (9) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if PrototypePropertyNameList of |ClassElementList| contains more than one occurrence of *\"constructor\"*.", "        </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "ClassBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ClassElementList",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-class-definitions-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (ClassElementList \"PrototypePropertyNameList\")\n  0:let __x1__ = __x0__\n  0:let __x2__ = \"constructor\"\n  0:let __x3__ = 0i\n  0:let __x4__ = 0i\n  0:let __x5__ = false\n  0:while (< __x4__ __x1__[\"length\"]) if (= __x1__[__x4__] __x2__) __x3__ = (+ __x3__ 1i) else 2:{}\n  0:if (< 1i __x3__) __x5__ = true else 2:{}\n  0:if __x5__ (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if PropName of |MethodDefinition| is not *\"constructor\"* and HasDirectSuper of |MethodDefinition| is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if PropName of |MethodDefinition| is *\"constructor\"* and SpecialMethod of |MethodDefinition| is *true*.", "        </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "ClassElement",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "MethodDefinition",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-class-definitions-static-semantics-early-errors",
    "rawBody": "{\n  0:let __x0__ = true\n  0:(0) access __x1__ = (MethodDefinition \"PropName\")\n  0:__x0__ = (! (= __x1__ \"constructor\"))\n  0:if __x0__ {\n    (1) access __x2__ = (MethodDefinition \"HasDirectSuper\")\n    __x0__ = (= __x2__ true)\n  } else 2:{}\n  0:if __x0__ (0) throw SyntaxError else 2:{}\n  1:let __x3__ = true\n  1:(2) access __x4__ = (MethodDefinition \"PropName\")\n  1:__x3__ = (= __x4__ \"constructor\")\n  1:if __x3__ {\n    (3) access __x5__ = (MethodDefinition \"SpecialMethod\")\n    __x3__ = (= __x5__ true)\n  } else 2:{}\n  1:if __x3__ (1) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if HasDirectSuper of |MethodDefinition| is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if PropName of |MethodDefinition| is *\"prototype\"*.", "        </li>"],
    "head": {
      "idx": 1,
      "methodName": "EarlyErrors",
      "prod": "ClassElement",
      "rhs": {
        "tokens": [{
          "term": "static"
        }, {
          "args": [],
          "name": "MethodDefinition",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-class-definitions-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (MethodDefinition \"HasDirectSuper\")\n  0:if (= __x0__ true) (0) throw SyntaxError else 2:{}\n  1:(1) access __x1__ = (MethodDefinition \"PropName\")\n  1:if (= __x1__ \"prototype\") (1) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>It is a Syntax Error if FunctionBodyContainsUseStrict of |AsyncFunctionBody| is *true* and IsSimpleParameterList of |UniqueFormalParameters| is *false*.</li>", "        <li>It is a Syntax Error if HasDirectSuper of |AsyncMethod| is *true*.</li>", "        <li>It is a Syntax Error if |UniqueFormalParameters| Contains |AwaitExpression| is *true*.</li>", "        <li>It is a Syntax Error if any element of the BoundNames of |UniqueFormalParameters| also occurs in the LexicallyDeclaredNames of |AsyncFunctionBody|.</li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "AsyncMethod",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "args": [],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-async-function-definitions-static-semantics-early-errors",
    "rawBody": "{\n  0:let __x0__ = true\n  0:(0) access __x1__ = (AsyncFunctionBody \"FunctionBodyContainsUseStrict\")\n  0:__x0__ = (= __x1__ true)\n  0:if __x0__ {\n    (1) access __x2__ = (UniqueFormalParameters \"IsSimpleParameterList\")\n    __x0__ = (= __x2__ false)\n  } else 2:{}\n  0:if __x0__ (0) throw SyntaxError else 2:{}\n  1:(2) access __x3__ = (AsyncMethod \"HasDirectSuper\")\n  1:if (= __x3__ true) (1) throw SyntaxError else 2:{}\n  2:(3) access __x4__ = (UniqueFormalParameters \"Contains\" \"AwaitExpression\")\n  2:if (= __x4__ true) (2) throw SyntaxError else 2:{}\n  3:(4) access __x5__ = (UniqueFormalParameters \"BoundNames\")\n  3:(5) access __x6__ = (AsyncFunctionBody \"LexicallyDeclaredNames\")\n  3:let __x7__ = __x5__\n  3:let __x8__ = __x6__\n  3:let __x9__ = 0i\n  3:let __x10__ = 0i\n  3:let __x11__ = false\n  3:while (< __x9__ __x7__[\"length\"]) {\n    __x10__ = 0i\n    while (< __x10__ __x8__[\"length\"]) if (= __x7__[__x9__] __x8__[__x10__]) __x11__ = true else 2:{}\n  }\n  3:if __x11__ (3) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>It is a Syntax Error if FunctionBodyContainsUseStrict of |AsyncFunctionBody| is *true* and IsSimpleParameterList of |FormalParameters| is *false*.</li>", "        <li>It is a Syntax Error if |FormalParameters| Contains |AwaitExpression| is *true*.</li>", "        <li>If the source code matching |FormalParameters| is strict mode code, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied.</li>", "        <li>If |BindingIdentifier| is present and the source code matching |BindingIdentifier| is strict mode code, it is a Syntax Error if the StringValue of |BindingIdentifier| is *\"eval\"* or *\"arguments\"*.</li>", "        <li>It is a Syntax Error if any element of the BoundNames of |FormalParameters| also occurs in the LexicallyDeclaredNames of |AsyncFunctionBody|.</li>", "        <li>It is a Syntax Error if |FormalParameters| Contains |SuperProperty| is *true*.</li>", "        <li>It is a Syntax Error if |AsyncFunctionBody| Contains |SuperProperty| is *true*.</li>", "        <li>It is a Syntax Error if |FormalParameters| Contains |SuperCall| is *true*.</li>", "        <li>It is a Syntax Error if |AsyncFunctionBody| Contains |SuperCall| is *true*.</li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "AsyncFunctionDeclaration",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-async-function-definitions-static-semantics-early-errors",
    "rawBody": "{\n  0:let __x0__ = true\n  0:(0) access __x1__ = (AsyncFunctionBody \"FunctionBodyContainsUseStrict\")\n  0:__x0__ = (= __x1__ true)\n  0:if __x0__ {\n    (1) access __x2__ = (FormalParameters \"IsSimpleParameterList\")\n    __x0__ = (= __x2__ false)\n  } else 2:{}\n  0:if __x0__ (0) throw SyntaxError else 2:{}\n  1:(2) access __x3__ = (FormalParameters \"Contains\" \"AwaitExpression\")\n  1:if (= __x3__ true) (1) throw SyntaxError else 2:{}\n  2:(2) ??? \"If the source code matching nt:{FormalParameters} is strict mode code , the Early Error rules for grammar:{UniqueFormalParameters0, [FormalParameters]} are applied .\"\n  3:if (&& (! (= BindingIdentifier absent)) true) {\n    (3) access __x4__ = (BindingIdentifier \"StringValue\")\n    if (|| (= __x4__ \"eval\") (= __x4__ \"arguments\")) (3) throw SyntaxError else 2:{}\n  } else 2:{}\n  4:(4) access __x5__ = (FormalParameters \"BoundNames\")\n  4:(5) access __x6__ = (AsyncFunctionBody \"LexicallyDeclaredNames\")\n  4:let __x7__ = __x5__\n  4:let __x8__ = __x6__\n  4:let __x9__ = 0i\n  4:let __x10__ = 0i\n  4:let __x11__ = false\n  4:while (< __x9__ __x7__[\"length\"]) {\n    __x10__ = 0i\n    while (< __x10__ __x8__[\"length\"]) if (= __x7__[__x9__] __x8__[__x10__]) __x11__ = true else 2:{}\n  }\n  4:if __x11__ (4) throw SyntaxError else 2:{}\n  5:(6) access __x12__ = (FormalParameters \"Contains\" \"SuperProperty\")\n  5:if (= __x12__ true) (5) throw SyntaxError else 2:{}\n  6:(7) access __x13__ = (AsyncFunctionBody \"Contains\" \"SuperProperty\")\n  6:if (= __x13__ true) (6) throw SyntaxError else 2:{}\n  7:(8) access __x14__ = (FormalParameters \"Contains\" \"SuperCall\")\n  7:if (= __x14__ true) (7) throw SyntaxError else 2:{}\n  8:(9) access __x15__ = (AsyncFunctionBody \"Contains\" \"SuperCall\")\n  8:if (= __x15__ true) (8) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>It is a Syntax Error if FunctionBodyContainsUseStrict of |AsyncFunctionBody| is *true* and IsSimpleParameterList of |FormalParameters| is *false*.</li>", "        <li>It is a Syntax Error if |FormalParameters| Contains |AwaitExpression| is *true*.</li>", "        <li>If the source code matching |FormalParameters| is strict mode code, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied.</li>", "        <li>If |BindingIdentifier| is present and the source code matching |BindingIdentifier| is strict mode code, it is a Syntax Error if the StringValue of |BindingIdentifier| is *\"eval\"* or *\"arguments\"*.</li>", "        <li>It is a Syntax Error if any element of the BoundNames of |FormalParameters| also occurs in the LexicallyDeclaredNames of |AsyncFunctionBody|.</li>", "        <li>It is a Syntax Error if |FormalParameters| Contains |SuperProperty| is *true*.</li>", "        <li>It is a Syntax Error if |AsyncFunctionBody| Contains |SuperProperty| is *true*.</li>", "        <li>It is a Syntax Error if |FormalParameters| Contains |SuperCall| is *true*.</li>", "        <li>It is a Syntax Error if |AsyncFunctionBody| Contains |SuperCall| is *true*.</li>"],
    "head": {
      "idx": 1,
      "methodName": "EarlyErrors",
      "prod": "AsyncFunctionDeclaration",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-async-function-definitions-static-semantics-early-errors",
    "rawBody": "{\n  0:let __x0__ = true\n  0:(0) access __x1__ = (AsyncFunctionBody \"FunctionBodyContainsUseStrict\")\n  0:__x0__ = (= __x1__ true)\n  0:if __x0__ {\n    (1) access __x2__ = (FormalParameters \"IsSimpleParameterList\")\n    __x0__ = (= __x2__ false)\n  } else 2:{}\n  0:if __x0__ (0) throw SyntaxError else 2:{}\n  1:(2) access __x3__ = (FormalParameters \"Contains\" \"AwaitExpression\")\n  1:if (= __x3__ true) (1) throw SyntaxError else 2:{}\n  2:(2) ??? \"If the source code matching nt:{FormalParameters} is strict mode code , the Early Error rules for grammar:{UniqueFormalParameters0, [FormalParameters]} are applied .\"\n  3:if (&& (! (= BindingIdentifier absent)) true) {\n    (3) access __x4__ = (BindingIdentifier \"StringValue\")\n    if (|| (= __x4__ \"eval\") (= __x4__ \"arguments\")) (3) throw SyntaxError else 2:{}\n  } else 2:{}\n  4:(4) access __x5__ = (FormalParameters \"BoundNames\")\n  4:(5) access __x6__ = (AsyncFunctionBody \"LexicallyDeclaredNames\")\n  4:let __x7__ = __x5__\n  4:let __x8__ = __x6__\n  4:let __x9__ = 0i\n  4:let __x10__ = 0i\n  4:let __x11__ = false\n  4:while (< __x9__ __x7__[\"length\"]) {\n    __x10__ = 0i\n    while (< __x10__ __x8__[\"length\"]) if (= __x7__[__x9__] __x8__[__x10__]) __x11__ = true else 2:{}\n  }\n  4:if __x11__ (4) throw SyntaxError else 2:{}\n  5:(6) access __x12__ = (FormalParameters \"Contains\" \"SuperProperty\")\n  5:if (= __x12__ true) (5) throw SyntaxError else 2:{}\n  6:(7) access __x13__ = (AsyncFunctionBody \"Contains\" \"SuperProperty\")\n  6:if (= __x13__ true) (6) throw SyntaxError else 2:{}\n  7:(8) access __x14__ = (FormalParameters \"Contains\" \"SuperCall\")\n  7:if (= __x14__ true) (7) throw SyntaxError else 2:{}\n  8:(9) access __x15__ = (AsyncFunctionBody \"Contains\" \"SuperCall\")\n  8:if (= __x15__ true) (8) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>It is a Syntax Error if FunctionBodyContainsUseStrict of |AsyncFunctionBody| is *true* and IsSimpleParameterList of |FormalParameters| is *false*.</li>", "        <li>It is a Syntax Error if |FormalParameters| Contains |AwaitExpression| is *true*.</li>", "        <li>If the source code matching |FormalParameters| is strict mode code, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied.</li>", "        <li>If |BindingIdentifier| is present and the source code matching |BindingIdentifier| is strict mode code, it is a Syntax Error if the StringValue of |BindingIdentifier| is *\"eval\"* or *\"arguments\"*.</li>", "        <li>It is a Syntax Error if any element of the BoundNames of |FormalParameters| also occurs in the LexicallyDeclaredNames of |AsyncFunctionBody|.</li>", "        <li>It is a Syntax Error if |FormalParameters| Contains |SuperProperty| is *true*.</li>", "        <li>It is a Syntax Error if |AsyncFunctionBody| Contains |SuperProperty| is *true*.</li>", "        <li>It is a Syntax Error if |FormalParameters| Contains |SuperCall| is *true*.</li>", "        <li>It is a Syntax Error if |AsyncFunctionBody| Contains |SuperCall| is *true*.</li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "AsyncFunctionExpression",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "term": "function"
        }, {
          "args": [],
          "name": "BindingIdentifier",
          "optional": true
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-async-function-definitions-static-semantics-early-errors",
    "rawBody": "{\n  0:let __x0__ = true\n  0:(0) access __x1__ = (AsyncFunctionBody \"FunctionBodyContainsUseStrict\")\n  0:__x0__ = (= __x1__ true)\n  0:if __x0__ {\n    (1) access __x2__ = (FormalParameters \"IsSimpleParameterList\")\n    __x0__ = (= __x2__ false)\n  } else 2:{}\n  0:if __x0__ (0) throw SyntaxError else 2:{}\n  1:(2) access __x3__ = (FormalParameters \"Contains\" \"AwaitExpression\")\n  1:if (= __x3__ true) (1) throw SyntaxError else 2:{}\n  2:(2) ??? \"If the source code matching nt:{FormalParameters} is strict mode code , the Early Error rules for grammar:{UniqueFormalParameters0, [FormalParameters]} are applied .\"\n  3:if (&& (! (= BindingIdentifier absent)) true) {\n    (3) access __x4__ = (BindingIdentifier \"StringValue\")\n    if (|| (= __x4__ \"eval\") (= __x4__ \"arguments\")) (3) throw SyntaxError else 2:{}\n  } else 2:{}\n  4:(4) access __x5__ = (FormalParameters \"BoundNames\")\n  4:(5) access __x6__ = (AsyncFunctionBody \"LexicallyDeclaredNames\")\n  4:let __x7__ = __x5__\n  4:let __x8__ = __x6__\n  4:let __x9__ = 0i\n  4:let __x10__ = 0i\n  4:let __x11__ = false\n  4:while (< __x9__ __x7__[\"length\"]) {\n    __x10__ = 0i\n    while (< __x10__ __x8__[\"length\"]) if (= __x7__[__x9__] __x8__[__x10__]) __x11__ = true else 2:{}\n  }\n  4:if __x11__ (4) throw SyntaxError else 2:{}\n  5:(6) access __x12__ = (FormalParameters \"Contains\" \"SuperProperty\")\n  5:if (= __x12__ true) (5) throw SyntaxError else 2:{}\n  6:(7) access __x13__ = (AsyncFunctionBody \"Contains\" \"SuperProperty\")\n  6:if (= __x13__ true) (6) throw SyntaxError else 2:{}\n  7:(8) access __x14__ = (FormalParameters \"Contains\" \"SuperCall\")\n  7:if (= __x14__ true) (7) throw SyntaxError else 2:{}\n  8:(9) access __x15__ = (AsyncFunctionBody \"Contains\" \"SuperCall\")\n  8:if (= __x15__ true) (8) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>It is a Syntax Error if any element of the BoundNames of |AsyncArrowBindingIdentifier| also occurs in the LexicallyDeclaredNames of |AsyncConciseBody|.</li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "AsyncArrowFunction",
      "rhs": {
        "tokens": [{
          "term": "async"
        }, {
          "args": [],
          "name": "AsyncArrowBindingIdentifier",
          "optional": false
        }, {
          "term": "=>"
        }, {
          "args": [],
          "name": "AsyncConciseBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-async-arrow-function-definitions-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (AsyncArrowBindingIdentifier \"BoundNames\")\n  0:(1) access __x1__ = (AsyncConciseBody \"LexicallyDeclaredNames\")\n  0:let __x2__ = __x0__\n  0:let __x3__ = __x1__\n  0:let __x4__ = 0i\n  0:let __x5__ = 0i\n  0:let __x6__ = false\n  0:while (< __x4__ __x2__[\"length\"]) {\n    __x5__ = 0i\n    while (< __x5__ __x3__[\"length\"]) if (= __x2__[__x4__] __x3__[__x5__]) __x6__ = true else 2:{}\n  }\n  0:if __x6__ (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>It is a Syntax Error if |CoverCallExpressionAndAsyncArrowHead| Contains |YieldExpression| is *true*.</li>", "        <li>It is a Syntax Error if |CoverCallExpressionAndAsyncArrowHead| Contains |AwaitExpression| is *true*.</li>", "        <li>It is a Syntax Error if |CoverCallExpressionAndAsyncArrowHead| is not covering an |AsyncArrowHead|.</li>", "        <li>It is a Syntax Error if any element of the BoundNames of |CoverCallExpressionAndAsyncArrowHead| also occurs in the LexicallyDeclaredNames of |AsyncConciseBody|.</li>", "        <li>It is a Syntax Error if AsyncConciseBodyContainsUseStrict of |AsyncConciseBody| is *true* and IsSimpleParameterList of |CoverCallExpressionAndAsyncArrowHead| is *false*.</li>", "        <li>All Early Error rules for |AsyncArrowHead| and its derived productions apply to CoveredAsyncArrowHead of |CoverCallExpressionAndAsyncArrowHead|.</li>"],
    "head": {
      "idx": 1,
      "methodName": "EarlyErrors",
      "prod": "AsyncArrowFunction",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "CoverCallExpressionAndAsyncArrowHead",
          "optional": false
        }, {
          "term": "=>"
        }, {
          "args": [],
          "name": "AsyncConciseBody",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-async-arrow-function-definitions-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (CoverCallExpressionAndAsyncArrowHead \"Contains\" \"YieldExpression\")\n  0:if (= __x0__ true) (0) throw SyntaxError else 2:{}\n  1:(1) access __x1__ = (CoverCallExpressionAndAsyncArrowHead \"Contains\" \"AwaitExpression\")\n  1:if (= __x1__ true) (1) throw SyntaxError else 2:{}\n  2:let __x2__ = false\n  2:if (= absent (parse-syntax CoverCallExpressionAndAsyncArrowHead \"AsyncArrowHead\" (2) (new []))) __x2__ = true else 2:{}\n  2:if __x2__ (3) throw SyntaxError else 2:{}\n  3:(2) access __x3__ = (CoverCallExpressionAndAsyncArrowHead \"BoundNames\")\n  3:(3) access __x4__ = (AsyncConciseBody \"LexicallyDeclaredNames\")\n  3:let __x5__ = __x3__\n  3:let __x6__ = __x4__\n  3:let __x7__ = 0i\n  3:let __x8__ = 0i\n  3:let __x9__ = false\n  3:while (< __x7__ __x5__[\"length\"]) {\n    __x8__ = 0i\n    while (< __x8__ __x6__[\"length\"]) if (= __x5__[__x7__] __x6__[__x8__]) __x9__ = true else 2:{}\n  }\n  3:if __x9__ (4) throw SyntaxError else 2:{}\n  4:let __x10__ = true\n  4:(4) access __x11__ = (AsyncConciseBody \"AsyncConciseBodyContainsUseStrict\")\n  4:__x10__ = (= __x11__ true)\n  4:if __x10__ {\n    (5) access __x12__ = (CoverCallExpressionAndAsyncArrowHead \"IsSimpleParameterList\")\n    __x10__ = (= __x12__ false)\n  } else 2:{}\n  4:if __x10__ (5) throw SyntaxError else 2:{}\n  5:(6) ??? \"All Early Error rules for nt:{AsyncArrowHead} and its derived productions apply to CoveredAsyncArrowHead of nt:{CoverCallExpressionAndAsyncArrowHead} .\"\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if the LexicallyDeclaredNames of |ScriptBody| contains any duplicate entries.", "        </li>", "        <li>", "          It is a Syntax Error if any element of the LexicallyDeclaredNames of |ScriptBody| also occurs in the VarDeclaredNames of |ScriptBody|.", "        </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "Script",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ScriptBody",
          "optional": false
        }]
      },
      "subIdx": 1,
      "withParams": []
    },
    "ids": "sec-scripts-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (ScriptBody \"LexicallyDeclaredNames\")\n  0:(1) app __x1__ = (IsDuplicate __x0__)\n  0:if __x1__ (0) throw SyntaxError else 2:{}\n  1:(2) access __x2__ = (ScriptBody \"LexicallyDeclaredNames\")\n  1:(3) access __x3__ = (ScriptBody \"VarDeclaredNames\")\n  1:let __x4__ = __x2__\n  1:let __x5__ = __x3__\n  1:let __x6__ = 0i\n  1:let __x7__ = 0i\n  1:let __x8__ = false\n  1:while (< __x6__ __x4__[\"length\"]) {\n    __x7__ = 0i\n    while (< __x7__ __x5__[\"length\"]) if (= __x4__[__x6__] __x5__[__x7__]) __x8__ = true else 2:{}\n  }\n  1:if __x8__ (1) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["        <li>", "          It is a Syntax Error if |StatementList| Contains `super` unless the source code containing `super` is eval code that is being processed by a direct eval. Additional early error rules for `super` within direct eval are defined in <emu-xref href=\"#sec-performeval\"></emu-xref>.", "        </li>", "        <li>", "          It is a Syntax Error if |StatementList| Contains |NewTarget| unless the source code containing |NewTarget| is eval code that is being processed by a direct eval. Additional early error rules for |NewTarget| in direct eval are defined in <emu-xref href=\"#sec-performeval\"></emu-xref>.", "        </li>", "        <li>", "          It is a Syntax Error if ContainsDuplicateLabels of |StatementList| with argument « » is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if ContainsUndefinedBreakTarget of |StatementList| with argument « » is *true*.", "        </li>", "        <li>", "          It is a Syntax Error if ContainsUndefinedContinueTarget of |StatementList| with arguments « » and « » is *true*.", "        </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "ScriptBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "StatementList",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-scripts-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) ??? \"It is a Syntax Error if nt:{StatementList} Contains code:{super} unless the source code containing code:{super} is eval code that is being processed by a direct eval . Additional early error rules for code:{super} within direct eval are defined in link:{sec-performeval} .\"\n  1:(1) ??? \"It is a Syntax Error if nt:{StatementList} Contains nt:{NewTarget} unless the source code containing nt:{NewTarget} is eval code that is being processed by a direct eval . Additional early error rules for nt:{NewTarget} in direct eval are defined in link:{sec-performeval} .\"\n  2:(0) access __x0__ = (StatementList \"ContainsDuplicateLabels\" (2) (new []))\n  2:if (= __x0__ true) (3) throw SyntaxError else 2:{}\n  3:(1) access __x1__ = (StatementList \"ContainsUndefinedBreakTarget\" (4) (new []))\n  3:if (= __x1__ true) (5) throw SyntaxError else 2:{}\n  4:(2) access __x2__ = (StatementList \"ContainsUndefinedContinueTarget\" (6) (new []) (7) (new []))\n  4:if (= __x2__ true) (8) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if the LexicallyDeclaredNames of |ModuleItemList| contains any duplicate entries.", "          </li>", "          <li>", "            It is a Syntax Error if any element of the LexicallyDeclaredNames of |ModuleItemList| also occurs in the VarDeclaredNames of |ModuleItemList|.", "          </li>", "          <li>", "            It is a Syntax Error if the ExportedNames of |ModuleItemList| contains any duplicate entries.", "          </li>", "          <li>", "            It is a Syntax Error if any element of the ExportedBindings of |ModuleItemList| does not also occur in either the VarDeclaredNames of |ModuleItemList|, or the LexicallyDeclaredNames of |ModuleItemList|.", "          </li>", "          <li>", "            It is a Syntax Error if |ModuleItemList| Contains `super`.", "          </li>", "          <li>", "            It is a Syntax Error if |ModuleItemList| Contains |NewTarget|.", "          </li>", "          <li>", "            It is a Syntax Error if ContainsDuplicateLabels of |ModuleItemList| with argument « » is *true*.", "          </li>", "          <li>", "            It is a Syntax Error if ContainsUndefinedBreakTarget of |ModuleItemList| with argument « » is *true*.", "          </li>", "          <li>", "            It is a Syntax Error if ContainsUndefinedContinueTarget of |ModuleItemList| with arguments « » and « » is *true*.", "          </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "ModuleBody",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ModuleItemList",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-module-semantics-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (ModuleItemList \"LexicallyDeclaredNames\")\n  0:(1) app __x1__ = (IsDuplicate __x0__)\n  0:if __x1__ (0) throw SyntaxError else 2:{}\n  1:(2) access __x2__ = (ModuleItemList \"LexicallyDeclaredNames\")\n  1:(3) access __x3__ = (ModuleItemList \"VarDeclaredNames\")\n  1:let __x4__ = __x2__\n  1:let __x5__ = __x3__\n  1:let __x6__ = 0i\n  1:let __x7__ = 0i\n  1:let __x8__ = false\n  1:while (< __x6__ __x4__[\"length\"]) {\n    __x7__ = 0i\n    while (< __x7__ __x5__[\"length\"]) if (= __x4__[__x6__] __x5__[__x7__]) __x8__ = true else 2:{}\n  }\n  1:if __x8__ (1) throw SyntaxError else 2:{}\n  2:(4) access __x9__ = (ModuleItemList \"ExportedNames\")\n  2:(5) app __x10__ = (IsDuplicate __x9__)\n  2:if __x10__ (2) throw SyntaxError else 2:{}\n  3:(6) access __x11__ = (ModuleItemList \"ExportedBindings\")\n  3:(7) access __x12__ = (ModuleItemList \"VarDeclaredNames\")\n  3:(8) access __x13__ = (ModuleItemList \"LexicallyDeclaredNames\")\n  3:let __x14__ = __x11__\n  3:let __x15__ = __x12__\n  3:let __x16__ = __x13__\n  3:let __x17__ = 0i\n  3:let __x18__ = 0i\n  3:let __x19__ = false\n  3:while (< __x17__ __x14__[\"length\"]) {\n    __x18__ = 0i\n    while (< __x18__ __x15__[\"length\"]) if (= __x14__[__x17__] __x15__[__x18__]) __x19__ = true else 2:{}\n    __x18__ = 0i\n    while (< __x18__ __x16__[\"length\"]) if (= __x14__[__x17__] __x16__[__x18__]) __x19__ = true else 2:{}\n  }\n  3:if __x19__ (3) throw SyntaxError else 2:{}\n  4:if (contains ModuleItemList \"super\") (4) throw SyntaxError else 2:{}\n  5:(9) access __x20__ = (ModuleItemList \"Contains\" \"NewTarget\")\n  5:if __x20__ (5) throw SyntaxError else 2:{}\n  6:(10) access __x21__ = (ModuleItemList \"ContainsDuplicateLabels\" (6) (new []))\n  6:if (= __x21__ true) (7) throw SyntaxError else 2:{}\n  7:(11) access __x22__ = (ModuleItemList \"ContainsUndefinedBreakTarget\" (8) (new []))\n  7:if (= __x22__ true) (9) throw SyntaxError else 2:{}\n  8:(12) access __x23__ = (ModuleItemList \"ContainsUndefinedContinueTarget\" (10) (new []) (11) (new []))\n  8:if (= __x23__ true) (12) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if the BoundNames of |ImportDeclaration| contains any duplicate entries.", "          </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "ModuleItem",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ImportDeclaration",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-imports-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (ImportDeclaration \"BoundNames\")\n  0:(1) app __x1__ = (IsDuplicate __x0__)\n  0:if __x1__ (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            For each |IdentifierName| _n_ in ReferencedBindings of |NamedExports|: It is a Syntax Error if StringValue of _n_ is a |ReservedWord| or if the StringValue of _n_ is one of: *\"implements\"*, *\"interface\"*, *\"let\"*, *\"package\"*, *\"private\"*, *\"protected\"*, *\"public\"*, or *\"static\"*.", "          </li>"],
    "head": {
      "idx": 1,
      "methodName": "EarlyErrors",
      "prod": "ExportDeclaration",
      "rhs": {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "NamedExports",
          "optional": false
        }, {
          "term": ";"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-exports-static-semantics-early-errors",
    "rawBody": "(0) ??? \"For each nt:{IdentifierName} id:{n} in ReferencedBindings of nt:{NamedExports} : It is a Syntax Error if StringValue of id:{n} is a nt:{ReservedWord} or if the StringValue of id:{n} is one of : value:{\\\"implements\\\"} , value:{\\\"interface\\\"} , value:{\\\"let\\\"} , value:{\\\"package\\\"} , value:{\\\"private\\\"} , value:{\\\"protected\\\"} , value:{\\\"public\\\"} , or value:{\\\"static\\\"} .\""
  }, {
    "code": ["          <li>", "            It is a Syntax Error if _NcapturingParens_ ≥ 2<sup>32</sup> - 1.", "          </li>", "          <li>", "            It is a Syntax Error if |Pattern| contains multiple |GroupSpecifier|s whose enclosed |RegExpIdentifierName|s have the same CapturingGroupName.", "          </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "Pattern",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "Disjunction",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-early-errors",
    "rawBody": "{\n  0:if (! (< NcapturingParens (- (** 2.0 32i) 1i))) (0) throw SyntaxError else 2:{}\n  1:(1) ??? \"It is a Syntax Error if nt:{Pattern} contains multiple nt:{GroupSpecifier} s whose enclosed nt:{RegExpIdentifierName} s have the same CapturingGroupName .\"\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if the MV of the first |DecimalDigits| is larger than the MV of the second |DecimalDigits|.", "          </li>"],
    "head": {
      "idx": 5,
      "methodName": "EarlyErrors",
      "prod": "QuantifierPrefix",
      "rhs": {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "DecimalDigits",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "DecimalDigits",
          "optional": false
        }, {
          "term": "}"
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) access __x0__ = (DecimalDigits0 \"MV\")\n  0:(1) access __x1__ = (DecimalDigits1 \"MV\")\n  0:if (< __x1__ __x0__) (0) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if the enclosing |Pattern| does not contain a |GroupSpecifier| with an enclosed |RegExpIdentifierName| whose CapturingGroupName equals the CapturingGroupName of the |RegExpIdentifierName| of this production's |GroupName|.", "          </li>"],
    "head": {
      "idx": 3,
      "methodName": "EarlyErrors",
      "prod": "AtomEscape",
      "rhs": {
        "tokens": [{
          "term": "k"
        }, {
          "args": [],
          "name": "GroupName",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-early-errors",
    "rawBody": "(0) ??? \"It is a Syntax Error if the enclosing nt:{Pattern} does not contain a nt:{GroupSpecifier} with an enclosed nt:{RegExpIdentifierName} whose CapturingGroupName equals the CapturingGroupName of the nt:{RegExpIdentifierName} of this production ' s nt:{GroupName} .\""
  }, {
    "code": ["          <li>", "            It is a Syntax Error if the CapturingGroupNumber of |DecimalEscape| is larger than _NcapturingParens_ (<emu-xref href=\"#sec-notation\"></emu-xref>).", "          </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "AtomEscape",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "DecimalEscape",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-early-errors",
    "rawBody": "(0) ??? \"It is a Syntax Error if the CapturingGroupNumber of nt:{DecimalEscape} is larger than id:{NcapturingParens} ( link:{sec-notation} ) .\""
  }, {
    "code": ["          <li>", "            It is a Syntax Error if IsCharacterClass of the first |ClassAtom| is *true* or IsCharacterClass of the second |ClassAtom| is *true*.", "          </li>", "          <li>", "            It is a Syntax Error if IsCharacterClass of the first |ClassAtom| is *false* and IsCharacterClass of the second |ClassAtom| is *false* and the CharacterValue of the first |ClassAtom| is larger than the CharacterValue of the second |ClassAtom|.", "          </li>"],
    "head": {
      "idx": 2,
      "methodName": "EarlyErrors",
      "prod": "NonemptyClassRanges",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ClassAtom",
          "optional": false
        }, {
          "term": "-"
        }, {
          "args": [],
          "name": "ClassAtom",
          "optional": false
        }, {
          "args": [],
          "name": "ClassRanges",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-early-errors",
    "rawBody": "{\n  0:let __x0__ = true\n  0:(0) access __x1__ = (ClassAtom0 \"IsCharacterClass\")\n  0:__x0__ = (= __x1__ true)\n  0:if __x0__ 2:{} else {\n    (1) access __x2__ = (ClassAtom1 \"IsCharacterClass\")\n    __x0__ = (= __x2__ true)\n  }\n  0:if __x0__ (0) throw SyntaxError else 2:{}\n  1:let __x3__ = true\n  1:(2) access __x4__ = (ClassAtom0 \"IsCharacterClass\")\n  1:__x3__ = (= __x4__ false)\n  1:if __x3__ {\n    let __x5__ = true\n    (3) access __x6__ = (ClassAtom1 \"IsCharacterClass\")\n    __x5__ = (= __x6__ false)\n    if __x5__ {\n      (4) access __x7__ = (ClassAtom0 \"CharacterValue\")\n      (5) access __x8__ = (ClassAtom1 \"CharacterValue\")\n      __x5__ = (< __x8__ __x7__)\n    } else 2:{}\n    __x3__ = __x5__\n  } else 2:{}\n  1:if __x3__ (1) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if IsCharacterClass of |ClassAtomNoDash| is *true* or IsCharacterClass of |ClassAtom| is *true*.", "          </li>", "          <li>", "            It is a Syntax Error if IsCharacterClass of |ClassAtomNoDash| is *false* and IsCharacterClass of |ClassAtom| is *false* and the CharacterValue of |ClassAtomNoDash| is larger than the CharacterValue of |ClassAtom|.", "          </li>"],
    "head": {
      "idx": 2,
      "methodName": "EarlyErrors",
      "prod": "NonemptyClassRangesNoDash",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "ClassAtomNoDash",
          "optional": false
        }, {
          "term": "-"
        }, {
          "args": [],
          "name": "ClassAtom",
          "optional": false
        }, {
          "args": [],
          "name": "ClassRanges",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-early-errors",
    "rawBody": "{\n  0:let __x0__ = true\n  0:(0) access __x1__ = (ClassAtomNoDash \"IsCharacterClass\")\n  0:__x0__ = (= __x1__ true)\n  0:if __x0__ 2:{} else {\n    (1) access __x2__ = (ClassAtom \"IsCharacterClass\")\n    __x0__ = (= __x2__ true)\n  }\n  0:if __x0__ (0) throw SyntaxError else 2:{}\n  1:let __x3__ = true\n  1:(2) access __x4__ = (ClassAtomNoDash \"IsCharacterClass\")\n  1:__x3__ = (= __x4__ false)\n  1:if __x3__ {\n    let __x5__ = true\n    (3) access __x6__ = (ClassAtom \"IsCharacterClass\")\n    __x5__ = (= __x6__ false)\n    if __x5__ {\n      (4) access __x7__ = (ClassAtomNoDash \"CharacterValue\")\n      (5) access __x8__ = (ClassAtom \"CharacterValue\")\n      __x5__ = (< __x8__ __x7__)\n    } else 2:{}\n    __x3__ = __x5__\n  } else 2:{}\n  1:if __x3__ (1) throw SyntaxError else 2:{}\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if the CharacterValue of |RegExpUnicodeEscapeSequence| is not the code point value of *\"$\"*, *\"_\"*, or some code point matched by the |UnicodeIDStart| lexical grammar production.", "          </li>"],
    "head": {
      "idx": 3,
      "methodName": "EarlyErrors",
      "prod": "RegExpIdentifierStart",
      "rhs": {
        "tokens": [{
          "term": "\\"
        }, {
          "args": ["+U"],
          "name": "RegExpUnicodeEscapeSequence",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-early-errors",
    "rawBody": "(0) ??? \"It is a Syntax Error if the CharacterValue of nt:{RegExpUnicodeEscapeSequence} is not the code point value of value:{\\\"$\\\"} , value:{\\\"_\\\"} , or some code point matched by the nt:{UnicodeIDStart} lexical grammar production .\""
  }, {
    "code": ["          <li>", "            It is a Syntax Error if the result of performing UTF16SurrogatePairToCodePoint on the two code points matched by |UnicodeLeadSurrogate| and |UnicodeTrailSurrogate| respectively is not matched by the |UnicodeIDStart| lexical grammar production.", "          </li>"],
    "head": {
      "idx": 4,
      "methodName": "EarlyErrors",
      "prod": "RegExpIdentifierStart",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "UnicodeLeadSurrogate",
          "optional": false
        }, {
          "args": [],
          "name": "UnicodeTrailSurrogate",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-early-errors",
    "rawBody": "(0) ??? \"It is a Syntax Error if the result of performing UTF16SurrogatePairToCodePoint on the two code points matched by nt:{UnicodeLeadSurrogate} and nt:{UnicodeTrailSurrogate} respectively is not matched by the nt:{UnicodeIDStart} lexical grammar production .\""
  }, {
    "code": ["          <li>", "            It is a Syntax Error if the CharacterValue of |RegExpUnicodeEscapeSequence| is not the code point value of *\"$\"*, *\"_\"*, <ZWNJ>, <ZWJ>, or some code point matched by the |UnicodeIDContinue| lexical grammar production.", "          </li>"],
    "head": {
      "idx": 2,
      "methodName": "EarlyErrors",
      "prod": "RegExpIdentifierPart",
      "rhs": {
        "tokens": [{
          "term": "\\"
        }, {
          "args": ["+U"],
          "name": "RegExpUnicodeEscapeSequence",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-early-errors",
    "rawBody": "(0) ??? \"It is a Syntax Error if the CharacterValue of nt:{RegExpUnicodeEscapeSequence} is not the code point value of value:{\\\"$\\\"} , value:{\\\"_\\\"} , < ZWNJ > , < ZWJ > , or some code point matched by the nt:{UnicodeIDContinue} lexical grammar production .\""
  }, {
    "code": ["          <li>", "            It is a Syntax Error if the result of performing UTF16SurrogatePairToCodePoint on the two code points matched by |UnicodeLeadSurrogate| and |UnicodeTrailSurrogate| respectively is not matched by the |UnicodeIDContinue| lexical grammar production.", "          </li>"],
    "head": {
      "idx": 3,
      "methodName": "EarlyErrors",
      "prod": "RegExpIdentifierPart",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "UnicodeLeadSurrogate",
          "optional": false
        }, {
          "args": [],
          "name": "UnicodeTrailSurrogate",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-early-errors",
    "rawBody": "(0) ??? \"It is a Syntax Error if the result of performing UTF16SurrogatePairToCodePoint on the two code points matched by nt:{UnicodeLeadSurrogate} and nt:{UnicodeTrailSurrogate} respectively is not matched by the nt:{UnicodeIDContinue} lexical grammar production .\""
  }, {
    "code": ["          <li>", "            It is a Syntax Error if the List of Unicode code points that is SourceText of |UnicodePropertyName| is not identical to a List of Unicode code points that is a Unicode property name or property alias listed in the “Property name and aliases” column of <emu-xref href=\"#table-nonbinary-unicode-properties\"></emu-xref>.", "          </li>", "          <li>", "            It is a Syntax Error if the List of Unicode code points that is SourceText of |UnicodePropertyValue| is not identical to a List of Unicode code points that is a value or value alias for the Unicode property or property alias given by SourceText of |UnicodePropertyName| listed in the “Property value and aliases” column of the corresponding tables <emu-xref href=\"#table-unicode-general-category-values\"></emu-xref> or <emu-xref href=\"#table-unicode-script-values\"></emu-xref>.", "          </li>"],
    "head": {
      "idx": 0,
      "methodName": "EarlyErrors",
      "prod": "UnicodePropertyValueExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "UnicodePropertyName",
          "optional": false
        }, {
          "term": "="
        }, {
          "args": [],
          "name": "UnicodePropertyValue",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-early-errors",
    "rawBody": "{\n  0:(0) ??? \"It is a Syntax Error if the List of Unicode code points that is SourceText of nt:{UnicodePropertyName} is not identical to a List of Unicode code points that is a Unicode property name or property alias listed in the “ Property name and aliases ” column of link:{table-nonbinary-unicode-properties} .\"\n  1:(1) ??? \"It is a Syntax Error if the List of Unicode code points that is SourceText of nt:{UnicodePropertyValue} is not identical to a List of Unicode code points that is a value or value alias for the Unicode property or property alias given by SourceText of nt:{UnicodePropertyName} listed in the “ Property value and aliases ” column of the corresponding tables link:{table-unicode-general-category-values} or link:{table-unicode-script-values} .\"\n}"
  }, {
    "code": ["          <li>", "            It is a Syntax Error if the List of Unicode code points that is SourceText of |LoneUnicodePropertyNameOrValue| is not identical to a List of Unicode code points that is a Unicode general category or general category alias listed in the “Property value and aliases” column of <emu-xref href=\"#table-unicode-general-category-values\"></emu-xref>, nor a binary property or binary property alias listed in the “Property name and aliases” column of <emu-xref href=\"#table-binary-unicode-properties\"></emu-xref>.", "          </li>"],
    "head": {
      "idx": 1,
      "methodName": "EarlyErrors",
      "prod": "UnicodePropertyValueExpression",
      "rhs": {
        "tokens": [{
          "args": [],
          "name": "LoneUnicodePropertyNameOrValue",
          "optional": false
        }]
      },
      "subIdx": 0,
      "withParams": []
    },
    "ids": "sec-patterns-static-semantics-early-errors",
    "rawBody": "(0) ??? \"It is a Syntax Error if the List of Unicode code points that is SourceText of nt:{LoneUnicodePropertyNameOrValue} is not identical to a List of Unicode code points that is a Unicode general category or general category alias listed in the “ Property value and aliases ” column of link:{table-unicode-general-category-values} , nor a binary property or binary property alias listed in the “ Property name and aliases ” column of link:{table-binary-unicode-properties} .\""
  }, {
    "code": ["        <table>", "          <tbody>", "          <tr>", "            <th>", "              Argument Type", "            </th>", "            <th>", "              Result", "            </th>", "          </tr>", "          <tr>", "            <td>", "              Undefined", "            </td>", "            <td>", "              Return *false*.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              Null", "            </td>", "            <td>", "              Return *false*.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              Boolean", "            </td>", "            <td>", "              Return _argument_.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              Number", "            </td>", "            <td>", "              If _argument_ is *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, or *NaN*, return *false*; otherwise return *true*.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              String", "            </td>", "            <td>", "              If _argument_ is the empty String (its length is 0), return *false*; otherwise return *true*.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              Symbol", "            </td>", "            <td>", "              Return *true*.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              BigInt", "            </td>", "            <td>", "              If _argument_ is *0*<sub>ℤ</sub>, return *false*; otherwise return *true*.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              Object", "            </td>", "            <td>", "              Return *true*.", "              <emu-note>", "                <p>An alternate algorithm related to the [[IsHTMLDDA]] internal slot is mandated in section <emu-xref href=\"#sec-IsHTMLDDA-internal-slot-to-boolean\"></emu-xref>.</p>", "              </emu-note>", "            </td>", "          </tr>", "          </tbody>", "        </table>"],
    "head": {
      "name": "ToBoolean",
      "params": [{
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "table-toboolean-conversions",
    "rawBody": "{\n  1:if (= (typeof argument) Undefined) return false else 2:{}\n  3:if (= (typeof argument) Null) return false else 2:{}\n  5:if (= (typeof argument) Boolean) return argument else 2:{}\n  7:if (= (typeof argument) Number) if (|| (|| (= argument 0i) (= argument -0.0)) (= argument NaN)) return false else return true else 2:{}\n  9:if (= (typeof argument) String) if (= argument \"\") return false else return true else 2:{}\n  11:if (= (typeof argument) Symbol) return true else 2:{}\n  13:if (= (typeof argument) BigInt) if (= argument 0i) return false else return true else 2:{}\n  15:if (= (typeof argument) Object) return true else 2:{}\n  16:assert false\n}"
  }, {
    "code": ["        <table>", "          <tbody>", "          <tr>", "            <th>", "              Argument Type", "            </th>", "            <th>", "              Result", "            </th>", "          </tr>", "          <tr>", "            <td>", "              Undefined", "            </td>", "            <td>", "              Return *NaN*.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              Null", "            </td>", "            <td>", "              Return *+0*<sub>𝔽</sub>.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              Boolean", "            </td>", "            <td>", "              If _argument_ is *true*, return *1*<sub>𝔽</sub>. If _argument_ is *false*, return *+0*<sub>𝔽</sub>.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              Number", "            </td>", "            <td>", "              Return _argument_ (no conversion).", "            </td>", "          </tr>", "          <tr>", "            <td>", "              String", "            </td>", "            <td>", "              See grammar and conversion algorithm below.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              Symbol", "            </td>", "            <td>", "              Throw a *TypeError* exception.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              BigInt", "            </td>", "            <td>", "              Throw a *TypeError* exception.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              Object", "            </td>", "            <td>", "              <p>Apply the following steps:</p>", "              <emu-alg>", "                1. Let _primValue_ be ? ToPrimitive(_argument_, ~number~).", "                1. Return ? ToNumber(_primValue_).", "              </emu-alg>", "            </td>", "          </tr>", "          </tbody>", "        </table>"],
    "head": {
      "name": "ToNumber",
      "params": [{
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "table-tonumber-conversions",
    "rawBody": "{\n  1:if (= (typeof argument) Undefined) return NaN else 8:{}\n  3:if (= (typeof argument) Null) return 0i else 8:{}\n  5:if (= (typeof argument) Boolean) {\n    4:if (= argument true) return 1i else {}\n    4:if (= argument false) return 0i else {}\n  } else 8:{}\n  7:if (= (typeof argument) Number) return argument else 8:{}\n  9:if (= (typeof argument) String) {} else 8:{}\n  11:if (= (typeof argument) Symbol) (0) throw TypeError else 8:{}\n  13:if (= (typeof argument) BigInt) (1) throw TypeError else 8:{}\n  16:if (= (typeof argument) Object) {\n    14:(0) app __x0__ = (ToPrimitive argument CONST_number)\n    14:let primValue = [? __x0__]\n    15:(1) app __x1__ = (ToNumber primValue)\n    15:return [? __x1__]\n  } else 8:{}\n  17:assert false\n}"
  }, {
    "code": ["        <table>", "          <tbody>", "            <tr>", "              <th>", "                Argument Type", "              </th>", "              <th>", "                Result", "              </th>", "            </tr>", "            <tr>", "              <td>", "                Undefined", "              </td>", "              <td>", "                Throw a *TypeError* exception.", "              </td>", "            </tr>", "            <tr>", "              <td>", "                Null", "              </td>", "              <td>", "                Throw a *TypeError* exception.", "              </td>", "            </tr>", "            <tr>", "              <td>", "                Boolean", "              </td>", "              <td>", "                Return `1n` if _prim_ is *true* and `0n` if _prim_ is *false*.", "              </td>", "            </tr>", "            <tr>", "              <td>", "                BigInt", "              </td>", "              <td>", "                Return _prim_.", "              </td>", "            </tr>", "            <tr>", "              <td>", "                Number", "              </td>", "              <td>", "                Throw a *TypeError* exception.", "              </td>", "            </tr>", "            <tr>", "              <td>", "                String", "              </td>", "              <td>", "                <emu-alg>", "                  1. Let _n_ be ! StringToBigInt(_prim_).", "                  1. If _n_ is *NaN*, throw a *SyntaxError* exception.", "                  1. Return _n_.", "                </emu-alg>", "              </td>", "            </tr>", "            <tr>", "              <td>", "                Symbol", "              </td>", "              <td>", "                Throw a *TypeError* exception.", "              </td>", "            </tr>", "          </tbody>", "        </table>"],
    "head": {
      "name": "ToBigInt",
      "params": [{
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "table-tobigint",
    "rawBody": "{\n  1:if (= (typeof argument) Undefined) (0) throw TypeError else 8:{}\n  3:if (= (typeof argument) Null) (1) throw TypeError else 8:{}\n  5:if (= (typeof argument) Boolean) if (= prim true) return 1n else if (= prim false) return 0n else return undefined else 8:{}\n  7:if (= (typeof argument) BigInt) return prim else 8:{}\n  9:if (= (typeof argument) Number) (2) throw TypeError else 8:{}\n  13:if (= (typeof argument) String) {\n    10:(0) app __x0__ = (StringToBigInt prim)\n    10:let n = [! __x0__]\n    11:if (= n NaN) (3) throw SyntaxError else 8:{}\n    12:return n\n  } else 8:{}\n  15:if (= (typeof argument) Symbol) (4) throw TypeError else 8:{}\n  16:assert false\n}"
  }, {
    "code": ["        <table>", "          <tbody>", "          <tr>", "            <th>", "              Argument Type", "            </th>", "            <th>", "              Result", "            </th>", "          </tr>", "          <tr>", "            <td>", "              Undefined", "            </td>", "            <td>", "              Return *\"undefined\"*.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              Null", "            </td>", "            <td>", "              Return *\"null\"*.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              Boolean", "            </td>", "            <td>", "              <p>If _argument_ is *true*, return *\"true\"*.</p>", "              <p>If _argument_ is *false*, return *\"false\"*.</p>", "            </td>", "          </tr>", "          <tr>", "            <td>", "              Number", "            </td>", "            <td>", "              Return ! Number::toString(_argument_).", "            </td>", "          </tr>", "          <tr>", "            <td>", "              String", "            </td>", "            <td>", "              Return _argument_.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              Symbol", "            </td>", "            <td>", "              Throw a *TypeError* exception.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              BigInt", "            </td>", "            <td>", "              Return ! BigInt::toString(_argument_).", "            </td>", "          </tr>", "          <tr>", "            <td>", "              Object", "            </td>", "            <td>", "              <p>Apply the following steps:</p>", "              <emu-alg>", "                1. Let _primValue_ be ? ToPrimitive(_argument_, ~string~).", "                1. Return ? ToString(_primValue_).", "              </emu-alg>", "            </td>", "          </tr>", "          </tbody>", "        </table>"],
    "head": {
      "name": "ToString",
      "params": [{
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "table-tostring-conversions",
    "rawBody": "{\n  1:if (= (typeof argument) Undefined) return \"undefined\" else 8:{}\n  3:if (= (typeof argument) Null) return \"null\" else 8:{}\n  6:if (= (typeof argument) Boolean) {\n    4:if (= argument true) return \"true\" else 8:{}\n    5:if (= argument false) return \"false\" else 8:{}\n  } else 8:{}\n  8:if (= (typeof argument) Number) {\n    7:(0) app __x0__ = (PRIMITIVE[Number][\"toString\"] argument)\n    7:return [! __x0__]\n  } else 8:{}\n  10:if (= (typeof argument) String) return argument else 8:{}\n  12:if (= (typeof argument) Symbol) (0) throw TypeError else 8:{}\n  14:if (= (typeof argument) BigInt) {\n    13:(1) app __x1__ = (PRIMITIVE[BigInt][\"toString\"] argument)\n    13:return [! __x1__]\n  } else 8:{}\n  17:if (= (typeof argument) Object) {\n    15:(2) app __x2__ = (ToPrimitive argument CONST_string)\n    15:let primValue = [? __x2__]\n    16:(3) app __x3__ = (ToString primValue)\n    16:return [? __x3__]\n  } else 8:{}\n  18:assert false\n}"
  }, {
    "code": ["        <table>", "          <tbody>", "          <tr>", "            <th>", "              Argument Type", "            </th>", "            <th>", "              Result", "            </th>", "          </tr>", "          <tr>", "            <td>", "              Undefined", "            </td>", "            <td>", "              Throw a *TypeError* exception.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              Null", "            </td>", "            <td>", "              Throw a *TypeError* exception.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              Boolean", "            </td>", "            <td>", "              Return a new Boolean object whose [[BooleanData]] internal slot is set to _argument_. See <emu-xref href=\"#sec-boolean-objects\"></emu-xref> for a description of Boolean objects.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              Number", "            </td>", "            <td>", "              Return a new Number object whose [[NumberData]] internal slot is set to _argument_. See <emu-xref href=\"#sec-number-objects\"></emu-xref> for a description of Number objects.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              String", "            </td>", "            <td>", "              Return a new String object whose [[StringData]] internal slot is set to _argument_. See <emu-xref href=\"#sec-string-objects\"></emu-xref> for a description of String objects.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              Symbol", "            </td>", "            <td>", "              Return a new Symbol object whose [[SymbolData]] internal slot is set to _argument_. See <emu-xref href=\"#sec-symbol-objects\"></emu-xref> for a description of Symbol objects.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              BigInt", "            </td>", "            <td>", "              Return a new BigInt object whose [[BigIntData]] internal slot is set to _argument_. See <emu-xref href=\"#sec-bigint-objects\"></emu-xref> for a description of BigInt objects.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              Object", "            </td>", "            <td>", "              Return _argument_.", "            </td>", "          </tr>", "          </tbody>", "        </table>"],
    "head": {
      "name": "ToObject",
      "params": [{
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "table-toobject-conversions",
    "rawBody": "{\n  1:if (= (typeof argument) Undefined) (0) throw TypeError else 8:{}\n  3:if (= (typeof argument) Null) (1) throw TypeError else 8:{}\n  5:if (= (typeof argument) Boolean) {\n    4:let obj = (2) (new OrdinaryObject(\"Prototype\" -> INTRINSIC_Boolean_prototype, \"BooleanData\" -> argument))\n    4:return obj\n  } else 8:{}\n  7:if (= (typeof argument) Number) {\n    6:let obj = (3) (new OrdinaryObject(\"Prototype\" -> INTRINSIC_Number_prototype, \"NumberData\" -> argument))\n    6:return obj\n  } else 8:{}\n  9:if (= (typeof argument) String) {\n    8:let obj = (4) (new StringExoticObject(\"Prototype\" -> INTRINSIC_String_prototype, \"StringData\" -> argument))\n    8:return obj\n  } else 8:{}\n  11:if (= (typeof argument) Symbol) {\n    10:let obj = (5) (new OrdinaryObject(\"Prototype\" -> INTRINSIC_Symbol_prototype, \"SymbolData\" -> argument))\n    10:return obj\n  } else 8:{}\n  13:if (= (typeof argument) BigInt) {\n    12:let obj = (6) (new OrdinaryObject(\"Prototype\" -> INTRINSIC_BigInt_prototype, \"BigIntData\" -> argument))\n    12:return obj\n  } else 8:{}\n  15:if (= (typeof argument) Object) return argument else 8:{}\n  16:assert false\n}"
  }, {
    "code": ["        <table>", "          <tbody>", "          <tr>", "            <th>", "              Argument Type", "            </th>", "            <th>", "              Result", "            </th>", "          </tr>", "          <tr>", "            <td>", "              Undefined", "            </td>", "            <td>", "              Throw a *TypeError* exception.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              Null", "            </td>", "            <td>", "              Throw a *TypeError* exception.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              Boolean", "            </td>", "            <td>", "              Return _argument_.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              Number", "            </td>", "            <td>", "              Return _argument_.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              String", "            </td>", "            <td>", "              Return _argument_.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              Symbol", "            </td>", "            <td>", "              Return _argument_.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              BigInt", "            </td>", "            <td>", "              Return _argument_.", "            </td>", "          </tr>", "          <tr>", "            <td>", "              Object", "            </td>", "            <td>", "              Return _argument_.", "            </td>", "          </tr>", "          </tbody>", "        </table>"],
    "head": {
      "name": "RequireObjectCoercible",
      "params": [{
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "table-requireobjectcoercible-results",
    "rawBody": "{\n  1:if (= (typeof argument) Undefined) (0) throw TypeError else 8:{}\n  3:if (= (typeof argument) Null) (1) throw TypeError else 8:{}\n  5:if (= (typeof argument) Boolean) return argument else 8:{}\n  7:if (= (typeof argument) Number) return argument else 8:{}\n  9:if (= (typeof argument) String) return argument else 8:{}\n  11:if (= (typeof argument) Symbol) return argument else 8:{}\n  13:if (= (typeof argument) BigInt) return argument else 8:{}\n  15:if (= (typeof argument) Object) return argument else 8:{}\n  16:assert false\n}"
  }, {
    "code": ["Day(_t_) = 𝔽(floor(ℝ(_t_ / msPerDay)))"],
    "head": {
      "name": "Day",
      "params": [{
        "kind": "Normal",
        "name": "t"
      }]
    },
    "ids": "eqn-Day",
    "rawBody": "{\n  0:(0) app __x0__ = (floor (/ t 8.64E7))\n  0:return __x0__\n}"
  }, {
    "code": ["msPerDay = *86400000* <sub>𝔽</sub>"],
    "head": {
      "name": "msPerDay",
      "params": []
    },
    "ids": "eqn-msPerDay",
    "rawBody": "return 86400000i"
  }, {
    "code": ["TimeWithinDay(_t_) = 𝔽(ℝ(_t_) modulo ℝ(msPerDay))"],
    "head": {
      "name": "TimeWithinDay",
      "params": [{
        "kind": "Normal",
        "name": "t"
      }]
    },
    "ids": "eqn-TimeWithinDay",
    "rawBody": "return (%% t 8.64E7)"
  }, {
    "code": ["          = *365*<sub>𝔽</sub> if (ℝ(_y_) modulo 4) ≠ 0", "          = *366*<sub>𝔽</sub> if (ℝ(_y_) modulo 4) = 0 and (ℝ(_y_) modulo 100) ≠ 0", "          = *365*<sub>𝔽</sub> if (ℝ(_y_) modulo 100) = 0 and (ℝ(_y_) modulo 400) ≠ 0", "          = *366*<sub>𝔽</sub> if (ℝ(_y_) modulo 400) = 0"],
    "head": {
      "name": "DaysInYear",
      "params": [{
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "eqn-DaysInYear",
    "rawBody": "{\n  0:if (! (== (%% y 4i) 0i)) return 365i else 8:{}\n  1:if (&& (== (%% y 4i) 0i) (! (== (%% y 100i) 0i))) return 366i else 8:{}\n  2:if (&& (== (%% y 100i) 0i) (! (== (%% y 400i) 0i))) return 365i else 8:{}\n  3:if (== (%% y 400i) 0i) return 366i else 8:{}\n}"
  }, {
    "code": ["DayFromYear(_y_) = 𝔽(365 × (ℝ(_y_) - 1970) + floor((ℝ(_y_) - 1969) / 4) - floor((ℝ(_y_) - 1901) / 100) + floor((ℝ(_y_) - 1601) / 400))"],
    "head": {
      "name": "DayFromYear",
      "params": [{
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "eqn-DaysFromYear",
    "rawBody": "{\n  0:(0) app __x0__ = (floor (/ (- y 1969i) 4i))\n  0:(1) app __x1__ = (floor (/ (- y 1901i) 100i))\n  0:(2) app __x2__ = (floor (/ (- y 1601i) 400i))\n  0:return (+ (- (+ (* 365i (- y 1970i)) __x0__) __x1__) __x2__)\n}"
  }, {
    "code": ["TimeFromYear(_y_) = msPerDay × DayFromYear(_y_)"],
    "head": {
      "name": "TimeFromYear",
      "params": [{
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "eqn-TimeFromYear",
    "rawBody": "{\n  0:(0) app __x0__ = (DayFromYear y)\n  0:return (* 8.64E7 __x0__)\n}"
  }, {
    "code": ["YearFromTime(_t_) = the largest integral Number _y_ (closest to +∞) such that TimeFromYear(_y_) ≤ _t_"],
    "head": {
      "name": "YearFromTime",
      "params": [{
        "kind": "Normal",
        "name": "t"
      }]
    },
    "ids": "eqn-YearFromTime",
    "rawBody": "(0) ??? \"YearFromTime ( id:{t} ) = the largest integral Number id:{y} ( closest to + ∞ ) such that TimeFromYear ( id:{y} ) ≤ id:{t}\""
  }, {
    "code": ["          = *+0*<sub>𝔽</sub> if DaysInYear(YearFromTime(_t_)) = *365*<sub>𝔽</sub>", "          = *1*<sub>𝔽</sub> if DaysInYear(YearFromTime(_t_)) = *366*<sub>𝔽</sub>"],
    "head": {
      "name": "InLeapYear",
      "params": [{
        "kind": "Normal",
        "name": "t"
      }]
    },
    "ids": "eqn-InLeapYear",
    "rawBody": "{\n  0:(0) app __x0__ = (YearFromTime t)\n  0:(1) app __x1__ = (DaysInYear __x0__)\n  0:if (== __x1__ 365i) return 0i else 8:{}\n  1:(2) app __x2__ = (YearFromTime t)\n  1:(3) app __x3__ = (DaysInYear __x2__)\n  1:if (== __x3__ 366i) return 1i else 8:{}\n}"
  }, {
    "code": ["          = *+0*<sub>𝔽</sub> if *+0*<sub>𝔽</sub> ≤ DayWithinYear(_t_) < *31*<sub>𝔽</sub>", "          = *1*<sub>𝔽</sub> if *31*<sub>𝔽</sub> ≤ DayWithinYear(_t_) < *59*<sub>𝔽</sub> + InLeapYear(_t_)", "          = *2*<sub>𝔽</sub> if *59*<sub>𝔽</sub> + InLeapYear(_t_) ≤ DayWithinYear(_t_) < *90*<sub>𝔽</sub> + InLeapYear(_t_)", "          = *3*<sub>𝔽</sub> if *90*<sub>𝔽</sub> + InLeapYear(_t_) ≤ DayWithinYear(_t_) < *120*<sub>𝔽</sub> + InLeapYear(_t_)", "          = *4*<sub>𝔽</sub> if *120*<sub>𝔽</sub> + InLeapYear(_t_) ≤ DayWithinYear(_t_) < *151*<sub>𝔽</sub> + InLeapYear(_t_)", "          = *5*<sub>𝔽</sub> if *151*<sub>𝔽</sub> + InLeapYear(_t_) ≤ DayWithinYear(_t_) < *181*<sub>𝔽</sub> + InLeapYear(_t_)", "          = *6*<sub>𝔽</sub> if *181*<sub>𝔽</sub> + InLeapYear(_t_) ≤ DayWithinYear(_t_) < *212*<sub>𝔽</sub> + InLeapYear(_t_)", "          = *7*<sub>𝔽</sub> if *212*<sub>𝔽</sub> + InLeapYear(_t_) ≤ DayWithinYear(_t_) < *243*<sub>𝔽</sub> + InLeapYear(_t_)", "          = *8*<sub>𝔽</sub> if *243*<sub>𝔽</sub> + InLeapYear(_t_) ≤ DayWithinYear(_t_) < *273*<sub>𝔽</sub> + InLeapYear(_t_)", "          = *9*<sub>𝔽</sub> if *273*<sub>𝔽</sub> + InLeapYear(_t_) ≤ DayWithinYear(_t_) < *304*<sub>𝔽</sub> + InLeapYear(_t_)", "          = *10*<sub>𝔽</sub> if *304*<sub>𝔽</sub> + InLeapYear(_t_) ≤ DayWithinYear(_t_) < *334*<sub>𝔽</sub> + InLeapYear(_t_)", "          = *11*<sub>𝔽</sub> if *334*<sub>𝔽</sub> + InLeapYear(_t_) ≤ DayWithinYear(_t_) < *365*<sub>𝔽</sub> + InLeapYear(_t_)"],
    "head": {
      "name": "MonthFromTime",
      "params": [{
        "kind": "Normal",
        "name": "t"
      }]
    },
    "ids": "eqn-MonthFromTime",
    "rawBody": "{\n  0:(0) app __x0__ = (DayWithinYear t)\n  0:if (&& (! (< __x0__ 0i)) (< __x0__ 31i)) return 0i else 8:{}\n  1:(1) app __x1__ = (DayWithinYear t)\n  1:(2) app __x2__ = (InLeapYear t)\n  1:if (&& (! (< __x1__ 31i)) (< __x1__ (+ 59i __x2__))) return 1i else 8:{}\n  2:(3) app __x3__ = (InLeapYear t)\n  2:(4) app __x4__ = (DayWithinYear t)\n  2:(5) app __x5__ = (InLeapYear t)\n  2:if (&& (! (< __x4__ (+ 59i __x3__))) (< __x4__ (+ 90i __x5__))) return 2i else 8:{}\n  3:(6) app __x6__ = (InLeapYear t)\n  3:(7) app __x7__ = (DayWithinYear t)\n  3:(8) app __x8__ = (InLeapYear t)\n  3:if (&& (! (< __x7__ (+ 90i __x6__))) (< __x7__ (+ 120i __x8__))) return 3i else 8:{}\n  4:(9) app __x9__ = (InLeapYear t)\n  4:(10) app __x10__ = (DayWithinYear t)\n  4:(11) app __x11__ = (InLeapYear t)\n  4:if (&& (! (< __x10__ (+ 120i __x9__))) (< __x10__ (+ 151i __x11__))) return 4i else 8:{}\n  5:(12) app __x12__ = (InLeapYear t)\n  5:(13) app __x13__ = (DayWithinYear t)\n  5:(14) app __x14__ = (InLeapYear t)\n  5:if (&& (! (< __x13__ (+ 151i __x12__))) (< __x13__ (+ 181i __x14__))) return 5i else 8:{}\n  6:(15) app __x15__ = (InLeapYear t)\n  6:(16) app __x16__ = (DayWithinYear t)\n  6:(17) app __x17__ = (InLeapYear t)\n  6:if (&& (! (< __x16__ (+ 181i __x15__))) (< __x16__ (+ 212i __x17__))) return 6i else 8:{}\n  7:(18) app __x18__ = (InLeapYear t)\n  7:(19) app __x19__ = (DayWithinYear t)\n  7:(20) app __x20__ = (InLeapYear t)\n  7:if (&& (! (< __x19__ (+ 212i __x18__))) (< __x19__ (+ 243i __x20__))) return 7i else 8:{}\n  8:(21) app __x21__ = (InLeapYear t)\n  8:(22) app __x22__ = (DayWithinYear t)\n  8:(23) app __x23__ = (InLeapYear t)\n  8:if (&& (! (< __x22__ (+ 243i __x21__))) (< __x22__ (+ 273i __x23__))) return 8i else 8:{}\n  9:(24) app __x24__ = (InLeapYear t)\n  9:(25) app __x25__ = (DayWithinYear t)\n  9:(26) app __x26__ = (InLeapYear t)\n  9:if (&& (! (< __x25__ (+ 273i __x24__))) (< __x25__ (+ 304i __x26__))) return 9i else 8:{}\n  10:(27) app __x27__ = (InLeapYear t)\n  10:(28) app __x28__ = (DayWithinYear t)\n  10:(29) app __x29__ = (InLeapYear t)\n  10:if (&& (! (< __x28__ (+ 304i __x27__))) (< __x28__ (+ 334i __x29__))) return 10i else 8:{}\n  11:(30) app __x30__ = (InLeapYear t)\n  11:(31) app __x31__ = (DayWithinYear t)\n  11:(32) app __x32__ = (InLeapYear t)\n  11:if (&& (! (< __x31__ (+ 334i __x30__))) (< __x31__ (+ 365i __x32__))) return 11i else 8:{}\n}"
  }, {
    "code": ["DayWithinYear(_t_) = Day(_t_) - DayFromYear(YearFromTime(_t_))"],
    "head": {
      "name": "DayWithinYear",
      "params": [{
        "kind": "Normal",
        "name": "t"
      }]
    },
    "ids": "eqn-DayWithinYear",
    "rawBody": "{\n  0:(0) app __x0__ = (Day t)\n  0:(1) app __x1__ = (YearFromTime t)\n  0:(2) app __x2__ = (DayFromYear __x1__)\n  0:return (- __x0__ __x2__)\n}"
  }, {
    "code": ["          = DayWithinYear(_t_) + *1*<sub>𝔽</sub> if MonthFromTime(_t_) = *+0*<sub>𝔽</sub>", "          = DayWithinYear(_t_) - *30*<sub>𝔽</sub> if MonthFromTime(_t_) = *1*<sub>𝔽</sub>", "          = DayWithinYear(_t_) - *58*<sub>𝔽</sub> - InLeapYear(_t_) if MonthFromTime(_t_) = *2*<sub>𝔽</sub>", "          = DayWithinYear(_t_) - *89*<sub>𝔽</sub> - InLeapYear(_t_) if MonthFromTime(_t_) = *3*<sub>𝔽</sub>", "          = DayWithinYear(_t_) - *119*<sub>𝔽</sub> - InLeapYear(_t_) if MonthFromTime(_t_) = *4*<sub>𝔽</sub>", "          = DayWithinYear(_t_) - *150*<sub>𝔽</sub> - InLeapYear(_t_) if MonthFromTime(_t_) = *5*<sub>𝔽</sub>", "          = DayWithinYear(_t_) - *180*<sub>𝔽</sub> - InLeapYear(_t_) if MonthFromTime(_t_) = *6*<sub>𝔽</sub>", "          = DayWithinYear(_t_) - *211*<sub>𝔽</sub> - InLeapYear(_t_) if MonthFromTime(_t_) = *7*<sub>𝔽</sub>", "          = DayWithinYear(_t_) - *242*<sub>𝔽</sub> - InLeapYear(_t_) if MonthFromTime(_t_) = *8*<sub>𝔽</sub>", "          = DayWithinYear(_t_) - *272*<sub>𝔽</sub> - InLeapYear(_t_) if MonthFromTime(_t_) = *9*<sub>𝔽</sub>", "          = DayWithinYear(_t_) - *303*<sub>𝔽</sub> - InLeapYear(_t_) if MonthFromTime(_t_) = *10*<sub>𝔽</sub>", "          = DayWithinYear(_t_) - *333*<sub>𝔽</sub> - InLeapYear(_t_) if MonthFromTime(_t_) = *11*<sub>𝔽</sub>"],
    "head": {
      "name": "DateFromTime",
      "params": [{
        "kind": "Normal",
        "name": "t"
      }]
    },
    "ids": "sec-date-number",
    "rawBody": "{\n  0:(0) app __x0__ = (MonthFromTime t)\n  0:if (== __x0__ 0i) {\n    (1) app __x1__ = (DayWithinYear t)\n    return (+ __x1__ 1i)\n  } else 8:{}\n  1:(2) app __x2__ = (MonthFromTime t)\n  1:if (== __x2__ 1i) {\n    (3) app __x3__ = (DayWithinYear t)\n    return (- __x3__ 30i)\n  } else 8:{}\n  2:(4) app __x4__ = (MonthFromTime t)\n  2:if (== __x4__ 2i) {\n    (5) app __x5__ = (DayWithinYear t)\n    (6) app __x6__ = (InLeapYear t)\n    return (- (- __x5__ 58i) __x6__)\n  } else 8:{}\n  3:(7) app __x7__ = (MonthFromTime t)\n  3:if (== __x7__ 3i) {\n    (8) app __x8__ = (DayWithinYear t)\n    (9) app __x9__ = (InLeapYear t)\n    return (- (- __x8__ 89i) __x9__)\n  } else 8:{}\n  4:(10) app __x10__ = (MonthFromTime t)\n  4:if (== __x10__ 4i) {\n    (11) app __x11__ = (DayWithinYear t)\n    (12) app __x12__ = (InLeapYear t)\n    return (- (- __x11__ 119i) __x12__)\n  } else 8:{}\n  5:(13) app __x13__ = (MonthFromTime t)\n  5:if (== __x13__ 5i) {\n    (14) app __x14__ = (DayWithinYear t)\n    (15) app __x15__ = (InLeapYear t)\n    return (- (- __x14__ 150i) __x15__)\n  } else 8:{}\n  6:(16) app __x16__ = (MonthFromTime t)\n  6:if (== __x16__ 6i) {\n    (17) app __x17__ = (DayWithinYear t)\n    (18) app __x18__ = (InLeapYear t)\n    return (- (- __x17__ 180i) __x18__)\n  } else 8:{}\n  7:(19) app __x19__ = (MonthFromTime t)\n  7:if (== __x19__ 7i) {\n    (20) app __x20__ = (DayWithinYear t)\n    (21) app __x21__ = (InLeapYear t)\n    return (- (- __x20__ 211i) __x21__)\n  } else 8:{}\n  8:(22) app __x22__ = (MonthFromTime t)\n  8:if (== __x22__ 8i) {\n    (23) app __x23__ = (DayWithinYear t)\n    (24) app __x24__ = (InLeapYear t)\n    return (- (- __x23__ 242i) __x24__)\n  } else 8:{}\n  9:(25) app __x25__ = (MonthFromTime t)\n  9:if (== __x25__ 9i) {\n    (26) app __x26__ = (DayWithinYear t)\n    (27) app __x27__ = (InLeapYear t)\n    return (- (- __x26__ 272i) __x27__)\n  } else 8:{}\n  10:(28) app __x28__ = (MonthFromTime t)\n  10:if (== __x28__ 10i) {\n    (29) app __x29__ = (DayWithinYear t)\n    (30) app __x30__ = (InLeapYear t)\n    return (- (- __x29__ 303i) __x30__)\n  } else 8:{}\n  11:(31) app __x31__ = (MonthFromTime t)\n  11:if (== __x31__ 11i) {\n    (32) app __x32__ = (DayWithinYear t)\n    (33) app __x33__ = (InLeapYear t)\n    return (- (- __x32__ 333i) __x33__)\n  } else 8:{}\n}"
  }, {
    "code": ["WeekDay(_t_) = 𝔽(ℝ(Day(_t_) + *4* <sub>𝔽</sub>) modulo 7)"],
    "head": {
      "name": "WeekDay",
      "params": [{
        "kind": "Normal",
        "name": "t"
      }]
    },
    "ids": "sec-week-day",
    "rawBody": "{\n  0:(0) app __x0__ = (Day t)\n  0:return (%% (+ __x0__ 4i) 7i)\n}"
  }, {
    "code": ["HourFromTime(_t_) = 𝔽(floor(ℝ(_t_ / msPerHour)) modulo HoursPerDay)"],
    "head": {
      "name": "HourFromTime",
      "params": [{
        "kind": "Normal",
        "name": "t"
      }]
    },
    "ids": "eqn-HourFromTime",
    "rawBody": "{\n  0:(0) app __x0__ = (floor (/ t 3600000.0))\n  0:return (%% __x0__ HoursPerDay)\n}"
  }, {
    "code": ["MinFromTime(_t_) = 𝔽(floor(ℝ(_t_ / msPerMinute)) modulo MinutesPerHour)"],
    "head": {
      "name": "MinFromTime",
      "params": [{
        "kind": "Normal",
        "name": "t"
      }]
    },
    "ids": "eqn-MinFromTime",
    "rawBody": "{\n  0:(0) app __x0__ = (floor (/ t 60000.0))\n  0:return (%% __x0__ MinutesPerHour)\n}"
  }, {
    "code": ["SecFromTime(_t_) = 𝔽(floor(ℝ(_t_ / msPerSecond)) modulo SecondsPerMinute)"],
    "head": {
      "name": "SecFromTime",
      "params": [{
        "kind": "Normal",
        "name": "t"
      }]
    },
    "ids": "eqn-SecFromTime",
    "rawBody": "{\n  0:(0) app __x0__ = (floor (/ t 1000.0))\n  0:return (%% __x0__ SecondsPerMinute)\n}"
  }, {
    "code": ["msFromTime(_t_) = 𝔽(ℝ(_t_) modulo msPerSecond)"],
    "head": {
      "name": "msFromTime",
      "params": [{
        "kind": "Normal",
        "name": "t"
      }]
    },
    "ids": "eqn-msFromTime",
    "rawBody": "return (%% t 1000.0)"
  }, {
    "code": ["HoursPerDay = 24"],
    "head": {
      "name": "HoursPerDay",
      "params": []
    },
    "ids": "eqn-HoursPerDay",
    "rawBody": "return 24i"
  }, {
    "code": ["MinutesPerHour = 60"],
    "head": {
      "name": "MinutesPerHour",
      "params": []
    },
    "ids": "eqn-MinutesPerHour",
    "rawBody": "return 60i"
  }, {
    "code": ["SecondsPerMinute = 60"],
    "head": {
      "name": "SecondsPerMinute",
      "params": []
    },
    "ids": "eqn-SecondsPerMinute",
    "rawBody": "return 60i"
  }, {
    "code": ["msPerSecond = *1000* <sub>𝔽</sub>"],
    "head": {
      "name": "msPerSecond",
      "params": []
    },
    "ids": "eqn-msPerSecond",
    "rawBody": "return 1000i"
  }, {
    "code": ["msPerMinute = *60000* <sub>𝔽</sub> = msPerSecond × 𝔽(SecondsPerMinute)"],
    "head": {
      "name": "msPerMinute",
      "params": []
    },
    "ids": "eqn-msPerMinute",
    "rawBody": "return (* 1000.0 SecondsPerMinute)"
  }, {
    "code": ["msPerHour = *3600000* <sub>𝔽</sub> = msPerMinute × 𝔽(MinutesPerHour)"],
    "head": {
      "name": "msPerHour",
      "params": []
    },
    "ids": "eqn-msPerHour",
    "rawBody": "return (* 60000.0 MinutesPerHour)"
  }, {
    "code": [],
    "head": {
      "base": "BuiltinFunctionObject",
      "methodName": "Construct",
      "origParams": [{
        "kind": "Normal",
        "name": "argumentsList"
      }, {
        "kind": "Normal",
        "name": "newTarget"
      }],
      "receiverParam": {
        "kind": "Normal",
        "name": "F"
      }
    },
    "ids": "",
    "rawBody": "{\n  let callerContext = CONTEXT\n  if (= callerContext null) CONTEXT = null else {}\n  let calleeContext = (new ExecutionContext())\n  calleeContext[\"Function\"] = F\n  let calleeRealm = F[\"Realm\"]\n  calleeContext[\"Realm\"] = calleeRealm\n  calleeContext[\"ScriptOrModule\"] = null\n  append calleeContext -> EXECUTION_STACK\n  CONTEXT = EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)]\n  app result = (F[\"Code\"] undefined argumentsList newTarget)\n  if (= EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)] calleeContext) {\n    let __x0__ = (- EXECUTION_STACK[\"length\"] 1i)\n    (pop EXECUTION_STACK __x0__)\n  } else {}\n  CONTEXT = EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)]\n  return result\n}"
  }, {
    "code": [],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "str"
      }],
      "ref": "HostPrint"
    },
    "ids": "",
    "rawBody": "{\n  print [? str]\n  return undefined\n}"
  }, {
    "code": [],
    "head": {
      "name": "Number::exponentiate",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "",
    "rawBody": "{\n  return (** x y)\n}"
  }, {
    "code": [],
    "head": {
      "name": "BigInt::add",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "",
    "rawBody": "{\n  return (+ x y)\n}"
  }, {
    "code": [],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "message"
      }],
      "ref": "SyntaxError"
    },
    "ids": "",
    "rawBody": "??? \"Need manual modeling\""
  }, {
    "code": [],
    "head": {
      "name": "Number::divide",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "",
    "rawBody": "{\n  return (/ x y)\n}"
  }, {
    "code": [],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "resolve"
      }, {
        "kind": "Normal",
        "name": "reject"
      }],
      "ref": "GetCapabilitiesExecutorFunctions"
    },
    "ids": "",
    "rawBody": "{\n  let capability = (new PromiseCapabilityRecord(\"Resolve\" -> undefined, \"Reject\" -> undefined))\n  let F = (new OrdinaryObject(\"Capability\" -> capability))\n  let promiseCapability = F[\"Capability\"]\n  if\n  (! (= promiseCapability[\"Resolve\"] undefined))\n  throw TypeError\n  if\n  (! (= promiseCapability[\"Reject\"] undefined))\n  throw TypeError\n  promiseCapability[\"Resolve\"] = resolve\n  promiseCapability[\"Reject\"] = reject\n  return undefined\n}"
  }, {
    "code": [],
    "head": {
      "name": "EnqueueJob",
      "params": [{
        "kind": "Normal",
        "name": "queueName"
      }, {
        "kind": "Normal",
        "name": "job"
      }, {
        "kind": "Normal",
        "name": "arguments"
      }]
    },
    "ids": "",
    "rawBody": "{\n  let callerContext = CONTEXT\n  let callerRealm = callerContext[\"Realm\"]\n  let callerScriptOrModule = callerContext[\"ScriptOrModule\"]\n  let pending = (new PendingJob(\"Job\" -> job, \"Arguments\" -> arguments, \"Realm\" -> callerRealm, \"ScriptOrModule\" -> callerScriptOrModule, \"HostDefined\" -> undefined))\n  append pending -> JOB_QUEUE\n  return CONST_empty\n}"
  }, {
    "code": [],
    "head": {
      "name": "HostFinalizeImportMeta",
      "params": [{
        "kind": "Normal",
        "name": "importMeta"
      }, {
        "kind": "Normal",
        "name": "moduleRecord"
      }]
    },
    "ids": "",
    "rawBody": "return CONST_empty"
  }, {
    "code": [],
    "head": {
      "name": "HostImportModuleDynamically",
      "params": [{
        "kind": "Normal",
        "name": "referencingScriptOrModule"
      }, {
        "kind": "Normal",
        "name": "specifier"
      }, {
        "kind": "Normal",
        "name": "promiseCapability"
      }]
    },
    "ids": "",
    "rawBody": "return undefined"
  }, {
    "code": [],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "message"
      }],
      "ref": "EvalError"
    },
    "ids": "",
    "rawBody": "??? \"Need manual modeling\""
  }, {
    "code": [],
    "head": {
      "name": "Number::remainder",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "",
    "rawBody": "{\n  return (% x y)\n}"
  }, {
    "code": [],
    "head": {
      "name": "BigInt::lessThan",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "",
    "rawBody": "{\n  return (< x y)\n}"
  }, {
    "code": [],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "message"
      }],
      "ref": "TypeError"
    },
    "ids": "",
    "rawBody": "??? \"Need manual modeling\""
  }, {
    "code": [],
    "head": {
      "name": "CodePointsToString",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }]
    },
    "ids": "",
    "rawBody": "return AnyStr"
  }, {
    "code": [],
    "head": {
      "name": "StringToBigInt",
      "params": [{
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "",
    "rawBody": "return (convert argument num2bigint )"
  }, {
    "code": [],
    "head": {
      "name": "NumericToRawBytes",
      "params": [{
        "kind": "Normal",
        "name": "type"
      }, {
        "kind": "Normal",
        "name": "value"
      }, {
        "kind": "Normal",
        "name": "isLittleEndian"
      }]
    },
    "ids": "",
    "rawBody": "return NumList"
  }, {
    "code": [],
    "head": {
      "name": "HostGetImportMetaProperties",
      "params": [{
        "kind": "Normal",
        "name": "moduleRecord"
      }]
    },
    "ids": "",
    "rawBody": "return (new [])"
  }, {
    "code": [],
    "head": {
      "name": "ToBigInt",
      "params": [{
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "",
    "rawBody": "{\n  app __x0__ = (ToPrimitive argument CONST_number)\n  let prim = [? __x0__]\n  if (= (typeof prim) Undefined) throw TypeError else if (= (typeof prim) Null) throw TypeError else if (= (typeof prim) Boolean) if prim return 1n else return 0n else if (= (typeof prim) BigInt) return prim else if (= (typeof prim) Number) throw TypeError else if (= (typeof prim) String) {\n    app __x1__ = (StringToBigInt prim)\n    let n = [! __x1__]\n    if (= n NaN) throw SyntaxError else {}\n    return n\n  } else if (= (typeof prim) Symbol) throw TypeError else {}\n}"
  }, {
    "code": [],
    "head": {
      "name": "BigInt::bitwiseNOT",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }]
    },
    "ids": "",
    "rawBody": "{\n  return (~ x)\n}"
  }, {
    "code": [],
    "head": {
      "name": "IsInTailPosition",
      "params": [{
        "kind": "Normal",
        "name": "call"
      }]
    },
    "ids": "",
    "rawBody": "{\n  if false return false else {}\n  let __x0__ = true\n  let __x1__ = call\n  while (&& (= __x0__ true) (! (= __x1__ absent))) {\n    if (is-instance-of __x1__ FunctionBody) __x0__ = false else {}\n    if (is-instance-of __x1__ ConciseBody) __x0__ = false else {}\n    if (is-instance-of __x1__ AsyncConciseBody) __x0__ = false else {}\n    access __x1__ = (__x1__ \"parent\")\n  }\n  if __x0__ return false else {}\n  let __x2__ = true\n  let __x3__ = call\n  while (&& (= __x2__ true) (! (= __x3__ absent))) {\n    if (is-instance-of __x3__ FunctionBody) __x2__ = false else {}\n    if (is-instance-of __x3__ ConciseBody) __x2__ = false else {}\n    if (is-instance-of __x3__ AsyncConciseBody) __x2__ = false else {}\n    if (= __x2__ true) access __x3__ = (__x3__ \"parent\") else {}\n  }\n  let body = __x3__\n  let __x4__ = false\n  if (is-instance-of body FunctionBody) {\n    access __x5__ = (body \"parent\")\n    if (&& (! (= __x5__ absent)) (is-instance-of __x5__ GeneratorBody)) __x4__ = true else {}\n  } else {}\n  if __x4__ return false else {}\n  let __x6__ = false\n  if (is-instance-of body FunctionBody) {\n    access __x7__ = (body \"parent\")\n    if (&& (! (= __x7__ absent)) (is-instance-of __x7__ AsyncFunctionBody)) __x6__ = true else {}\n  } else {}\n  if __x6__ return false else {}\n  let __x8__ = false\n  if (is-instance-of body FunctionBody) {\n    access __x9__ = (body \"parent\")\n    if (&& (! (= __x9__ absent)) (is-instance-of __x9__ AsyncGeneratorBody)) __x8__ = true else {}\n  } else {}\n  if __x8__ return false else {}\n  if (is-instance-of body AsyncConciseBody) return false else {}\n  access __x10__ = (body \"HasCallInTailPosition\")\n  app __x11__ = (__x10__ call)\n  return __x11__\n}"
  }, {
    "code": [],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "message"
      }],
      "ref": "ReferenceError"
    },
    "ids": "",
    "rawBody": "??? \"Need manual modeling\""
  }, {
    "code": [],
    "head": {
      "name": "ProxyRevocationFunctions",
      "params": [{
        "kind": "Normal",
        "name": "resolve"
      }, {
        "kind": "Normal",
        "name": "reject"
      }]
    },
    "ids": "",
    "rawBody": "{\n  return undefined\n}"
  }, {
    "code": [],
    "head": {
      "origParams": [],
      "ref": "Function[\"prototype\"]"
    },
    "ids": "",
    "rawBody": "return undefined"
  }, {
    "code": [],
    "head": {
      "name": "RunJobs",
      "params": []
    },
    "ids": "",
    "rawBody": "{\n  app __x0__ = (InitializeHostDefinedRealm)\n  [? __x0__]\n  app __x1__ = (EnqueueJob \"ScriptJobs\" ScriptEvaluationJob (new [SCRIPT_BODY, HOST_DEFINED]))\n  while true {\n    if (= EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)] CONTEXT) {\n      let __x2__ = (- EXECUTION_STACK[\"length\"] 1i)\n      (pop EXECUTION_STACK __x2__)\n      if (= EXECUTION_STACK[\"length\"] 0i) CONTEXT = null else CONTEXT = EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)]\n    } else CONTEXT = null\n    if (= JOB_QUEUE[\"length\"] 0.0) return undefined else {}\n    let nextQueue = JOB_QUEUE\n    let nextPending = (pop nextQueue 0i)\n    let newContext = (new ExecutionContext(\"SubMap\" -> (new SubMap())))\n    newContext[\"Function\"] = null\n    newContext[\"Realm\"] = nextPending[\"Realm\"]\n    newContext[\"ScriptOrModule\"] = nextPending[\"ScriptOrModule\"]\n    append newContext -> EXECUTION_STACK\n    CONTEXT = EXECUTION_STACK[(- EXECUTION_STACK[\"length\"] 1i)]\n    let job = nextPending[\"Job\"]\n    let args = nextPending[\"Arguments\"]\n    if (= args[\"length\"] 2i) app __x3__ = (job args[0i] args[1i]) else app __x3__ = (job args[0i] args[1i] args[2i])\n    let result = __x3__\n    app __x4__ = (IsAbruptCompletion result)\n    if __x4__ return result else {}\n  }\n}"
  }, {
    "code": [],
    "head": {
      "name": "ModuleRecord.ResolveExport",
      "params": [{
        "kind": "Normal",
        "name": "this"
      }, {
        "kind": "Normal",
        "name": "exportName"
      }, {
        "kind": "Optional",
        "name": "resolveSet"
      }]
    },
    "ids": "",
    "rawBody": "return (new ResolvedBindingRecord())"
  }, {
    "code": [],
    "head": {
      "name": "ToNumber",
      "params": [{
        "kind": "Normal",
        "name": "argument"
      }]
    },
    "ids": "",
    "rawBody": "{\n  if (= (typeof argument) Undefined) return NaN else if (= (typeof argument) Null) return 0.0 else if (= (typeof argument) Boolean) if argument return 1.0 else return 0.0 else if (= (typeof argument) Number) return argument else if (= (typeof argument) String) return (convert argument str2num ) else if (= (typeof argument) Symbol) throw TypeError else if (= (typeof argument) BigInt) throw TypeError else {\n    app __x0__ = (ToPrimitive argument CONST_number)\n    let primValue = [? __x0__]\n    app __x1__ = (ToNumber primValue)\n    return [? __x1__]\n  }\n}"
  }, {
    "code": [],
    "head": {
      "name": "HostEnsureCanCompileStrings",
      "params": [{
        "kind": "Normal",
        "name": "callerRealm"
      }, {
        "kind": "Normal",
        "name": "calleeRealm"
      }]
    },
    "ids": "",
    "rawBody": "return CONST_empty"
  }, {
    "code": [],
    "head": {
      "name": "BigInt::subtract",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "",
    "rawBody": "{\n  return (- x y)\n}"
  }, {
    "code": [],
    "head": {
      "name": "BigInt::equal",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "",
    "rawBody": "{\n  return (= x y)\n}"
  }, {
    "code": [],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "message"
      }],
      "ref": "URIError"
    },
    "ids": "",
    "rawBody": "??? \"Need manual modeling\""
  }, {
    "code": [],
    "head": {
      "name": "Number::toString",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }]
    },
    "ids": "",
    "rawBody": "{\n  return (convert x num2str )\n}"
  }, {
    "code": [],
    "head": {
      "name": "BigInt::multiply",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "",
    "rawBody": "{\n  return (* x y)\n}"
  }, {
    "code": [],
    "head": {
      "name": "ModuleRecord.Link",
      "params": [{
        "kind": "Normal",
        "name": "this"
      }]
    },
    "ids": "",
    "rawBody": "return undefined"
  }, {
    "code": [],
    "head": {
      "name": "ModuleRecord.Evaluate",
      "params": [{
        "kind": "Normal",
        "name": "this"
      }]
    },
    "ids": "",
    "rawBody": "return undefined"
  }, {
    "code": [],
    "head": {
      "origParams": [{
        "kind": "Normal",
        "name": "message"
      }],
      "ref": "RangeError"
    },
    "ids": "",
    "rawBody": "??? \"Need manual modeling\""
  }, {
    "code": [],
    "head": {
      "name": "Number::add",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "",
    "rawBody": "{\n  return (+ x y)\n}"
  }, {
    "code": [],
    "head": {
      "name": "NumberToString",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }]
    },
    "ids": "",
    "rawBody": "{\n  return (convert x num2str )\n}"
  }, {
    "code": [],
    "head": {
      "name": "GetArgument",
      "params": [{
        "kind": "Normal",
        "name": "argumentsList"
      }, {
        "kind": "Normal",
        "name": "idx"
      }]
    },
    "ids": "",
    "rawBody": "{\n  let arg = argumentsList[idx]\n  if (= arg absent) return undefined else return arg\n}"
  }, {
    "code": [],
    "head": {
      "name": "MakeArgSetter",
      "params": [{
        "kind": "Normal",
        "name": "name"
      }, {
        "kind": "Normal",
        "name": "env"
      }]
    },
    "ids": "",
    "rawBody": "return (new BuiltinFunctionObject())"
  }, {
    "code": [],
    "head": {
      "name": "ScriptEvaluationJob",
      "params": [{
        "kind": "Normal",
        "name": "sourceText"
      }, {
        "kind": "Normal",
        "name": "hostDefined"
      }]
    },
    "ids": "",
    "rawBody": "{\n  let realm = REALM\n  app scriptRecord = (ParseScript sourceText realm hostDefined)\n  app __x1__ = (ScriptEvaluation scriptRecord)\n  [? __x1__]\n  return undefined\n}"
  }, {
    "code": [],
    "head": {
      "name": "ModuleRecord.GetExportedNames",
      "params": [{
        "kind": "Normal",
        "name": "this"
      }, {
        "kind": "Optional",
        "name": "exportStarSet"
      }]
    },
    "ids": "",
    "rawBody": "return StrList"
  }, {
    "code": [],
    "head": {
      "name": "HostPromiseRejectionTracker",
      "params": [{
        "kind": "Normal",
        "name": "promise"
      }, {
        "kind": "Normal",
        "name": "operation"
      }]
    },
    "ids": "",
    "rawBody": "return CONST_empty"
  }, {
    "code": [],
    "head": {
      "name": "Number::multiply",
      "params": [{
        "kind": "Normal",
        "name": "x"
      }, {
        "kind": "Normal",
        "name": "y"
      }]
    },
    "ids": "",
    "rawBody": "{\n  return (* x y)\n}"
  }],
  "aoids": ["ToInt8", "OrdinaryGet", "RegExpCreate", "GetViewValue", "ConciseBodyContainsUseStrict", "EvalDeclarationInstantiation", "PerformPromiseAllSettled", "BigInt::toString", "IteratorClose", "CodePointAt", "ParseScript", "RawBytesToNumeric", "UnicodeEscape", "SerializeJSONProperty", "HasProperty", "PromiseResolve", "GetPrototypeFromConstructor", "Invoke", "RestBindingInitialization", "BlockDeclarationInstantiation", "MakeMethod", "CaseBlockEvaluation", "PutValue", "DateFromTime", "IsDataDescriptor", "CreateUnmappedArgumentsObject", "CreateMapIterator", "IsBigIntElementType", "ToUint8Clamp", "BindingInitialization", "LoopEvaluation", "GetGlobalObject", "SharedDataBlockEventSet", "VarDeclaredNames", "KeyedBindingInitialization", "RegExpBuiltinExec", "RestDestructuringAssignmentEvaluation", "MakeBasicObject", "memory-order", "IsCallable", "ArrayAccumulation", "KeyedDestructuringAssignmentEvaluation", "AgentCanSuspend", "PerformPromiseThen", "IsConcatSpreadable", "IsFunctionDefinition", "CharacterRange", "ExportEntries", "DaysInYear", "ToLength", "AddWaiter", "CoveredAsyncArrowHead", "CreateArrayFromList", "GetModifySetValueInBuffer", "ArrayCreate", "InstantiateGeneratorFunctionExpression", "IteratorComplete", "GlobalDeclarationInstantiation", "CreateAsyncFromSyncIterator", "OrdinaryPreventExtensions", "IntegerIndexedElementGet", "RegExpAlloc", "InitializeBoundName", "GetIdentifierReference", "HostImportModuleDynamically", "SetRealmGlobalObject", "ByteListEqual", "IsIdentifierRef", "PerformPromiseAll", "IsConstantDeclaration", "IsCharacterClass", "CreateListIteratorRecord", "IteratorDestructuringAssignmentEvaluation", "TimeZoneString", "AtomicReadModifyWrite", "GeneratorResumeAbrupt", "IsAnonymousFunctionDefinition", "TypedArrayCreate", "HoursPerDay", "CoveredFormalsList", "LocalTZA", "NewObjectEnvironment", "AgentSignifier", "NormalCompletion", "PerformPromiseAny", "GetNewTarget", "InstantiateGeneratorFunctionObject", "GetSubstitution", "AsyncConciseBodyContainsUseStrict", "OrdinaryToPrimitive", "BinaryOr", "EnterCriticalSection", "AddToKeptObjects", "IsRegExp", "ForDeclarationBindingInitialization", "TopLevelVarDeclaredNames", "UTC", "msPerHour", "CreateRegExpStringIterator", "OrdinaryCallEvaluateBody", "SetTypedArrayFromArrayLike", "ForInOfHeadEvaluation", "IntegerIndexedObjectCreate", "HasCallInTailPosition", "thisBooleanValue", "AsyncGeneratorYield", "ProxyCreate", "EvaluateAsyncConciseBody", "SameValueZero", "MinutesPerHour", "AsyncFromSyncIteratorContinuation", "DestructuringAssignmentEvaluation", "ContainsDuplicateLabels", "HostEventSet", "StringCreate", "BoundNames", "ParseModule", "ClassElementKind", "TemplateStrings", "FunctionDeclarationInstantiation", "thisSymbolValue", "TopLevelVarScopedDeclarations", "host-synchronizes-with", "ToUint8", "QuoteJSONString", "IterableToList", "Await", "FulfillPromise", "AsyncGeneratorResumeNext", "HostResolveImportedModule", "ValidateTypedArray", "PropertyBindingInitialization", "RemoveWaiter", "IsIntegralNumber", "RegExpInitialize", "WhileLoopEvaluation", "HasName", "GetModuleNamespace", "ParseText", "ClassDefinitionEvaluation", "RegExpExec", "ToPropertyDescriptor", "InitializeTypedArrayFromList", "HasOwnProperty", "DeclarationPart", "WeakRefDeref", "SecondsPerMinute", "InitializeEnvironment", "ComputedPropertyContains", "UnicodeMatchPropertyValue", "TimeWithinDay", "Set", "CreateBuiltinFunction", "WeekDay", "ToBoolean", "NumericToRawBytes", "DetachArrayBuffer", "SerializeJSONArray", "ChainEvaluation", "ValidateIntegerTypedArray", "AdvanceStringIndex", "ValueOfReadEvent", "ResolveBinding", "InternalizeJSONProperty", "GetPromiseResolve", "ExpectedArgumentCount", "NewPromiseCapability", "IsUnresolvableReference", "CreateListFromArrayLike", "GetSuperConstructor", "ToInt32", "thisTimeValue", "ExportEntriesForModule", "DoWhileLoopEvaluation", "TriggerPromiseReactions", "ReferencedBindings", "TopLevelLexicallyDeclaredNames", "GetValue", "GetThisValue", "MinFromTime", "OrdinarySetPrototypeOf", "Type", "CreateDataPropertyOrThrow", "ExecuteModule", "InLeapYear", "ToPrimitive", "IsNoTearConfiguration", "ToIndex", "RequireObjectCoercible", "ResolveThisBinding", "StrictEqualityComparison", "CatchClauseEvaluation", "BinaryAnd", "IsValidIntegerIndex", "SubstitutionEvaluation", "SetViewValue", "Day", "NumberToBigInt", "ToBigUint64", "InitializeHostDefinedRealm", "Call", "GetMethod", "EscapeRegExpPattern", "MakeDay", "UpdateEmpty", "LeaveCriticalSection", "IsUnclampedIntegerElementType", "RemoveWaiters", "SetDefaultGlobalBindings", "GetTemplateObject", "TimeFromYear", "AsyncGeneratorResolve", "CreateDataProperty", "LexicallyDeclaredNames", "StringToCodePoints", "ForInOfBodyEvaluation", "OrdinaryObjectCreate", "BinaryXor", "RequireInternalSlot", "EvaluatePropertyAccessWithIdentifierKey", "SetFunctionName", "ContainsUndefinedBreakTarget", "ForBodyEvaluation", "IsPromise", "StringToBigInt", "InstantiateAsyncArrowFunctionExpression", "TimeClip", "GetV", "OrdinaryDefineOwnProperty", "StringGetOwnProperty", "AsyncGeneratorStart", "HasInitializer", "agent-order", "DeletePropertyOrThrow", "SetTypedArrayFromTypedArray", "GeneratorValidate", "AsyncFunctionStart", "IsStrict", "msPerSecond", "DefineMethod", "EvaluateAsyncFunctionBody", "OrdinarySetWithOwnDescriptor", "LocalTime", "PropName", "ValidateAtomicAccess", "ForDeclarationBindingInstantiation", "CharacterValue", "reads-bytes-from", "CanonicalNumericIndexString", "Contains", "IsWordChar", "HostMakeJobCallback", "NotifyWaiter", "MakeArgSetter", "RepeatMatcher", "CreateResolvingFunctions", "SymbolDescriptiveString", "SerializeJSONObject", "BackreferenceMatcher", "AssignmentTargetType", "CreateDynamicFunction", "Number::toString", "LabelledEvaluation", "InstantiateArrowFunctionExpression", "EvaluateConciseBody", "thisStringValue", "ToNumber", "SecFromTime", "SpecialMethod", "HasDirectSuper", "InitializeTypedArrayFromArrayLike", "ModuleNamespaceCreate", "PerformEval", "ArraySpeciesCreate", "FromPropertyDescriptor", "IsPropertyReference", "InstanceofOperator", "SuspendAgent", "IsConstructor", "TestIntegrityLevel", "EnumerateObjectProperties", "FinishDynamicImport", "EventSet", "reads-from", "AllocateTypedArrayBuffer", "CapturingGroupName", "ToObject", "IteratorBindingInitialization", "ValidateAndApplyPropertyDescriptor", "CopyDataProperties", "ObjectDefineProperties", "CoveredCallExpression", "Yield", "RejectPromise", "InitializeReferencedBinding", "AbstractRelationalComparison", "IsStringPrefix", "GetActiveScriptOrModule", "IsPropertyKey", "LexicallyScopedDeclarations", "LoopContinues", "UTF16EncodeCodePoint", "msPerDay", "BindingClassDeclarationEvaluation", "LengthOfArrayLike", "OrdinaryGetOwnProperty", "ContainsUndefinedContinueTarget", "MakeTime", "FlagText", "SpeciesConstructor", "FlattenIntoArray", "CreateIterResultObject", "IsGenericDescriptor", "ToNumeric", "MakeClassConstructor", "InstantiateOrdinaryFunctionObject", "IsLabelledFunction", "Completion", "NewModuleEnvironment", "SortCompare", "ApplyStringOrNumericBinaryOperator", "happens-before", "msFromTime", "InstantiateOrdinaryFunctionExpression", "ParsePattern", "IsUnsignedElementType", "ToPropertyKey", "IsExtensible", "CodePointsToString", "InstantiateAsyncFunctionObject", "GetWaiterList", "InnerModuleEvaluation", "MethodDefinitionEvaluation", "GeneratorYield", "NewDeclarativeEnvironment", "CreateIntrinsics", "AsyncGeneratorReject", "MakeSuperPropertyReference", "HostHasSourceTextAvailable", "SameValueNonNumeric", "HostEnqueuePromiseJob", "CloneArrayBuffer", "SourceText", "ArgumentListEvaluation", "NewPromiseResolveThenableJob", "PrepareForTailCall", "InitializeTypedArrayFromArrayBuffer", "CapturingGroupNumber", "CreateForInIterator", "TimeString", "NewFunctionEnvironment", "IteratorStep", "ToBigInt", "BoundFunctionCreate", "DateString", "UTF16SurrogatePairToCodePoint", "IfAbruptRejectPromise", "AddRestrictedFunctionProperties", "OrdinaryGetPrototypeOf", "CreateRealm", "HostEnsureCanCompileStrings", "ExportedNames", "FunctionBodyContainsUseStrict", "Get", "ToUint32", "CharacterSetMatcher", "CopyDataBlockBytes", "InstantiateFunctionObject", "CreateArrayIterator", "OrdinaryIsExtensible", "OrdinaryHasProperty", "HourFromTime", "ComposeWriteEventBytes", "IsDetachedBuffer", "ToBigInt64", "OrdinaryCallBindThis", "ScriptEvaluation", "IsSharedArrayBuffer", "NewGlobalEnvironment", "CreateByteDataBlock", "EvaluateAsyncGeneratorBody", "IsAccessorDescriptor", "GetOwnPropertyKeys", "NamedEvaluation", "AddEntriesFromIterable", "SameValue", "Canonicalize", "DayFromYear", "TopLevelLexicallyScopedDeclarations", "thisBigIntValue", "MonthFromTime", "HostEnqueueFinalizationRegistryCleanupJob", "NumericValue", "TypedArraySpeciesCreate", "ConstructorMethod", "OrdinaryHasInstance", "IsSuperReference", "BodyText", "StringIndexOf", "InstantiateAsyncFunctionExpression", "ArraySetLength", "ToString", "ByteListBitwiseOp", "CreateMappedArgumentsObject", "GetValueFromBuffer", "InitializeTypedArrayFromTypedArray", "ImportEntriesForModule", "OrdinaryCreateFromConstructor", "AllocateArrayBuffer", "PerformPromiseRace", "SetValueInBuffer", "AllocateTypedArray", "Decode", "CreateIteratorFromClosure", "GetIterator", "CreateSharedByteDataBlock", "SetIntegrityLevel", "ClearKeptObjects", "EvaluateCall", "OrdinaryDelete", "GetFunctionRealm", "ExportedBindings", "DayWithinYear", "ToDateString", "GetThisEnvironment", "ThrowCompletion", "GeneratorResume", "IntegerIndexedElementSet", "AsyncIteratorClose", "CaseClauseIsSelected", "HostPromiseRejectionTracker", "BigIntBitwiseOp", "IsComputedPropertyKey", "IsCompatiblePropertyDescriptor", "NonConstructorMethodDefinitions", "EvaluateGeneratorBody", "GetGeneratorKind", "IteratorNext", "IsValidRegularExpressionLiteral", "synchronizes-with", "EvaluateNew", "HostGetImportMetaProperties", "YearFromTime", "StringValue", "MakeDate", "ToInt16", "InstantiateAsyncGeneratorFunctionObject", "ImportedLocalNames", "InstantiateAsyncGeneratorFunctionExpression", "AbstractEqualityComparison", "HostFinalizeImportMeta", "SetFunctionLength", "DefinePropertyOrThrow", "Encode", "UnicodeMatchProperty", "EvaluatePropertyAccessWithExpressionKey", "StringPad", "NewPromiseReactionJob", "CleanupFinalizationRegistry", "MakeArgGetter", "SV", "SplitMatch", "OrdinarySet", "CreateMethodProperty", "msPerMinute", "SetImmutablePrototype", "PropertyDefinitionEvaluation", "MakeConstructor", "ForInOfLoopEvaluation", "ImportEntries", "thisNumberValue", "AsyncGeneratorEnqueue", "IsSimpleParameterList", "PropertyNameList", "AllocateSharedArrayBuffer", "IteratorValue", "AsyncGeneratorValidate", "ModuleRequests", "HostCallJobCallback", "OrdinaryOwnPropertyKeys", "CoveredParenthesizedExpression", "IsInTailPosition", "TrimString", "CreateSetIterator", "EvaluateBody", "IsArray", "GeneratorStart", "IsDestructuring", "CreateAsyncIteratorFromClosure", "ForLoopEvaluation", "OrdinaryFunctionCreate", "PrepareForOrdinaryCall", "PrototypePropertyNameList", "EnumerableOwnPropertyNames", "ContainsExpression", "VarScopedDeclarations", "NumberBitwiseOp", "CompletePropertyDescriptor", "EvaluateFunctionBody", "ToIntegerOrInfinity", "CreatePerIterationEnvironment", "Construct", "EvaluateStringOrNumericBinaryExpression", "ToUint16", "PropertyDestructuringAssignmentEvaluation", "InnerModuleLinking", "IsStatic"],
  "consts": ["linking", "BigUint64", "invalid", "SeqCst", "ConstructorMethod", "suspendedStart", "BigInt64", "iterate", "uninitialized", "awaitingDASHreturn", "NonConstructorMethod", "Uint16", "Float64", "Reject", "sync", "rejected", "base", "unresolvable", "evaluated", "continue", "fulfilled", "key", "Init", "throw", "completed", "nonDASHgenerator", "failure", "Number", "executing", "derived", "empty", "Uint8C", "asyncDASHiterate", "Int16", "lexicalDASHthis", "Int8", "evaluating", "varBinding", "strict", "Uint32", "return", "BigInt", "Fulfill", "suspendedYield", "keyPLUSvalue", "async", "sealed", "startPLUSend", "assignment", "Unordered", "initialized", "simple", "nonDASHlexicalDASHthis", "linked", "generator", "number", "start", "value", "enumerate", "Float32", "string", "asyncGenerator", "normal", "pending", "frozen", "end", "notDASHmatched", "unlinked", "lexical", "break", "Uint8", "symbol", "lexicalBinding", "global", "Int32"],
  "grammar": {
    "lexProds": [{
      "lhs": {
        "name": "StringNumericLiteral",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "StrWhiteSpace",
          "optional": true
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "StrWhiteSpace",
          "optional": true
        }, {
          "args": [],
          "name": "StrNumericLiteral",
          "optional": false
        }, {
          "args": [],
          "name": "StrWhiteSpace",
          "optional": true
        }]
      }]
    }, {
      "lhs": {
        "name": "StrWhiteSpace",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "StrWhiteSpaceChar",
          "optional": false
        }, {
          "args": [],
          "name": "StrWhiteSpace",
          "optional": true
        }]
      }]
    }, {
      "lhs": {
        "name": "StrWhiteSpaceChar",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "WhiteSpace",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "LineTerminator",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "StrNumericLiteral",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "StrDecimalLiteral",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["~Sep"],
          "name": "NonDecimalIntegerLiteral",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "StrDecimalLiteral",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "StrUnsignedDecimalLiteral",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "+"
        }, {
          "args": [],
          "name": "StrUnsignedDecimalLiteral",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "-"
        }, {
          "args": [],
          "name": "StrUnsignedDecimalLiteral",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "StrUnsignedDecimalLiteral",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "Infinity"
        }]
      }, {
        "tokens": [{
          "args": ["~Sep"],
          "name": "DecimalDigits",
          "optional": false
        }, {
          "term": "."
        }, {
          "args": ["~Sep"],
          "name": "DecimalDigits",
          "optional": true
        }, {
          "args": ["~Sep"],
          "name": "ExponentPart",
          "optional": true
        }]
      }, {
        "tokens": [{
          "term": "."
        }, {
          "args": ["~Sep"],
          "name": "DecimalDigits",
          "optional": false
        }, {
          "args": ["~Sep"],
          "name": "ExponentPart",
          "optional": true
        }]
      }, {
        "tokens": [{
          "args": ["~Sep"],
          "name": "DecimalDigits",
          "optional": false
        }, {
          "args": ["~Sep"],
          "name": "ExponentPart",
          "optional": true
        }]
      }]
    }, {
      "lhs": {
        "name": "SourceCharacter",
        "params": []
      },
      "rhsList": [{
        "tokens": ["UnicodeAny"]
      }]
    }, {
      "lhs": {
        "name": "InputElementDiv",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "WhiteSpace",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "LineTerminator",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "Comment",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "CommonToken",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "DivPunctuator",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "RightBracePunctuator",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "InputElementRegExp",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "WhiteSpace",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "LineTerminator",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "Comment",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "CommonToken",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "RightBracePunctuator",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "RegularExpressionLiteral",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "InputElementRegExpOrTemplateTail",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "WhiteSpace",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "LineTerminator",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "Comment",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "CommonToken",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "RegularExpressionLiteral",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "TemplateSubstitutionTail",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "InputElementTemplateTail",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "WhiteSpace",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "LineTerminator",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "Comment",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "CommonToken",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "DivPunctuator",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "TemplateSubstitutionTail",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "WhiteSpace",
        "params": []
      },
      "rhsList": [{
        "tokens": ["TAB"]
      }, {
        "tokens": ["VT"]
      }, {
        "tokens": ["FF"]
      }, {
        "tokens": ["SP"]
      }, {
        "tokens": ["NBSP"]
      }, {
        "tokens": ["ZWNBSP"]
      }, {
        "tokens": ["USP"]
      }]
    }, {
      "lhs": {
        "name": "LineTerminator",
        "params": []
      },
      "rhsList": [{
        "tokens": ["LF"]
      }, {
        "tokens": ["CR"]
      }, {
        "tokens": ["LS"]
      }, {
        "tokens": ["PS"]
      }]
    }, {
      "lhs": {
        "name": "LineTerminatorSequence",
        "params": []
      },
      "rhsList": [{
        "tokens": ["LF"]
      }, {
        "tokens": ["CR", {
          "cases": [["LF"]],
          "contains": false
        }]
      }, {
        "tokens": ["LS"]
      }, {
        "tokens": ["PS"]
      }, {
        "tokens": ["CR", "LF"]
      }]
    }, {
      "lhs": {
        "name": "Comment",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "MultiLineComment",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "SingleLineComment",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "MultiLineComment",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "/*"
        }, {
          "args": [],
          "name": "MultiLineCommentChars",
          "optional": true
        }, {
          "term": "*/"
        }]
      }]
    }, {
      "lhs": {
        "name": "MultiLineCommentChars",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "MultiLineNotAsteriskChar",
          "optional": false
        }, {
          "args": [],
          "name": "MultiLineCommentChars",
          "optional": true
        }]
      }, {
        "tokens": [{
          "term": "*"
        }, {
          "args": [],
          "name": "PostAsteriskCommentChars",
          "optional": true
        }]
      }]
    }, {
      "lhs": {
        "name": "PostAsteriskCommentChars",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "MultiLineNotForwardSlashOrAsteriskChar",
          "optional": false
        }, {
          "args": [],
          "name": "MultiLineCommentChars",
          "optional": true
        }]
      }, {
        "tokens": [{
          "term": "*"
        }, {
          "args": [],
          "name": "PostAsteriskCommentChars",
          "optional": true
        }]
      }]
    }, {
      "lhs": {
        "name": "MultiLineNotAsteriskChar",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "base": {
            "args": [],
            "name": "SourceCharacter",
            "optional": false
          },
          "cases": [{
            "term": "*"
          }]
        }]
      }]
    }, {
      "lhs": {
        "name": "MultiLineNotForwardSlashOrAsteriskChar",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "base": {
            "args": [],
            "name": "SourceCharacter",
            "optional": false
          },
          "cases": [{
            "term": "/"
          }, {
            "term": "*"
          }]
        }]
      }]
    }, {
      "lhs": {
        "name": "SingleLineComment",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "//"
        }, {
          "args": [],
          "name": "SingleLineCommentChars",
          "optional": true
        }]
      }]
    }, {
      "lhs": {
        "name": "SingleLineCommentChars",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "SingleLineCommentChar",
          "optional": false
        }, {
          "args": [],
          "name": "SingleLineCommentChars",
          "optional": true
        }]
      }]
    }, {
      "lhs": {
        "name": "SingleLineCommentChar",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "base": {
            "args": [],
            "name": "SourceCharacter",
            "optional": false
          },
          "cases": [{
            "args": [],
            "name": "LineTerminator",
            "optional": false
          }]
        }]
      }]
    }, {
      "lhs": {
        "name": "CommonToken",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "Punctuator",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "NumericLiteral",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "StringLiteral",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "Template",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "IdentifierName",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "IdentifierStart",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }, {
          "args": [],
          "name": "IdentifierPart",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "IdentifierStart",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "UnicodeIDStart",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "$"
        }]
      }, {
        "tokens": [{
          "term": "_"
        }]
      }, {
        "tokens": [{
          "term": "\\"
        }, {
          "args": [],
          "name": "UnicodeEscapeSequence",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "IdentifierPart",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "UnicodeIDContinue",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "$"
        }]
      }, {
        "tokens": [{
          "term": "\\"
        }, {
          "args": [],
          "name": "UnicodeEscapeSequence",
          "optional": false
        }]
      }, {
        "tokens": ["ZWNJ"]
      }, {
        "tokens": ["ZWJ"]
      }]
    }, {
      "lhs": {
        "name": "UnicodeIDStart",
        "params": []
      },
      "rhsList": [{
        "tokens": ["UnicodeIdStart"]
      }]
    }, {
      "lhs": {
        "name": "UnicodeIDContinue",
        "params": []
      },
      "rhsList": [{
        "tokens": ["UnicodeIdContinue"]
      }]
    }, {
      "lhs": {
        "name": "ReservedWord",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "await"
        }]
      }, {
        "tokens": [{
          "term": "break"
        }]
      }, {
        "tokens": [{
          "term": "case"
        }]
      }, {
        "tokens": [{
          "term": "catch"
        }]
      }, {
        "tokens": [{
          "term": "class"
        }]
      }, {
        "tokens": [{
          "term": "const"
        }]
      }, {
        "tokens": [{
          "term": "continue"
        }]
      }, {
        "tokens": [{
          "term": "debugger"
        }]
      }, {
        "tokens": [{
          "term": "default"
        }]
      }, {
        "tokens": [{
          "term": "delete"
        }]
      }, {
        "tokens": [{
          "term": "do"
        }]
      }, {
        "tokens": [{
          "term": "else"
        }]
      }, {
        "tokens": [{
          "term": "enum"
        }]
      }, {
        "tokens": [{
          "term": "export"
        }]
      }, {
        "tokens": [{
          "term": "extends"
        }]
      }, {
        "tokens": [{
          "term": "false"
        }]
      }, {
        "tokens": [{
          "term": "finally"
        }]
      }, {
        "tokens": [{
          "term": "for"
        }]
      }, {
        "tokens": [{
          "term": "function"
        }]
      }, {
        "tokens": [{
          "term": "if"
        }]
      }, {
        "tokens": [{
          "term": "import"
        }]
      }, {
        "tokens": [{
          "term": "in"
        }]
      }, {
        "tokens": [{
          "term": "instanceof"
        }]
      }, {
        "tokens": [{
          "term": "new"
        }]
      }, {
        "tokens": [{
          "term": "null"
        }]
      }, {
        "tokens": [{
          "term": "return"
        }]
      }, {
        "tokens": [{
          "term": "super"
        }]
      }, {
        "tokens": [{
          "term": "switch"
        }]
      }, {
        "tokens": [{
          "term": "this"
        }]
      }, {
        "tokens": [{
          "term": "throw"
        }]
      }, {
        "tokens": [{
          "term": "true"
        }]
      }, {
        "tokens": [{
          "term": "try"
        }]
      }, {
        "tokens": [{
          "term": "typeof"
        }]
      }, {
        "tokens": [{
          "term": "var"
        }]
      }, {
        "tokens": [{
          "term": "void"
        }]
      }, {
        "tokens": [{
          "term": "while"
        }]
      }, {
        "tokens": [{
          "term": "with"
        }]
      }, {
        "tokens": [{
          "term": "yield"
        }]
      }]
    }, {
      "lhs": {
        "name": "Punctuator",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "OptionalChainingPunctuator",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "OtherPunctuator",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "OptionalChainingPunctuator",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "?."
        }, {
          "cases": [[{
            "args": [],
            "name": "DecimalDigit",
            "optional": false
          }]],
          "contains": false
        }]
      }]
    }, {
      "lhs": {
        "name": "OtherPunctuator",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "{"
        }]
      }, {
        "tokens": [{
          "term": "("
        }]
      }, {
        "tokens": [{
          "term": ")"
        }]
      }, {
        "tokens": [{
          "term": "["
        }]
      }, {
        "tokens": [{
          "term": "]"
        }]
      }, {
        "tokens": [{
          "term": "."
        }]
      }, {
        "tokens": [{
          "term": "..."
        }]
      }, {
        "tokens": [{
          "term": ";"
        }]
      }, {
        "tokens": [{
          "term": ","
        }]
      }, {
        "tokens": [{
          "term": "<"
        }]
      }, {
        "tokens": [{
          "term": ">"
        }]
      }, {
        "tokens": [{
          "term": "<="
        }]
      }, {
        "tokens": [{
          "term": ">="
        }]
      }, {
        "tokens": [{
          "term": "=="
        }]
      }, {
        "tokens": [{
          "term": "!="
        }]
      }, {
        "tokens": [{
          "term": "==="
        }]
      }, {
        "tokens": [{
          "term": "!=="
        }]
      }, {
        "tokens": [{
          "term": "+"
        }]
      }, {
        "tokens": [{
          "term": "-"
        }]
      }, {
        "tokens": [{
          "term": "*"
        }]
      }, {
        "tokens": [{
          "term": "%"
        }]
      }, {
        "tokens": [{
          "term": "**"
        }]
      }, {
        "tokens": [{
          "term": "++"
        }]
      }, {
        "tokens": [{
          "term": "--"
        }]
      }, {
        "tokens": [{
          "term": "<<"
        }]
      }, {
        "tokens": [{
          "term": ">>"
        }]
      }, {
        "tokens": [{
          "term": ">>>"
        }]
      }, {
        "tokens": [{
          "term": "&"
        }]
      }, {
        "tokens": [{
          "term": "|"
        }]
      }, {
        "tokens": [{
          "term": "^"
        }]
      }, {
        "tokens": [{
          "term": "!"
        }]
      }, {
        "tokens": [{
          "term": "~"
        }]
      }, {
        "tokens": [{
          "term": "&&"
        }]
      }, {
        "tokens": [{
          "term": "||"
        }]
      }, {
        "tokens": [{
          "term": "??"
        }]
      }, {
        "tokens": [{
          "term": "?"
        }]
      }, {
        "tokens": [{
          "term": ":"
        }]
      }, {
        "tokens": [{
          "term": "="
        }]
      }, {
        "tokens": [{
          "term": "+="
        }]
      }, {
        "tokens": [{
          "term": "-="
        }]
      }, {
        "tokens": [{
          "term": "*="
        }]
      }, {
        "tokens": [{
          "term": "%="
        }]
      }, {
        "tokens": [{
          "term": "**="
        }]
      }, {
        "tokens": [{
          "term": "<<="
        }]
      }, {
        "tokens": [{
          "term": ">>="
        }]
      }, {
        "tokens": [{
          "term": ">>>="
        }]
      }, {
        "tokens": [{
          "term": "&="
        }]
      }, {
        "tokens": [{
          "term": "|="
        }]
      }, {
        "tokens": [{
          "term": "^="
        }]
      }, {
        "tokens": [{
          "term": "&&="
        }]
      }, {
        "tokens": [{
          "term": "||="
        }]
      }, {
        "tokens": [{
          "term": "??="
        }]
      }, {
        "tokens": [{
          "term": "=>"
        }]
      }]
    }, {
      "lhs": {
        "name": "DivPunctuator",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "/"
        }]
      }, {
        "tokens": [{
          "term": "/="
        }]
      }]
    }, {
      "lhs": {
        "name": "RightBracePunctuator",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "}"
        }]
      }]
    }, {
      "lhs": {
        "name": "NullLiteral",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "null"
        }]
      }]
    }, {
      "lhs": {
        "name": "BooleanLiteral",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "true"
        }]
      }, {
        "tokens": [{
          "term": "false"
        }]
      }]
    }, {
      "lhs": {
        "name": "NumericLiteralSeparator",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "_"
        }]
      }]
    }, {
      "lhs": {
        "name": "NumericLiteral",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "DecimalLiteral",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "DecimalBigIntegerLiteral",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["+Sep"],
          "name": "NonDecimalIntegerLiteral",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["+Sep"],
          "name": "NonDecimalIntegerLiteral",
          "optional": false
        }, {
          "args": [],
          "name": "BigIntLiteralSuffix",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "DecimalBigIntegerLiteral",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "0"
        }, {
          "args": [],
          "name": "BigIntLiteralSuffix",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "NonZeroDigit",
          "optional": false
        }, {
          "args": ["+Sep"],
          "name": "DecimalDigits",
          "optional": true
        }, {
          "args": [],
          "name": "BigIntLiteralSuffix",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "NonZeroDigit",
          "optional": false
        }, {
          "args": [],
          "name": "NumericLiteralSeparator",
          "optional": false
        }, {
          "args": ["+Sep"],
          "name": "DecimalDigits",
          "optional": false
        }, {
          "args": [],
          "name": "BigIntLiteralSuffix",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "NonDecimalIntegerLiteral",
        "params": ["Sep"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Sep"],
          "name": "BinaryIntegerLiteral",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Sep"],
          "name": "OctalIntegerLiteral",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Sep"],
          "name": "HexIntegerLiteral",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "BigIntLiteralSuffix",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "n"
        }]
      }]
    }, {
      "lhs": {
        "name": "DecimalLiteral",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "DecimalIntegerLiteral",
          "optional": false
        }, {
          "term": "."
        }, {
          "args": ["+Sep"],
          "name": "DecimalDigits",
          "optional": true
        }, {
          "args": ["+Sep"],
          "name": "ExponentPart",
          "optional": true
        }]
      }, {
        "tokens": [{
          "term": "."
        }, {
          "args": ["+Sep"],
          "name": "DecimalDigits",
          "optional": false
        }, {
          "args": ["+Sep"],
          "name": "ExponentPart",
          "optional": true
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "DecimalIntegerLiteral",
          "optional": false
        }, {
          "args": ["+Sep"],
          "name": "ExponentPart",
          "optional": true
        }]
      }]
    }, {
      "lhs": {
        "name": "DecimalIntegerLiteral",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "0"
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "NonZeroDigit",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "NonZeroDigit",
          "optional": false
        }, {
          "args": [],
          "name": "NumericLiteralSeparator",
          "optional": true
        }, {
          "args": ["+Sep"],
          "name": "DecimalDigits",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "DecimalDigits",
        "params": ["Sep"]
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "DecimalDigit",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Sep"],
          "name": "DecimalDigits",
          "optional": false
        }, {
          "args": [],
          "name": "DecimalDigit",
          "optional": false
        }]
      }, {
        "condOpt": {
          "name": "Sep",
          "pass": true
        },
        "tokens": [{
          "args": ["+Sep"],
          "name": "DecimalDigits",
          "optional": false
        }, {
          "args": [],
          "name": "NumericLiteralSeparator",
          "optional": false
        }, {
          "args": [],
          "name": "DecimalDigit",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "DecimalDigit",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "0"
        }]
      }, {
        "tokens": [{
          "term": "1"
        }]
      }, {
        "tokens": [{
          "term": "2"
        }]
      }, {
        "tokens": [{
          "term": "3"
        }]
      }, {
        "tokens": [{
          "term": "4"
        }]
      }, {
        "tokens": [{
          "term": "5"
        }]
      }, {
        "tokens": [{
          "term": "6"
        }]
      }, {
        "tokens": [{
          "term": "7"
        }]
      }, {
        "tokens": [{
          "term": "8"
        }]
      }, {
        "tokens": [{
          "term": "9"
        }]
      }]
    }, {
      "lhs": {
        "name": "NonZeroDigit",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "1"
        }]
      }, {
        "tokens": [{
          "term": "2"
        }]
      }, {
        "tokens": [{
          "term": "3"
        }]
      }, {
        "tokens": [{
          "term": "4"
        }]
      }, {
        "tokens": [{
          "term": "5"
        }]
      }, {
        "tokens": [{
          "term": "6"
        }]
      }, {
        "tokens": [{
          "term": "7"
        }]
      }, {
        "tokens": [{
          "term": "8"
        }]
      }, {
        "tokens": [{
          "term": "9"
        }]
      }]
    }, {
      "lhs": {
        "name": "ExponentPart",
        "params": ["Sep"]
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "ExponentIndicator",
          "optional": false
        }, {
          "args": ["?Sep"],
          "name": "SignedInteger",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ExponentIndicator",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "e"
        }]
      }, {
        "tokens": [{
          "term": "E"
        }]
      }]
    }, {
      "lhs": {
        "name": "SignedInteger",
        "params": ["Sep"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Sep"],
          "name": "DecimalDigits",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "+"
        }, {
          "args": ["?Sep"],
          "name": "DecimalDigits",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "-"
        }, {
          "args": ["?Sep"],
          "name": "DecimalDigits",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "BinaryIntegerLiteral",
        "params": ["Sep"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "0b"
        }, {
          "args": ["?Sep"],
          "name": "BinaryDigits",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "0B"
        }, {
          "args": ["?Sep"],
          "name": "BinaryDigits",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "BinaryDigits",
        "params": ["Sep"]
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "BinaryDigit",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Sep"],
          "name": "BinaryDigits",
          "optional": false
        }, {
          "args": [],
          "name": "BinaryDigit",
          "optional": false
        }]
      }, {
        "condOpt": {
          "name": "Sep",
          "pass": true
        },
        "tokens": [{
          "args": ["+Sep"],
          "name": "BinaryDigits",
          "optional": false
        }, {
          "args": [],
          "name": "NumericLiteralSeparator",
          "optional": false
        }, {
          "args": [],
          "name": "BinaryDigit",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "BinaryDigit",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "0"
        }]
      }, {
        "tokens": [{
          "term": "1"
        }]
      }]
    }, {
      "lhs": {
        "name": "OctalIntegerLiteral",
        "params": ["Sep"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "0o"
        }, {
          "args": ["?Sep"],
          "name": "OctalDigits",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "0O"
        }, {
          "args": ["?Sep"],
          "name": "OctalDigits",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "OctalDigits",
        "params": ["Sep"]
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "OctalDigit",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Sep"],
          "name": "OctalDigits",
          "optional": false
        }, {
          "args": [],
          "name": "OctalDigit",
          "optional": false
        }]
      }, {
        "condOpt": {
          "name": "Sep",
          "pass": true
        },
        "tokens": [{
          "args": ["+Sep"],
          "name": "OctalDigits",
          "optional": false
        }, {
          "args": [],
          "name": "NumericLiteralSeparator",
          "optional": false
        }, {
          "args": [],
          "name": "OctalDigit",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "OctalDigit",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "0"
        }]
      }, {
        "tokens": [{
          "term": "1"
        }]
      }, {
        "tokens": [{
          "term": "2"
        }]
      }, {
        "tokens": [{
          "term": "3"
        }]
      }, {
        "tokens": [{
          "term": "4"
        }]
      }, {
        "tokens": [{
          "term": "5"
        }]
      }, {
        "tokens": [{
          "term": "6"
        }]
      }, {
        "tokens": [{
          "term": "7"
        }]
      }]
    }, {
      "lhs": {
        "name": "HexIntegerLiteral",
        "params": ["Sep"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "0x"
        }, {
          "args": ["?Sep"],
          "name": "HexDigits",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "0X"
        }, {
          "args": ["?Sep"],
          "name": "HexDigits",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "HexDigits",
        "params": ["Sep"]
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "HexDigit",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Sep"],
          "name": "HexDigits",
          "optional": false
        }, {
          "args": [],
          "name": "HexDigit",
          "optional": false
        }]
      }, {
        "condOpt": {
          "name": "Sep",
          "pass": true
        },
        "tokens": [{
          "args": ["+Sep"],
          "name": "HexDigits",
          "optional": false
        }, {
          "args": [],
          "name": "NumericLiteralSeparator",
          "optional": false
        }, {
          "args": [],
          "name": "HexDigit",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "HexDigit",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "0"
        }]
      }, {
        "tokens": [{
          "term": "1"
        }]
      }, {
        "tokens": [{
          "term": "2"
        }]
      }, {
        "tokens": [{
          "term": "3"
        }]
      }, {
        "tokens": [{
          "term": "4"
        }]
      }, {
        "tokens": [{
          "term": "5"
        }]
      }, {
        "tokens": [{
          "term": "6"
        }]
      }, {
        "tokens": [{
          "term": "7"
        }]
      }, {
        "tokens": [{
          "term": "8"
        }]
      }, {
        "tokens": [{
          "term": "9"
        }]
      }, {
        "tokens": [{
          "term": "a"
        }]
      }, {
        "tokens": [{
          "term": "b"
        }]
      }, {
        "tokens": [{
          "term": "c"
        }]
      }, {
        "tokens": [{
          "term": "d"
        }]
      }, {
        "tokens": [{
          "term": "e"
        }]
      }, {
        "tokens": [{
          "term": "f"
        }]
      }, {
        "tokens": [{
          "term": "A"
        }]
      }, {
        "tokens": [{
          "term": "B"
        }]
      }, {
        "tokens": [{
          "term": "C"
        }]
      }, {
        "tokens": [{
          "term": "D"
        }]
      }, {
        "tokens": [{
          "term": "E"
        }]
      }, {
        "tokens": [{
          "term": "F"
        }]
      }]
    }, {
      "lhs": {
        "name": "StringLiteral",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "\""
        }, {
          "args": [],
          "name": "DoubleStringCharacters",
          "optional": true
        }, {
          "term": "\""
        }]
      }, {
        "tokens": [{
          "term": "'"
        }, {
          "args": [],
          "name": "SingleStringCharacters",
          "optional": true
        }, {
          "term": "'"
        }]
      }]
    }, {
      "lhs": {
        "name": "DoubleStringCharacters",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "DoubleStringCharacter",
          "optional": false
        }, {
          "args": [],
          "name": "DoubleStringCharacters",
          "optional": true
        }]
      }]
    }, {
      "lhs": {
        "name": "SingleStringCharacters",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "SingleStringCharacter",
          "optional": false
        }, {
          "args": [],
          "name": "SingleStringCharacters",
          "optional": true
        }]
      }]
    }, {
      "lhs": {
        "name": "DoubleStringCharacter",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "base": {
            "args": [],
            "name": "SourceCharacter",
            "optional": false
          },
          "cases": [{
            "term": "\""
          }, {
            "term": "\\"
          }, {
            "args": [],
            "name": "LineTerminator",
            "optional": false
          }]
        }]
      }, {
        "tokens": ["LS"]
      }, {
        "tokens": ["PS"]
      }, {
        "tokens": [{
          "term": "\\"
        }, {
          "args": [],
          "name": "EscapeSequence",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "LineContinuation",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "SingleStringCharacter",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "base": {
            "args": [],
            "name": "SourceCharacter",
            "optional": false
          },
          "cases": [{
            "term": "'"
          }, {
            "term": "\\"
          }, {
            "args": [],
            "name": "LineTerminator",
            "optional": false
          }]
        }]
      }, {
        "tokens": ["LS"]
      }, {
        "tokens": ["PS"]
      }, {
        "tokens": [{
          "term": "\\"
        }, {
          "args": [],
          "name": "EscapeSequence",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "LineContinuation",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "LineContinuation",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "\\"
        }, {
          "args": [],
          "name": "LineTerminatorSequence",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "EscapeSequence",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "CharacterEscapeSequence",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "0"
        }, {
          "cases": [[{
            "args": [],
            "name": "DecimalDigit",
            "optional": false
          }]],
          "contains": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "HexEscapeSequence",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "UnicodeEscapeSequence",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "CharacterEscapeSequence",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "SingleEscapeCharacter",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "NonEscapeCharacter",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "SingleEscapeCharacter",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "'"
        }]
      }, {
        "tokens": [{
          "term": "\""
        }]
      }, {
        "tokens": [{
          "term": "\\"
        }]
      }, {
        "tokens": [{
          "term": "b"
        }]
      }, {
        "tokens": [{
          "term": "f"
        }]
      }, {
        "tokens": [{
          "term": "n"
        }]
      }, {
        "tokens": [{
          "term": "r"
        }]
      }, {
        "tokens": [{
          "term": "t"
        }]
      }, {
        "tokens": [{
          "term": "v"
        }]
      }]
    }, {
      "lhs": {
        "name": "NonEscapeCharacter",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "base": {
            "args": [],
            "name": "SourceCharacter",
            "optional": false
          },
          "cases": [{
            "args": [],
            "name": "EscapeCharacter",
            "optional": false
          }, {
            "args": [],
            "name": "LineTerminator",
            "optional": false
          }]
        }]
      }]
    }, {
      "lhs": {
        "name": "EscapeCharacter",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "SingleEscapeCharacter",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "DecimalDigit",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "x"
        }]
      }, {
        "tokens": [{
          "term": "u"
        }]
      }]
    }, {
      "lhs": {
        "name": "HexEscapeSequence",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "x"
        }, {
          "args": [],
          "name": "HexDigit",
          "optional": false
        }, {
          "args": [],
          "name": "HexDigit",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "UnicodeEscapeSequence",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "u"
        }, {
          "args": [],
          "name": "Hex4Digits",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "u{"
        }, {
          "args": [],
          "name": "CodePoint",
          "optional": false
        }, {
          "term": "}"
        }]
      }]
    }, {
      "lhs": {
        "name": "Hex4Digits",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "HexDigit",
          "optional": false
        }, {
          "args": [],
          "name": "HexDigit",
          "optional": false
        }, {
          "args": [],
          "name": "HexDigit",
          "optional": false
        }, {
          "args": [],
          "name": "HexDigit",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "RegularExpressionLiteral",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "/"
        }, {
          "args": [],
          "name": "RegularExpressionBody",
          "optional": false
        }, {
          "term": "/"
        }, {
          "args": [],
          "name": "RegularExpressionFlags",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "RegularExpressionBody",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "RegularExpressionFirstChar",
          "optional": false
        }, {
          "args": [],
          "name": "RegularExpressionChars",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "RegularExpressionChars",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "empty": null
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "RegularExpressionChars",
          "optional": false
        }, {
          "args": [],
          "name": "RegularExpressionChar",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "RegularExpressionFirstChar",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "base": {
            "args": [],
            "name": "RegularExpressionNonTerminator",
            "optional": false
          },
          "cases": [{
            "term": "*"
          }, {
            "term": "\\"
          }, {
            "term": "/"
          }, {
            "term": "["
          }]
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "RegularExpressionBackslashSequence",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "RegularExpressionClass",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "RegularExpressionChar",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "base": {
            "args": [],
            "name": "RegularExpressionNonTerminator",
            "optional": false
          },
          "cases": [{
            "term": "\\"
          }, {
            "term": "/"
          }, {
            "term": "["
          }]
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "RegularExpressionBackslashSequence",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "RegularExpressionClass",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "RegularExpressionBackslashSequence",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "\\"
        }, {
          "args": [],
          "name": "RegularExpressionNonTerminator",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "RegularExpressionNonTerminator",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "base": {
            "args": [],
            "name": "SourceCharacter",
            "optional": false
          },
          "cases": [{
            "args": [],
            "name": "LineTerminator",
            "optional": false
          }]
        }]
      }]
    }, {
      "lhs": {
        "name": "RegularExpressionClass",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "["
        }, {
          "args": [],
          "name": "RegularExpressionClassChars",
          "optional": false
        }, {
          "term": "]"
        }]
      }]
    }, {
      "lhs": {
        "name": "RegularExpressionClassChars",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "empty": null
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "RegularExpressionClassChars",
          "optional": false
        }, {
          "args": [],
          "name": "RegularExpressionClassChar",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "RegularExpressionClassChar",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "base": {
            "args": [],
            "name": "RegularExpressionNonTerminator",
            "optional": false
          },
          "cases": [{
            "term": "]"
          }, {
            "term": "\\"
          }]
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "RegularExpressionBackslashSequence",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "RegularExpressionFlags",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "empty": null
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "RegularExpressionFlags",
          "optional": false
        }, {
          "args": [],
          "name": "IdentifierPart",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "Template",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "NoSubstitutionTemplate",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "TemplateHead",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "NoSubstitutionTemplate",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "`"
        }, {
          "args": [],
          "name": "TemplateCharacters",
          "optional": true
        }, {
          "term": "`"
        }]
      }]
    }, {
      "lhs": {
        "name": "TemplateHead",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "`"
        }, {
          "args": [],
          "name": "TemplateCharacters",
          "optional": true
        }, {
          "term": "${"
        }]
      }]
    }, {
      "lhs": {
        "name": "TemplateSubstitutionTail",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "TemplateMiddle",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "TemplateTail",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "TemplateMiddle",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "}"
        }, {
          "args": [],
          "name": "TemplateCharacters",
          "optional": true
        }, {
          "term": "${"
        }]
      }]
    }, {
      "lhs": {
        "name": "TemplateTail",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "}"
        }, {
          "args": [],
          "name": "TemplateCharacters",
          "optional": true
        }, {
          "term": "`"
        }]
      }]
    }, {
      "lhs": {
        "name": "TemplateCharacters",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "TemplateCharacter",
          "optional": false
        }, {
          "args": [],
          "name": "TemplateCharacters",
          "optional": true
        }]
      }]
    }, {
      "lhs": {
        "name": "TemplateCharacter",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "$"
        }, {
          "cases": [[{
            "term": "{"
          }]],
          "contains": false
        }]
      }, {
        "tokens": [{
          "term": "\\"
        }, {
          "args": [],
          "name": "EscapeSequence",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "\\"
        }, {
          "args": [],
          "name": "NotEscapeSequence",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "LineContinuation",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "LineTerminatorSequence",
          "optional": false
        }]
      }, {
        "tokens": [{
          "base": {
            "args": [],
            "name": "SourceCharacter",
            "optional": false
          },
          "cases": [{
            "term": "`"
          }, {
            "term": "\\"
          }, {
            "term": "$"
          }, {
            "args": [],
            "name": "LineTerminator",
            "optional": false
          }]
        }]
      }]
    }, {
      "lhs": {
        "name": "NotEscapeSequence",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "0"
        }, {
          "args": [],
          "name": "DecimalDigit",
          "optional": false
        }]
      }, {
        "tokens": [{
          "base": {
            "args": [],
            "name": "DecimalDigit",
            "optional": false
          },
          "cases": [{
            "term": "0"
          }]
        }]
      }, {
        "tokens": [{
          "term": "x"
        }, {
          "cases": [[{
            "args": [],
            "name": "HexDigit",
            "optional": false
          }]],
          "contains": false
        }]
      }, {
        "tokens": [{
          "term": "x"
        }, {
          "args": [],
          "name": "HexDigit",
          "optional": false
        }, {
          "cases": [[{
            "args": [],
            "name": "HexDigit",
            "optional": false
          }]],
          "contains": false
        }]
      }, {
        "tokens": [{
          "term": "u"
        }, {
          "cases": [[{
            "args": [],
            "name": "HexDigit",
            "optional": false
          }]],
          "contains": false
        }, {
          "cases": [[{
            "term": "{"
          }]],
          "contains": false
        }]
      }, {
        "tokens": [{
          "term": "u"
        }, {
          "args": [],
          "name": "HexDigit",
          "optional": false
        }, {
          "cases": [[{
            "args": [],
            "name": "HexDigit",
            "optional": false
          }]],
          "contains": false
        }]
      }, {
        "tokens": [{
          "term": "u"
        }, {
          "args": [],
          "name": "HexDigit",
          "optional": false
        }, {
          "args": [],
          "name": "HexDigit",
          "optional": false
        }, {
          "cases": [[{
            "args": [],
            "name": "HexDigit",
            "optional": false
          }]],
          "contains": false
        }]
      }, {
        "tokens": [{
          "term": "u"
        }, {
          "args": [],
          "name": "HexDigit",
          "optional": false
        }, {
          "args": [],
          "name": "HexDigit",
          "optional": false
        }, {
          "args": [],
          "name": "HexDigit",
          "optional": false
        }, {
          "cases": [[{
            "args": [],
            "name": "HexDigit",
            "optional": false
          }]],
          "contains": false
        }]
      }, {
        "tokens": [{
          "term": "u"
        }, {
          "term": "{"
        }, {
          "cases": [[{
            "args": [],
            "name": "HexDigit",
            "optional": false
          }]],
          "contains": false
        }]
      }, {
        "tokens": [{
          "term": "u"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "NotCodePoint",
          "optional": false
        }, {
          "cases": [[{
            "args": [],
            "name": "HexDigit",
            "optional": false
          }]],
          "contains": false
        }]
      }, {
        "tokens": [{
          "term": "u"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "CodePoint",
          "optional": false
        }, {
          "cases": [[{
            "args": [],
            "name": "HexDigit",
            "optional": false
          }]],
          "contains": false
        }, {
          "cases": [[{
            "term": "}"
          }]],
          "contains": false
        }]
      }]
    }, {
      "lhs": {
        "name": "NotCodePoint",
        "params": []
      },
      "rhsList": [{
        "tokens": ["NotCodePoint"]
      }]
    }, {
      "lhs": {
        "name": "CodePoint",
        "params": []
      },
      "rhsList": [{
        "tokens": ["CodePoint"]
      }]
    }, {
      "lhs": {
        "name": "uri",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "uriCharacters",
          "optional": true
        }]
      }]
    }, {
      "lhs": {
        "name": "uriCharacters",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "uriCharacter",
          "optional": false
        }, {
          "args": [],
          "name": "uriCharacters",
          "optional": true
        }]
      }]
    }, {
      "lhs": {
        "name": "uriCharacter",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "uriReserved",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "uriUnescaped",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "uriEscaped",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "uriReserved",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": ";"
        }]
      }, {
        "tokens": [{
          "term": "/"
        }]
      }, {
        "tokens": [{
          "term": "?"
        }]
      }, {
        "tokens": [{
          "term": ":"
        }]
      }, {
        "tokens": [{
          "term": "@"
        }]
      }, {
        "tokens": [{
          "term": "&"
        }]
      }, {
        "tokens": [{
          "term": "="
        }]
      }, {
        "tokens": [{
          "term": "+"
        }]
      }, {
        "tokens": [{
          "term": "$"
        }]
      }, {
        "tokens": [{
          "term": ","
        }]
      }]
    }, {
      "lhs": {
        "name": "uriUnescaped",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "uriAlpha",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "DecimalDigit",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "uriMark",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "uriEscaped",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "%"
        }, {
          "args": [],
          "name": "HexDigit",
          "optional": false
        }, {
          "args": [],
          "name": "HexDigit",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "uriAlpha",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "a"
        }]
      }, {
        "tokens": [{
          "term": "b"
        }]
      }, {
        "tokens": [{
          "term": "c"
        }]
      }, {
        "tokens": [{
          "term": "d"
        }]
      }, {
        "tokens": [{
          "term": "e"
        }]
      }, {
        "tokens": [{
          "term": "f"
        }]
      }, {
        "tokens": [{
          "term": "g"
        }]
      }, {
        "tokens": [{
          "term": "h"
        }]
      }, {
        "tokens": [{
          "term": "i"
        }]
      }, {
        "tokens": [{
          "term": "j"
        }]
      }, {
        "tokens": [{
          "term": "k"
        }]
      }, {
        "tokens": [{
          "term": "l"
        }]
      }, {
        "tokens": [{
          "term": "m"
        }]
      }, {
        "tokens": [{
          "term": "n"
        }]
      }, {
        "tokens": [{
          "term": "o"
        }]
      }, {
        "tokens": [{
          "term": "p"
        }]
      }, {
        "tokens": [{
          "term": "q"
        }]
      }, {
        "tokens": [{
          "term": "r"
        }]
      }, {
        "tokens": [{
          "term": "s"
        }]
      }, {
        "tokens": [{
          "term": "t"
        }]
      }, {
        "tokens": [{
          "term": "u"
        }]
      }, {
        "tokens": [{
          "term": "v"
        }]
      }, {
        "tokens": [{
          "term": "w"
        }]
      }, {
        "tokens": [{
          "term": "x"
        }]
      }, {
        "tokens": [{
          "term": "y"
        }]
      }, {
        "tokens": [{
          "term": "z"
        }]
      }, {
        "tokens": [{
          "term": "A"
        }]
      }, {
        "tokens": [{
          "term": "B"
        }]
      }, {
        "tokens": [{
          "term": "C"
        }]
      }, {
        "tokens": [{
          "term": "D"
        }]
      }, {
        "tokens": [{
          "term": "E"
        }]
      }, {
        "tokens": [{
          "term": "F"
        }]
      }, {
        "tokens": [{
          "term": "G"
        }]
      }, {
        "tokens": [{
          "term": "H"
        }]
      }, {
        "tokens": [{
          "term": "I"
        }]
      }, {
        "tokens": [{
          "term": "J"
        }]
      }, {
        "tokens": [{
          "term": "K"
        }]
      }, {
        "tokens": [{
          "term": "L"
        }]
      }, {
        "tokens": [{
          "term": "M"
        }]
      }, {
        "tokens": [{
          "term": "N"
        }]
      }, {
        "tokens": [{
          "term": "O"
        }]
      }, {
        "tokens": [{
          "term": "P"
        }]
      }, {
        "tokens": [{
          "term": "Q"
        }]
      }, {
        "tokens": [{
          "term": "R"
        }]
      }, {
        "tokens": [{
          "term": "S"
        }]
      }, {
        "tokens": [{
          "term": "T"
        }]
      }, {
        "tokens": [{
          "term": "U"
        }]
      }, {
        "tokens": [{
          "term": "V"
        }]
      }, {
        "tokens": [{
          "term": "W"
        }]
      }, {
        "tokens": [{
          "term": "X"
        }]
      }, {
        "tokens": [{
          "term": "Y"
        }]
      }, {
        "tokens": [{
          "term": "Z"
        }]
      }]
    }, {
      "lhs": {
        "name": "uriMark",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "-"
        }]
      }, {
        "tokens": [{
          "term": "_"
        }]
      }, {
        "tokens": [{
          "term": "."
        }]
      }, {
        "tokens": [{
          "term": "!"
        }]
      }, {
        "tokens": [{
          "term": "~"
        }]
      }, {
        "tokens": [{
          "term": "*"
        }]
      }, {
        "tokens": [{
          "term": "'"
        }]
      }, {
        "tokens": [{
          "term": "("
        }]
      }, {
        "tokens": [{
          "term": ")"
        }]
      }]
    }, {
      "lhs": {
        "name": "Pattern",
        "params": ["U", "N"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?U", "?N"],
          "name": "Disjunction",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "Disjunction",
        "params": ["U", "N"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?U", "?N"],
          "name": "Alternative",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?U", "?N"],
          "name": "Alternative",
          "optional": false
        }, {
          "term": "|"
        }, {
          "args": ["?U", "?N"],
          "name": "Disjunction",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "Alternative",
        "params": ["U", "N"]
      },
      "rhsList": [{
        "tokens": [{
          "empty": null
        }]
      }, {
        "tokens": [{
          "args": ["?U", "?N"],
          "name": "Alternative",
          "optional": false
        }, {
          "args": ["?U", "?N"],
          "name": "Term",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "Term",
        "params": ["U", "N"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?U", "?N"],
          "name": "Assertion",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?U", "?N"],
          "name": "Atom",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?U", "?N"],
          "name": "Atom",
          "optional": false
        }, {
          "args": [],
          "name": "Quantifier",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "Assertion",
        "params": ["U", "N"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "^"
        }]
      }, {
        "tokens": [{
          "term": "$"
        }]
      }, {
        "tokens": [{
          "term": "\\"
        }, {
          "term": "b"
        }]
      }, {
        "tokens": [{
          "term": "\\"
        }, {
          "term": "B"
        }]
      }, {
        "tokens": [{
          "term": "("
        }, {
          "term": "?"
        }, {
          "term": "="
        }, {
          "args": ["?U", "?N"],
          "name": "Disjunction",
          "optional": false
        }, {
          "term": ")"
        }]
      }, {
        "tokens": [{
          "term": "("
        }, {
          "term": "?"
        }, {
          "term": "!"
        }, {
          "args": ["?U", "?N"],
          "name": "Disjunction",
          "optional": false
        }, {
          "term": ")"
        }]
      }, {
        "tokens": [{
          "term": "("
        }, {
          "term": "?"
        }, {
          "term": "<="
        }, {
          "args": ["?U", "?N"],
          "name": "Disjunction",
          "optional": false
        }, {
          "term": ")"
        }]
      }, {
        "tokens": [{
          "term": "("
        }, {
          "term": "?"
        }, {
          "term": "<!"
        }, {
          "args": ["?U", "?N"],
          "name": "Disjunction",
          "optional": false
        }, {
          "term": ")"
        }]
      }]
    }, {
      "lhs": {
        "name": "Quantifier",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "QuantifierPrefix",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "QuantifierPrefix",
          "optional": false
        }, {
          "term": "?"
        }]
      }]
    }, {
      "lhs": {
        "name": "QuantifierPrefix",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "*"
        }]
      }, {
        "tokens": [{
          "term": "+"
        }]
      }, {
        "tokens": [{
          "term": "?"
        }]
      }, {
        "tokens": [{
          "term": "{"
        }, {
          "args": ["~Sep"],
          "name": "DecimalDigits",
          "optional": false
        }, {
          "term": "}"
        }]
      }, {
        "tokens": [{
          "term": "{"
        }, {
          "args": ["~Sep"],
          "name": "DecimalDigits",
          "optional": false
        }, {
          "term": ","
        }, {
          "term": "}"
        }]
      }, {
        "tokens": [{
          "term": "{"
        }, {
          "args": ["~Sep"],
          "name": "DecimalDigits",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": ["~Sep"],
          "name": "DecimalDigits",
          "optional": false
        }, {
          "term": "}"
        }]
      }]
    }, {
      "lhs": {
        "name": "Atom",
        "params": ["U", "N"]
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "PatternCharacter",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "."
        }]
      }, {
        "tokens": [{
          "term": "\\"
        }, {
          "args": ["?U", "?N"],
          "name": "AtomEscape",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?U"],
          "name": "CharacterClass",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "("
        }, {
          "args": ["?U"],
          "name": "GroupSpecifier",
          "optional": false
        }, {
          "args": ["?U", "?N"],
          "name": "Disjunction",
          "optional": false
        }, {
          "term": ")"
        }]
      }, {
        "tokens": [{
          "term": "("
        }, {
          "term": "?"
        }, {
          "term": ":"
        }, {
          "args": ["?U", "?N"],
          "name": "Disjunction",
          "optional": false
        }, {
          "term": ")"
        }]
      }]
    }, {
      "lhs": {
        "name": "SyntaxCharacter",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "^"
        }]
      }, {
        "tokens": [{
          "term": "$"
        }]
      }, {
        "tokens": [{
          "term": "\\"
        }]
      }, {
        "tokens": [{
          "term": "."
        }]
      }, {
        "tokens": [{
          "term": "*"
        }]
      }, {
        "tokens": [{
          "term": "+"
        }]
      }, {
        "tokens": [{
          "term": "?"
        }]
      }, {
        "tokens": [{
          "term": "("
        }]
      }, {
        "tokens": [{
          "term": ")"
        }]
      }, {
        "tokens": [{
          "term": "["
        }]
      }, {
        "tokens": [{
          "term": "]"
        }]
      }, {
        "tokens": [{
          "term": "{"
        }]
      }, {
        "tokens": [{
          "term": "}"
        }]
      }, {
        "tokens": [{
          "term": "|"
        }]
      }]
    }, {
      "lhs": {
        "name": "PatternCharacter",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "base": {
            "args": [],
            "name": "SourceCharacter",
            "optional": false
          },
          "cases": [{
            "args": [],
            "name": "SyntaxCharacter",
            "optional": false
          }]
        }]
      }]
    }, {
      "lhs": {
        "name": "AtomEscape",
        "params": ["U", "N"]
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "DecimalEscape",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?U"],
          "name": "CharacterClassEscape",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?U"],
          "name": "CharacterEscape",
          "optional": false
        }]
      }, {
        "condOpt": {
          "name": "N",
          "pass": true
        },
        "tokens": [{
          "term": "k"
        }, {
          "args": ["?U"],
          "name": "GroupName",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "CharacterEscape",
        "params": ["U"]
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "ControlEscape",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "c"
        }, {
          "args": [],
          "name": "ControlLetter",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "0"
        }, {
          "cases": [[{
            "args": [],
            "name": "DecimalDigit",
            "optional": false
          }]],
          "contains": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "HexEscapeSequence",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?U"],
          "name": "RegExpUnicodeEscapeSequence",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?U"],
          "name": "IdentityEscape",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ControlEscape",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "f"
        }]
      }, {
        "tokens": [{
          "term": "n"
        }]
      }, {
        "tokens": [{
          "term": "r"
        }]
      }, {
        "tokens": [{
          "term": "t"
        }]
      }, {
        "tokens": [{
          "term": "v"
        }]
      }]
    }, {
      "lhs": {
        "name": "ControlLetter",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "a"
        }]
      }, {
        "tokens": [{
          "term": "b"
        }]
      }, {
        "tokens": [{
          "term": "c"
        }]
      }, {
        "tokens": [{
          "term": "d"
        }]
      }, {
        "tokens": [{
          "term": "e"
        }]
      }, {
        "tokens": [{
          "term": "f"
        }]
      }, {
        "tokens": [{
          "term": "g"
        }]
      }, {
        "tokens": [{
          "term": "h"
        }]
      }, {
        "tokens": [{
          "term": "i"
        }]
      }, {
        "tokens": [{
          "term": "j"
        }]
      }, {
        "tokens": [{
          "term": "k"
        }]
      }, {
        "tokens": [{
          "term": "l"
        }]
      }, {
        "tokens": [{
          "term": "m"
        }]
      }, {
        "tokens": [{
          "term": "n"
        }]
      }, {
        "tokens": [{
          "term": "o"
        }]
      }, {
        "tokens": [{
          "term": "p"
        }]
      }, {
        "tokens": [{
          "term": "q"
        }]
      }, {
        "tokens": [{
          "term": "r"
        }]
      }, {
        "tokens": [{
          "term": "s"
        }]
      }, {
        "tokens": [{
          "term": "t"
        }]
      }, {
        "tokens": [{
          "term": "u"
        }]
      }, {
        "tokens": [{
          "term": "v"
        }]
      }, {
        "tokens": [{
          "term": "w"
        }]
      }, {
        "tokens": [{
          "term": "x"
        }]
      }, {
        "tokens": [{
          "term": "y"
        }]
      }, {
        "tokens": [{
          "term": "z"
        }]
      }, {
        "tokens": [{
          "term": "A"
        }]
      }, {
        "tokens": [{
          "term": "B"
        }]
      }, {
        "tokens": [{
          "term": "C"
        }]
      }, {
        "tokens": [{
          "term": "D"
        }]
      }, {
        "tokens": [{
          "term": "E"
        }]
      }, {
        "tokens": [{
          "term": "F"
        }]
      }, {
        "tokens": [{
          "term": "G"
        }]
      }, {
        "tokens": [{
          "term": "H"
        }]
      }, {
        "tokens": [{
          "term": "I"
        }]
      }, {
        "tokens": [{
          "term": "J"
        }]
      }, {
        "tokens": [{
          "term": "K"
        }]
      }, {
        "tokens": [{
          "term": "L"
        }]
      }, {
        "tokens": [{
          "term": "M"
        }]
      }, {
        "tokens": [{
          "term": "N"
        }]
      }, {
        "tokens": [{
          "term": "O"
        }]
      }, {
        "tokens": [{
          "term": "P"
        }]
      }, {
        "tokens": [{
          "term": "Q"
        }]
      }, {
        "tokens": [{
          "term": "R"
        }]
      }, {
        "tokens": [{
          "term": "S"
        }]
      }, {
        "tokens": [{
          "term": "T"
        }]
      }, {
        "tokens": [{
          "term": "U"
        }]
      }, {
        "tokens": [{
          "term": "V"
        }]
      }, {
        "tokens": [{
          "term": "W"
        }]
      }, {
        "tokens": [{
          "term": "X"
        }]
      }, {
        "tokens": [{
          "term": "Y"
        }]
      }, {
        "tokens": [{
          "term": "Z"
        }]
      }]
    }, {
      "lhs": {
        "name": "GroupSpecifier",
        "params": ["U"]
      },
      "rhsList": [{
        "tokens": [{
          "empty": null
        }]
      }, {
        "tokens": [{
          "term": "?"
        }, {
          "args": ["?U"],
          "name": "GroupName",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "GroupName",
        "params": ["U"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "<"
        }, {
          "args": ["?U"],
          "name": "RegExpIdentifierName",
          "optional": false
        }, {
          "term": ">"
        }]
      }]
    }, {
      "lhs": {
        "name": "RegExpIdentifierName",
        "params": ["U"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?U"],
          "name": "RegExpIdentifierStart",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?U"],
          "name": "RegExpIdentifierName",
          "optional": false
        }, {
          "args": ["?U"],
          "name": "RegExpIdentifierPart",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "RegExpIdentifierStart",
        "params": ["U"]
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "UnicodeIDStart",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "$"
        }]
      }, {
        "tokens": [{
          "term": "_"
        }]
      }, {
        "tokens": [{
          "term": "\\"
        }, {
          "args": ["+U"],
          "name": "RegExpUnicodeEscapeSequence",
          "optional": false
        }]
      }, {
        "condOpt": {
          "name": "U",
          "pass": false
        },
        "tokens": [{
          "args": [],
          "name": "UnicodeLeadSurrogate",
          "optional": false
        }, {
          "args": [],
          "name": "UnicodeTrailSurrogate",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "RegExpIdentifierPart",
        "params": ["U"]
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "UnicodeIDContinue",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "$"
        }]
      }, {
        "tokens": [{
          "term": "\\"
        }, {
          "args": ["+U"],
          "name": "RegExpUnicodeEscapeSequence",
          "optional": false
        }]
      }, {
        "condOpt": {
          "name": "U",
          "pass": false
        },
        "tokens": [{
          "args": [],
          "name": "UnicodeLeadSurrogate",
          "optional": false
        }, {
          "args": [],
          "name": "UnicodeTrailSurrogate",
          "optional": false
        }]
      }, {
        "tokens": ["ZWNJ"]
      }, {
        "tokens": ["ZWJ"]
      }]
    }, {
      "lhs": {
        "name": "RegExpUnicodeEscapeSequence",
        "params": ["U"]
      },
      "rhsList": [{
        "condOpt": {
          "name": "U",
          "pass": true
        },
        "tokens": [{
          "term": "u"
        }, {
          "args": [],
          "name": "HexLeadSurrogate",
          "optional": false
        }, {
          "term": "\\u"
        }, {
          "args": [],
          "name": "HexTrailSurrogate",
          "optional": false
        }]
      }, {
        "condOpt": {
          "name": "U",
          "pass": true
        },
        "tokens": [{
          "term": "u"
        }, {
          "args": [],
          "name": "HexLeadSurrogate",
          "optional": false
        }]
      }, {
        "condOpt": {
          "name": "U",
          "pass": true
        },
        "tokens": [{
          "term": "u"
        }, {
          "args": [],
          "name": "HexTrailSurrogate",
          "optional": false
        }]
      }, {
        "condOpt": {
          "name": "U",
          "pass": true
        },
        "tokens": [{
          "term": "u"
        }, {
          "args": [],
          "name": "HexNonSurrogate",
          "optional": false
        }]
      }, {
        "condOpt": {
          "name": "U",
          "pass": false
        },
        "tokens": [{
          "term": "u"
        }, {
          "args": [],
          "name": "Hex4Digits",
          "optional": false
        }]
      }, {
        "condOpt": {
          "name": "U",
          "pass": true
        },
        "tokens": [{
          "term": "u{"
        }, {
          "args": [],
          "name": "CodePoint",
          "optional": false
        }, {
          "term": "}"
        }]
      }]
    }, {
      "lhs": {
        "name": "UnicodeLeadSurrogate",
        "params": []
      },
      "rhsList": [{
        "tokens": ["UnicodeLeadSurrogate"]
      }]
    }, {
      "lhs": {
        "name": "UnicodeTrailSurrogate",
        "params": []
      },
      "rhsList": [{
        "tokens": ["UnicodeTrailSurrogate"]
      }]
    }, {
      "lhs": {
        "name": "HexLeadSurrogate",
        "params": []
      },
      "rhsList": [{
        "tokens": ["HexLeadSurrogate"]
      }]
    }, {
      "lhs": {
        "name": "HexTrailSurrogate",
        "params": []
      },
      "rhsList": [{
        "tokens": ["HexTrailSurrogate"]
      }]
    }, {
      "lhs": {
        "name": "HexNonSurrogate",
        "params": []
      },
      "rhsList": [{
        "tokens": ["HexNonSurrogate"]
      }]
    }, {
      "lhs": {
        "name": "IdentityEscape",
        "params": ["U"]
      },
      "rhsList": [{
        "condOpt": {
          "name": "U",
          "pass": true
        },
        "tokens": [{
          "args": [],
          "name": "SyntaxCharacter",
          "optional": false
        }]
      }, {
        "condOpt": {
          "name": "U",
          "pass": true
        },
        "tokens": [{
          "term": "/"
        }]
      }, {
        "condOpt": {
          "name": "U",
          "pass": false
        },
        "tokens": [{
          "base": {
            "args": [],
            "name": "SourceCharacter",
            "optional": false
          },
          "cases": [{
            "args": [],
            "name": "UnicodeIDContinue",
            "optional": false
          }]
        }]
      }]
    }, {
      "lhs": {
        "name": "DecimalEscape",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "NonZeroDigit",
          "optional": false
        }, {
          "args": ["~Sep"],
          "name": "DecimalDigits",
          "optional": true
        }, {
          "cases": [[{
            "args": [],
            "name": "DecimalDigit",
            "optional": false
          }]],
          "contains": false
        }]
      }]
    }, {
      "lhs": {
        "name": "CharacterClassEscape",
        "params": ["U"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "d"
        }]
      }, {
        "tokens": [{
          "term": "D"
        }]
      }, {
        "tokens": [{
          "term": "s"
        }]
      }, {
        "tokens": [{
          "term": "S"
        }]
      }, {
        "tokens": [{
          "term": "w"
        }]
      }, {
        "tokens": [{
          "term": "W"
        }]
      }, {
        "condOpt": {
          "name": "U",
          "pass": true
        },
        "tokens": [{
          "term": "p{"
        }, {
          "args": [],
          "name": "UnicodePropertyValueExpression",
          "optional": false
        }, {
          "term": "}"
        }]
      }, {
        "condOpt": {
          "name": "U",
          "pass": true
        },
        "tokens": [{
          "term": "P{"
        }, {
          "args": [],
          "name": "UnicodePropertyValueExpression",
          "optional": false
        }, {
          "term": "}"
        }]
      }]
    }, {
      "lhs": {
        "name": "UnicodePropertyValueExpression",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "UnicodePropertyName",
          "optional": false
        }, {
          "term": "="
        }, {
          "args": [],
          "name": "UnicodePropertyValue",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "LoneUnicodePropertyNameOrValue",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "UnicodePropertyName",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "UnicodePropertyNameCharacters",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "UnicodePropertyNameCharacters",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "UnicodePropertyNameCharacter",
          "optional": false
        }, {
          "args": [],
          "name": "UnicodePropertyNameCharacters",
          "optional": true
        }]
      }]
    }, {
      "lhs": {
        "name": "UnicodePropertyValue",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "UnicodePropertyValueCharacters",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "LoneUnicodePropertyNameOrValue",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "UnicodePropertyValueCharacters",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "UnicodePropertyValueCharacters",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "UnicodePropertyValueCharacter",
          "optional": false
        }, {
          "args": [],
          "name": "UnicodePropertyValueCharacters",
          "optional": true
        }]
      }]
    }, {
      "lhs": {
        "name": "UnicodePropertyValueCharacter",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "UnicodePropertyNameCharacter",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "DecimalDigit",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "UnicodePropertyNameCharacter",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "ControlLetter",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "_"
        }]
      }]
    }, {
      "lhs": {
        "name": "CharacterClass",
        "params": ["U"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "["
        }, {
          "cases": [[{
            "term": "^"
          }]],
          "contains": false
        }, {
          "args": ["?U"],
          "name": "ClassRanges",
          "optional": false
        }, {
          "term": "]"
        }]
      }, {
        "tokens": [{
          "term": "["
        }, {
          "term": "^"
        }, {
          "args": ["?U"],
          "name": "ClassRanges",
          "optional": false
        }, {
          "term": "]"
        }]
      }]
    }, {
      "lhs": {
        "name": "ClassRanges",
        "params": ["U"]
      },
      "rhsList": [{
        "tokens": [{
          "empty": null
        }]
      }, {
        "tokens": [{
          "args": ["?U"],
          "name": "NonemptyClassRanges",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "NonemptyClassRanges",
        "params": ["U"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?U"],
          "name": "ClassAtom",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?U"],
          "name": "ClassAtom",
          "optional": false
        }, {
          "args": ["?U"],
          "name": "NonemptyClassRangesNoDash",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?U"],
          "name": "ClassAtom",
          "optional": false
        }, {
          "term": "-"
        }, {
          "args": ["?U"],
          "name": "ClassAtom",
          "optional": false
        }, {
          "args": ["?U"],
          "name": "ClassRanges",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "NonemptyClassRangesNoDash",
        "params": ["U"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?U"],
          "name": "ClassAtom",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?U"],
          "name": "ClassAtomNoDash",
          "optional": false
        }, {
          "args": ["?U"],
          "name": "NonemptyClassRangesNoDash",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?U"],
          "name": "ClassAtomNoDash",
          "optional": false
        }, {
          "term": "-"
        }, {
          "args": ["?U"],
          "name": "ClassAtom",
          "optional": false
        }, {
          "args": ["?U"],
          "name": "ClassRanges",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ClassAtom",
        "params": ["U"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "-"
        }]
      }, {
        "tokens": [{
          "args": ["?U"],
          "name": "ClassAtomNoDash",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ClassAtomNoDash",
        "params": ["U"]
      },
      "rhsList": [{
        "tokens": [{
          "base": {
            "args": [],
            "name": "SourceCharacter",
            "optional": false
          },
          "cases": [{
            "term": "\\"
          }, {
            "term": "]"
          }, {
            "term": "-"
          }]
        }]
      }, {
        "tokens": [{
          "term": "\\"
        }, {
          "args": ["?U"],
          "name": "ClassEscape",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ClassEscape",
        "params": ["U"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "b"
        }]
      }, {
        "condOpt": {
          "name": "U",
          "pass": true
        },
        "tokens": [{
          "term": "-"
        }]
      }, {
        "tokens": [{
          "args": ["?U"],
          "name": "CharacterClassEscape",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?U"],
          "name": "CharacterEscape",
          "optional": false
        }]
      }]
    }],
    "prods": [{
      "lhs": {
        "name": "IdentifierReference",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "Identifier",
          "optional": false
        }]
      }, {
        "condOpt": {
          "name": "Yield",
          "pass": false
        },
        "tokens": [{
          "term": "yield"
        }]
      }, {
        "condOpt": {
          "name": "Await",
          "pass": false
        },
        "tokens": [{
          "term": "await"
        }]
      }]
    }, {
      "lhs": {
        "name": "BindingIdentifier",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "Identifier",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "yield"
        }]
      }, {
        "tokens": [{
          "term": "await"
        }]
      }]
    }, {
      "lhs": {
        "name": "LabelIdentifier",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "Identifier",
          "optional": false
        }]
      }, {
        "condOpt": {
          "name": "Yield",
          "pass": false
        },
        "tokens": [{
          "term": "yield"
        }]
      }, {
        "condOpt": {
          "name": "Await",
          "pass": false
        },
        "tokens": [{
          "term": "await"
        }]
      }]
    }, {
      "lhs": {
        "name": "Identifier",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "base": {
            "args": [],
            "name": "IdentifierName",
            "optional": false
          },
          "cases": [{
            "args": [],
            "name": "ReservedWord",
            "optional": false
          }]
        }]
      }]
    }, {
      "lhs": {
        "name": "PrimaryExpression",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "this"
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "IdentifierReference",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "Literal",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "ArrayLiteral",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "ObjectLiteral",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "FunctionExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "ClassExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "GeneratorExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "AsyncFunctionExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "AsyncGeneratorExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "RegularExpressionLiteral",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await", "~Tagged"],
          "name": "TemplateLiteral",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "CoverParenthesizedExpressionAndArrowParameterList",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "CoverParenthesizedExpressionAndArrowParameterList",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "("
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }]
      }, {
        "tokens": [{
          "term": "("
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": false
        }, {
          "term": ","
        }, {
          "term": ")"
        }]
      }, {
        "tokens": [{
          "term": "("
        }, {
          "term": ")"
        }]
      }, {
        "tokens": [{
          "term": "("
        }, {
          "term": "..."
        }, {
          "args": ["?Yield", "?Await"],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": ")"
        }]
      }, {
        "tokens": [{
          "term": "("
        }, {
          "term": "..."
        }, {
          "args": ["?Yield", "?Await"],
          "name": "BindingPattern",
          "optional": false
        }, {
          "term": ")"
        }]
      }, {
        "tokens": [{
          "term": "("
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": false
        }, {
          "term": ","
        }, {
          "term": "..."
        }, {
          "args": ["?Yield", "?Await"],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": ")"
        }]
      }, {
        "tokens": [{
          "term": "("
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": false
        }, {
          "term": ","
        }, {
          "term": "..."
        }, {
          "args": ["?Yield", "?Await"],
          "name": "BindingPattern",
          "optional": false
        }, {
          "term": ")"
        }]
      }]
    }, {
      "lhs": {
        "name": "ParenthesizedExpression",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "("
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }]
      }]
    }, {
      "lhs": {
        "name": "Literal",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "NullLiteral",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "BooleanLiteral",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "NumericLiteral",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "StringLiteral",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ArrayLiteral",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "["
        }, {
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "term": "]"
        }]
      }, {
        "tokens": [{
          "term": "["
        }, {
          "args": ["?Yield", "?Await"],
          "name": "ElementList",
          "optional": false
        }, {
          "term": "]"
        }]
      }, {
        "tokens": [{
          "term": "["
        }, {
          "args": ["?Yield", "?Await"],
          "name": "ElementList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "term": "]"
        }]
      }]
    }, {
      "lhs": {
        "name": "ElementList",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "AssignmentExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "args": ["?Yield", "?Await"],
          "name": "SpreadElement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "ElementList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "AssignmentExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "ElementList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "args": ["?Yield", "?Await"],
          "name": "SpreadElement",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "Elision",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": ","
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "Elision",
          "optional": false
        }, {
          "term": ","
        }]
      }]
    }, {
      "lhs": {
        "name": "SpreadElement",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "..."
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "AssignmentExpression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ObjectLiteral",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      }, {
        "tokens": [{
          "term": "{"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "PropertyDefinitionList",
          "optional": false
        }, {
          "term": "}"
        }]
      }, {
        "tokens": [{
          "term": "{"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "PropertyDefinitionList",
          "optional": false
        }, {
          "term": ","
        }, {
          "term": "}"
        }]
      }]
    }, {
      "lhs": {
        "name": "PropertyDefinitionList",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "PropertyDefinition",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "PropertyDefinitionList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": ["?Yield", "?Await"],
          "name": "PropertyDefinition",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "PropertyDefinition",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "IdentifierReference",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "CoverInitializedName",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "AssignmentExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "MethodDefinition",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "..."
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "AssignmentExpression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "PropertyName",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "LiteralPropertyName",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "ComputedPropertyName",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "LiteralPropertyName",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "StringLiteral",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "NumericLiteral",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ComputedPropertyName",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "["
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": "]"
        }]
      }]
    }, {
      "lhs": {
        "name": "CoverInitializedName",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "IdentifierReference",
          "optional": false
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Initializer",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "Initializer",
        "params": ["In", "Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "="
        }, {
          "args": ["?In", "?Yield", "?Await"],
          "name": "AssignmentExpression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "TemplateLiteral",
        "params": ["Yield", "Await", "Tagged"]
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "NoSubstitutionTemplate",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await", "?Tagged"],
          "name": "SubstitutionTemplate",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "SubstitutionTemplate",
        "params": ["Yield", "Await", "Tagged"]
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "TemplateHead",
          "optional": false
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": false
        }, {
          "args": ["?Yield", "?Await", "?Tagged"],
          "name": "TemplateSpans",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "TemplateSpans",
        "params": ["Yield", "Await", "Tagged"]
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "TemplateTail",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await", "?Tagged"],
          "name": "TemplateMiddleList",
          "optional": false
        }, {
          "args": [],
          "name": "TemplateTail",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "TemplateMiddleList",
        "params": ["Yield", "Await", "Tagged"]
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "TemplateMiddle",
          "optional": false
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await", "?Tagged"],
          "name": "TemplateMiddleList",
          "optional": false
        }, {
          "args": [],
          "name": "TemplateMiddle",
          "optional": false
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "MemberExpression",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "PrimaryExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "MemberExpression",
          "optional": false
        }, {
          "term": "["
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": false
        }, {
          "term": "]"
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "MemberExpression",
          "optional": false
        }, {
          "term": "."
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "MemberExpression",
          "optional": false
        }, {
          "args": ["?Yield", "?Await", "+Tagged"],
          "name": "TemplateLiteral",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "SuperProperty",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "MetaProperty",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "new"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "MemberExpression",
          "optional": false
        }, {
          "args": ["?Yield", "?Await"],
          "name": "Arguments",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "SuperProperty",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "super"
        }, {
          "term": "["
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": false
        }, {
          "term": "]"
        }]
      }, {
        "tokens": [{
          "term": "super"
        }, {
          "term": "."
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "MetaProperty",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "NewTarget",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "ImportMeta",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "NewTarget",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "new"
        }, {
          "term": "."
        }, {
          "term": "target"
        }]
      }]
    }, {
      "lhs": {
        "name": "ImportMeta",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "import"
        }, {
          "term": "."
        }, {
          "term": "meta"
        }]
      }]
    }, {
      "lhs": {
        "name": "NewExpression",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "MemberExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "new"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "NewExpression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "CallExpression",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "CoverCallExpressionAndAsyncArrowHead",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "SuperCall",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "ImportCall",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "CallExpression",
          "optional": false
        }, {
          "args": ["?Yield", "?Await"],
          "name": "Arguments",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "CallExpression",
          "optional": false
        }, {
          "term": "["
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": false
        }, {
          "term": "]"
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "CallExpression",
          "optional": false
        }, {
          "term": "."
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "CallExpression",
          "optional": false
        }, {
          "args": ["?Yield", "?Await", "+Tagged"],
          "name": "TemplateLiteral",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "SuperCall",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "super"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "Arguments",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ImportCall",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "import"
        }, {
          "term": "("
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }]
      }]
    }, {
      "lhs": {
        "name": "Arguments",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "("
        }, {
          "term": ")"
        }]
      }, {
        "tokens": [{
          "term": "("
        }, {
          "args": ["?Yield", "?Await"],
          "name": "ArgumentList",
          "optional": false
        }, {
          "term": ")"
        }]
      }, {
        "tokens": [{
          "term": "("
        }, {
          "args": ["?Yield", "?Await"],
          "name": "ArgumentList",
          "optional": false
        }, {
          "term": ","
        }, {
          "term": ")"
        }]
      }]
    }, {
      "lhs": {
        "name": "ArgumentList",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["+In", "?Yield", "?Await"],
          "name": "AssignmentExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "..."
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "AssignmentExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "ArgumentList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "AssignmentExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "ArgumentList",
          "optional": false
        }, {
          "term": ","
        }, {
          "term": "..."
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "AssignmentExpression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "OptionalExpression",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "MemberExpression",
          "optional": false
        }, {
          "args": ["?Yield", "?Await"],
          "name": "OptionalChain",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "CallExpression",
          "optional": false
        }, {
          "args": ["?Yield", "?Await"],
          "name": "OptionalChain",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "OptionalExpression",
          "optional": false
        }, {
          "args": ["?Yield", "?Await"],
          "name": "OptionalChain",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "OptionalChain",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "?."
        }, {
          "args": ["?Yield", "?Await"],
          "name": "Arguments",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "?."
        }, {
          "term": "["
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": false
        }, {
          "term": "]"
        }]
      }, {
        "tokens": [{
          "term": "?."
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "?."
        }, {
          "args": ["?Yield", "?Await", "+Tagged"],
          "name": "TemplateLiteral",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "OptionalChain",
          "optional": false
        }, {
          "args": ["?Yield", "?Await"],
          "name": "Arguments",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "OptionalChain",
          "optional": false
        }, {
          "term": "["
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": false
        }, {
          "term": "]"
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "OptionalChain",
          "optional": false
        }, {
          "term": "."
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "OptionalChain",
          "optional": false
        }, {
          "args": ["?Yield", "?Await", "+Tagged"],
          "name": "TemplateLiteral",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "LeftHandSideExpression",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "NewExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "CallExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "OptionalExpression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "CallMemberExpression",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "MemberExpression",
          "optional": false
        }, {
          "args": ["?Yield", "?Await"],
          "name": "Arguments",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "UpdateExpression",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "LeftHandSideExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "nlt": null
        }, {
          "term": "++"
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "nlt": null
        }, {
          "term": "--"
        }]
      }, {
        "tokens": [{
          "term": "++"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "UnaryExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "--"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "UnaryExpression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "UnaryExpression",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "UpdateExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "delete"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "UnaryExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "void"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "UnaryExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "typeof"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "UnaryExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "+"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "UnaryExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "-"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "UnaryExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "~"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "UnaryExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "!"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "UnaryExpression",
          "optional": false
        }]
      }, {
        "condOpt": {
          "name": "Await",
          "pass": true
        },
        "tokens": [{
          "args": ["?Yield"],
          "name": "AwaitExpression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ExponentiationExpression",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "UnaryExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "UpdateExpression",
          "optional": false
        }, {
          "term": "**"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "ExponentiationExpression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "MultiplicativeExpression",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "ExponentiationExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "MultiplicativeExpression",
          "optional": false
        }, {
          "args": [],
          "name": "MultiplicativeOperator",
          "optional": false
        }, {
          "args": ["?Yield", "?Await"],
          "name": "ExponentiationExpression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "MultiplicativeOperator",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "*"
        }]
      }, {
        "tokens": [{
          "term": "/"
        }]
      }, {
        "tokens": [{
          "term": "%"
        }]
      }]
    }, {
      "lhs": {
        "name": "AdditiveExpression",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "MultiplicativeExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "AdditiveExpression",
          "optional": false
        }, {
          "term": "+"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "MultiplicativeExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "AdditiveExpression",
          "optional": false
        }, {
          "term": "-"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "MultiplicativeExpression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ShiftExpression",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "AdditiveExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "ShiftExpression",
          "optional": false
        }, {
          "term": "<<"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "AdditiveExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "ShiftExpression",
          "optional": false
        }, {
          "term": ">>"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "AdditiveExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "ShiftExpression",
          "optional": false
        }, {
          "term": ">>>"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "AdditiveExpression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "RelationalExpression",
        "params": ["In", "Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "ShiftExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "RelationalExpression",
          "optional": false
        }, {
          "term": "<"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "ShiftExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "RelationalExpression",
          "optional": false
        }, {
          "term": ">"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "ShiftExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "RelationalExpression",
          "optional": false
        }, {
          "term": "<="
        }, {
          "args": ["?Yield", "?Await"],
          "name": "ShiftExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "RelationalExpression",
          "optional": false
        }, {
          "term": ">="
        }, {
          "args": ["?Yield", "?Await"],
          "name": "ShiftExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "RelationalExpression",
          "optional": false
        }, {
          "term": "instanceof"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "ShiftExpression",
          "optional": false
        }]
      }, {
        "condOpt": {
          "name": "In",
          "pass": true
        },
        "tokens": [{
          "args": ["+In", "?Yield", "?Await"],
          "name": "RelationalExpression",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "ShiftExpression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "EqualityExpression",
        "params": ["In", "Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "RelationalExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "EqualityExpression",
          "optional": false
        }, {
          "term": "=="
        }, {
          "args": ["?In", "?Yield", "?Await"],
          "name": "RelationalExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "EqualityExpression",
          "optional": false
        }, {
          "term": "!="
        }, {
          "args": ["?In", "?Yield", "?Await"],
          "name": "RelationalExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "EqualityExpression",
          "optional": false
        }, {
          "term": "==="
        }, {
          "args": ["?In", "?Yield", "?Await"],
          "name": "RelationalExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "EqualityExpression",
          "optional": false
        }, {
          "term": "!=="
        }, {
          "args": ["?In", "?Yield", "?Await"],
          "name": "RelationalExpression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "BitwiseANDExpression",
        "params": ["In", "Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "EqualityExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "BitwiseANDExpression",
          "optional": false
        }, {
          "term": "&"
        }, {
          "args": ["?In", "?Yield", "?Await"],
          "name": "EqualityExpression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "BitwiseXORExpression",
        "params": ["In", "Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "BitwiseANDExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "BitwiseXORExpression",
          "optional": false
        }, {
          "term": "^"
        }, {
          "args": ["?In", "?Yield", "?Await"],
          "name": "BitwiseANDExpression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "BitwiseORExpression",
        "params": ["In", "Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "BitwiseXORExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "BitwiseORExpression",
          "optional": false
        }, {
          "term": "|"
        }, {
          "args": ["?In", "?Yield", "?Await"],
          "name": "BitwiseXORExpression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "LogicalANDExpression",
        "params": ["In", "Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "BitwiseORExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "LogicalANDExpression",
          "optional": false
        }, {
          "term": "&&"
        }, {
          "args": ["?In", "?Yield", "?Await"],
          "name": "BitwiseORExpression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "LogicalORExpression",
        "params": ["In", "Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "LogicalANDExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "LogicalORExpression",
          "optional": false
        }, {
          "term": "||"
        }, {
          "args": ["?In", "?Yield", "?Await"],
          "name": "LogicalANDExpression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "CoalesceExpression",
        "params": ["In", "Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "CoalesceExpressionHead",
          "optional": false
        }, {
          "term": "??"
        }, {
          "args": ["?In", "?Yield", "?Await"],
          "name": "BitwiseORExpression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "CoalesceExpressionHead",
        "params": ["In", "Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "CoalesceExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "BitwiseORExpression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ShortCircuitExpression",
        "params": ["In", "Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "LogicalORExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "CoalesceExpression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ConditionalExpression",
        "params": ["In", "Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "ShortCircuitExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "ShortCircuitExpression",
          "optional": false
        }, {
          "term": "?"
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": ["?In", "?Yield", "?Await"],
          "name": "AssignmentExpression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "AssignmentExpression",
        "params": ["In", "Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "ConditionalExpression",
          "optional": false
        }]
      }, {
        "condOpt": {
          "name": "Yield",
          "pass": true
        },
        "tokens": [{
          "args": ["?In", "?Await"],
          "name": "YieldExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "ArrowFunction",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "AsyncArrowFunction",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "="
        }, {
          "args": ["?In", "?Yield", "?Await"],
          "name": "AssignmentExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "args": [],
          "name": "AssignmentOperator",
          "optional": false
        }, {
          "args": ["?In", "?Yield", "?Await"],
          "name": "AssignmentExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "&&="
        }, {
          "args": ["?In", "?Yield", "?Await"],
          "name": "AssignmentExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "||="
        }, {
          "args": ["?In", "?Yield", "?Await"],
          "name": "AssignmentExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "??="
        }, {
          "args": ["?In", "?Yield", "?Await"],
          "name": "AssignmentExpression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "AssignmentOperator",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "*="
        }]
      }, {
        "tokens": [{
          "term": "/="
        }]
      }, {
        "tokens": [{
          "term": "%="
        }]
      }, {
        "tokens": [{
          "term": "+="
        }]
      }, {
        "tokens": [{
          "term": "-="
        }]
      }, {
        "tokens": [{
          "term": "<<="
        }]
      }, {
        "tokens": [{
          "term": ">>="
        }]
      }, {
        "tokens": [{
          "term": ">>>="
        }]
      }, {
        "tokens": [{
          "term": "&="
        }]
      }, {
        "tokens": [{
          "term": "^="
        }]
      }, {
        "tokens": [{
          "term": "|="
        }]
      }, {
        "tokens": [{
          "term": "**="
        }]
      }]
    }, {
      "lhs": {
        "name": "AssignmentPattern",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "ObjectAssignmentPattern",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "ArrayAssignmentPattern",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ObjectAssignmentPattern",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      }, {
        "tokens": [{
          "term": "{"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "AssignmentRestProperty",
          "optional": false
        }, {
          "term": "}"
        }]
      }, {
        "tokens": [{
          "term": "{"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "AssignmentPropertyList",
          "optional": false
        }, {
          "term": "}"
        }]
      }, {
        "tokens": [{
          "term": "{"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "AssignmentPropertyList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": ["?Yield", "?Await"],
          "name": "AssignmentRestProperty",
          "optional": true
        }, {
          "term": "}"
        }]
      }]
    }, {
      "lhs": {
        "name": "ArrayAssignmentPattern",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "["
        }, {
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "args": ["?Yield", "?Await"],
          "name": "AssignmentRestElement",
          "optional": true
        }, {
          "term": "]"
        }]
      }, {
        "tokens": [{
          "term": "["
        }, {
          "args": ["?Yield", "?Await"],
          "name": "AssignmentElementList",
          "optional": false
        }, {
          "term": "]"
        }]
      }, {
        "tokens": [{
          "term": "["
        }, {
          "args": ["?Yield", "?Await"],
          "name": "AssignmentElementList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "args": ["?Yield", "?Await"],
          "name": "AssignmentRestElement",
          "optional": true
        }, {
          "term": "]"
        }]
      }]
    }, {
      "lhs": {
        "name": "AssignmentRestProperty",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "..."
        }, {
          "args": ["?Yield", "?Await"],
          "name": "DestructuringAssignmentTarget",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "AssignmentPropertyList",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "AssignmentProperty",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "AssignmentPropertyList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": ["?Yield", "?Await"],
          "name": "AssignmentProperty",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "AssignmentElementList",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "AssignmentElisionElement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "AssignmentElementList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": ["?Yield", "?Await"],
          "name": "AssignmentElisionElement",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "AssignmentElisionElement",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "args": ["?Yield", "?Await"],
          "name": "AssignmentElement",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "AssignmentProperty",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "IdentifierReference",
          "optional": false
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Initializer",
          "optional": true
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "AssignmentElement",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "AssignmentElement",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "DestructuringAssignmentTarget",
          "optional": false
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Initializer",
          "optional": true
        }]
      }]
    }, {
      "lhs": {
        "name": "AssignmentRestElement",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "..."
        }, {
          "args": ["?Yield", "?Await"],
          "name": "DestructuringAssignmentTarget",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "DestructuringAssignmentTarget",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "LeftHandSideExpression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "Expression",
        "params": ["In", "Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "AssignmentExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": ["?In", "?Yield", "?Await"],
          "name": "AssignmentExpression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "Statement",
        "params": ["Yield", "Await", "Return"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await", "?Return"],
          "name": "BlockStatement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "VariableStatement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "EmptyStatement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "ExpressionStatement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await", "?Return"],
          "name": "IfStatement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await", "?Return"],
          "name": "BreakableStatement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "ContinueStatement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "BreakStatement",
          "optional": false
        }]
      }, {
        "condOpt": {
          "name": "Return",
          "pass": true
        },
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "ReturnStatement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await", "?Return"],
          "name": "WithStatement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await", "?Return"],
          "name": "LabelledStatement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "ThrowStatement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await", "?Return"],
          "name": "TryStatement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "DebuggerStatement",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "Declaration",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await", "~Default"],
          "name": "HoistableDeclaration",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await", "~Default"],
          "name": "ClassDeclaration",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["+In", "?Yield", "?Await"],
          "name": "LexicalDeclaration",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "HoistableDeclaration",
        "params": ["Yield", "Await", "Default"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await", "?Default"],
          "name": "FunctionDeclaration",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await", "?Default"],
          "name": "GeneratorDeclaration",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await", "?Default"],
          "name": "AsyncFunctionDeclaration",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await", "?Default"],
          "name": "AsyncGeneratorDeclaration",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "BreakableStatement",
        "params": ["Yield", "Await", "Return"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await", "?Return"],
          "name": "IterationStatement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await", "?Return"],
          "name": "SwitchStatement",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "BlockStatement",
        "params": ["Yield", "Await", "Return"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Block",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "Block",
        "params": ["Yield", "Await", "Return"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "{"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "StatementList",
          "optional": true
        }, {
          "term": "}"
        }]
      }]
    }, {
      "lhs": {
        "name": "StatementList",
        "params": ["Yield", "Await", "Return"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await", "?Return"],
          "name": "StatementListItem",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await", "?Return"],
          "name": "StatementList",
          "optional": false
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "StatementListItem",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "StatementListItem",
        "params": ["Yield", "Await", "Return"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Statement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "Declaration",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "LexicalDeclaration",
        "params": ["In", "Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "LetOrConst",
          "optional": false
        }, {
          "args": ["?In", "?Yield", "?Await"],
          "name": "BindingList",
          "optional": false
        }, {
          "term": ";"
        }]
      }]
    }, {
      "lhs": {
        "name": "LetOrConst",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "let"
        }]
      }, {
        "tokens": [{
          "term": "const"
        }]
      }]
    }, {
      "lhs": {
        "name": "BindingList",
        "params": ["In", "Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "LexicalBinding",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "BindingList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": ["?In", "?Yield", "?Await"],
          "name": "LexicalBinding",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "LexicalBinding",
        "params": ["In", "Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "args": ["?In", "?Yield", "?Await"],
          "name": "Initializer",
          "optional": true
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "BindingPattern",
          "optional": false
        }, {
          "args": ["?In", "?Yield", "?Await"],
          "name": "Initializer",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "VariableStatement",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "var"
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "VariableDeclarationList",
          "optional": false
        }, {
          "term": ";"
        }]
      }]
    }, {
      "lhs": {
        "name": "VariableDeclarationList",
        "params": ["In", "Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "VariableDeclaration",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?In", "?Yield", "?Await"],
          "name": "VariableDeclarationList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": ["?In", "?Yield", "?Await"],
          "name": "VariableDeclaration",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "VariableDeclaration",
        "params": ["In", "Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "args": ["?In", "?Yield", "?Await"],
          "name": "Initializer",
          "optional": true
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "BindingPattern",
          "optional": false
        }, {
          "args": ["?In", "?Yield", "?Await"],
          "name": "Initializer",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "BindingPattern",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "ObjectBindingPattern",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "ArrayBindingPattern",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ObjectBindingPattern",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      }, {
        "tokens": [{
          "term": "{"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "BindingRestProperty",
          "optional": false
        }, {
          "term": "}"
        }]
      }, {
        "tokens": [{
          "term": "{"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "BindingPropertyList",
          "optional": false
        }, {
          "term": "}"
        }]
      }, {
        "tokens": [{
          "term": "{"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "BindingPropertyList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": ["?Yield", "?Await"],
          "name": "BindingRestProperty",
          "optional": true
        }, {
          "term": "}"
        }]
      }]
    }, {
      "lhs": {
        "name": "ArrayBindingPattern",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "["
        }, {
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "args": ["?Yield", "?Await"],
          "name": "BindingRestElement",
          "optional": true
        }, {
          "term": "]"
        }]
      }, {
        "tokens": [{
          "term": "["
        }, {
          "args": ["?Yield", "?Await"],
          "name": "BindingElementList",
          "optional": false
        }, {
          "term": "]"
        }]
      }, {
        "tokens": [{
          "term": "["
        }, {
          "args": ["?Yield", "?Await"],
          "name": "BindingElementList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "args": ["?Yield", "?Await"],
          "name": "BindingRestElement",
          "optional": true
        }, {
          "term": "]"
        }]
      }]
    }, {
      "lhs": {
        "name": "BindingRestProperty",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "..."
        }, {
          "args": ["?Yield", "?Await"],
          "name": "BindingIdentifier",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "BindingPropertyList",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "BindingProperty",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "BindingPropertyList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": ["?Yield", "?Await"],
          "name": "BindingProperty",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "BindingElementList",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "BindingElisionElement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "BindingElementList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": ["?Yield", "?Await"],
          "name": "BindingElisionElement",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "BindingElisionElement",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "Elision",
          "optional": true
        }, {
          "args": ["?Yield", "?Await"],
          "name": "BindingElement",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "BindingProperty",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "SingleNameBinding",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "BindingElement",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "BindingElement",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "SingleNameBinding",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "BindingPattern",
          "optional": false
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Initializer",
          "optional": true
        }]
      }]
    }, {
      "lhs": {
        "name": "SingleNameBinding",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Initializer",
          "optional": true
        }]
      }]
    }, {
      "lhs": {
        "name": "BindingRestElement",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "..."
        }, {
          "args": ["?Yield", "?Await"],
          "name": "BindingIdentifier",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "..."
        }, {
          "args": ["?Yield", "?Await"],
          "name": "BindingPattern",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "EmptyStatement",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": ";"
        }]
      }]
    }, {
      "lhs": {
        "name": "ExpressionStatement",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "cases": [[{
            "term": "{"
          }], [{
            "term": "function"
          }], [{
            "term": "async"
          }, {
            "nlt": null
          }, {
            "term": "function"
          }], [{
            "term": "class"
          }], [{
            "term": "let"
          }, {
            "term": "["
          }]],
          "contains": false
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": false
        }, {
          "term": ";"
        }]
      }]
    }, {
      "lhs": {
        "name": "IfStatement",
        "params": ["Yield", "Await", "Return"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "if"
        }, {
          "term": "("
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Statement",
          "optional": false
        }, {
          "term": "else"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Statement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "if"
        }, {
          "term": "("
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Statement",
          "optional": false
        }, {
          "cases": [[{
            "term": "else"
          }]],
          "contains": false
        }]
      }]
    }, {
      "lhs": {
        "name": "IterationStatement",
        "params": ["Yield", "Await", "Return"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await", "?Return"],
          "name": "DoWhileStatement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await", "?Return"],
          "name": "WhileStatement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await", "?Return"],
          "name": "ForStatement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await", "?Return"],
          "name": "ForInOfStatement",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "DoWhileStatement",
        "params": ["Yield", "Await", "Return"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "do"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Statement",
          "optional": false
        }, {
          "term": "while"
        }, {
          "term": "("
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": ";"
        }]
      }]
    }, {
      "lhs": {
        "name": "WhileStatement",
        "params": ["Yield", "Await", "Return"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "while"
        }, {
          "term": "("
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Statement",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ForStatement",
        "params": ["Yield", "Await", "Return"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "cases": [[{
            "term": "let"
          }, {
            "term": "["
          }]],
          "contains": false
        }, {
          "args": ["~In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": true
        }, {
          "term": ")"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Statement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": ["~In", "?Yield", "?Await"],
          "name": "VariableDeclarationList",
          "optional": false
        }, {
          "term": ";"
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": true
        }, {
          "term": ")"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Statement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": ["~In", "?Yield", "?Await"],
          "name": "LexicalDeclaration",
          "optional": false
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": true
        }, {
          "term": ";"
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": true
        }, {
          "term": ")"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Statement",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ForInOfStatement",
        "params": ["Yield", "Await", "Return"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "cases": [[{
            "term": "let"
          }, {
            "term": "["
          }]],
          "contains": false
        }, {
          "args": ["?Yield", "?Await"],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Statement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "ForBinding",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Statement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": ["?Yield", "?Await"],
          "name": "ForDeclaration",
          "optional": false
        }, {
          "term": "in"
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Statement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "cases": [[{
            "term": "let"
          }], [{
            "term": "async"
          }, {
            "term": "of"
          }]],
          "contains": false
        }, {
          "args": ["?Yield", "?Await"],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Statement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "ForBinding",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Statement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "for"
        }, {
          "term": "("
        }, {
          "args": ["?Yield", "?Await"],
          "name": "ForDeclaration",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Statement",
          "optional": false
        }]
      }, {
        "condOpt": {
          "name": "Await",
          "pass": true
        },
        "tokens": [{
          "term": "for"
        }, {
          "term": "await"
        }, {
          "term": "("
        }, {
          "cases": [[{
            "term": "let"
          }]],
          "contains": false
        }, {
          "args": ["?Yield", "?Await"],
          "name": "LeftHandSideExpression",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Statement",
          "optional": false
        }]
      }, {
        "condOpt": {
          "name": "Await",
          "pass": true
        },
        "tokens": [{
          "term": "for"
        }, {
          "term": "await"
        }, {
          "term": "("
        }, {
          "term": "var"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "ForBinding",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Statement",
          "optional": false
        }]
      }, {
        "condOpt": {
          "name": "Await",
          "pass": true
        },
        "tokens": [{
          "term": "for"
        }, {
          "term": "await"
        }, {
          "term": "("
        }, {
          "args": ["?Yield", "?Await"],
          "name": "ForDeclaration",
          "optional": false
        }, {
          "term": "of"
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Statement",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ForDeclaration",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "LetOrConst",
          "optional": false
        }, {
          "args": ["?Yield", "?Await"],
          "name": "ForBinding",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ForBinding",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "BindingIdentifier",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "BindingPattern",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ContinueStatement",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "continue"
        }, {
          "term": ";"
        }]
      }, {
        "tokens": [{
          "term": "continue"
        }, {
          "nlt": null
        }, {
          "args": ["?Yield", "?Await"],
          "name": "LabelIdentifier",
          "optional": false
        }, {
          "term": ";"
        }]
      }]
    }, {
      "lhs": {
        "name": "BreakStatement",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "break"
        }, {
          "term": ";"
        }]
      }, {
        "tokens": [{
          "term": "break"
        }, {
          "nlt": null
        }, {
          "args": ["?Yield", "?Await"],
          "name": "LabelIdentifier",
          "optional": false
        }, {
          "term": ";"
        }]
      }]
    }, {
      "lhs": {
        "name": "ReturnStatement",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "return"
        }, {
          "term": ";"
        }]
      }, {
        "tokens": [{
          "term": "return"
        }, {
          "nlt": null
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": false
        }, {
          "term": ";"
        }]
      }]
    }, {
      "lhs": {
        "name": "WithStatement",
        "params": ["Yield", "Await", "Return"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "with"
        }, {
          "term": "("
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Statement",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "SwitchStatement",
        "params": ["Yield", "Await", "Return"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "switch"
        }, {
          "term": "("
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "CaseBlock",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "CaseBlock",
        "params": ["Yield", "Await", "Return"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "{"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "CaseClauses",
          "optional": true
        }, {
          "term": "}"
        }]
      }, {
        "tokens": [{
          "term": "{"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "CaseClauses",
          "optional": true
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "DefaultClause",
          "optional": false
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "CaseClauses",
          "optional": true
        }, {
          "term": "}"
        }]
      }]
    }, {
      "lhs": {
        "name": "CaseClauses",
        "params": ["Yield", "Await", "Return"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await", "?Return"],
          "name": "CaseClause",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await", "?Return"],
          "name": "CaseClauses",
          "optional": false
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "CaseClause",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "CaseClause",
        "params": ["Yield", "Await", "Return"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "case"
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "StatementList",
          "optional": true
        }]
      }]
    }, {
      "lhs": {
        "name": "DefaultClause",
        "params": ["Yield", "Await", "Return"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "default"
        }, {
          "term": ":"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "StatementList",
          "optional": true
        }]
      }]
    }, {
      "lhs": {
        "name": "LabelledStatement",
        "params": ["Yield", "Await", "Return"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "LabelIdentifier",
          "optional": false
        }, {
          "term": ":"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "LabelledItem",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "LabelledItem",
        "params": ["Yield", "Await", "Return"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Statement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await", "~Default"],
          "name": "FunctionDeclaration",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ThrowStatement",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "throw"
        }, {
          "nlt": null
        }, {
          "args": ["+In", "?Yield", "?Await"],
          "name": "Expression",
          "optional": false
        }, {
          "term": ";"
        }]
      }]
    }, {
      "lhs": {
        "name": "TryStatement",
        "params": ["Yield", "Await", "Return"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "try"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Block",
          "optional": false
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Catch",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "try"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Block",
          "optional": false
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Finally",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "try"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Block",
          "optional": false
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Catch",
          "optional": false
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Finally",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "Catch",
        "params": ["Yield", "Await", "Return"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "catch"
        }, {
          "term": "("
        }, {
          "args": ["?Yield", "?Await"],
          "name": "CatchParameter",
          "optional": false
        }, {
          "term": ")"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Block",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "catch"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Block",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "Finally",
        "params": ["Yield", "Await", "Return"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "finally"
        }, {
          "args": ["?Yield", "?Await", "?Return"],
          "name": "Block",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "CatchParameter",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "BindingIdentifier",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "BindingPattern",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "DebuggerStatement",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "debugger"
        }, {
          "term": ";"
        }]
      }]
    }, {
      "lhs": {
        "name": "UniqueFormalParameters",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "FormalParameters",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "FormalParameters",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "empty": null
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "FunctionRestParameter",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "FormalParameterList",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "FormalParameterList",
          "optional": false
        }, {
          "term": ","
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "FormalParameterList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": ["?Yield", "?Await"],
          "name": "FunctionRestParameter",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "FormalParameterList",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "FormalParameter",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "FormalParameterList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": ["?Yield", "?Await"],
          "name": "FormalParameter",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "FunctionRestParameter",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "BindingRestElement",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "FormalParameter",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "BindingElement",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "FunctionDeclaration",
        "params": ["Yield", "Await", "Default"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "function"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": ["~Yield", "~Await"],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": ["~Yield", "~Await"],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      }, {
        "condOpt": {
          "name": "Default",
          "pass": true
        },
        "tokens": [{
          "term": "function"
        }, {
          "term": "("
        }, {
          "args": ["~Yield", "~Await"],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": ["~Yield", "~Await"],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      }]
    }, {
      "lhs": {
        "name": "FunctionExpression",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "function"
        }, {
          "args": ["~Yield", "~Await"],
          "name": "BindingIdentifier",
          "optional": true
        }, {
          "term": "("
        }, {
          "args": ["~Yield", "~Await"],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": ["~Yield", "~Await"],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      }]
    }, {
      "lhs": {
        "name": "FunctionBody",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "FunctionStatementList",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "FunctionStatementList",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await", "+Return"],
          "name": "StatementList",
          "optional": true
        }]
      }]
    }, {
      "lhs": {
        "name": "ArrowFunction",
        "params": ["In", "Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "ArrowParameters",
          "optional": false
        }, {
          "nlt": null
        }, {
          "term": "=>"
        }, {
          "args": ["?In"],
          "name": "ConciseBody",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ArrowParameters",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "BindingIdentifier",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "CoverParenthesizedExpressionAndArrowParameterList",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ConciseBody",
        "params": ["In"]
      },
      "rhsList": [{
        "tokens": [{
          "cases": [[{
            "term": "{"
          }]],
          "contains": false
        }, {
          "args": ["?In", "~Await"],
          "name": "ExpressionBody",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "{"
        }, {
          "args": ["~Yield", "~Await"],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      }]
    }, {
      "lhs": {
        "name": "ExpressionBody",
        "params": ["In", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?In", "~Yield", "?Await"],
          "name": "AssignmentExpression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ArrowFormalParameters",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "("
        }, {
          "args": ["?Yield", "?Await"],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }]
      }]
    }, {
      "lhs": {
        "name": "MethodDefinition",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": ["~Yield", "~Await"],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": ["~Yield", "~Await"],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "GeneratorMethod",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "AsyncMethod",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "AsyncGeneratorMethod",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "get"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": ["~Yield", "~Await"],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      }, {
        "tokens": [{
          "term": "set"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": [],
          "name": "PropertySetParameterList",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": ["~Yield", "~Await"],
          "name": "FunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      }]
    }, {
      "lhs": {
        "name": "PropertySetParameterList",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": ["~Yield", "~Await"],
          "name": "FormalParameter",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "GeneratorMethod",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "*"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": ["+Yield", "~Await"],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      }]
    }, {
      "lhs": {
        "name": "GeneratorDeclaration",
        "params": ["Yield", "Await", "Default"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "function"
        }, {
          "term": "*"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": ["+Yield", "~Await"],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      }, {
        "condOpt": {
          "name": "Default",
          "pass": true
        },
        "tokens": [{
          "term": "function"
        }, {
          "term": "*"
        }, {
          "term": "("
        }, {
          "args": ["+Yield", "~Await"],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      }]
    }, {
      "lhs": {
        "name": "GeneratorExpression",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "function"
        }, {
          "term": "*"
        }, {
          "args": ["+Yield", "~Await"],
          "name": "BindingIdentifier",
          "optional": true
        }, {
          "term": "("
        }, {
          "args": ["+Yield", "~Await"],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "GeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      }]
    }, {
      "lhs": {
        "name": "GeneratorBody",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": ["+Yield", "~Await"],
          "name": "FunctionBody",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "YieldExpression",
        "params": ["In", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "yield"
        }]
      }, {
        "tokens": [{
          "term": "yield"
        }, {
          "nlt": null
        }, {
          "args": ["?In", "+Yield", "?Await"],
          "name": "AssignmentExpression",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "yield"
        }, {
          "nlt": null
        }, {
          "term": "*"
        }, {
          "args": ["?In", "+Yield", "?Await"],
          "name": "AssignmentExpression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "AsyncGeneratorMethod",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "async"
        }, {
          "nlt": null
        }, {
          "term": "*"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": ["+Yield", "+Await"],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      }]
    }, {
      "lhs": {
        "name": "AsyncGeneratorDeclaration",
        "params": ["Yield", "Await", "Default"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "async"
        }, {
          "nlt": null
        }, {
          "term": "function"
        }, {
          "term": "*"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": ["+Yield", "+Await"],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      }, {
        "condOpt": {
          "name": "Default",
          "pass": true
        },
        "tokens": [{
          "term": "async"
        }, {
          "nlt": null
        }, {
          "term": "function"
        }, {
          "term": "*"
        }, {
          "term": "("
        }, {
          "args": ["+Yield", "+Await"],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      }]
    }, {
      "lhs": {
        "name": "AsyncGeneratorExpression",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "async"
        }, {
          "nlt": null
        }, {
          "term": "function"
        }, {
          "term": "*"
        }, {
          "args": ["+Yield", "+Await"],
          "name": "BindingIdentifier",
          "optional": true
        }, {
          "term": "("
        }, {
          "args": ["+Yield", "+Await"],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncGeneratorBody",
          "optional": false
        }, {
          "term": "}"
        }]
      }]
    }, {
      "lhs": {
        "name": "AsyncGeneratorBody",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": ["+Yield", "+Await"],
          "name": "FunctionBody",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ClassDeclaration",
        "params": ["Yield", "Await", "Default"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "class"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "args": ["?Yield", "?Await"],
          "name": "ClassTail",
          "optional": false
        }]
      }, {
        "condOpt": {
          "name": "Default",
          "pass": true
        },
        "tokens": [{
          "term": "class"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "ClassTail",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ClassExpression",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "class"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "BindingIdentifier",
          "optional": true
        }, {
          "args": ["?Yield", "?Await"],
          "name": "ClassTail",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ClassTail",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "ClassHeritage",
          "optional": true
        }, {
          "term": "{"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "ClassBody",
          "optional": true
        }, {
          "term": "}"
        }]
      }]
    }, {
      "lhs": {
        "name": "ClassHeritage",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "extends"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "LeftHandSideExpression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ClassBody",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "ClassElementList",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ClassElementList",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "ClassElement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "ClassElementList",
          "optional": false
        }, {
          "args": ["?Yield", "?Await"],
          "name": "ClassElement",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ClassElement",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "MethodDefinition",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "static"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "MethodDefinition",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": ";"
        }]
      }]
    }, {
      "lhs": {
        "name": "AsyncFunctionDeclaration",
        "params": ["Yield", "Await", "Default"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "async"
        }, {
          "nlt": null
        }, {
          "term": "function"
        }, {
          "args": ["?Yield", "?Await"],
          "name": "BindingIdentifier",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": ["~Yield", "+Await"],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      }, {
        "condOpt": {
          "name": "Default",
          "pass": true
        },
        "tokens": [{
          "term": "async"
        }, {
          "nlt": null
        }, {
          "term": "function"
        }, {
          "term": "("
        }, {
          "args": ["~Yield", "+Await"],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      }]
    }, {
      "lhs": {
        "name": "AsyncFunctionExpression",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "async"
        }, {
          "nlt": null
        }, {
          "term": "function"
        }, {
          "args": ["~Yield", "+Await"],
          "name": "BindingIdentifier",
          "optional": true
        }, {
          "term": "("
        }, {
          "args": ["~Yield", "+Await"],
          "name": "FormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      }]
    }, {
      "lhs": {
        "name": "AsyncMethod",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "async"
        }, {
          "nlt": null
        }, {
          "args": ["?Yield", "?Await"],
          "name": "PropertyName",
          "optional": false
        }, {
          "term": "("
        }, {
          "args": ["~Yield", "+Await"],
          "name": "UniqueFormalParameters",
          "optional": false
        }, {
          "term": ")"
        }, {
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      }]
    }, {
      "lhs": {
        "name": "AsyncFunctionBody",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": ["~Yield", "+Await"],
          "name": "FunctionBody",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "AwaitExpression",
        "params": ["Yield"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "await"
        }, {
          "args": ["?Yield", "+Await"],
          "name": "UnaryExpression",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "AsyncArrowFunction",
        "params": ["In", "Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "term": "async"
        }, {
          "nlt": null
        }, {
          "args": ["?Yield"],
          "name": "AsyncArrowBindingIdentifier",
          "optional": false
        }, {
          "nlt": null
        }, {
          "term": "=>"
        }, {
          "args": ["?In"],
          "name": "AsyncConciseBody",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "CoverCallExpressionAndAsyncArrowHead",
          "optional": false
        }, {
          "nlt": null
        }, {
          "term": "=>"
        }, {
          "args": ["?In"],
          "name": "AsyncConciseBody",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "AsyncConciseBody",
        "params": ["In"]
      },
      "rhsList": [{
        "tokens": [{
          "cases": [[{
            "term": "{"
          }]],
          "contains": false
        }, {
          "args": ["?In", "+Await"],
          "name": "ExpressionBody",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "AsyncFunctionBody",
          "optional": false
        }, {
          "term": "}"
        }]
      }]
    }, {
      "lhs": {
        "name": "AsyncArrowBindingIdentifier",
        "params": ["Yield"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "+Await"],
          "name": "BindingIdentifier",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "CoverCallExpressionAndAsyncArrowHead",
        "params": ["Yield", "Await"]
      },
      "rhsList": [{
        "tokens": [{
          "args": ["?Yield", "?Await"],
          "name": "MemberExpression",
          "optional": false
        }, {
          "args": ["?Yield", "?Await"],
          "name": "Arguments",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "AsyncArrowHead",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "async"
        }, {
          "nlt": null
        }, {
          "args": ["~Yield", "+Await"],
          "name": "ArrowFormalParameters",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "Script",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "ScriptBody",
          "optional": true
        }]
      }]
    }, {
      "lhs": {
        "name": "ScriptBody",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": ["~Yield", "~Await", "~Return"],
          "name": "StatementList",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "Module",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "ModuleBody",
          "optional": true
        }]
      }]
    }, {
      "lhs": {
        "name": "ModuleBody",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "ModuleItemList",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ModuleItemList",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "ModuleItem",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "ModuleItemList",
          "optional": false
        }, {
          "args": [],
          "name": "ModuleItem",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ModuleItem",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "ImportDeclaration",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "ExportDeclaration",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": ["~Yield", "~Await", "~Return"],
          "name": "StatementListItem",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ImportDeclaration",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "import"
        }, {
          "args": [],
          "name": "ImportClause",
          "optional": false
        }, {
          "args": [],
          "name": "FromClause",
          "optional": false
        }, {
          "term": ";"
        }]
      }, {
        "tokens": [{
          "term": "import"
        }, {
          "args": [],
          "name": "ModuleSpecifier",
          "optional": false
        }, {
          "term": ";"
        }]
      }]
    }, {
      "lhs": {
        "name": "ImportClause",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "ImportedDefaultBinding",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "NameSpaceImport",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "NamedImports",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "ImportedDefaultBinding",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "NameSpaceImport",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "ImportedDefaultBinding",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "NamedImports",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ImportedDefaultBinding",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "ImportedBinding",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "NameSpaceImport",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "*"
        }, {
          "term": "as"
        }, {
          "args": [],
          "name": "ImportedBinding",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "NamedImports",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      }, {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "ImportsList",
          "optional": false
        }, {
          "term": "}"
        }]
      }, {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "ImportsList",
          "optional": false
        }, {
          "term": ","
        }, {
          "term": "}"
        }]
      }]
    }, {
      "lhs": {
        "name": "FromClause",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "from"
        }, {
          "args": [],
          "name": "ModuleSpecifier",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ImportsList",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "ImportSpecifier",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "ImportsList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "ImportSpecifier",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ImportSpecifier",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "ImportedBinding",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }, {
          "term": "as"
        }, {
          "args": [],
          "name": "ImportedBinding",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ModuleSpecifier",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "StringLiteral",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ImportedBinding",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": ["~Yield", "~Await"],
          "name": "BindingIdentifier",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ExportDeclaration",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "ExportFromClause",
          "optional": false
        }, {
          "args": [],
          "name": "FromClause",
          "optional": false
        }, {
          "term": ";"
        }]
      }, {
        "tokens": [{
          "term": "export"
        }, {
          "args": [],
          "name": "NamedExports",
          "optional": false
        }, {
          "term": ";"
        }]
      }, {
        "tokens": [{
          "term": "export"
        }, {
          "args": ["~Yield", "~Await"],
          "name": "VariableStatement",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "export"
        }, {
          "args": ["~Yield", "~Await"],
          "name": "Declaration",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "export"
        }, {
          "term": "default"
        }, {
          "args": ["~Yield", "~Await", "+Default"],
          "name": "HoistableDeclaration",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "export"
        }, {
          "term": "default"
        }, {
          "args": ["~Yield", "~Await", "+Default"],
          "name": "ClassDeclaration",
          "optional": false
        }]
      }, {
        "tokens": [{
          "term": "export"
        }, {
          "term": "default"
        }, {
          "cases": [[{
            "term": "function"
          }], [{
            "term": "async"
          }, {
            "nlt": null
          }, {
            "term": "function"
          }], [{
            "term": "class"
          }]],
          "contains": false
        }, {
          "args": ["+In", "~Yield", "~Await"],
          "name": "AssignmentExpression",
          "optional": false
        }, {
          "term": ";"
        }]
      }]
    }, {
      "lhs": {
        "name": "ExportFromClause",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "*"
        }]
      }, {
        "tokens": [{
          "term": "*"
        }, {
          "term": "as"
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "NamedExports",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "NamedExports",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "term": "{"
        }, {
          "term": "}"
        }]
      }, {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "ExportsList",
          "optional": false
        }, {
          "term": "}"
        }]
      }, {
        "tokens": [{
          "term": "{"
        }, {
          "args": [],
          "name": "ExportsList",
          "optional": false
        }, {
          "term": ","
        }, {
          "term": "}"
        }]
      }]
    }, {
      "lhs": {
        "name": "ExportsList",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "ExportSpecifier",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "ExportsList",
          "optional": false
        }, {
          "term": ","
        }, {
          "args": [],
          "name": "ExportSpecifier",
          "optional": false
        }]
      }]
    }, {
      "lhs": {
        "name": "ExportSpecifier",
        "params": []
      },
      "rhsList": [{
        "tokens": [{
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      }, {
        "tokens": [{
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }, {
          "term": "as"
        }, {
          "args": [],
          "name": "IdentifierName",
          "optional": false
        }]
      }]
    }]
  },
  "intrinsics": ["Array_prototype_values", "Object_prototype_toString", "Function_prototype", "Symbol", "eval", "String_prototype", "SharedArrayBuffer", "RegExp", "JSON", "Uint8Array", "Symbol_prototype", "Int8Array", "Float64Array", "BigUint64Array", "Number_prototype", "GeneratorFunction_prototype_prototype_next", "Map", "EvalError", "DataView", "URIError", "FinalizationRegistry", "AsyncIteratorPrototype", "Boolean_prototype", "AsyncGeneratorFunction", "RegExp_prototype", "Error", "AsyncFromSyncIteratorPrototype", "MapIteratorPrototype", "IteratorPrototype", "GeneratorFunction_prototype_prototype", "Set", "Number", "String", "WeakMap", "Function", "AsyncFunction_prototype", "parseInt", "AggregateError", "GeneratorFunction", "Boolean", "Object", "isFinite", "AsyncFunction", "Uint8ClampedArray", "AsyncGeneratorFunction_prototype_prototype", "BigInt64Array", "ArrayIteratorPrototype", "Math", "Date", "decodeURIComponent", "Atomics", "decodeURI", "BigInt", "encodeURI", "Float32Array", "Proxy", "AsyncGeneratorFunction_prototype", "SetIteratorPrototype", "WeakRef", "encodeURIComponent", "isNaN", "ForInIteratorPrototype", "WeakSet", "ArrayBuffer", "TypeError", "parseFloat", "TypedArray", "Promise", "ReferenceError", "ThrowTypeError", "RegExpStringIteratorPrototype", "Int16Array", "Array_prototype", "GeneratorFunction_prototype", "Object_prototype", "RangeError", "Array", "Uint16Array", "StringIteratorPrototype", "BigInt_prototype", "Int32Array", "Uint32Array", "SyntaxError", "Reflect"],
  "section": {
    "id": "",
    "subs": [{
      "id": "sec-ecmascript-data-types-and-values",
      "subs": [{
        "id": "sec-ecmascript-language-types",
        "subs": [{
          "id": "sec-ecmascript-language-types-undefined-type",
          "subs": []
        }, {
          "id": "sec-ecmascript-language-types-null-type",
          "subs": []
        }, {
          "id": "sec-ecmascript-language-types-boolean-type",
          "subs": []
        }, {
          "id": "sec-ecmascript-language-types-string-type",
          "subs": [{
            "id": "sec-stringindexof",
            "subs": []
          }]
        }, {
          "id": "sec-ecmascript-language-types-symbol-type",
          "subs": [{
            "id": "sec-well-known-symbols",
            "subs": []
          }]
        }, {
          "id": "sec-numeric-types",
          "subs": [{
            "id": "sec-ecmascript-language-types-number-type",
            "subs": [{
              "id": "sec-numeric-types-number-unaryMinus",
              "subs": []
            }, {
              "id": "sec-numeric-types-number-bitwiseNOT",
              "subs": []
            }, {
              "id": "sec-numeric-types-number-exponentiate",
              "subs": []
            }, {
              "id": "sec-numeric-types-number-multiply",
              "subs": []
            }, {
              "id": "sec-numeric-types-number-divide",
              "subs": []
            }, {
              "id": "sec-numeric-types-number-remainder",
              "subs": []
            }, {
              "id": "sec-numeric-types-number-add",
              "subs": []
            }, {
              "id": "sec-numeric-types-number-subtract",
              "subs": []
            }, {
              "id": "sec-numeric-types-number-leftShift",
              "subs": []
            }, {
              "id": "sec-numeric-types-number-signedRightShift",
              "subs": []
            }, {
              "id": "sec-numeric-types-number-unsignedRightShift",
              "subs": []
            }, {
              "id": "sec-numeric-types-number-lessThan",
              "subs": []
            }, {
              "id": "sec-numeric-types-number-equal",
              "subs": []
            }, {
              "id": "sec-numeric-types-number-sameValue",
              "subs": []
            }, {
              "id": "sec-numeric-types-number-sameValueZero",
              "subs": []
            }, {
              "id": "sec-numberbitwiseop",
              "subs": []
            }, {
              "id": "sec-numeric-types-number-bitwiseAND",
              "subs": []
            }, {
              "id": "sec-numeric-types-number-bitwiseXOR",
              "subs": []
            }, {
              "id": "sec-numeric-types-number-bitwiseOR",
              "subs": []
            }, {
              "id": "sec-numeric-types-number-tostring",
              "subs": []
            }]
          }, {
            "id": "sec-ecmascript-language-types-bigint-type",
            "subs": [{
              "id": "sec-numeric-types-bigint-unaryMinus",
              "subs": []
            }, {
              "id": "sec-numeric-types-bigint-bitwiseNOT",
              "subs": []
            }, {
              "id": "sec-numeric-types-bigint-exponentiate",
              "subs": []
            }, {
              "id": "sec-numeric-types-bigint-multiply",
              "subs": []
            }, {
              "id": "sec-numeric-types-bigint-divide",
              "subs": []
            }, {
              "id": "sec-numeric-types-bigint-remainder",
              "subs": []
            }, {
              "id": "sec-numeric-types-bigint-add",
              "subs": []
            }, {
              "id": "sec-numeric-types-bigint-subtract",
              "subs": []
            }, {
              "id": "sec-numeric-types-bigint-leftShift",
              "subs": []
            }, {
              "id": "sec-numeric-types-bigint-signedRightShift",
              "subs": []
            }, {
              "id": "sec-numeric-types-bigint-unsignedRightShift",
              "subs": []
            }, {
              "id": "sec-numeric-types-bigint-lessThan",
              "subs": []
            }, {
              "id": "sec-numeric-types-bigint-equal",
              "subs": []
            }, {
              "id": "sec-numeric-types-bigint-sameValue",
              "subs": []
            }, {
              "id": "sec-numeric-types-bigint-sameValueZero",
              "subs": []
            }, {
              "id": "sec-binaryand",
              "subs": []
            }, {
              "id": "sec-binaryor",
              "subs": []
            }, {
              "id": "sec-binaryxor",
              "subs": []
            }, {
              "id": "sec-bigintbitwiseop",
              "subs": []
            }, {
              "id": "sec-numeric-types-bigint-bitwiseAND",
              "subs": []
            }, {
              "id": "sec-numeric-types-bigint-bitwiseXOR",
              "subs": []
            }, {
              "id": "sec-numeric-types-bigint-bitwiseOR",
              "subs": []
            }, {
              "id": "sec-numeric-types-bigint-tostring",
              "subs": []
            }]
          }]
        }, {
          "id": "sec-object-type",
          "subs": [{
            "id": "sec-property-attributes",
            "subs": []
          }, {
            "id": "sec-object-internal-methods-and-internal-slots",
            "subs": []
          }, {
            "id": "sec-invariants-of-the-essential-internal-methods",
            "subs": []
          }, {
            "id": "sec-well-known-intrinsic-objects",
            "subs": []
          }]
        }]
      }, {
        "id": "sec-ecmascript-specification-types",
        "subs": [{
          "id": "sec-list-and-record-specification-type",
          "subs": []
        }, {
          "id": "sec-set-and-relation-specification-type",
          "subs": []
        }, {
          "id": "sec-completion-record-specification-type",
          "subs": [{
            "id": "await",
            "subs": [{
              "id": "await-fulfilled",
              "subs": []
            }, {
              "id": "await-rejected",
              "subs": []
            }]
          }, {
            "id": "sec-normalcompletion",
            "subs": []
          }, {
            "id": "sec-throwcompletion",
            "subs": []
          }, {
            "id": "sec-updateempty",
            "subs": []
          }]
        }, {
          "id": "sec-reference-record-specification-type",
          "subs": [{
            "id": "sec-ispropertyreference",
            "subs": []
          }, {
            "id": "sec-isunresolvablereference",
            "subs": []
          }, {
            "id": "sec-issuperreference",
            "subs": []
          }, {
            "id": "sec-getvalue",
            "subs": []
          }, {
            "id": "sec-putvalue",
            "subs": []
          }, {
            "id": "sec-getthisvalue",
            "subs": []
          }, {
            "id": "sec-initializereferencedbinding",
            "subs": []
          }]
        }, {
          "id": "sec-property-descriptor-specification-type",
          "subs": [{
            "id": "sec-isaccessordescriptor",
            "subs": []
          }, {
            "id": "sec-isdatadescriptor",
            "subs": []
          }, {
            "id": "sec-isgenericdescriptor",
            "subs": []
          }, {
            "id": "sec-frompropertydescriptor",
            "subs": []
          }, {
            "id": "sec-topropertydescriptor",
            "subs": []
          }, {
            "id": "sec-completepropertydescriptor",
            "subs": []
          }]
        }, {
          "id": "sec-lexical-environment-and-environment-record-specification-types",
          "subs": []
        }, {
          "id": "sec-abstract-closure",
          "subs": []
        }, {
          "id": "sec-data-blocks",
          "subs": [{
            "id": "sec-createbytedatablock",
            "subs": []
          }, {
            "id": "sec-createsharedbytedatablock",
            "subs": []
          }, {
            "id": "sec-copydatablockbytes",
            "subs": []
          }]
        }]
      }]
    }, {
      "id": "sec-abstract-operations",
      "subs": [{
        "id": "sec-type-conversion",
        "subs": [{
          "id": "sec-toprimitive",
          "subs": [{
            "id": "sec-ordinarytoprimitive",
            "subs": []
          }]
        }, {
          "id": "sec-toboolean",
          "subs": []
        }, {
          "id": "sec-tonumeric",
          "subs": []
        }, {
          "id": "sec-tonumber",
          "subs": [{
            "id": "sec-tonumber-applied-to-the-string-type",
            "subs": [{
              "id": "sec-runtime-semantics-mv-s",
              "subs": []
            }]
          }]
        }, {
          "id": "sec-tointegerorinfinity",
          "subs": []
        }, {
          "id": "sec-toint32",
          "subs": []
        }, {
          "id": "sec-touint32",
          "subs": []
        }, {
          "id": "sec-toint16",
          "subs": []
        }, {
          "id": "sec-touint16",
          "subs": []
        }, {
          "id": "sec-toint8",
          "subs": []
        }, {
          "id": "sec-touint8",
          "subs": []
        }, {
          "id": "sec-touint8clamp",
          "subs": []
        }, {
          "id": "sec-tobigint",
          "subs": []
        }, {
          "id": "sec-stringtobigint",
          "subs": []
        }, {
          "id": "sec-tobigint64",
          "subs": []
        }, {
          "id": "sec-tobiguint64",
          "subs": []
        }, {
          "id": "sec-tostring",
          "subs": []
        }, {
          "id": "sec-toobject",
          "subs": []
        }, {
          "id": "sec-topropertykey",
          "subs": []
        }, {
          "id": "sec-tolength",
          "subs": []
        }, {
          "id": "sec-canonicalnumericindexstring",
          "subs": []
        }, {
          "id": "sec-toindex",
          "subs": []
        }]
      }, {
        "id": "sec-testing-and-comparison-operations",
        "subs": [{
          "id": "sec-requireobjectcoercible",
          "subs": []
        }, {
          "id": "sec-isarray",
          "subs": []
        }, {
          "id": "sec-iscallable",
          "subs": []
        }, {
          "id": "sec-isconstructor",
          "subs": []
        }, {
          "id": "sec-isextensible-o",
          "subs": []
        }, {
          "id": "sec-isintegralnumber",
          "subs": []
        }, {
          "id": "sec-ispropertykey",
          "subs": []
        }, {
          "id": "sec-isregexp",
          "subs": []
        }, {
          "id": "sec-isstringprefix",
          "subs": []
        }, {
          "id": "sec-samevalue",
          "subs": []
        }, {
          "id": "sec-samevaluezero",
          "subs": []
        }, {
          "id": "sec-samevaluenonnumeric",
          "subs": []
        }, {
          "id": "sec-abstract-relational-comparison",
          "subs": []
        }, {
          "id": "sec-abstract-equality-comparison",
          "subs": []
        }, {
          "id": "sec-strict-equality-comparison",
          "subs": []
        }]
      }, {
        "id": "sec-operations-on-objects",
        "subs": [{
          "id": "sec-makebasicobject",
          "subs": []
        }, {
          "id": "sec-get-o-p",
          "subs": []
        }, {
          "id": "sec-getv",
          "subs": []
        }, {
          "id": "sec-set-o-p-v-throw",
          "subs": []
        }, {
          "id": "sec-createdataproperty",
          "subs": []
        }, {
          "id": "sec-createmethodproperty",
          "subs": []
        }, {
          "id": "sec-createdatapropertyorthrow",
          "subs": []
        }, {
          "id": "sec-definepropertyorthrow",
          "subs": []
        }, {
          "id": "sec-deletepropertyorthrow",
          "subs": []
        }, {
          "id": "sec-getmethod",
          "subs": []
        }, {
          "id": "sec-hasproperty",
          "subs": []
        }, {
          "id": "sec-hasownproperty",
          "subs": []
        }, {
          "id": "sec-call",
          "subs": []
        }, {
          "id": "sec-construct",
          "subs": []
        }, {
          "id": "sec-setintegritylevel",
          "subs": []
        }, {
          "id": "sec-testintegritylevel",
          "subs": []
        }, {
          "id": "sec-createarrayfromlist",
          "subs": []
        }, {
          "id": "sec-lengthofarraylike",
          "subs": []
        }, {
          "id": "sec-createlistfromarraylike",
          "subs": []
        }, {
          "id": "sec-invoke",
          "subs": []
        }, {
          "id": "sec-ordinaryhasinstance",
          "subs": []
        }, {
          "id": "sec-speciesconstructor",
          "subs": []
        }, {
          "id": "sec-enumerableownpropertynames",
          "subs": []
        }, {
          "id": "sec-getfunctionrealm",
          "subs": []
        }, {
          "id": "sec-copydataproperties",
          "subs": []
        }]
      }, {
        "id": "sec-operations-on-iterator-objects",
        "subs": [{
          "id": "sec-getiterator",
          "subs": []
        }, {
          "id": "sec-iteratornext",
          "subs": []
        }, {
          "id": "sec-iteratorcomplete",
          "subs": []
        }, {
          "id": "sec-iteratorvalue",
          "subs": []
        }, {
          "id": "sec-iteratorstep",
          "subs": []
        }, {
          "id": "sec-iteratorclose",
          "subs": []
        }, {
          "id": "sec-asynciteratorclose",
          "subs": []
        }, {
          "id": "sec-createiterresultobject",
          "subs": []
        }, {
          "id": "sec-createlistiteratorRecord",
          "subs": []
        }, {
          "id": "sec-iterabletolist",
          "subs": []
        }]
      }]
    }, {
      "id": "sec-syntax-directed-operations",
      "subs": [{
        "id": "sec-syntax-directed-operations-scope-analysis",
        "subs": [{
          "id": "sec-static-semantics-boundnames",
          "subs": []
        }, {
          "id": "sec-static-semantics-declarationpart",
          "subs": []
        }, {
          "id": "sec-static-semantics-isconstantdeclaration",
          "subs": []
        }, {
          "id": "sec-static-semantics-lexicallydeclarednames",
          "subs": []
        }, {
          "id": "sec-static-semantics-lexicallyscopeddeclarations",
          "subs": []
        }, {
          "id": "sec-static-semantics-vardeclarednames",
          "subs": []
        }, {
          "id": "sec-static-semantics-varscopeddeclarations",
          "subs": []
        }, {
          "id": "sec-static-semantics-toplevellexicallydeclarednames",
          "subs": []
        }, {
          "id": "sec-static-semantics-toplevellexicallyscopeddeclarations",
          "subs": []
        }, {
          "id": "sec-static-semantics-toplevelvardeclarednames",
          "subs": []
        }, {
          "id": "sec-static-semantics-toplevelvarscopeddeclarations",
          "subs": []
        }]
      }, {
        "id": "sec-syntax-directed-operations-labels",
        "subs": [{
          "id": "sec-static-semantics-containsduplicatelabels",
          "subs": []
        }, {
          "id": "sec-static-semantics-containsundefinedbreaktarget",
          "subs": []
        }, {
          "id": "sec-static-semantics-containsundefinedcontinuetarget",
          "subs": []
        }]
      }, {
        "id": "sec-syntax-directed-operations-function-name-inference",
        "subs": [{
          "id": "sec-static-semantics-hasname",
          "subs": []
        }, {
          "id": "sec-static-semantics-isfunctiondefinition",
          "subs": []
        }, {
          "id": "sec-isanonymousfunctiondefinition",
          "subs": []
        }, {
          "id": "sec-static-semantics-isidentifierref",
          "subs": []
        }, {
          "id": "sec-runtime-semantics-namedevaluation",
          "subs": []
        }]
      }, {
        "id": "sec-syntax-directed-operations-contains",
        "subs": [{
          "id": "sec-static-semantics-contains",
          "subs": []
        }, {
          "id": "sec-static-semantics-computedpropertycontains",
          "subs": []
        }]
      }, {
        "id": "sec-syntax-directed-operations-miscellaneous",
        "subs": [{
          "id": "sec-runtime-semantics-instantiatefunctionobject",
          "subs": []
        }, {
          "id": "sec-runtime-semantics-bindinginitialization",
          "subs": [{
            "id": "sec-initializeboundname",
            "subs": []
          }]
        }, {
          "id": "sec-runtime-semantics-iteratorbindinginitialization",
          "subs": []
        }, {
          "id": "sec-static-semantics-assignmenttargettype",
          "subs": []
        }, {
          "id": "sec-static-semantics-propname",
          "subs": []
        }]
      }]
    }, {
      "id": "sec-executable-code-and-execution-contexts",
      "subs": [{
        "id": "sec-environment-records",
        "subs": [{
          "id": "sec-the-environment-record-type-hierarchy",
          "subs": [{
            "id": "sec-declarative-environment-records",
            "subs": [{
              "id": "sec-declarative-environment-records-hasbinding-n",
              "subs": []
            }, {
              "id": "sec-declarative-environment-records-createmutablebinding-n-d",
              "subs": []
            }, {
              "id": "sec-declarative-environment-records-createimmutablebinding-n-s",
              "subs": []
            }, {
              "id": "sec-declarative-environment-records-initializebinding-n-v",
              "subs": []
            }, {
              "id": "sec-declarative-environment-records-setmutablebinding-n-v-s",
              "subs": []
            }, {
              "id": "sec-declarative-environment-records-getbindingvalue-n-s",
              "subs": []
            }, {
              "id": "sec-declarative-environment-records-deletebinding-n",
              "subs": []
            }, {
              "id": "sec-declarative-environment-records-hasthisbinding",
              "subs": []
            }, {
              "id": "sec-declarative-environment-records-hassuperbinding",
              "subs": []
            }, {
              "id": "sec-declarative-environment-records-withbaseobject",
              "subs": []
            }]
          }, {
            "id": "sec-object-environment-records",
            "subs": [{
              "id": "sec-object-environment-records-hasbinding-n",
              "subs": []
            }, {
              "id": "sec-object-environment-records-createmutablebinding-n-d",
              "subs": []
            }, {
              "id": "sec-object-environment-records-createimmutablebinding-n-s",
              "subs": []
            }, {
              "id": "sec-object-environment-records-initializebinding-n-v",
              "subs": []
            }, {
              "id": "sec-object-environment-records-setmutablebinding-n-v-s",
              "subs": []
            }, {
              "id": "sec-object-environment-records-getbindingvalue-n-s",
              "subs": []
            }, {
              "id": "sec-object-environment-records-deletebinding-n",
              "subs": []
            }, {
              "id": "sec-object-environment-records-hasthisbinding",
              "subs": []
            }, {
              "id": "sec-object-environment-records-hassuperbinding",
              "subs": []
            }, {
              "id": "sec-object-environment-records-withbaseobject",
              "subs": []
            }]
          }, {
            "id": "sec-function-environment-records",
            "subs": [{
              "id": "sec-bindthisvalue",
              "subs": []
            }, {
              "id": "sec-function-environment-records-hasthisbinding",
              "subs": []
            }, {
              "id": "sec-function-environment-records-hassuperbinding",
              "subs": []
            }, {
              "id": "sec-function-environment-records-getthisbinding",
              "subs": []
            }, {
              "id": "sec-getsuperbase",
              "subs": []
            }]
          }, {
            "id": "sec-global-environment-records",
            "subs": [{
              "id": "sec-global-environment-records-hasbinding-n",
              "subs": []
            }, {
              "id": "sec-global-environment-records-createmutablebinding-n-d",
              "subs": []
            }, {
              "id": "sec-global-environment-records-createimmutablebinding-n-s",
              "subs": []
            }, {
              "id": "sec-global-environment-records-initializebinding-n-v",
              "subs": []
            }, {
              "id": "sec-global-environment-records-setmutablebinding-n-v-s",
              "subs": []
            }, {
              "id": "sec-global-environment-records-getbindingvalue-n-s",
              "subs": []
            }, {
              "id": "sec-global-environment-records-deletebinding-n",
              "subs": []
            }, {
              "id": "sec-global-environment-records-hasthisbinding",
              "subs": []
            }, {
              "id": "sec-global-environment-records-hassuperbinding",
              "subs": []
            }, {
              "id": "sec-global-environment-records-withbaseobject",
              "subs": []
            }, {
              "id": "sec-global-environment-records-getthisbinding",
              "subs": []
            }, {
              "id": "sec-hasvardeclaration",
              "subs": []
            }, {
              "id": "sec-haslexicaldeclaration",
              "subs": []
            }, {
              "id": "sec-hasrestrictedglobalproperty",
              "subs": []
            }, {
              "id": "sec-candeclareglobalvar",
              "subs": []
            }, {
              "id": "sec-candeclareglobalfunction",
              "subs": []
            }, {
              "id": "sec-createglobalvarbinding",
              "subs": []
            }, {
              "id": "sec-createglobalfunctionbinding",
              "subs": []
            }]
          }, {
            "id": "sec-module-environment-records",
            "subs": [{
              "id": "sec-module-environment-records-getbindingvalue-n-s",
              "subs": []
            }, {
              "id": "sec-module-environment-records-deletebinding-n",
              "subs": []
            }, {
              "id": "sec-module-environment-records-hasthisbinding",
              "subs": []
            }, {
              "id": "sec-module-environment-records-getthisbinding",
              "subs": []
            }, {
              "id": "sec-createimportbinding",
              "subs": []
            }]
          }]
        }, {
          "id": "sec-environment-record-operations",
          "subs": [{
            "id": "sec-getidentifierreference",
            "subs": []
          }, {
            "id": "sec-newdeclarativeenvironment",
            "subs": []
          }, {
            "id": "sec-newobjectenvironment",
            "subs": []
          }, {
            "id": "sec-newfunctionenvironment",
            "subs": []
          }, {
            "id": "sec-newglobalenvironment",
            "subs": []
          }, {
            "id": "sec-newmoduleenvironment",
            "subs": []
          }]
        }]
      }, {
        "id": "sec-code-realms",
        "subs": [{
          "id": "sec-createrealm",
          "subs": []
        }, {
          "id": "sec-createintrinsics",
          "subs": []
        }, {
          "id": "sec-setrealmglobalobject",
          "subs": []
        }, {
          "id": "sec-setdefaultglobalbindings",
          "subs": []
        }]
      }, {
        "id": "sec-execution-contexts",
        "subs": [{
          "id": "sec-getactivescriptormodule",
          "subs": []
        }, {
          "id": "sec-resolvebinding",
          "subs": []
        }, {
          "id": "sec-getthisenvironment",
          "subs": []
        }, {
          "id": "sec-resolvethisbinding",
          "subs": []
        }, {
          "id": "sec-getnewtarget",
          "subs": []
        }, {
          "id": "sec-getglobalobject",
          "subs": []
        }]
      }, {
        "id": "sec-jobs",
        "subs": [{
          "id": "sec-jobcallback-records",
          "subs": []
        }, {
          "id": "sec-hostmakejobcallback",
          "subs": []
        }, {
          "id": "sec-hostcalljobcallback",
          "subs": []
        }, {
          "id": "sec-hostenqueuepromisejob",
          "subs": []
        }]
      }, {
        "id": "sec-initializehostdefinedrealm",
        "subs": []
      }, {
        "id": "sec-agents",
        "subs": [{
          "id": "sec-agentsignifier",
          "subs": []
        }, {
          "id": "sec-agentcansuspend",
          "subs": []
        }]
      }, {
        "id": "sec-agent-clusters",
        "subs": []
      }, {
        "id": "sec-forward-progress",
        "subs": []
      }, {
        "id": "sec-weakref-processing-model",
        "subs": [{
          "id": "sec-weakref-invariants",
          "subs": []
        }, {
          "id": "sec-liveness",
          "subs": []
        }, {
          "id": "sec-weakref-execution",
          "subs": []
        }, {
          "id": "sec-weakref-host-hooks",
          "subs": [{
            "id": "sec-host-cleanup-finalization-registry",
            "subs": []
          }]
        }]
      }, {
        "id": "sec-clear-kept-objects",
        "subs": []
      }, {
        "id": "sec-addtokeptobjects",
        "subs": []
      }, {
        "id": "sec-cleanup-finalization-registry",
        "subs": []
      }]
    }, {
      "id": "sec-ordinary-and-exotic-objects-behaviours",
      "subs": [{
        "id": "sec-ordinary-object-internal-methods-and-internal-slots",
        "subs": [{
          "id": "sec-ordinary-object-internal-methods-and-internal-slots-getprototypeof",
          "subs": [{
            "id": "sec-ordinarygetprototypeof",
            "subs": []
          }]
        }, {
          "id": "sec-ordinary-object-internal-methods-and-internal-slots-setprototypeof-v",
          "subs": [{
            "id": "sec-ordinarysetprototypeof",
            "subs": []
          }]
        }, {
          "id": "sec-ordinary-object-internal-methods-and-internal-slots-isextensible",
          "subs": [{
            "id": "sec-ordinaryisextensible",
            "subs": []
          }]
        }, {
          "id": "sec-ordinary-object-internal-methods-and-internal-slots-preventextensions",
          "subs": [{
            "id": "sec-ordinarypreventextensions",
            "subs": []
          }]
        }, {
          "id": "sec-ordinary-object-internal-methods-and-internal-slots-getownproperty-p",
          "subs": [{
            "id": "sec-ordinarygetownproperty",
            "subs": []
          }]
        }, {
          "id": "sec-ordinary-object-internal-methods-and-internal-slots-defineownproperty-p-desc",
          "subs": [{
            "id": "sec-ordinarydefineownproperty",
            "subs": []
          }, {
            "id": "sec-iscompatiblepropertydescriptor",
            "subs": []
          }, {
            "id": "sec-validateandapplypropertydescriptor",
            "subs": []
          }]
        }, {
          "id": "sec-ordinary-object-internal-methods-and-internal-slots-hasproperty-p",
          "subs": [{
            "id": "sec-ordinaryhasproperty",
            "subs": []
          }]
        }, {
          "id": "sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver",
          "subs": [{
            "id": "sec-ordinaryget",
            "subs": []
          }]
        }, {
          "id": "sec-ordinary-object-internal-methods-and-internal-slots-set-p-v-receiver",
          "subs": [{
            "id": "sec-ordinaryset",
            "subs": []
          }, {
            "id": "sec-ordinarysetwithowndescriptor",
            "subs": []
          }]
        }, {
          "id": "sec-ordinary-object-internal-methods-and-internal-slots-delete-p",
          "subs": [{
            "id": "sec-ordinarydelete",
            "subs": []
          }]
        }, {
          "id": "sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys",
          "subs": [{
            "id": "sec-ordinaryownpropertykeys",
            "subs": []
          }]
        }, {
          "id": "sec-ordinaryobjectcreate",
          "subs": []
        }, {
          "id": "sec-ordinarycreatefromconstructor",
          "subs": []
        }, {
          "id": "sec-getprototypefromconstructor",
          "subs": []
        }, {
          "id": "sec-requireinternalslot",
          "subs": []
        }]
      }, {
        "id": "sec-ecmascript-function-objects",
        "subs": [{
          "id": "sec-ecmascript-function-objects-call-thisargument-argumentslist",
          "subs": [{
            "id": "sec-prepareforordinarycall",
            "subs": []
          }, {
            "id": "sec-ordinarycallbindthis",
            "subs": []
          }, {
            "id": "sec-runtime-semantics-evaluatebody",
            "subs": []
          }, {
            "id": "sec-ordinarycallevaluatebody",
            "subs": []
          }]
        }, {
          "id": "sec-ecmascript-function-objects-construct-argumentslist-newtarget",
          "subs": []
        }, {
          "id": "sec-ordinaryfunctioncreate",
          "subs": []
        }, {
          "id": "sec-addrestrictedfunctionproperties",
          "subs": [{
            "id": "sec-%throwtypeerror%",
            "subs": []
          }]
        }, {
          "id": "sec-makeconstructor",
          "subs": []
        }, {
          "id": "sec-makeclassconstructor",
          "subs": []
        }, {
          "id": "sec-makemethod",
          "subs": []
        }, {
          "id": "sec-setfunctionname",
          "subs": []
        }, {
          "id": "sec-setfunctionlength",
          "subs": []
        }, {
          "id": "sec-functiondeclarationinstantiation",
          "subs": []
        }]
      }, {
        "id": "sec-built-in-function-objects",
        "subs": [{
          "id": "sec-built-in-function-objects-call-thisargument-argumentslist",
          "subs": []
        }, {
          "id": "sec-built-in-function-objects-construct-argumentslist-newtarget",
          "subs": []
        }, {
          "id": "sec-createbuiltinfunction",
          "subs": []
        }]
      }, {
        "id": "sec-built-in-exotic-object-internal-methods-and-slots",
        "subs": [{
          "id": "sec-bound-function-exotic-objects",
          "subs": [{
            "id": "sec-bound-function-exotic-objects-call-thisargument-argumentslist",
            "subs": []
          }, {
            "id": "sec-bound-function-exotic-objects-construct-argumentslist-newtarget",
            "subs": []
          }, {
            "id": "sec-boundfunctioncreate",
            "subs": []
          }]
        }, {
          "id": "sec-array-exotic-objects",
          "subs": [{
            "id": "sec-array-exotic-objects-defineownproperty-p-desc",
            "subs": []
          }, {
            "id": "sec-arraycreate",
            "subs": []
          }, {
            "id": "sec-arrayspeciescreate",
            "subs": []
          }, {
            "id": "sec-arraysetlength",
            "subs": []
          }]
        }, {
          "id": "sec-string-exotic-objects",
          "subs": [{
            "id": "sec-string-exotic-objects-getownproperty-p",
            "subs": []
          }, {
            "id": "sec-string-exotic-objects-defineownproperty-p-desc",
            "subs": []
          }, {
            "id": "sec-string-exotic-objects-ownpropertykeys",
            "subs": []
          }, {
            "id": "sec-stringcreate",
            "subs": []
          }, {
            "id": "sec-stringgetownproperty",
            "subs": []
          }]
        }, {
          "id": "sec-arguments-exotic-objects",
          "subs": [{
            "id": "sec-arguments-exotic-objects-getownproperty-p",
            "subs": []
          }, {
            "id": "sec-arguments-exotic-objects-defineownproperty-p-desc",
            "subs": []
          }, {
            "id": "sec-arguments-exotic-objects-get-p-receiver",
            "subs": []
          }, {
            "id": "sec-arguments-exotic-objects-set-p-v-receiver",
            "subs": []
          }, {
            "id": "sec-arguments-exotic-objects-delete-p",
            "subs": []
          }, {
            "id": "sec-createunmappedargumentsobject",
            "subs": []
          }, {
            "id": "sec-createmappedargumentsobject",
            "subs": [{
              "id": "sec-makearggetter",
              "subs": []
            }, {
              "id": "sec-makeargsetter",
              "subs": []
            }]
          }]
        }, {
          "id": "sec-integer-indexed-exotic-objects",
          "subs": [{
            "id": "sec-integer-indexed-exotic-objects-getownproperty-p",
            "subs": []
          }, {
            "id": "sec-integer-indexed-exotic-objects-hasproperty-p",
            "subs": []
          }, {
            "id": "sec-integer-indexed-exotic-objects-defineownproperty-p-desc",
            "subs": []
          }, {
            "id": "sec-integer-indexed-exotic-objects-get-p-receiver",
            "subs": []
          }, {
            "id": "sec-integer-indexed-exotic-objects-set-p-v-receiver",
            "subs": []
          }, {
            "id": "sec-integer-indexed-exotic-objects-delete-p",
            "subs": []
          }, {
            "id": "sec-integer-indexed-exotic-objects-ownpropertykeys",
            "subs": []
          }, {
            "id": "sec-integerindexedobjectcreate",
            "subs": []
          }, {
            "id": "sec-isvalidintegerindex",
            "subs": []
          }, {
            "id": "sec-integerindexedelementget",
            "subs": []
          }, {
            "id": "sec-integerindexedelementset",
            "subs": []
          }]
        }, {
          "id": "sec-module-namespace-exotic-objects",
          "subs": [{
            "id": "sec-module-namespace-exotic-objects-setprototypeof-v",
            "subs": []
          }, {
            "id": "sec-module-namespace-exotic-objects-isextensible",
            "subs": []
          }, {
            "id": "sec-module-namespace-exotic-objects-preventextensions",
            "subs": []
          }, {
            "id": "sec-module-namespace-exotic-objects-getownproperty-p",
            "subs": []
          }, {
            "id": "sec-module-namespace-exotic-objects-defineownproperty-p-desc",
            "subs": []
          }, {
            "id": "sec-module-namespace-exotic-objects-hasproperty-p",
            "subs": []
          }, {
            "id": "sec-module-namespace-exotic-objects-get-p-receiver",
            "subs": []
          }, {
            "id": "sec-module-namespace-exotic-objects-set-p-v-receiver",
            "subs": []
          }, {
            "id": "sec-module-namespace-exotic-objects-delete-p",
            "subs": []
          }, {
            "id": "sec-module-namespace-exotic-objects-ownpropertykeys",
            "subs": []
          }, {
            "id": "sec-modulenamespacecreate",
            "subs": []
          }]
        }, {
          "id": "sec-immutable-prototype-exotic-objects",
          "subs": [{
            "id": "sec-immutable-prototype-exotic-objects-setprototypeof-v",
            "subs": []
          }, {
            "id": "sec-set-immutable-prototype",
            "subs": []
          }]
        }]
      }, {
        "id": "sec-proxy-object-internal-methods-and-internal-slots",
        "subs": [{
          "id": "sec-proxy-object-internal-methods-and-internal-slots-getprototypeof",
          "subs": []
        }, {
          "id": "sec-proxy-object-internal-methods-and-internal-slots-setprototypeof-v",
          "subs": []
        }, {
          "id": "sec-proxy-object-internal-methods-and-internal-slots-isextensible",
          "subs": []
        }, {
          "id": "sec-proxy-object-internal-methods-and-internal-slots-preventextensions",
          "subs": []
        }, {
          "id": "sec-proxy-object-internal-methods-and-internal-slots-getownproperty-p",
          "subs": []
        }, {
          "id": "sec-proxy-object-internal-methods-and-internal-slots-defineownproperty-p-desc",
          "subs": []
        }, {
          "id": "sec-proxy-object-internal-methods-and-internal-slots-hasproperty-p",
          "subs": []
        }, {
          "id": "sec-proxy-object-internal-methods-and-internal-slots-get-p-receiver",
          "subs": []
        }, {
          "id": "sec-proxy-object-internal-methods-and-internal-slots-set-p-v-receiver",
          "subs": []
        }, {
          "id": "sec-proxy-object-internal-methods-and-internal-slots-delete-p",
          "subs": []
        }, {
          "id": "sec-proxy-object-internal-methods-and-internal-slots-ownpropertykeys",
          "subs": []
        }, {
          "id": "sec-proxy-object-internal-methods-and-internal-slots-call-thisargument-argumentslist",
          "subs": []
        }, {
          "id": "sec-proxy-object-internal-methods-and-internal-slots-construct-argumentslist-newtarget",
          "subs": []
        }, {
          "id": "sec-proxycreate",
          "subs": []
        }]
      }]
    }, {
      "id": "sec-ecmascript-language-source-code",
      "subs": [{
        "id": "sec-source-text",
        "subs": [{
          "id": "sec-utf16encodecodepoint",
          "subs": []
        }, {
          "id": "sec-codepointstostring",
          "subs": []
        }, {
          "id": "sec-utf16decodesurrogatepair",
          "subs": []
        }, {
          "id": "sec-codepointat",
          "subs": []
        }, {
          "id": "sec-stringtocodepoints",
          "subs": []
        }, {
          "id": "sec-parsetext",
          "subs": []
        }]
      }, {
        "id": "sec-types-of-source-code",
        "subs": [{
          "id": "sec-directive-prologues-and-the-use-strict-directive",
          "subs": []
        }, {
          "id": "sec-strict-mode-code",
          "subs": []
        }, {
          "id": "sec-non-ecmascript-functions",
          "subs": []
        }]
      }]
    }, {
      "id": "sec-ecmascript-language-lexical-grammar",
      "subs": [{
        "id": "sec-unicode-format-control-characters",
        "subs": []
      }, {
        "id": "sec-white-space",
        "subs": []
      }, {
        "id": "sec-line-terminators",
        "subs": []
      }, {
        "id": "sec-comments",
        "subs": []
      }, {
        "id": "sec-tokens",
        "subs": []
      }, {
        "id": "sec-names-and-keywords",
        "subs": [{
          "id": "sec-identifier-names",
          "subs": [{
            "id": "sec-identifier-names-static-semantics-early-errors",
            "subs": []
          }]
        }, {
          "id": "sec-keywords-and-reserved-words",
          "subs": []
        }]
      }, {
        "id": "sec-punctuators",
        "subs": []
      }, {
        "id": "sec-ecmascript-language-lexical-grammar-literals",
        "subs": [{
          "id": "sec-null-literals",
          "subs": []
        }, {
          "id": "sec-boolean-literals",
          "subs": []
        }, {
          "id": "sec-literals-numeric-literals",
          "subs": [{
            "id": "sec-static-semantics-mv",
            "subs": []
          }, {
            "id": "sec-numericvalue",
            "subs": []
          }]
        }, {
          "id": "sec-literals-string-literals",
          "subs": [{
            "id": "sec-static-semantics-sv",
            "subs": []
          }, {
            "id": "sec-string-literals-static-semantics-mv",
            "subs": []
          }]
        }, {
          "id": "sec-literals-regular-expression-literals",
          "subs": [{
            "id": "sec-literals-regular-expression-literals-static-semantics-early-errors",
            "subs": []
          }, {
            "id": "sec-static-semantics-bodytext",
            "subs": []
          }, {
            "id": "sec-static-semantics-flagtext",
            "subs": []
          }]
        }, {
          "id": "sec-template-literal-lexical-components",
          "subs": [{
            "id": "sec-static-semantics-tv-and-trv",
            "subs": []
          }]
        }]
      }, {
        "id": "sec-automatic-semicolon-insertion",
        "subs": [{
          "id": "sec-rules-of-automatic-semicolon-insertion",
          "subs": []
        }, {
          "id": "sec-examples-of-automatic-semicolon-insertion",
          "subs": []
        }, {
          "id": "sec-interesting-cases-of-automatic-semicolon-insertion",
          "subs": [{
            "id": "sec-asi-interesting-cases-in-statement-lists",
            "subs": []
          }, {
            "id": "sec-asi-cases-with-no-lineterminator-here",
            "subs": [{
              "id": "sec-no-lineterminator-here-automatic-semicolon-insertion-list",
              "subs": []
            }]
          }]
        }]
      }]
    }, {
      "id": "sec-ecmascript-language-expressions",
      "subs": [{
        "id": "sec-identifiers",
        "subs": [{
          "id": "sec-identifiers-static-semantics-early-errors",
          "subs": []
        }, {
          "id": "sec-static-semantics-stringvalue",
          "subs": []
        }, {
          "id": "sec-identifiers-runtime-semantics-evaluation",
          "subs": []
        }]
      }, {
        "id": "sec-primary-expression",
        "subs": [{
          "id": "sec-primary-expression-semantics",
          "subs": [{
            "id": "sec-static-semantics-coveredparenthesizedexpression",
            "subs": []
          }]
        }, {
          "id": "sec-this-keyword",
          "subs": [{
            "id": "sec-this-keyword-runtime-semantics-evaluation",
            "subs": []
          }]
        }, {
          "id": "sec-identifier-reference",
          "subs": []
        }, {
          "id": "sec-primary-expression-literals",
          "subs": [{
            "id": "sec-literals-runtime-semantics-evaluation",
            "subs": []
          }]
        }, {
          "id": "sec-array-initializer",
          "subs": [{
            "id": "sec-runtime-semantics-arrayaccumulation",
            "subs": []
          }, {
            "id": "sec-array-initializer-runtime-semantics-evaluation",
            "subs": []
          }]
        }, {
          "id": "sec-object-initializer",
          "subs": [{
            "id": "sec-object-initializer-static-semantics-early-errors",
            "subs": []
          }, {
            "id": "sec-static-semantics-iscomputedpropertykey",
            "subs": []
          }, {
            "id": "sec-static-semantics-propertynamelist",
            "subs": []
          }, {
            "id": "sec-object-initializer-runtime-semantics-evaluation",
            "subs": []
          }, {
            "id": "sec-runtime-semantics-propertydefinitionevaluation",
            "subs": []
          }]
        }, {
          "id": "sec-function-defining-expressions",
          "subs": []
        }, {
          "id": "sec-primary-expression-regular-expression-literals",
          "subs": [{
            "id": "sec-primary-expression-regular-expression-literals-static-semantics-early-errors",
            "subs": []
          }, {
            "id": "sec-isvalidregularexpressionliteral",
            "subs": []
          }, {
            "id": "sec-regular-expression-literals-runtime-semantics-evaluation",
            "subs": []
          }]
        }, {
          "id": "sec-template-literals",
          "subs": [{
            "id": "sec-static-semantics-template-early-errors",
            "subs": []
          }, {
            "id": "sec-static-semantics-templatestrings",
            "subs": []
          }, {
            "id": "sec-gettemplateobject",
            "subs": []
          }, {
            "id": "sec-runtime-semantics-substitutionevaluation",
            "subs": []
          }, {
            "id": "sec-template-literals-runtime-semantics-evaluation",
            "subs": []
          }]
        }, {
          "id": "sec-grouping-operator",
          "subs": [{
            "id": "sec-grouping-operator-static-semantics-early-errors",
            "subs": []
          }, {
            "id": "sec-grouping-operator-runtime-semantics-evaluation",
            "subs": []
          }]
        }]
      }, {
        "id": "sec-left-hand-side-expressions",
        "subs": [{
          "id": "sec-static-semantics",
          "subs": [{
            "id": "sec-left-hand-side-expressions-static-semantics-early-errors",
            "subs": []
          }, {
            "id": "sec-left-hand-side-expressions-static-semantics-coveredcallexpression",
            "subs": []
          }]
        }, {
          "id": "sec-property-accessors",
          "subs": [{
            "id": "sec-property-accessors-runtime-semantics-evaluation",
            "subs": []
          }]
        }, {
          "id": "sec-evaluate-property-access-with-expression-key",
          "subs": []
        }, {
          "id": "sec-evaluate-property-access-with-identifier-key",
          "subs": []
        }, {
          "id": "sec-new-operator",
          "subs": [{
            "id": "sec-new-operator-runtime-semantics-evaluation",
            "subs": [{
              "id": "sec-evaluatenew",
              "subs": []
            }]
          }]
        }, {
          "id": "sec-function-calls",
          "subs": [{
            "id": "sec-function-calls-runtime-semantics-evaluation",
            "subs": []
          }, {
            "id": "sec-evaluatecall",
            "subs": []
          }]
        }, {
          "id": "sec-super-keyword",
          "subs": [{
            "id": "sec-super-keyword-runtime-semantics-evaluation",
            "subs": []
          }, {
            "id": "sec-getsuperconstructor",
            "subs": []
          }, {
            "id": "sec-makesuperpropertyreference",
            "subs": []
          }]
        }, {
          "id": "sec-argument-lists",
          "subs": [{
            "id": "sec-runtime-semantics-argumentlistevaluation",
            "subs": []
          }]
        }, {
          "id": "sec-optional-chains",
          "subs": [{
            "id": "sec-optional-chaining-evaluation",
            "subs": []
          }, {
            "id": "sec-optional-chaining-chain-evaluation",
            "subs": []
          }]
        }, {
          "id": "sec-import-calls",
          "subs": [{
            "id": "sec-import-call-runtime-semantics-evaluation",
            "subs": []
          }]
        }, {
          "id": "sec-tagged-templates",
          "subs": [{
            "id": "sec-tagged-templates-runtime-semantics-evaluation",
            "subs": []
          }]
        }, {
          "id": "sec-meta-properties",
          "subs": [{
            "id": "sec-meta-properties-runtime-semantics-evaluation",
            "subs": [{
              "id": "sec-hostgetimportmetaproperties",
              "subs": []
            }, {
              "id": "sec-hostfinalizeimportmeta",
              "subs": []
            }]
          }]
        }]
      }, {
        "id": "sec-update-expressions",
        "subs": [{
          "id": "sec-update-expressions-static-semantics-early-errors",
          "subs": []
        }, {
          "id": "sec-postfix-increment-operator",
          "subs": [{
            "id": "sec-postfix-increment-operator-runtime-semantics-evaluation",
            "subs": []
          }]
        }, {
          "id": "sec-postfix-decrement-operator",
          "subs": [{
            "id": "sec-postfix-decrement-operator-runtime-semantics-evaluation",
            "subs": []
          }]
        }, {
          "id": "sec-prefix-increment-operator",
          "subs": [{
            "id": "sec-prefix-increment-operator-runtime-semantics-evaluation",
            "subs": []
          }]
        }, {
          "id": "sec-prefix-decrement-operator",
          "subs": [{
            "id": "sec-prefix-decrement-operator-runtime-semantics-evaluation",
            "subs": []
          }]
        }]
      }, {
        "id": "sec-unary-operators",
        "subs": [{
          "id": "sec-delete-operator",
          "subs": [{
            "id": "sec-delete-operator-static-semantics-early-errors",
            "subs": []
          }, {
            "id": "sec-delete-operator-runtime-semantics-evaluation",
            "subs": []
          }]
        }, {
          "id": "sec-void-operator",
          "subs": [{
            "id": "sec-void-operator-runtime-semantics-evaluation",
            "subs": []
          }]
        }, {
          "id": "sec-typeof-operator",
          "subs": [{
            "id": "sec-typeof-operator-runtime-semantics-evaluation",
            "subs": []
          }]
        }, {
          "id": "sec-unary-plus-operator",
          "subs": [{
            "id": "sec-unary-plus-operator-runtime-semantics-evaluation",
            "subs": []
          }]
        }, {
          "id": "sec-unary-minus-operator",
          "subs": [{
            "id": "sec-unary-minus-operator-runtime-semantics-evaluation",
            "subs": []
          }]
        }, {
          "id": "sec-bitwise-not-operator",
          "subs": [{
            "id": "sec-bitwise-not-operator-runtime-semantics-evaluation",
            "subs": []
          }]
        }, {
          "id": "sec-logical-not-operator",
          "subs": [{
            "id": "sec-logical-not-operator-runtime-semantics-evaluation",
            "subs": []
          }]
        }]
      }, {
        "id": "sec-exp-operator",
        "subs": [{
          "id": "sec-exp-operator-runtime-semantics-evaluation",
          "subs": []
        }]
      }, {
        "id": "sec-multiplicative-operators",
        "subs": [{
          "id": "sec-multiplicative-operators-runtime-semantics-evaluation",
          "subs": []
        }]
      }, {
        "id": "sec-additive-operators",
        "subs": [{
          "id": "sec-addition-operator-plus",
          "subs": [{
            "id": "sec-addition-operator-plus-runtime-semantics-evaluation",
            "subs": []
          }]
        }, {
          "id": "sec-subtraction-operator-minus",
          "subs": [{
            "id": "sec-subtraction-operator-minus-runtime-semantics-evaluation",
            "subs": []
          }]
        }]
      }, {
        "id": "sec-bitwise-shift-operators",
        "subs": [{
          "id": "sec-left-shift-operator",
          "subs": [{
            "id": "sec-left-shift-operator-runtime-semantics-evaluation",
            "subs": []
          }]
        }, {
          "id": "sec-signed-right-shift-operator",
          "subs": [{
            "id": "sec-signed-right-shift-operator-runtime-semantics-evaluation",
            "subs": []
          }]
        }, {
          "id": "sec-unsigned-right-shift-operator",
          "subs": [{
            "id": "sec-unsigned-right-shift-operator-runtime-semantics-evaluation",
            "subs": []
          }]
        }]
      }, {
        "id": "sec-relational-operators",
        "subs": [{
          "id": "sec-relational-operators-runtime-semantics-evaluation",
          "subs": []
        }, {
          "id": "sec-instanceofoperator",
          "subs": []
        }]
      }, {
        "id": "sec-equality-operators",
        "subs": [{
          "id": "sec-equality-operators-runtime-semantics-evaluation",
          "subs": []
        }]
      }, {
        "id": "sec-binary-bitwise-operators",
        "subs": [{
          "id": "sec-binary-bitwise-operators-runtime-semantics-evaluation",
          "subs": []
        }]
      }, {
        "id": "sec-binary-logical-operators",
        "subs": [{
          "id": "sec-binary-logical-operators-runtime-semantics-evaluation",
          "subs": []
        }]
      }, {
        "id": "sec-conditional-operator",
        "subs": [{
          "id": "sec-conditional-operator-runtime-semantics-evaluation",
          "subs": []
        }]
      }, {
        "id": "sec-assignment-operators",
        "subs": [{
          "id": "sec-assignment-operators-static-semantics-early-errors",
          "subs": []
        }, {
          "id": "sec-assignment-operators-runtime-semantics-evaluation",
          "subs": []
        }, {
          "id": "sec-applystringornumericbinaryoperator",
          "subs": []
        }, {
          "id": "sec-evaluatestringornumericbinaryexpression",
          "subs": []
        }, {
          "id": "sec-destructuring-assignment",
          "subs": [{
            "id": "sec-destructuring-assignment-static-semantics-early-errors",
            "subs": []
          }, {
            "id": "sec-runtime-semantics-destructuringassignmentevaluation",
            "subs": []
          }, {
            "id": "sec-runtime-semantics-propertydestructuringassignmentevaluation",
            "subs": []
          }, {
            "id": "sec-runtime-semantics-restdestructuringassignmentevaluation",
            "subs": []
          }, {
            "id": "sec-runtime-semantics-iteratordestructuringassignmentevaluation",
            "subs": []
          }, {
            "id": "sec-runtime-semantics-keyeddestructuringassignmentevaluation",
            "subs": []
          }]
        }]
      }, {
        "id": "sec-comma-operator",
        "subs": [{
          "id": "sec-comma-operator-runtime-semantics-evaluation",
          "subs": []
        }]
      }]
    }, {
      "id": "sec-ecmascript-language-statements-and-declarations",
      "subs": [{
        "id": "sec-statement-semantics",
        "subs": [{
          "id": "sec-statement-semantics-runtime-semantics-evaluation",
          "subs": []
        }]
      }, {
        "id": "sec-block",
        "subs": [{
          "id": "sec-block-static-semantics-early-errors",
          "subs": []
        }, {
          "id": "sec-block-runtime-semantics-evaluation",
          "subs": []
        }, {
          "id": "sec-blockdeclarationinstantiation",
          "subs": []
        }]
      }, {
        "id": "sec-declarations-and-the-variable-statement",
        "subs": [{
          "id": "sec-let-and-const-declarations",
          "subs": [{
            "id": "sec-let-and-const-declarations-static-semantics-early-errors",
            "subs": []
          }, {
            "id": "sec-let-and-const-declarations-runtime-semantics-evaluation",
            "subs": []
          }]
        }, {
          "id": "sec-variable-statement",
          "subs": [{
            "id": "sec-variable-statement-runtime-semantics-evaluation",
            "subs": []
          }]
        }, {
          "id": "sec-destructuring-binding-patterns",
          "subs": [{
            "id": "sec-destructuring-binding-patterns-runtime-semantics-propertybindinginitialization",
            "subs": []
          }, {
            "id": "sec-destructuring-binding-patterns-runtime-semantics-restbindinginitialization",
            "subs": []
          }, {
            "id": "sec-runtime-semantics-keyedbindinginitialization",
            "subs": []
          }]
        }]
      }, {
        "id": "sec-empty-statement",
        "subs": [{
          "id": "sec-empty-statement-runtime-semantics-evaluation",
          "subs": []
        }]
      }, {
        "id": "sec-expression-statement",
        "subs": [{
          "id": "sec-expression-statement-runtime-semantics-evaluation",
          "subs": []
        }]
      }, {
        "id": "sec-if-statement",
        "subs": [{
          "id": "sec-if-statement-static-semantics-early-errors",
          "subs": []
        }, {
          "id": "sec-if-statement-runtime-semantics-evaluation",
          "subs": []
        }]
      }, {
        "id": "sec-iteration-statements",
        "subs": [{
          "id": "sec-iteration-statements-semantics",
          "subs": [{
            "id": "sec-loopcontinues",
            "subs": []
          }, {
            "id": "sec-runtime-semantics-loopevaluation",
            "subs": []
          }]
        }, {
          "id": "sec-do-while-statement",
          "subs": [{
            "id": "sec-do-while-statement-static-semantics-early-errors",
            "subs": []
          }, {
            "id": "sec-runtime-semantics-dowhileloopevaluation",
            "subs": []
          }]
        }, {
          "id": "sec-while-statement",
          "subs": [{
            "id": "sec-while-statement-static-semantics-early-errors",
            "subs": []
          }, {
            "id": "sec-runtime-semantics-whileloopevaluation",
            "subs": []
          }]
        }, {
          "id": "sec-for-statement",
          "subs": [{
            "id": "sec-for-statement-static-semantics-early-errors",
            "subs": []
          }, {
            "id": "sec-runtime-semantics-forloopevaluation",
            "subs": []
          }, {
            "id": "sec-forbodyevaluation",
            "subs": []
          }, {
            "id": "sec-createperiterationenvironment",
            "subs": []
          }]
        }, {
          "id": "sec-for-in-and-for-of-statements",
          "subs": [{
            "id": "sec-for-in-and-for-of-statements-static-semantics-early-errors",
            "subs": []
          }, {
            "id": "sec-static-semantics-isdestructuring",
            "subs": []
          }, {
            "id": "sec-runtime-semantics-fordeclarationbindinginitialization",
            "subs": []
          }, {
            "id": "sec-runtime-semantics-fordeclarationbindinginstantiation",
            "subs": []
          }, {
            "id": "sec-runtime-semantics-forinofloopevaluation",
            "subs": []
          }, {
            "id": "sec-runtime-semantics-forinofheadevaluation",
            "subs": []
          }, {
            "id": "sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset",
            "subs": []
          }, {
            "id": "sec-for-in-and-for-of-statements-runtime-semantics-evaluation",
            "subs": []
          }, {
            "id": "sec-enumerate-object-properties",
            "subs": []
          }, {
            "id": "sec-for-in-iterator-objects",
            "subs": [{
              "id": "sec-createforiniterator",
              "subs": []
            }, {
              "id": "sec-%foriniteratorprototype%-object",
              "subs": [{
                "id": "sec-%foriniteratorprototype%.next",
                "subs": []
              }]
            }, {
              "id": "sec-properties-of-for-in-iterator-instances",
              "subs": []
            }]
          }]
        }]
      }, {
        "id": "sec-continue-statement",
        "subs": [{
          "id": "sec-continue-statement-static-semantics-early-errors",
          "subs": []
        }, {
          "id": "sec-continue-statement-runtime-semantics-evaluation",
          "subs": []
        }]
      }, {
        "id": "sec-break-statement",
        "subs": [{
          "id": "sec-break-statement-static-semantics-early-errors",
          "subs": []
        }, {
          "id": "sec-break-statement-runtime-semantics-evaluation",
          "subs": []
        }]
      }, {
        "id": "sec-return-statement",
        "subs": [{
          "id": "sec-return-statement-runtime-semantics-evaluation",
          "subs": []
        }]
      }, {
        "id": "sec-with-statement",
        "subs": [{
          "id": "sec-with-statement-static-semantics-early-errors",
          "subs": []
        }, {
          "id": "sec-with-statement-runtime-semantics-evaluation",
          "subs": []
        }]
      }, {
        "id": "sec-switch-statement",
        "subs": [{
          "id": "sec-switch-statement-static-semantics-early-errors",
          "subs": []
        }, {
          "id": "sec-runtime-semantics-caseblockevaluation",
          "subs": []
        }, {
          "id": "sec-runtime-semantics-caseclauseisselected",
          "subs": []
        }, {
          "id": "sec-switch-statement-runtime-semantics-evaluation",
          "subs": []
        }]
      }, {
        "id": "sec-labelled-statements",
        "subs": [{
          "id": "sec-labelled-statements-static-semantics-early-errors",
          "subs": []
        }, {
          "id": "sec-islabelledfunction",
          "subs": []
        }, {
          "id": "sec-labelled-statements-runtime-semantics-evaluation",
          "subs": []
        }, {
          "id": "sec-runtime-semantics-labelledevaluation",
          "subs": []
        }]
      }, {
        "id": "sec-throw-statement",
        "subs": [{
          "id": "sec-throw-statement-runtime-semantics-evaluation",
          "subs": []
        }]
      }, {
        "id": "sec-try-statement",
        "subs": [{
          "id": "sec-try-statement-static-semantics-early-errors",
          "subs": []
        }, {
          "id": "sec-runtime-semantics-catchclauseevaluation",
          "subs": []
        }, {
          "id": "sec-try-statement-runtime-semantics-evaluation",
          "subs": []
        }]
      }, {
        "id": "sec-debugger-statement",
        "subs": [{
          "id": "sec-debugger-statement-runtime-semantics-evaluation",
          "subs": []
        }]
      }]
    }, {
      "id": "sec-ecmascript-language-functions-and-classes",
      "subs": [{
        "id": "sec-parameter-lists",
        "subs": [{
          "id": "sec-parameter-lists-static-semantics-early-errors",
          "subs": []
        }, {
          "id": "sec-static-semantics-containsexpression",
          "subs": []
        }, {
          "id": "sec-static-semantics-issimpleparameterlist",
          "subs": []
        }, {
          "id": "sec-static-semantics-hasinitializer",
          "subs": []
        }, {
          "id": "sec-static-semantics-expectedargumentcount",
          "subs": []
        }]
      }, {
        "id": "sec-function-definitions",
        "subs": [{
          "id": "sec-function-definitions-static-semantics-early-errors",
          "subs": []
        }, {
          "id": "sec-static-semantics-functionbodycontainsusestrict",
          "subs": []
        }, {
          "id": "sec-runtime-semantics-evaluatefunctionbody",
          "subs": []
        }, {
          "id": "sec-runtime-semantics-instantiateordinaryfunctionobject",
          "subs": []
        }, {
          "id": "sec-runtime-semantics-instantiateordinaryfunctionexpression",
          "subs": []
        }, {
          "id": "sec-function-definitions-runtime-semantics-evaluation",
          "subs": []
        }]
      }, {
        "id": "sec-arrow-function-definitions",
        "subs": [{
          "id": "sec-arrow-function-definitions-static-semantics-early-errors",
          "subs": []
        }, {
          "id": "sec-static-semantics-concisebodycontainsusestrict",
          "subs": []
        }, {
          "id": "sec-static-semantics-coveredformalslist",
          "subs": []
        }, {
          "id": "sec-runtime-semantics-evaluateconcisebody",
          "subs": []
        }, {
          "id": "sec-runtime-semantics-instantiatearrowfunctionexpression",
          "subs": []
        }, {
          "id": "sec-arrow-function-definitions-runtime-semantics-evaluation",
          "subs": []
        }]
      }, {
        "id": "sec-method-definitions",
        "subs": [{
          "id": "sec-method-definitions-static-semantics-early-errors",
          "subs": []
        }, {
          "id": "sec-static-semantics-hasdirectsuper",
          "subs": []
        }, {
          "id": "sec-static-semantics-specialmethod",
          "subs": []
        }, {
          "id": "sec-runtime-semantics-definemethod",
          "subs": []
        }, {
          "id": "sec-runtime-semantics-methoddefinitionevaluation",
          "subs": []
        }]
      }, {
        "id": "sec-generator-function-definitions",
        "subs": [{
          "id": "sec-generator-function-definitions-static-semantics-early-errors",
          "subs": []
        }, {
          "id": "sec-runtime-semantics-evaluategeneratorbody",
          "subs": []
        }, {
          "id": "sec-runtime-semantics-instantiategeneratorfunctionobject",
          "subs": []
        }, {
          "id": "sec-runtime-semantics-instantiategeneratorfunctionexpression",
          "subs": []
        }, {
          "id": "sec-generator-function-definitions-runtime-semantics-evaluation",
          "subs": []
        }]
      }, {
        "id": "sec-async-generator-function-definitions",
        "subs": [{
          "id": "sec-async-generator-function-definitions-static-semantics-early-errors",
          "subs": []
        }, {
          "id": "sec-runtime-semantics-evaluateasyncgeneratorbody",
          "subs": []
        }, {
          "id": "sec-runtime-semantics-instantiateasyncgeneratorfunctionobject",
          "subs": []
        }, {
          "id": "sec-runtime-semantics-instantiateasyncgeneratorfunctionexpression",
          "subs": []
        }, {
          "id": "sec-asyncgenerator-definitions-evaluation",
          "subs": []
        }]
      }, {
        "id": "sec-class-definitions",
        "subs": [{
          "id": "sec-class-definitions-static-semantics-early-errors",
          "subs": []
        }, {
          "id": "sec-static-semantics-classelementkind",
          "subs": []
        }, {
          "id": "sec-static-semantics-constructormethod",
          "subs": []
        }, {
          "id": "sec-static-semantics-isstatic",
          "subs": []
        }, {
          "id": "sec-static-semantics-nonconstructormethoddefinitions",
          "subs": []
        }, {
          "id": "sec-static-semantics-prototypepropertynamelist",
          "subs": []
        }, {
          "id": "sec-runtime-semantics-classdefinitionevaluation",
          "subs": [{
            "id": "sec-default-constructor-functions",
            "subs": []
          }]
        }, {
          "id": "sec-runtime-semantics-bindingclassdeclarationevaluation",
          "subs": []
        }, {
          "id": "sec-class-definitions-runtime-semantics-evaluation",
          "subs": []
        }]
      }, {
        "id": "sec-async-function-definitions",
        "subs": [{
          "id": "sec-async-function-definitions-static-semantics-early-errors",
          "subs": []
        }, {
          "id": "sec-runtime-semantics-instantiateasyncfunctionobject",
          "subs": []
        }, {
          "id": "sec-runtime-semantics-instantiateasyncfunctionexpression",
          "subs": []
        }, {
          "id": "sec-runtime-semantics-evaluateasyncfunctionbody",
          "subs": []
        }, {
          "id": "sec-async-function-definitions-runtime-semantics-evaluation",
          "subs": []
        }]
      }, {
        "id": "sec-async-arrow-function-definitions",
        "subs": [{
          "id": "sec-async-arrow-function-definitions-static-semantics-early-errors",
          "subs": []
        }, {
          "id": "sec-async-arrow-function-definitions-static-semantics-CoveredAsyncArrowHead",
          "subs": []
        }, {
          "id": "sec-static-semantics-asyncconcisebodycontainsusestrict",
          "subs": []
        }, {
          "id": "sec-runtime-semantics-evaluateasyncconcisebody",
          "subs": []
        }, {
          "id": "sec-runtime-semantics-instantiateasyncarrowfunctionexpression",
          "subs": []
        }, {
          "id": "sec-async-arrow-function-definitions-runtime-semantics-evaluation",
          "subs": []
        }]
      }, {
        "id": "sec-tail-position-calls",
        "subs": [{
          "id": "sec-isintailposition",
          "subs": []
        }, {
          "id": "sec-static-semantics-hascallintailposition",
          "subs": [{
            "id": "sec-statement-rules",
            "subs": []
          }, {
            "id": "sec-expression-rules",
            "subs": []
          }]
        }, {
          "id": "sec-preparefortailcall",
          "subs": []
        }]
      }]
    }, {
      "id": "sec-ecmascript-language-scripts-and-modules",
      "subs": [{
        "id": "sec-scripts",
        "subs": [{
          "id": "sec-scripts-static-semantics-early-errors",
          "subs": []
        }, {
          "id": "sec-static-semantics-isstrict",
          "subs": []
        }, {
          "id": "sec-script-semantics-runtime-semantics-evaluation",
          "subs": []
        }, {
          "id": "sec-script-records",
          "subs": []
        }, {
          "id": "sec-parse-script",
          "subs": []
        }, {
          "id": "sec-runtime-semantics-scriptevaluation",
          "subs": []
        }, {
          "id": "sec-globaldeclarationinstantiation",
          "subs": []
        }]
      }, {
        "id": "sec-modules",
        "subs": [{
          "id": "sec-module-semantics",
          "subs": [{
            "id": "sec-module-semantics-static-semantics-early-errors",
            "subs": []
          }, {
            "id": "sec-importedlocalnames",
            "subs": []
          }, {
            "id": "sec-static-semantics-modulerequests",
            "subs": []
          }, {
            "id": "sec-abstract-module-records",
            "subs": []
          }, {
            "id": "sec-cyclic-module-records",
            "subs": [{
              "id": "sec-moduledeclarationlinking",
              "subs": [{
                "id": "sec-InnerModuleLinking",
                "subs": []
              }]
            }, {
              "id": "sec-moduleevaluation",
              "subs": [{
                "id": "sec-innermoduleevaluation",
                "subs": []
              }]
            }, {
              "id": "sec-example-cyclic-module-record-graphs",
              "subs": []
            }]
          }, {
            "id": "sec-source-text-module-records",
            "subs": [{
              "id": "sec-parsemodule",
              "subs": []
            }, {
              "id": "sec-getexportednames",
              "subs": []
            }, {
              "id": "sec-resolveexport",
              "subs": []
            }, {
              "id": "sec-source-text-module-record-initialize-environment",
              "subs": []
            }, {
              "id": "sec-source-text-module-record-execute-module",
              "subs": []
            }]
          }, {
            "id": "sec-hostresolveimportedmodule",
            "subs": []
          }, {
            "id": "sec-hostimportmoduledynamically",
            "subs": []
          }, {
            "id": "sec-finishdynamicimport",
            "subs": []
          }, {
            "id": "sec-getmodulenamespace",
            "subs": []
          }, {
            "id": "sec-module-semantics-runtime-semantics-evaluation",
            "subs": []
          }]
        }, {
          "id": "sec-imports",
          "subs": [{
            "id": "sec-imports-static-semantics-early-errors",
            "subs": []
          }, {
            "id": "sec-static-semantics-importentries",
            "subs": []
          }, {
            "id": "sec-static-semantics-importentriesformodule",
            "subs": []
          }]
        }, {
          "id": "sec-exports",
          "subs": [{
            "id": "sec-exports-static-semantics-early-errors",
            "subs": []
          }, {
            "id": "sec-static-semantics-exportedbindings",
            "subs": []
          }, {
            "id": "sec-static-semantics-exportednames",
            "subs": []
          }, {
            "id": "sec-static-semantics-exportentries",
            "subs": []
          }, {
            "id": "sec-static-semantics-exportentriesformodule",
            "subs": []
          }, {
            "id": "sec-static-semantics-referencedbindings",
            "subs": []
          }, {
            "id": "sec-exports-runtime-semantics-evaluation",
            "subs": []
          }]
        }]
      }]
    }, {
      "id": "sec-error-handling-and-language-extensions",
      "subs": [{
        "id": "sec-forbidden-extensions",
        "subs": []
      }]
    }, {
      "id": "sec-ecmascript-standard-built-in-objects",
      "subs": []
    }, {
      "id": "sec-global-object",
      "subs": [{
        "id": "sec-value-properties-of-the-global-object",
        "subs": [{
          "id": "sec-globalthis",
          "subs": []
        }, {
          "id": "sec-value-properties-of-the-global-object-infinity",
          "subs": []
        }, {
          "id": "sec-value-properties-of-the-global-object-nan",
          "subs": []
        }, {
          "id": "sec-undefined",
          "subs": []
        }]
      }, {
        "id": "sec-function-properties-of-the-global-object",
        "subs": [{
          "id": "sec-eval-x",
          "subs": [{
            "id": "sec-performeval",
            "subs": []
          }, {
            "id": "sec-hostensurecancompilestrings",
            "subs": []
          }, {
            "id": "sec-evaldeclarationinstantiation",
            "subs": []
          }]
        }, {
          "id": "sec-isfinite-number",
          "subs": []
        }, {
          "id": "sec-isnan-number",
          "subs": []
        }, {
          "id": "sec-parsefloat-string",
          "subs": []
        }, {
          "id": "sec-parseint-string-radix",
          "subs": []
        }, {
          "id": "sec-uri-handling-functions",
          "subs": [{
            "id": "sec-uri-syntax-and-semantics",
            "subs": [{
              "id": "sec-encode",
              "subs": []
            }, {
              "id": "sec-decode",
              "subs": []
            }]
          }, {
            "id": "sec-decodeuri-encodeduri",
            "subs": []
          }, {
            "id": "sec-decodeuricomponent-encodeduricomponent",
            "subs": []
          }, {
            "id": "sec-encodeuri-uri",
            "subs": []
          }, {
            "id": "sec-encodeuricomponent-uricomponent",
            "subs": []
          }]
        }]
      }, {
        "id": "sec-constructor-properties-of-the-global-object",
        "subs": [{
          "id": "sec-constructor-properties-of-the-global-object-array",
          "subs": []
        }, {
          "id": "sec-constructor-properties-of-the-global-object-arraybuffer",
          "subs": []
        }, {
          "id": "sec-constructor-properties-of-the-global-object-bigint",
          "subs": []
        }, {
          "id": "sec-constructor-properties-of-the-global-object-bigint64array",
          "subs": []
        }, {
          "id": "sec-constructor-properties-of-the-global-object-biguint64array",
          "subs": []
        }, {
          "id": "sec-constructor-properties-of-the-global-object-boolean",
          "subs": []
        }, {
          "id": "sec-constructor-properties-of-the-global-object-dataview",
          "subs": []
        }, {
          "id": "sec-constructor-properties-of-the-global-object-date",
          "subs": []
        }, {
          "id": "sec-constructor-properties-of-the-global-object-error",
          "subs": []
        }, {
          "id": "sec-constructor-properties-of-the-global-object-evalerror",
          "subs": []
        }, {
          "id": "sec-constructor-properties-of-the-global-object-finnalization-registry",
          "subs": []
        }, {
          "id": "sec-float32array",
          "subs": []
        }, {
          "id": "sec-float64array",
          "subs": []
        }, {
          "id": "sec-constructor-properties-of-the-global-object-function",
          "subs": []
        }, {
          "id": "sec-int8array",
          "subs": []
        }, {
          "id": "sec-int16array",
          "subs": []
        }, {
          "id": "sec-int32array",
          "subs": []
        }, {
          "id": "sec-map",
          "subs": []
        }, {
          "id": "sec-constructor-properties-of-the-global-object-number",
          "subs": []
        }, {
          "id": "sec-constructor-properties-of-the-global-object-object",
          "subs": []
        }, {
          "id": "sec-constructor-properties-of-the-global-object-promise",
          "subs": []
        }, {
          "id": "sec-constructor-properties-of-the-global-object-proxy",
          "subs": []
        }, {
          "id": "sec-constructor-properties-of-the-global-object-rangeerror",
          "subs": []
        }, {
          "id": "sec-constructor-properties-of-the-global-object-referenceerror",
          "subs": []
        }, {
          "id": "sec-constructor-properties-of-the-global-object-regexp",
          "subs": []
        }, {
          "id": "sec-set",
          "subs": []
        }, {
          "id": "sec-constructor-properties-of-the-global-object-sharedarraybuffer",
          "subs": []
        }, {
          "id": "sec-constructor-properties-of-the-global-object-string",
          "subs": []
        }, {
          "id": "sec-constructor-properties-of-the-global-object-symbol",
          "subs": []
        }, {
          "id": "sec-constructor-properties-of-the-global-object-syntaxerror",
          "subs": []
        }, {
          "id": "sec-constructor-properties-of-the-global-object-typeerror",
          "subs": []
        }, {
          "id": "sec-uint8array",
          "subs": []
        }, {
          "id": "sec-uint8clampedarray",
          "subs": []
        }, {
          "id": "sec-uint16array",
          "subs": []
        }, {
          "id": "sec-uint32array",
          "subs": []
        }, {
          "id": "sec-constructor-properties-of-the-global-object-urierror",
          "subs": []
        }, {
          "id": "sec-constructor-properties-of-the-global-object-weakmap",
          "subs": []
        }, {
          "id": "sec-constructor-properties-of-the-global-object-weakref",
          "subs": []
        }, {
          "id": "sec-constructor-properties-of-the-global-object-weakset",
          "subs": []
        }]
      }, {
        "id": "sec-other-properties-of-the-global-object",
        "subs": [{
          "id": "sec-atomics",
          "subs": []
        }, {
          "id": "sec-json",
          "subs": []
        }, {
          "id": "sec-math",
          "subs": []
        }, {
          "id": "sec-reflect",
          "subs": []
        }]
      }]
    }, {
      "id": "sec-fundamental-objects",
      "subs": [{
        "id": "sec-object-objects",
        "subs": [{
          "id": "sec-object-constructor",
          "subs": [{
            "id": "sec-object-value",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-object-constructor",
          "subs": [{
            "id": "sec-object.assign",
            "subs": []
          }, {
            "id": "sec-object.create",
            "subs": []
          }, {
            "id": "sec-object.defineproperties",
            "subs": [{
              "id": "sec-objectdefineproperties",
              "subs": []
            }]
          }, {
            "id": "sec-object.defineproperty",
            "subs": []
          }, {
            "id": "sec-object.entries",
            "subs": []
          }, {
            "id": "sec-object.freeze",
            "subs": []
          }, {
            "id": "sec-object.fromentries",
            "subs": [{
              "id": "sec-create-data-property-on-object-functions",
              "subs": []
            }]
          }, {
            "id": "sec-object.getownpropertydescriptor",
            "subs": []
          }, {
            "id": "sec-object.getownpropertydescriptors",
            "subs": []
          }, {
            "id": "sec-object.getownpropertynames",
            "subs": []
          }, {
            "id": "sec-object.getownpropertysymbols",
            "subs": [{
              "id": "sec-getownpropertykeys",
              "subs": []
            }]
          }, {
            "id": "sec-object.getprototypeof",
            "subs": []
          }, {
            "id": "sec-object.is",
            "subs": []
          }, {
            "id": "sec-object.isextensible",
            "subs": []
          }, {
            "id": "sec-object.isfrozen",
            "subs": []
          }, {
            "id": "sec-object.issealed",
            "subs": []
          }, {
            "id": "sec-object.keys",
            "subs": []
          }, {
            "id": "sec-object.preventextensions",
            "subs": []
          }, {
            "id": "sec-object.prototype",
            "subs": []
          }, {
            "id": "sec-object.seal",
            "subs": []
          }, {
            "id": "sec-object.setprototypeof",
            "subs": []
          }, {
            "id": "sec-object.values",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-object-prototype-object",
          "subs": [{
            "id": "sec-object.prototype.constructor",
            "subs": []
          }, {
            "id": "sec-object.prototype.hasownproperty",
            "subs": []
          }, {
            "id": "sec-object.prototype.isprototypeof",
            "subs": []
          }, {
            "id": "sec-object.prototype.propertyisenumerable",
            "subs": []
          }, {
            "id": "sec-object.prototype.tolocalestring",
            "subs": []
          }, {
            "id": "sec-object.prototype.tostring",
            "subs": []
          }, {
            "id": "sec-object.prototype.valueof",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-object-instances",
          "subs": []
        }]
      }, {
        "id": "sec-function-objects",
        "subs": [{
          "id": "sec-function-constructor",
          "subs": [{
            "id": "sec-function-p1-p2-pn-body",
            "subs": [{
              "id": "sec-createdynamicfunction",
              "subs": []
            }]
          }]
        }, {
          "id": "sec-properties-of-the-function-constructor",
          "subs": [{
            "id": "sec-function.length",
            "subs": []
          }, {
            "id": "sec-function.prototype",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-function-prototype-object",
          "subs": [{
            "id": "sec-function.prototype.apply",
            "subs": []
          }, {
            "id": "sec-function.prototype.bind",
            "subs": []
          }, {
            "id": "sec-function.prototype.call",
            "subs": []
          }, {
            "id": "sec-function.prototype.constructor",
            "subs": []
          }, {
            "id": "sec-function.prototype.tostring",
            "subs": []
          }, {
            "id": "sec-function.prototype-@@hasinstance",
            "subs": []
          }]
        }, {
          "id": "sec-function-instances",
          "subs": [{
            "id": "sec-function-instances-length",
            "subs": []
          }, {
            "id": "sec-function-instances-name",
            "subs": []
          }, {
            "id": "sec-function-instances-prototype",
            "subs": []
          }]
        }, {
          "id": "sec-hosthassourcetextavailable",
          "subs": []
        }]
      }, {
        "id": "sec-boolean-objects",
        "subs": [{
          "id": "sec-boolean-constructor",
          "subs": [{
            "id": "sec-boolean-constructor-boolean-value",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-boolean-constructor",
          "subs": [{
            "id": "sec-boolean.prototype",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-boolean-prototype-object",
          "subs": [{
            "id": "sec-boolean.prototype.constructor",
            "subs": []
          }, {
            "id": "sec-boolean.prototype.tostring",
            "subs": []
          }, {
            "id": "sec-boolean.prototype.valueof",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-boolean-instances",
          "subs": []
        }]
      }, {
        "id": "sec-symbol-objects",
        "subs": [{
          "id": "sec-symbol-constructor",
          "subs": [{
            "id": "sec-symbol-description",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-symbol-constructor",
          "subs": [{
            "id": "sec-symbol.asynciterator",
            "subs": []
          }, {
            "id": "sec-symbol.for",
            "subs": []
          }, {
            "id": "sec-symbol.hasinstance",
            "subs": []
          }, {
            "id": "sec-symbol.isconcatspreadable",
            "subs": []
          }, {
            "id": "sec-symbol.iterator",
            "subs": []
          }, {
            "id": "sec-symbol.keyfor",
            "subs": []
          }, {
            "id": "sec-symbol.match",
            "subs": []
          }, {
            "id": "sec-symbol.matchall",
            "subs": []
          }, {
            "id": "sec-symbol.prototype",
            "subs": []
          }, {
            "id": "sec-symbol.replace",
            "subs": []
          }, {
            "id": "sec-symbol.search",
            "subs": []
          }, {
            "id": "sec-symbol.species",
            "subs": []
          }, {
            "id": "sec-symbol.split",
            "subs": []
          }, {
            "id": "sec-symbol.toprimitive",
            "subs": []
          }, {
            "id": "sec-symbol.tostringtag",
            "subs": []
          }, {
            "id": "sec-symbol.unscopables",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-symbol-prototype-object",
          "subs": [{
            "id": "sec-symbol.prototype.constructor",
            "subs": []
          }, {
            "id": "sec-symbol.prototype.description",
            "subs": []
          }, {
            "id": "sec-symbol.prototype.tostring",
            "subs": [{
              "id": "sec-symboldescriptivestring",
              "subs": []
            }]
          }, {
            "id": "sec-symbol.prototype.valueof",
            "subs": []
          }, {
            "id": "sec-symbol.prototype-@@toprimitive",
            "subs": []
          }, {
            "id": "sec-symbol.prototype-@@tostringtag",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-symbol-instances",
          "subs": []
        }]
      }, {
        "id": "sec-error-objects",
        "subs": [{
          "id": "sec-error-constructor",
          "subs": [{
            "id": "sec-error-message",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-error-constructor",
          "subs": [{
            "id": "sec-error.prototype",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-error-prototype-object",
          "subs": [{
            "id": "sec-error.prototype.constructor",
            "subs": []
          }, {
            "id": "sec-error.prototype.message",
            "subs": []
          }, {
            "id": "sec-error.prototype.name",
            "subs": []
          }, {
            "id": "sec-error.prototype.tostring",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-error-instances",
          "subs": []
        }, {
          "id": "sec-native-error-types-used-in-this-standard",
          "subs": [{
            "id": "sec-native-error-types-used-in-this-standard-evalerror",
            "subs": []
          }, {
            "id": "sec-native-error-types-used-in-this-standard-rangeerror",
            "subs": []
          }, {
            "id": "sec-native-error-types-used-in-this-standard-referenceerror",
            "subs": []
          }, {
            "id": "sec-native-error-types-used-in-this-standard-syntaxerror",
            "subs": []
          }, {
            "id": "sec-native-error-types-used-in-this-standard-typeerror",
            "subs": []
          }, {
            "id": "sec-native-error-types-used-in-this-standard-urierror",
            "subs": []
          }]
        }, {
          "id": "sec-nativeerror-object-structure",
          "subs": [{
            "id": "sec-nativeerror-constructors",
            "subs": [{
              "id": "sec-nativeerror",
              "subs": []
            }]
          }, {
            "id": "sec-properties-of-the-nativeerror-constructors",
            "subs": [{
              "id": "sec-nativeerror.prototype",
              "subs": []
            }]
          }, {
            "id": "sec-properties-of-the-nativeerror-prototype-objects",
            "subs": [{
              "id": "sec-nativeerror.prototype.constructor",
              "subs": []
            }, {
              "id": "sec-nativeerror.prototype.message",
              "subs": []
            }, {
              "id": "sec-nativeerror.prototype.name",
              "subs": []
            }]
          }, {
            "id": "sec-properties-of-nativeerror-instances",
            "subs": []
          }]
        }, {
          "id": "sec-aggregate-error-objects",
          "subs": [{
            "id": "sec-aggregate-error-constructor",
            "subs": [{
              "id": "sec-aggregate-error",
              "subs": []
            }]
          }, {
            "id": "sec-properties-of-the-aggregate-error-constructors",
            "subs": [{
              "id": "sec-aggregate-error.prototype",
              "subs": []
            }]
          }, {
            "id": "sec-properties-of-the-aggregate-error-prototype-objects",
            "subs": [{
              "id": "sec-aggregate-error.prototype.constructor",
              "subs": []
            }, {
              "id": "sec-aggregate-error.prototype.message",
              "subs": []
            }, {
              "id": "sec-aggregate-error.prototype.name",
              "subs": []
            }]
          }, {
            "id": "sec-properties-of-aggregate-error-instances",
            "subs": []
          }]
        }]
      }]
    }, {
      "id": "sec-numbers-and-dates",
      "subs": [{
        "id": "sec-number-objects",
        "subs": [{
          "id": "sec-number-constructor",
          "subs": [{
            "id": "sec-number-constructor-number-value",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-number-constructor",
          "subs": [{
            "id": "sec-number.epsilon",
            "subs": []
          }, {
            "id": "sec-number.isfinite",
            "subs": []
          }, {
            "id": "sec-number.isinteger",
            "subs": []
          }, {
            "id": "sec-number.isnan",
            "subs": []
          }, {
            "id": "sec-number.issafeinteger",
            "subs": []
          }, {
            "id": "sec-number.max_safe_integer",
            "subs": []
          }, {
            "id": "sec-number.max_value",
            "subs": []
          }, {
            "id": "sec-number.min_safe_integer",
            "subs": []
          }, {
            "id": "sec-number.min_value",
            "subs": []
          }, {
            "id": "sec-number.nan",
            "subs": []
          }, {
            "id": "sec-number.negative_infinity",
            "subs": []
          }, {
            "id": "sec-number.parsefloat",
            "subs": []
          }, {
            "id": "sec-number.parseint",
            "subs": []
          }, {
            "id": "sec-number.positive_infinity",
            "subs": []
          }, {
            "id": "sec-number.prototype",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-number-prototype-object",
          "subs": [{
            "id": "sec-number.prototype.constructor",
            "subs": []
          }, {
            "id": "sec-number.prototype.toexponential",
            "subs": []
          }, {
            "id": "sec-number.prototype.tofixed",
            "subs": []
          }, {
            "id": "sec-number.prototype.tolocalestring",
            "subs": []
          }, {
            "id": "sec-number.prototype.toprecision",
            "subs": []
          }, {
            "id": "sec-number.prototype.tostring",
            "subs": []
          }, {
            "id": "sec-number.prototype.valueof",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-number-instances",
          "subs": []
        }]
      }, {
        "id": "sec-bigint-objects",
        "subs": [{
          "id": "sec-bigint-constructor",
          "subs": [{
            "id": "sec-bigint-constructor-number-value",
            "subs": [{
              "id": "sec-numbertobigint",
              "subs": []
            }]
          }]
        }, {
          "id": "sec-properties-of-the-bigint-constructor",
          "subs": [{
            "id": "sec-bigint.asintn",
            "subs": []
          }, {
            "id": "sec-bigint.asuintn",
            "subs": []
          }, {
            "id": "sec-bigint.prototype",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-bigint-prototype-object",
          "subs": [{
            "id": "sec-bigint.prototype.constructor",
            "subs": []
          }, {
            "id": "sec-bigint.prototype.tolocalestring",
            "subs": []
          }, {
            "id": "sec-bigint.prototype.tostring",
            "subs": []
          }, {
            "id": "sec-bigint.prototype.valueof",
            "subs": []
          }, {
            "id": "sec-bigint.prototype-@@tostringtag",
            "subs": []
          }]
        }]
      }, {
        "id": "sec-math-object",
        "subs": [{
          "id": "sec-value-properties-of-the-math-object",
          "subs": [{
            "id": "sec-math.e",
            "subs": []
          }, {
            "id": "sec-math.ln10",
            "subs": []
          }, {
            "id": "sec-math.ln2",
            "subs": []
          }, {
            "id": "sec-math.log10e",
            "subs": []
          }, {
            "id": "sec-math.log2e",
            "subs": []
          }, {
            "id": "sec-math.pi",
            "subs": []
          }, {
            "id": "sec-math.sqrt1_2",
            "subs": []
          }, {
            "id": "sec-math.sqrt2",
            "subs": []
          }, {
            "id": "sec-math-@@tostringtag",
            "subs": []
          }]
        }, {
          "id": "sec-function-properties-of-the-math-object",
          "subs": [{
            "id": "sec-math.abs",
            "subs": []
          }, {
            "id": "sec-math.acos",
            "subs": []
          }, {
            "id": "sec-math.acosh",
            "subs": []
          }, {
            "id": "sec-math.asin",
            "subs": []
          }, {
            "id": "sec-math.asinh",
            "subs": []
          }, {
            "id": "sec-math.atan",
            "subs": []
          }, {
            "id": "sec-math.atanh",
            "subs": []
          }, {
            "id": "sec-math.atan2",
            "subs": []
          }, {
            "id": "sec-math.cbrt",
            "subs": []
          }, {
            "id": "sec-math.ceil",
            "subs": []
          }, {
            "id": "sec-math.clz32",
            "subs": []
          }, {
            "id": "sec-math.cos",
            "subs": []
          }, {
            "id": "sec-math.cosh",
            "subs": []
          }, {
            "id": "sec-math.exp",
            "subs": []
          }, {
            "id": "sec-math.expm1",
            "subs": []
          }, {
            "id": "sec-math.floor",
            "subs": []
          }, {
            "id": "sec-math.fround",
            "subs": []
          }, {
            "id": "sec-math.hypot",
            "subs": []
          }, {
            "id": "sec-math.imul",
            "subs": []
          }, {
            "id": "sec-math.log",
            "subs": []
          }, {
            "id": "sec-math.log1p",
            "subs": []
          }, {
            "id": "sec-math.log10",
            "subs": []
          }, {
            "id": "sec-math.log2",
            "subs": []
          }, {
            "id": "sec-math.max",
            "subs": []
          }, {
            "id": "sec-math.min",
            "subs": []
          }, {
            "id": "sec-math.pow",
            "subs": []
          }, {
            "id": "sec-math.random",
            "subs": []
          }, {
            "id": "sec-math.round",
            "subs": []
          }, {
            "id": "sec-math.sign",
            "subs": []
          }, {
            "id": "sec-math.sin",
            "subs": []
          }, {
            "id": "sec-math.sinh",
            "subs": []
          }, {
            "id": "sec-math.sqrt",
            "subs": []
          }, {
            "id": "sec-math.tan",
            "subs": []
          }, {
            "id": "sec-math.tanh",
            "subs": []
          }, {
            "id": "sec-math.trunc",
            "subs": []
          }]
        }]
      }, {
        "id": "sec-date-objects",
        "subs": [{
          "id": "sec-overview-of-date-objects-and-definitions-of-abstract-operations",
          "subs": [{
            "id": "sec-time-values-and-time-range",
            "subs": []
          }, {
            "id": "sec-day-number-and-time-within-day",
            "subs": []
          }, {
            "id": "sec-year-number",
            "subs": []
          }, {
            "id": "sec-month-number",
            "subs": []
          }, {
            "id": "sec-date-number",
            "subs": []
          }, {
            "id": "sec-week-day",
            "subs": []
          }, {
            "id": "sec-local-time-zone-adjustment",
            "subs": []
          }, {
            "id": "sec-localtime",
            "subs": []
          }, {
            "id": "sec-utc-t",
            "subs": []
          }, {
            "id": "sec-hours-minutes-second-and-milliseconds",
            "subs": []
          }, {
            "id": "sec-maketime",
            "subs": []
          }, {
            "id": "sec-makeday",
            "subs": []
          }, {
            "id": "sec-makedate",
            "subs": []
          }, {
            "id": "sec-timeclip",
            "subs": []
          }, {
            "id": "sec-date-time-string-format",
            "subs": [{
              "id": "sec-expanded-years",
              "subs": []
            }]
          }]
        }, {
          "id": "sec-date-constructor",
          "subs": [{
            "id": "sec-date",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-date-constructor",
          "subs": [{
            "id": "sec-date.now",
            "subs": []
          }, {
            "id": "sec-date.parse",
            "subs": []
          }, {
            "id": "sec-date.prototype",
            "subs": []
          }, {
            "id": "sec-date.utc",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-date-prototype-object",
          "subs": [{
            "id": "sec-date.prototype.constructor",
            "subs": []
          }, {
            "id": "sec-date.prototype.getdate",
            "subs": []
          }, {
            "id": "sec-date.prototype.getday",
            "subs": []
          }, {
            "id": "sec-date.prototype.getfullyear",
            "subs": []
          }, {
            "id": "sec-date.prototype.gethours",
            "subs": []
          }, {
            "id": "sec-date.prototype.getmilliseconds",
            "subs": []
          }, {
            "id": "sec-date.prototype.getminutes",
            "subs": []
          }, {
            "id": "sec-date.prototype.getmonth",
            "subs": []
          }, {
            "id": "sec-date.prototype.getseconds",
            "subs": []
          }, {
            "id": "sec-date.prototype.gettime",
            "subs": []
          }, {
            "id": "sec-date.prototype.gettimezoneoffset",
            "subs": []
          }, {
            "id": "sec-date.prototype.getutcdate",
            "subs": []
          }, {
            "id": "sec-date.prototype.getutcday",
            "subs": []
          }, {
            "id": "sec-date.prototype.getutcfullyear",
            "subs": []
          }, {
            "id": "sec-date.prototype.getutchours",
            "subs": []
          }, {
            "id": "sec-date.prototype.getutcmilliseconds",
            "subs": []
          }, {
            "id": "sec-date.prototype.getutcminutes",
            "subs": []
          }, {
            "id": "sec-date.prototype.getutcmonth",
            "subs": []
          }, {
            "id": "sec-date.prototype.getutcseconds",
            "subs": []
          }, {
            "id": "sec-date.prototype.setdate",
            "subs": []
          }, {
            "id": "sec-date.prototype.setfullyear",
            "subs": []
          }, {
            "id": "sec-date.prototype.sethours",
            "subs": []
          }, {
            "id": "sec-date.prototype.setmilliseconds",
            "subs": []
          }, {
            "id": "sec-date.prototype.setminutes",
            "subs": []
          }, {
            "id": "sec-date.prototype.setmonth",
            "subs": []
          }, {
            "id": "sec-date.prototype.setseconds",
            "subs": []
          }, {
            "id": "sec-date.prototype.settime",
            "subs": []
          }, {
            "id": "sec-date.prototype.setutcdate",
            "subs": []
          }, {
            "id": "sec-date.prototype.setutcfullyear",
            "subs": []
          }, {
            "id": "sec-date.prototype.setutchours",
            "subs": []
          }, {
            "id": "sec-date.prototype.setutcmilliseconds",
            "subs": []
          }, {
            "id": "sec-date.prototype.setutcminutes",
            "subs": []
          }, {
            "id": "sec-date.prototype.setutcmonth",
            "subs": []
          }, {
            "id": "sec-date.prototype.setutcseconds",
            "subs": []
          }, {
            "id": "sec-date.prototype.todatestring",
            "subs": []
          }, {
            "id": "sec-date.prototype.toisostring",
            "subs": []
          }, {
            "id": "sec-date.prototype.tojson",
            "subs": []
          }, {
            "id": "sec-date.prototype.tolocaledatestring",
            "subs": []
          }, {
            "id": "sec-date.prototype.tolocalestring",
            "subs": []
          }, {
            "id": "sec-date.prototype.tolocaletimestring",
            "subs": []
          }, {
            "id": "sec-date.prototype.tostring",
            "subs": [{
              "id": "sec-timestring",
              "subs": []
            }, {
              "id": "sec-datestring",
              "subs": []
            }, {
              "id": "sec-timezoneestring",
              "subs": []
            }, {
              "id": "sec-todatestring",
              "subs": []
            }]
          }, {
            "id": "sec-date.prototype.totimestring",
            "subs": []
          }, {
            "id": "sec-date.prototype.toutcstring",
            "subs": []
          }, {
            "id": "sec-date.prototype.valueof",
            "subs": []
          }, {
            "id": "sec-date.prototype-@@toprimitive",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-date-instances",
          "subs": []
        }]
      }]
    }, {
      "id": "sec-text-processing",
      "subs": [{
        "id": "sec-string-objects",
        "subs": [{
          "id": "sec-string-constructor",
          "subs": [{
            "id": "sec-string-constructor-string-value",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-string-constructor",
          "subs": [{
            "id": "sec-string.fromcharcode",
            "subs": []
          }, {
            "id": "sec-string.fromcodepoint",
            "subs": []
          }, {
            "id": "sec-string.prototype",
            "subs": []
          }, {
            "id": "sec-string.raw",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-string-prototype-object",
          "subs": [{
            "id": "sec-string.prototype.charat",
            "subs": []
          }, {
            "id": "sec-string.prototype.charcodeat",
            "subs": []
          }, {
            "id": "sec-string.prototype.codepointat",
            "subs": []
          }, {
            "id": "sec-string.prototype.concat",
            "subs": []
          }, {
            "id": "sec-string.prototype.constructor",
            "subs": []
          }, {
            "id": "sec-string.prototype.endswith",
            "subs": []
          }, {
            "id": "sec-string.prototype.includes",
            "subs": []
          }, {
            "id": "sec-string.prototype.indexof",
            "subs": []
          }, {
            "id": "sec-string.prototype.lastindexof",
            "subs": []
          }, {
            "id": "sec-string.prototype.localecompare",
            "subs": []
          }, {
            "id": "sec-string.prototype.match",
            "subs": []
          }, {
            "id": "sec-string.prototype.matchall",
            "subs": []
          }, {
            "id": "sec-string.prototype.normalize",
            "subs": []
          }, {
            "id": "sec-string.prototype.padend",
            "subs": []
          }, {
            "id": "sec-string.prototype.padstart",
            "subs": [{
              "id": "sec-stringpad",
              "subs": []
            }]
          }, {
            "id": "sec-string.prototype.repeat",
            "subs": []
          }, {
            "id": "sec-string.prototype.replace",
            "subs": [{
              "id": "sec-getsubstitution",
              "subs": []
            }]
          }, {
            "id": "sec-string.prototype.replaceall",
            "subs": []
          }, {
            "id": "sec-string.prototype.search",
            "subs": []
          }, {
            "id": "sec-string.prototype.slice",
            "subs": []
          }, {
            "id": "sec-string.prototype.split",
            "subs": [{
              "id": "sec-splitmatch",
              "subs": []
            }]
          }, {
            "id": "sec-string.prototype.startswith",
            "subs": []
          }, {
            "id": "sec-string.prototype.substring",
            "subs": []
          }, {
            "id": "sec-string.prototype.tolocalelowercase",
            "subs": []
          }, {
            "id": "sec-string.prototype.tolocaleuppercase",
            "subs": []
          }, {
            "id": "sec-string.prototype.tolowercase",
            "subs": []
          }, {
            "id": "sec-string.prototype.tostring",
            "subs": []
          }, {
            "id": "sec-string.prototype.touppercase",
            "subs": []
          }, {
            "id": "sec-string.prototype.trim",
            "subs": [{
              "id": "sec-trimstring",
              "subs": []
            }]
          }, {
            "id": "sec-string.prototype.trimend",
            "subs": []
          }, {
            "id": "sec-string.prototype.trimstart",
            "subs": []
          }, {
            "id": "sec-string.prototype.valueof",
            "subs": []
          }, {
            "id": "sec-string.prototype-@@iterator",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-string-instances",
          "subs": [{
            "id": "sec-properties-of-string-instances-length",
            "subs": []
          }]
        }, {
          "id": "sec-string-iterator-objects",
          "subs": [{
            "id": "sec-%stringiteratorprototype%-object",
            "subs": [{
              "id": "sec-%stringiteratorprototype%.next",
              "subs": []
            }, {
              "id": "sec-%stringiteratorprototype%-@@tostringtag",
              "subs": []
            }]
          }]
        }]
      }, {
        "id": "sec-regexp-regular-expression-objects",
        "subs": [{
          "id": "sec-patterns",
          "subs": [{
            "id": "sec-patterns-static-semantics-early-errors",
            "subs": []
          }, {
            "id": "sec-patterns-static-semantics-capturing-group-number",
            "subs": []
          }, {
            "id": "sec-patterns-static-semantics-is-character-class",
            "subs": []
          }, {
            "id": "sec-patterns-static-semantics-character-value",
            "subs": []
          }, {
            "id": "sec-static-semantics-sourcetext",
            "subs": []
          }, {
            "id": "sec-static-semantics-capturinggroupname",
            "subs": []
          }]
        }, {
          "id": "sec-pattern-semantics",
          "subs": [{
            "id": "sec-notation",
            "subs": []
          }, {
            "id": "sec-pattern",
            "subs": []
          }, {
            "id": "sec-disjunction",
            "subs": []
          }, {
            "id": "sec-alternative",
            "subs": []
          }, {
            "id": "sec-term",
            "subs": [{
              "id": "sec-runtime-semantics-repeatmatcher-abstract-operation",
              "subs": []
            }]
          }, {
            "id": "sec-assertion",
            "subs": [{
              "id": "sec-runtime-semantics-iswordchar-abstract-operation",
              "subs": []
            }]
          }, {
            "id": "sec-quantifier",
            "subs": []
          }, {
            "id": "sec-atom",
            "subs": [{
              "id": "sec-runtime-semantics-charactersetmatcher-abstract-operation",
              "subs": []
            }, {
              "id": "sec-runtime-semantics-canonicalize-ch",
              "subs": []
            }, {
              "id": "sec-runtime-semantics-unicodematchproperty-p",
              "subs": []
            }, {
              "id": "sec-runtime-semantics-unicodematchpropertyvalue-p-v",
              "subs": []
            }]
          }, {
            "id": "sec-atomescape",
            "subs": [{
              "id": "sec-backreference-matcher",
              "subs": []
            }]
          }, {
            "id": "sec-characterescape",
            "subs": []
          }, {
            "id": "sec-decimalescape",
            "subs": []
          }, {
            "id": "sec-characterclassescape",
            "subs": []
          }, {
            "id": "sec-characterclass",
            "subs": []
          }, {
            "id": "sec-classranges",
            "subs": []
          }, {
            "id": "sec-nonemptyclassranges",
            "subs": [{
              "id": "sec-runtime-semantics-characterrange-abstract-operation",
              "subs": []
            }]
          }, {
            "id": "sec-nonemptyclassrangesnodash",
            "subs": []
          }, {
            "id": "sec-classatom",
            "subs": []
          }, {
            "id": "sec-classatomnodash",
            "subs": []
          }, {
            "id": "sec-classescape",
            "subs": []
          }]
        }, {
          "id": "sec-regexp-constructor",
          "subs": [{
            "id": "sec-regexp-pattern-flags",
            "subs": []
          }, {
            "id": "sec-abstract-operations-for-the-regexp-constructor",
            "subs": [{
              "id": "sec-regexpalloc",
              "subs": []
            }, {
              "id": "sec-regexpinitialize",
              "subs": []
            }, {
              "id": "sec-parsepattern",
              "subs": []
            }, {
              "id": "sec-regexpcreate",
              "subs": []
            }, {
              "id": "sec-escaperegexppattern",
              "subs": []
            }]
          }]
        }, {
          "id": "sec-properties-of-the-regexp-constructor",
          "subs": [{
            "id": "sec-regexp.prototype",
            "subs": []
          }, {
            "id": "sec-get-regexp-@@species",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-regexp-prototype-object",
          "subs": [{
            "id": "sec-regexp.prototype.constructor",
            "subs": []
          }, {
            "id": "sec-regexp.prototype.exec",
            "subs": [{
              "id": "sec-regexpexec",
              "subs": []
            }, {
              "id": "sec-regexpbuiltinexec",
              "subs": []
            }, {
              "id": "sec-advancestringindex",
              "subs": []
            }]
          }, {
            "id": "sec-get-regexp.prototype.dotAll",
            "subs": []
          }, {
            "id": "sec-get-regexp.prototype.flags",
            "subs": []
          }, {
            "id": "sec-get-regexp.prototype.global",
            "subs": []
          }, {
            "id": "sec-get-regexp.prototype.ignorecase",
            "subs": []
          }, {
            "id": "sec-regexp.prototype-@@match",
            "subs": []
          }, {
            "id": "sec-regexp-prototype-matchall",
            "subs": []
          }, {
            "id": "sec-get-regexp.prototype.multiline",
            "subs": []
          }, {
            "id": "sec-regexp.prototype-@@replace",
            "subs": []
          }, {
            "id": "sec-regexp.prototype-@@search",
            "subs": []
          }, {
            "id": "sec-get-regexp.prototype.source",
            "subs": []
          }, {
            "id": "sec-regexp.prototype-@@split",
            "subs": []
          }, {
            "id": "sec-get-regexp.prototype.sticky",
            "subs": []
          }, {
            "id": "sec-regexp.prototype.test",
            "subs": []
          }, {
            "id": "sec-regexp.prototype.tostring",
            "subs": []
          }, {
            "id": "sec-get-regexp.prototype.unicode",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-regexp-instances",
          "subs": [{
            "id": "sec-lastindex",
            "subs": []
          }]
        }, {
          "id": "sec-regexp-string-iterator-objects",
          "subs": [{
            "id": "sec-createregexpstringiterator",
            "subs": []
          }, {
            "id": "sec-%regexpstringiteratorprototype%-object",
            "subs": [{
              "id": "sec-%regexpstringiteratorprototype%.next",
              "subs": []
            }, {
              "id": "sec-%regexpstringiteratorprototype%-@@tostringtag",
              "subs": []
            }]
          }]
        }]
      }]
    }, {
      "id": "sec-indexed-collections",
      "subs": [{
        "id": "sec-array-objects",
        "subs": [{
          "id": "sec-array-constructor",
          "subs": [{
            "id": "sec-array",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-array-constructor",
          "subs": [{
            "id": "sec-array.from",
            "subs": []
          }, {
            "id": "sec-array.isarray",
            "subs": []
          }, {
            "id": "sec-array.of",
            "subs": []
          }, {
            "id": "sec-array.prototype",
            "subs": []
          }, {
            "id": "sec-get-array-@@species",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-array-prototype-object",
          "subs": [{
            "id": "sec-array.prototype.concat",
            "subs": [{
              "id": "sec-isconcatspreadable",
              "subs": []
            }]
          }, {
            "id": "sec-array.prototype.constructor",
            "subs": []
          }, {
            "id": "sec-array.prototype.copywithin",
            "subs": []
          }, {
            "id": "sec-array.prototype.entries",
            "subs": []
          }, {
            "id": "sec-array.prototype.every",
            "subs": []
          }, {
            "id": "sec-array.prototype.fill",
            "subs": []
          }, {
            "id": "sec-array.prototype.filter",
            "subs": []
          }, {
            "id": "sec-array.prototype.find",
            "subs": []
          }, {
            "id": "sec-array.prototype.findindex",
            "subs": []
          }, {
            "id": "sec-array.prototype.flat",
            "subs": [{
              "id": "sec-flattenintoarray",
              "subs": []
            }]
          }, {
            "id": "sec-array.prototype.flatmap",
            "subs": []
          }, {
            "id": "sec-array.prototype.foreach",
            "subs": []
          }, {
            "id": "sec-array.prototype.includes",
            "subs": []
          }, {
            "id": "sec-array.prototype.indexof",
            "subs": []
          }, {
            "id": "sec-array.prototype.join",
            "subs": []
          }, {
            "id": "sec-array.prototype.keys",
            "subs": []
          }, {
            "id": "sec-array.prototype.lastindexof",
            "subs": []
          }, {
            "id": "sec-array.prototype.map",
            "subs": []
          }, {
            "id": "sec-array.prototype.pop",
            "subs": []
          }, {
            "id": "sec-array.prototype.push",
            "subs": []
          }, {
            "id": "sec-array.prototype.reduce",
            "subs": []
          }, {
            "id": "sec-array.prototype.reduceright",
            "subs": []
          }, {
            "id": "sec-array.prototype.reverse",
            "subs": []
          }, {
            "id": "sec-array.prototype.shift",
            "subs": []
          }, {
            "id": "sec-array.prototype.slice",
            "subs": []
          }, {
            "id": "sec-array.prototype.some",
            "subs": []
          }, {
            "id": "sec-array.prototype.sort",
            "subs": [{
              "id": "sec-sortcompare",
              "subs": []
            }]
          }, {
            "id": "sec-array.prototype.splice",
            "subs": []
          }, {
            "id": "sec-array.prototype.tolocalestring",
            "subs": []
          }, {
            "id": "sec-array.prototype.tostring",
            "subs": []
          }, {
            "id": "sec-array.prototype.unshift",
            "subs": []
          }, {
            "id": "sec-array.prototype.values",
            "subs": []
          }, {
            "id": "sec-array.prototype-@@iterator",
            "subs": []
          }, {
            "id": "sec-array.prototype-@@unscopables",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-array-instances",
          "subs": [{
            "id": "sec-properties-of-array-instances-length",
            "subs": []
          }]
        }, {
          "id": "sec-array-iterator-objects",
          "subs": [{
            "id": "sec-createarrayiterator",
            "subs": []
          }, {
            "id": "sec-%arrayiteratorprototype%-object",
            "subs": [{
              "id": "sec-%arrayiteratorprototype%.next",
              "subs": []
            }, {
              "id": "sec-%arrayiteratorprototype%-@@tostringtag",
              "subs": []
            }]
          }]
        }]
      }, {
        "id": "sec-typedarray-objects",
        "subs": [{
          "id": "sec-%typedarray%-intrinsic-object",
          "subs": [{
            "id": "sec-%typedarray%",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-%typedarray%-intrinsic-object",
          "subs": [{
            "id": "sec-%typedarray%.from",
            "subs": []
          }, {
            "id": "sec-%typedarray%.of",
            "subs": []
          }, {
            "id": "sec-%typedarray%.prototype",
            "subs": []
          }, {
            "id": "sec-get-%typedarray%-@@species",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-%typedarrayprototype%-object",
          "subs": [{
            "id": "sec-get-%typedarray%.prototype.buffer",
            "subs": []
          }, {
            "id": "sec-get-%typedarray%.prototype.bytelength",
            "subs": []
          }, {
            "id": "sec-get-%typedarray%.prototype.byteoffset",
            "subs": []
          }, {
            "id": "sec-%typedarray%.prototype.constructor",
            "subs": []
          }, {
            "id": "sec-%typedarray%.prototype.copywithin",
            "subs": []
          }, {
            "id": "sec-%typedarray%.prototype.entries",
            "subs": []
          }, {
            "id": "sec-%typedarray%.prototype.every",
            "subs": []
          }, {
            "id": "sec-%typedarray%.prototype.fill",
            "subs": []
          }, {
            "id": "sec-%typedarray%.prototype.filter",
            "subs": []
          }, {
            "id": "sec-%typedarray%.prototype.find",
            "subs": []
          }, {
            "id": "sec-%typedarray%.prototype.findindex",
            "subs": []
          }, {
            "id": "sec-%typedarray%.prototype.foreach",
            "subs": []
          }, {
            "id": "sec-%typedarray%.prototype.includes",
            "subs": []
          }, {
            "id": "sec-%typedarray%.prototype.indexof",
            "subs": []
          }, {
            "id": "sec-%typedarray%.prototype.join",
            "subs": []
          }, {
            "id": "sec-%typedarray%.prototype.keys",
            "subs": []
          }, {
            "id": "sec-%typedarray%.prototype.lastindexof",
            "subs": []
          }, {
            "id": "sec-get-%typedarray%.prototype.length",
            "subs": []
          }, {
            "id": "sec-%typedarray%.prototype.map",
            "subs": []
          }, {
            "id": "sec-%typedarray%.prototype.reduce",
            "subs": []
          }, {
            "id": "sec-%typedarray%.prototype.reduceright",
            "subs": []
          }, {
            "id": "sec-%typedarray%.prototype.reverse",
            "subs": []
          }, {
            "id": "sec-%typedarray%.prototype.set",
            "subs": [{
              "id": "sec-settypedarrayfromtypedarray",
              "subs": []
            }, {
              "id": "sec-settypedarrayfromarraylike",
              "subs": []
            }]
          }, {
            "id": "sec-%typedarray%.prototype.slice",
            "subs": []
          }, {
            "id": "sec-%typedarray%.prototype.some",
            "subs": []
          }, {
            "id": "sec-%typedarray%.prototype.sort",
            "subs": []
          }, {
            "id": "sec-%typedarray%.prototype.subarray",
            "subs": []
          }, {
            "id": "sec-%typedarray%.prototype.tolocalestring",
            "subs": []
          }, {
            "id": "sec-%typedarray%.prototype.tostring",
            "subs": []
          }, {
            "id": "sec-%typedarray%.prototype.values",
            "subs": []
          }, {
            "id": "sec-%typedarray%.prototype-@@iterator",
            "subs": []
          }, {
            "id": "sec-get-%typedarray%.prototype-@@tostringtag",
            "subs": []
          }]
        }, {
          "id": "sec-abstract-operations-for-typedarray-objects",
          "subs": [{
            "id": "typedarray-species-create",
            "subs": []
          }, {
            "id": "typedarray-create",
            "subs": []
          }, {
            "id": "sec-validatetypedarray",
            "subs": []
          }]
        }, {
          "id": "sec-typedarray-constructors",
          "subs": [{
            "id": "sec-typedarray",
            "subs": [{
              "id": "sec-allocatetypedarray",
              "subs": []
            }, {
              "id": "sec-initializetypedarrayfromtypedarray",
              "subs": []
            }, {
              "id": "sec-initializetypedarrayfromarraybuffer",
              "subs": []
            }, {
              "id": "sec-initializetypedarrayfromlist",
              "subs": []
            }, {
              "id": "sec-initializetypedarrayfromarraylike",
              "subs": []
            }, {
              "id": "sec-allocatetypedarraybuffer",
              "subs": []
            }]
          }]
        }, {
          "id": "sec-properties-of-the-typedarray-constructors",
          "subs": [{
            "id": "sec-typedarray.bytes_per_element",
            "subs": []
          }, {
            "id": "sec-typedarray.prototype",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-typedarray-prototype-objects",
          "subs": [{
            "id": "sec-typedarray.prototype.bytes_per_element",
            "subs": []
          }, {
            "id": "sec-typedarray.prototype.constructor",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-typedarray-instances",
          "subs": []
        }]
      }]
    }, {
      "id": "sec-keyed-collections",
      "subs": [{
        "id": "sec-map-objects",
        "subs": [{
          "id": "sec-map-constructor",
          "subs": [{
            "id": "sec-map-iterable",
            "subs": []
          }, {
            "id": "sec-add-entries-from-iterable",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-map-constructor",
          "subs": [{
            "id": "sec-map.prototype",
            "subs": []
          }, {
            "id": "sec-get-map-@@species",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-map-prototype-object",
          "subs": [{
            "id": "sec-map.prototype.clear",
            "subs": []
          }, {
            "id": "sec-map.prototype.constructor",
            "subs": []
          }, {
            "id": "sec-map.prototype.delete",
            "subs": []
          }, {
            "id": "sec-map.prototype.entries",
            "subs": []
          }, {
            "id": "sec-map.prototype.foreach",
            "subs": []
          }, {
            "id": "sec-map.prototype.get",
            "subs": []
          }, {
            "id": "sec-map.prototype.has",
            "subs": []
          }, {
            "id": "sec-map.prototype.keys",
            "subs": []
          }, {
            "id": "sec-map.prototype.set",
            "subs": []
          }, {
            "id": "sec-get-map.prototype.size",
            "subs": []
          }, {
            "id": "sec-map.prototype.values",
            "subs": []
          }, {
            "id": "sec-map.prototype-@@iterator",
            "subs": []
          }, {
            "id": "sec-map.prototype-@@tostringtag",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-map-instances",
          "subs": []
        }, {
          "id": "sec-map-iterator-objects",
          "subs": [{
            "id": "sec-createmapiterator",
            "subs": []
          }, {
            "id": "sec-%mapiteratorprototype%-object",
            "subs": [{
              "id": "sec-%mapiteratorprototype%.next",
              "subs": []
            }, {
              "id": "sec-%mapiteratorprototype%-@@tostringtag",
              "subs": []
            }]
          }]
        }]
      }, {
        "id": "sec-set-objects",
        "subs": [{
          "id": "sec-set-constructor",
          "subs": [{
            "id": "sec-set-iterable",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-set-constructor",
          "subs": [{
            "id": "sec-set.prototype",
            "subs": []
          }, {
            "id": "sec-get-set-@@species",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-set-prototype-object",
          "subs": [{
            "id": "sec-set.prototype.add",
            "subs": []
          }, {
            "id": "sec-set.prototype.clear",
            "subs": []
          }, {
            "id": "sec-set.prototype.constructor",
            "subs": []
          }, {
            "id": "sec-set.prototype.delete",
            "subs": []
          }, {
            "id": "sec-set.prototype.entries",
            "subs": []
          }, {
            "id": "sec-set.prototype.foreach",
            "subs": []
          }, {
            "id": "sec-set.prototype.has",
            "subs": []
          }, {
            "id": "sec-set.prototype.keys",
            "subs": []
          }, {
            "id": "sec-get-set.prototype.size",
            "subs": []
          }, {
            "id": "sec-set.prototype.values",
            "subs": []
          }, {
            "id": "sec-set.prototype-@@iterator",
            "subs": []
          }, {
            "id": "sec-set.prototype-@@tostringtag",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-set-instances",
          "subs": []
        }, {
          "id": "sec-set-iterator-objects",
          "subs": [{
            "id": "sec-createsetiterator",
            "subs": []
          }, {
            "id": "sec-%setiteratorprototype%-object",
            "subs": [{
              "id": "sec-%setiteratorprototype%.next",
              "subs": []
            }, {
              "id": "sec-%setiteratorprototype%-@@tostringtag",
              "subs": []
            }]
          }]
        }]
      }, {
        "id": "sec-weakmap-objects",
        "subs": [{
          "id": "sec-weakmap-constructor",
          "subs": [{
            "id": "sec-weakmap-iterable",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-weakmap-constructor",
          "subs": [{
            "id": "sec-weakmap.prototype",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-weakmap-prototype-object",
          "subs": [{
            "id": "sec-weakmap.prototype.constructor",
            "subs": []
          }, {
            "id": "sec-weakmap.prototype.delete",
            "subs": []
          }, {
            "id": "sec-weakmap.prototype.get",
            "subs": []
          }, {
            "id": "sec-weakmap.prototype.has",
            "subs": []
          }, {
            "id": "sec-weakmap.prototype.set",
            "subs": []
          }, {
            "id": "sec-weakmap.prototype-@@tostringtag",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-weakmap-instances",
          "subs": []
        }]
      }, {
        "id": "sec-weakset-objects",
        "subs": [{
          "id": "sec-weakset-constructor",
          "subs": [{
            "id": "sec-weakset-iterable",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-weakset-constructor",
          "subs": [{
            "id": "sec-weakset.prototype",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-weakset-prototype-object",
          "subs": [{
            "id": "sec-weakset.prototype.add",
            "subs": []
          }, {
            "id": "sec-weakset.prototype.constructor",
            "subs": []
          }, {
            "id": "sec-weakset.prototype.delete",
            "subs": []
          }, {
            "id": "sec-weakset.prototype.has",
            "subs": []
          }, {
            "id": "sec-weakset.prototype-@@tostringtag",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-weakset-instances",
          "subs": []
        }]
      }]
    }, {
      "id": "sec-structured-data",
      "subs": [{
        "id": "sec-arraybuffer-objects",
        "subs": [{
          "id": "sec-arraybuffer-notation",
          "subs": []
        }, {
          "id": "sec-abstract-operations-for-arraybuffer-objects",
          "subs": [{
            "id": "sec-allocatearraybuffer",
            "subs": []
          }, {
            "id": "sec-isdetachedbuffer",
            "subs": []
          }, {
            "id": "sec-detacharraybuffer",
            "subs": []
          }, {
            "id": "sec-clonearraybuffer",
            "subs": []
          }, {
            "id": "sec-isunsignedelementtype",
            "subs": []
          }, {
            "id": "sec-isunclampedintegerelementtype",
            "subs": []
          }, {
            "id": "sec-isbigintelementtype",
            "subs": []
          }, {
            "id": "sec-isnotearconfiguration",
            "subs": []
          }, {
            "id": "sec-rawbytestonumeric",
            "subs": []
          }, {
            "id": "sec-getvaluefrombuffer",
            "subs": []
          }, {
            "id": "sec-numerictorawbytes",
            "subs": []
          }, {
            "id": "sec-setvalueinbuffer",
            "subs": []
          }, {
            "id": "sec-getmodifysetvalueinbuffer",
            "subs": []
          }]
        }, {
          "id": "sec-arraybuffer-constructor",
          "subs": [{
            "id": "sec-arraybuffer-length",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-arraybuffer-constructor",
          "subs": [{
            "id": "sec-arraybuffer.isview",
            "subs": []
          }, {
            "id": "sec-arraybuffer.prototype",
            "subs": []
          }, {
            "id": "sec-get-arraybuffer-@@species",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-arraybuffer-prototype-object",
          "subs": [{
            "id": "sec-get-arraybuffer.prototype.bytelength",
            "subs": []
          }, {
            "id": "sec-arraybuffer.prototype.constructor",
            "subs": []
          }, {
            "id": "sec-arraybuffer.prototype.slice",
            "subs": []
          }, {
            "id": "sec-arraybuffer.prototype-@@tostringtag",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-arraybuffer-instances",
          "subs": []
        }]
      }, {
        "id": "sec-sharedarraybuffer-objects",
        "subs": [{
          "id": "sec-abstract-operations-for-sharedarraybuffer-objects",
          "subs": [{
            "id": "sec-allocatesharedarraybuffer",
            "subs": []
          }, {
            "id": "sec-issharedarraybuffer",
            "subs": []
          }]
        }, {
          "id": "sec-sharedarraybuffer-constructor",
          "subs": [{
            "id": "sec-sharedarraybuffer-length",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-sharedarraybuffer-constructor",
          "subs": [{
            "id": "sec-sharedarraybuffer.prototype",
            "subs": []
          }, {
            "id": "sec-sharedarraybuffer-@@species",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-sharedarraybuffer-prototype-object",
          "subs": [{
            "id": "sec-get-sharedarraybuffer.prototype.bytelength",
            "subs": []
          }, {
            "id": "sec-sharedarraybuffer.prototype.constructor",
            "subs": []
          }, {
            "id": "sec-sharedarraybuffer.prototype.slice",
            "subs": []
          }, {
            "id": "sec-sharedarraybuffer.prototype.toString",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-sharedarraybuffer-instances",
          "subs": []
        }]
      }, {
        "id": "sec-dataview-objects",
        "subs": [{
          "id": "sec-abstract-operations-for-dataview-objects",
          "subs": [{
            "id": "sec-getviewvalue",
            "subs": []
          }, {
            "id": "sec-setviewvalue",
            "subs": []
          }]
        }, {
          "id": "sec-dataview-constructor",
          "subs": [{
            "id": "sec-dataview-buffer-byteoffset-bytelength",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-dataview-constructor",
          "subs": [{
            "id": "sec-dataview.prototype",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-dataview-prototype-object",
          "subs": [{
            "id": "sec-get-dataview.prototype.buffer",
            "subs": []
          }, {
            "id": "sec-get-dataview.prototype.bytelength",
            "subs": []
          }, {
            "id": "sec-get-dataview.prototype.byteoffset",
            "subs": []
          }, {
            "id": "sec-dataview.prototype.constructor",
            "subs": []
          }, {
            "id": "sec-dataview.prototype.getbigint64",
            "subs": []
          }, {
            "id": "sec-dataview.prototype.getbiguint64",
            "subs": []
          }, {
            "id": "sec-dataview.prototype.getfloat32",
            "subs": []
          }, {
            "id": "sec-dataview.prototype.getfloat64",
            "subs": []
          }, {
            "id": "sec-dataview.prototype.getint8",
            "subs": []
          }, {
            "id": "sec-dataview.prototype.getint16",
            "subs": []
          }, {
            "id": "sec-dataview.prototype.getint32",
            "subs": []
          }, {
            "id": "sec-dataview.prototype.getuint8",
            "subs": []
          }, {
            "id": "sec-dataview.prototype.getuint16",
            "subs": []
          }, {
            "id": "sec-dataview.prototype.getuint32",
            "subs": []
          }, {
            "id": "sec-dataview.prototype.setbigint64",
            "subs": []
          }, {
            "id": "sec-dataview.prototype.setbiguint64",
            "subs": []
          }, {
            "id": "sec-dataview.prototype.setfloat32",
            "subs": []
          }, {
            "id": "sec-dataview.prototype.setfloat64",
            "subs": []
          }, {
            "id": "sec-dataview.prototype.setint8",
            "subs": []
          }, {
            "id": "sec-dataview.prototype.setint16",
            "subs": []
          }, {
            "id": "sec-dataview.prototype.setint32",
            "subs": []
          }, {
            "id": "sec-dataview.prototype.setuint8",
            "subs": []
          }, {
            "id": "sec-dataview.prototype.setuint16",
            "subs": []
          }, {
            "id": "sec-dataview.prototype.setuint32",
            "subs": []
          }, {
            "id": "sec-dataview.prototype-@@tostringtag",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-dataview-instances",
          "subs": []
        }]
      }, {
        "id": "sec-atomics-object",
        "subs": [{
          "id": "sec-abstract-operations-for-atomics",
          "subs": [{
            "id": "sec-validateintegertypedarray",
            "subs": []
          }, {
            "id": "sec-validateatomicaccess",
            "subs": []
          }, {
            "id": "sec-getwaiterlist",
            "subs": []
          }, {
            "id": "sec-entercriticalsection",
            "subs": []
          }, {
            "id": "sec-leavecriticalsection",
            "subs": []
          }, {
            "id": "sec-addwaiter",
            "subs": []
          }, {
            "id": "sec-removewaiter",
            "subs": []
          }, {
            "id": "sec-removewaiters",
            "subs": []
          }, {
            "id": "sec-suspendagent",
            "subs": []
          }, {
            "id": "sec-notifywaiter",
            "subs": []
          }, {
            "id": "sec-atomicreadmodifywrite",
            "subs": []
          }, {
            "id": "sec-bytelistbitwiseop",
            "subs": []
          }, {
            "id": "sec-bytelistequal",
            "subs": []
          }]
        }, {
          "id": "sec-atomics.add",
          "subs": []
        }, {
          "id": "sec-atomics.and",
          "subs": []
        }, {
          "id": "sec-atomics.compareexchange",
          "subs": []
        }, {
          "id": "sec-atomics.exchange",
          "subs": []
        }, {
          "id": "sec-atomics.islockfree",
          "subs": []
        }, {
          "id": "sec-atomics.load",
          "subs": []
        }, {
          "id": "sec-atomics.or",
          "subs": []
        }, {
          "id": "sec-atomics.store",
          "subs": []
        }, {
          "id": "sec-atomics.sub",
          "subs": []
        }, {
          "id": "sec-atomics.wait",
          "subs": []
        }, {
          "id": "sec-atomics.notify",
          "subs": []
        }, {
          "id": "sec-atomics.xor",
          "subs": []
        }, {
          "id": "sec-atomics-@@tostringtag",
          "subs": []
        }]
      }, {
        "id": "sec-json-object",
        "subs": [{
          "id": "sec-json.parse",
          "subs": [{
            "id": "sec-internalizejsonproperty",
            "subs": []
          }]
        }, {
          "id": "sec-json.stringify",
          "subs": [{
            "id": "sec-serializejsonproperty",
            "subs": []
          }, {
            "id": "sec-quotejsonstring",
            "subs": []
          }, {
            "id": "sec-unicodeescape",
            "subs": []
          }, {
            "id": "sec-serializejsonobject",
            "subs": []
          }, {
            "id": "sec-serializejsonarray",
            "subs": []
          }]
        }, {
          "id": "sec-json-@@tostringtag",
          "subs": []
        }]
      }]
    }, {
      "id": "sec-managing-memory",
      "subs": [{
        "id": "sec-weak-ref-objects",
        "subs": [{
          "id": "sec-weak-ref-constructor",
          "subs": [{
            "id": "sec-weak-ref-target",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-weak-ref-constructor",
          "subs": [{
            "id": "sec-weak-ref.prototype",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-weak-ref-prototype-object",
          "subs": [{
            "id": "sec-weak-ref.prototype.constructor",
            "subs": []
          }, {
            "id": "sec-weak-ref.prototype.deref",
            "subs": []
          }, {
            "id": "sec-weak-ref.prototype-@@tostringtag",
            "subs": []
          }]
        }, {
          "id": "sec-weakref-abstract-operations",
          "subs": [{
            "id": "sec-weakrefderef",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-weak-ref-instances",
          "subs": []
        }]
      }, {
        "id": "sec-finalization-registry-objects",
        "subs": [{
          "id": "sec-finalization-registry-constructor",
          "subs": [{
            "id": "sec-finalization-registry-cleanup-callback",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-finalization-registry-constructor",
          "subs": [{
            "id": "sec-finalization-registry.prototype",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-finalization-registry-prototype-object",
          "subs": [{
            "id": "sec-finalization-registry.prototype.constructor",
            "subs": []
          }, {
            "id": "sec-finalization-registry.prototype.register",
            "subs": []
          }, {
            "id": "sec-finalization-registry.prototype.unregister",
            "subs": []
          }, {
            "id": "sec-finalization-registry.prototype-@@tostringtag",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-finalization-registry-instances",
          "subs": []
        }]
      }]
    }, {
      "id": "sec-control-abstraction-objects",
      "subs": [{
        "id": "sec-iteration",
        "subs": [{
          "id": "sec-common-iteration-interfaces",
          "subs": [{
            "id": "sec-iterable-interface",
            "subs": []
          }, {
            "id": "sec-iterator-interface",
            "subs": []
          }, {
            "id": "sec-asynciterable-interface",
            "subs": []
          }, {
            "id": "sec-asynciterator-interface",
            "subs": []
          }, {
            "id": "sec-iteratorresult-interface",
            "subs": []
          }]
        }, {
          "id": "sec-%iteratorprototype%-object",
          "subs": [{
            "id": "sec-%iteratorprototype%-@@iterator",
            "subs": []
          }]
        }, {
          "id": "sec-asynciteratorprototype",
          "subs": [{
            "id": "sec-asynciteratorprototype-asynciterator",
            "subs": []
          }]
        }, {
          "id": "sec-async-from-sync-iterator-objects",
          "subs": [{
            "id": "sec-createasyncfromsynciterator",
            "subs": []
          }, {
            "id": "sec-%asyncfromsynciteratorprototype%-object",
            "subs": [{
              "id": "sec-%asyncfromsynciteratorprototype%.next",
              "subs": []
            }, {
              "id": "sec-%asyncfromsynciteratorprototype%.return",
              "subs": []
            }, {
              "id": "sec-%asyncfromsynciteratorprototype%.throw",
              "subs": []
            }, {
              "id": "sec-async-from-sync-iterator-value-unwrap-functions",
              "subs": []
            }]
          }, {
            "id": "sec-properties-of-async-from-sync-iterator-instances",
            "subs": []
          }, {
            "id": "sec-asyncfromsynciteratorcontinuation",
            "subs": []
          }]
        }]
      }, {
        "id": "sec-promise-objects",
        "subs": [{
          "id": "sec-promise-abstract-operations",
          "subs": [{
            "id": "sec-promisecapability-records",
            "subs": [{
              "id": "sec-ifabruptrejectpromise",
              "subs": []
            }]
          }, {
            "id": "sec-promisereaction-records",
            "subs": []
          }, {
            "id": "sec-createresolvingfunctions",
            "subs": [{
              "id": "sec-promise-reject-functions",
              "subs": []
            }, {
              "id": "sec-promise-resolve-functions",
              "subs": []
            }]
          }, {
            "id": "sec-fulfillpromise",
            "subs": []
          }, {
            "id": "sec-newpromisecapability",
            "subs": [{
              "id": "sec-getcapabilitiesexecutor-functions",
              "subs": []
            }]
          }, {
            "id": "sec-ispromise",
            "subs": []
          }, {
            "id": "sec-rejectpromise",
            "subs": []
          }, {
            "id": "sec-triggerpromisereactions",
            "subs": []
          }, {
            "id": "sec-host-promise-rejection-tracker",
            "subs": []
          }]
        }, {
          "id": "sec-promise-jobs",
          "subs": [{
            "id": "sec-newpromisereactionjob",
            "subs": []
          }, {
            "id": "sec-newpromiseresolvethenablejob",
            "subs": []
          }]
        }, {
          "id": "sec-promise-constructor",
          "subs": [{
            "id": "sec-promise-executor",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-promise-constructor",
          "subs": [{
            "id": "sec-promise.all",
            "subs": [{
              "id": "sec-getpromiseresolve",
              "subs": []
            }, {
              "id": "sec-performpromiseall",
              "subs": []
            }, {
              "id": "sec-promise.all-resolve-element-functions",
              "subs": []
            }]
          }, {
            "id": "sec-promise.allsettled",
            "subs": [{
              "id": "sec-performpromiseallsettled",
              "subs": []
            }, {
              "id": "sec-promise.allsettled-resolve-element-functions",
              "subs": []
            }, {
              "id": "sec-promise.allsettled-reject-element-functions",
              "subs": []
            }]
          }, {
            "id": "sec-promise.any",
            "subs": [{
              "id": "sec-performpromiseany",
              "subs": []
            }, {
              "id": "sec-promise.any-reject-element-functions",
              "subs": []
            }]
          }, {
            "id": "sec-promise.prototype",
            "subs": []
          }, {
            "id": "sec-promise.race",
            "subs": [{
              "id": "sec-performpromiserace",
              "subs": []
            }]
          }, {
            "id": "sec-promise.reject",
            "subs": []
          }, {
            "id": "sec-promise.resolve",
            "subs": [{
              "id": "sec-promise-resolve",
              "subs": []
            }]
          }, {
            "id": "sec-get-promise-@@species",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-promise-prototype-object",
          "subs": [{
            "id": "sec-promise.prototype.catch",
            "subs": []
          }, {
            "id": "sec-promise.prototype.constructor",
            "subs": []
          }, {
            "id": "sec-promise.prototype.finally",
            "subs": [{
              "id": "sec-thenfinallyfunctions",
              "subs": []
            }, {
              "id": "sec-catchfinallyfunctions",
              "subs": []
            }]
          }, {
            "id": "sec-promise.prototype.then",
            "subs": [{
              "id": "sec-performpromisethen",
              "subs": []
            }]
          }, {
            "id": "sec-promise.prototype-@@tostringtag",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-promise-instances",
          "subs": []
        }]
      }, {
        "id": "sec-generatorfunction-objects",
        "subs": [{
          "id": "sec-generatorfunction-constructor",
          "subs": [{
            "id": "sec-generatorfunction",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-generatorfunction-constructor",
          "subs": [{
            "id": "sec-generatorfunction.length",
            "subs": []
          }, {
            "id": "sec-generatorfunction.prototype",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-generatorfunction-prototype-object",
          "subs": [{
            "id": "sec-generatorfunction.prototype.constructor",
            "subs": []
          }, {
            "id": "sec-generatorfunction.prototype.prototype",
            "subs": []
          }, {
            "id": "sec-generatorfunction.prototype-@@tostringtag",
            "subs": []
          }]
        }, {
          "id": "sec-generatorfunction-instances",
          "subs": [{
            "id": "sec-generatorfunction-instances-length",
            "subs": []
          }, {
            "id": "sec-generatorfunction-instances-name",
            "subs": []
          }, {
            "id": "sec-generatorfunction-instances-prototype",
            "subs": []
          }]
        }]
      }, {
        "id": "sec-asyncgeneratorfunction-objects",
        "subs": [{
          "id": "sec-asyncgeneratorfunction-constructor",
          "subs": [{
            "id": "sec-asyncgeneratorfunction",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-asyncgeneratorfunction",
          "subs": [{
            "id": "sec-asyncgeneratorfunction-length",
            "subs": []
          }, {
            "id": "sec-asyncgeneratorfunction-prototype",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-asyncgeneratorfunction-prototype",
          "subs": [{
            "id": "sec-asyncgeneratorfunction-prototype-constructor",
            "subs": []
          }, {
            "id": "sec-asyncgeneratorfunction-prototype-prototype",
            "subs": []
          }, {
            "id": "sec-asyncgeneratorfunction-prototype-tostringtag",
            "subs": []
          }]
        }, {
          "id": "sec-asyncgeneratorfunction-instances",
          "subs": [{
            "id": "sec-asyncgeneratorfunction-instance-length",
            "subs": []
          }, {
            "id": "sec-asyncgeneratorfunction-instance-name",
            "subs": []
          }, {
            "id": "sec-asyncgeneratorfunction-instance-prototype",
            "subs": []
          }]
        }]
      }, {
        "id": "sec-generator-objects",
        "subs": [{
          "id": "sec-properties-of-generator-prototype",
          "subs": [{
            "id": "sec-generator.prototype.constructor",
            "subs": []
          }, {
            "id": "sec-generator.prototype.next",
            "subs": []
          }, {
            "id": "sec-generator.prototype.return",
            "subs": []
          }, {
            "id": "sec-generator.prototype.throw",
            "subs": []
          }, {
            "id": "sec-generator.prototype-@@tostringtag",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-generator-instances",
          "subs": []
        }, {
          "id": "sec-generator-abstract-operations",
          "subs": [{
            "id": "sec-generatorstart",
            "subs": []
          }, {
            "id": "sec-generatorvalidate",
            "subs": []
          }, {
            "id": "sec-generatorresume",
            "subs": []
          }, {
            "id": "sec-generatorresumeabrupt",
            "subs": []
          }, {
            "id": "sec-getgeneratorkind",
            "subs": []
          }, {
            "id": "sec-generatoryield",
            "subs": []
          }, {
            "id": "sec-yield",
            "subs": []
          }, {
            "id": "sec-createiteratorfromclosure",
            "subs": []
          }]
        }]
      }, {
        "id": "sec-asyncgenerator-objects",
        "subs": [{
          "id": "sec-properties-of-asyncgenerator-prototype",
          "subs": [{
            "id": "sec-asyncgenerator-prototype-constructor",
            "subs": []
          }, {
            "id": "sec-asyncgenerator-prototype-next",
            "subs": []
          }, {
            "id": "sec-asyncgenerator-prototype-return",
            "subs": []
          }, {
            "id": "sec-asyncgenerator-prototype-throw",
            "subs": []
          }, {
            "id": "sec-asyncgenerator-prototype-tostringtag",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-asyncgenerator-intances",
          "subs": []
        }, {
          "id": "sec-asyncgenerator-abstract-operations",
          "subs": [{
            "id": "sec-asyncgeneratorrequest-records",
            "subs": []
          }, {
            "id": "sec-asyncgeneratorstart",
            "subs": []
          }, {
            "id": "sec-asyncgeneratorvalidate",
            "subs": []
          }, {
            "id": "sec-asyncgeneratorresolve",
            "subs": []
          }, {
            "id": "sec-asyncgeneratorreject",
            "subs": []
          }, {
            "id": "sec-asyncgeneratorresumenext",
            "subs": [{
              "id": "async-generator-resume-next-return-processor-fulfilled",
              "subs": []
            }, {
              "id": "async-generator-resume-next-return-processor-rejected",
              "subs": []
            }]
          }, {
            "id": "sec-asyncgeneratorenqueue",
            "subs": []
          }, {
            "id": "sec-asyncgeneratoryield",
            "subs": []
          }, {
            "id": "sec-createasynciteratorfromclosure",
            "subs": []
          }]
        }]
      }, {
        "id": "sec-async-function-objects",
        "subs": [{
          "id": "sec-async-function-constructor",
          "subs": [{
            "id": "sec-async-function-constructor-arguments",
            "subs": []
          }]
        }, {
          "id": "sec-async-function-constructor-properties",
          "subs": [{
            "id": "sec-async-function-constructor-length",
            "subs": []
          }, {
            "id": "sec-async-function-constructor-prototype",
            "subs": []
          }]
        }, {
          "id": "sec-async-function-prototype-properties",
          "subs": [{
            "id": "sec-async-function-prototype-properties-constructor",
            "subs": []
          }, {
            "id": "sec-async-function-prototype-properties-toStringTag",
            "subs": []
          }]
        }, {
          "id": "sec-async-function-instances",
          "subs": [{
            "id": "sec-async-function-instances-length",
            "subs": []
          }, {
            "id": "sec-async-function-instances-name",
            "subs": []
          }]
        }, {
          "id": "sec-async-functions-abstract-operations",
          "subs": [{
            "id": "sec-async-functions-abstract-operations-async-function-start",
            "subs": []
          }]
        }]
      }]
    }, {
      "id": "sec-reflection",
      "subs": [{
        "id": "sec-reflect-object",
        "subs": [{
          "id": "sec-reflect.apply",
          "subs": []
        }, {
          "id": "sec-reflect.construct",
          "subs": []
        }, {
          "id": "sec-reflect.defineproperty",
          "subs": []
        }, {
          "id": "sec-reflect.deleteproperty",
          "subs": []
        }, {
          "id": "sec-reflect.get",
          "subs": []
        }, {
          "id": "sec-reflect.getownpropertydescriptor",
          "subs": []
        }, {
          "id": "sec-reflect.getprototypeof",
          "subs": []
        }, {
          "id": "sec-reflect.has",
          "subs": []
        }, {
          "id": "sec-reflect.isextensible",
          "subs": []
        }, {
          "id": "sec-reflect.ownkeys",
          "subs": []
        }, {
          "id": "sec-reflect.preventextensions",
          "subs": []
        }, {
          "id": "sec-reflect.set",
          "subs": []
        }, {
          "id": "sec-reflect.setprototypeof",
          "subs": []
        }, {
          "id": "sec-reflect-@@tostringtag",
          "subs": []
        }]
      }, {
        "id": "sec-proxy-objects",
        "subs": [{
          "id": "sec-proxy-constructor",
          "subs": [{
            "id": "sec-proxy-target-handler",
            "subs": []
          }]
        }, {
          "id": "sec-properties-of-the-proxy-constructor",
          "subs": [{
            "id": "sec-proxy.revocable",
            "subs": [{
              "id": "sec-proxy-revocation-functions",
              "subs": []
            }]
          }]
        }]
      }, {
        "id": "sec-module-namespace-objects",
        "subs": [{
          "id": "sec-@@tostringtag",
          "subs": []
        }]
      }]
    }, {
      "id": "sec-memory-model",
      "subs": [{
        "id": "sec-memory-model-fundamentals",
        "subs": []
      }, {
        "id": "sec-agent-event-records",
        "subs": []
      }, {
        "id": "sec-chosen-value-records",
        "subs": []
      }, {
        "id": "sec-candidate-executions",
        "subs": []
      }, {
        "id": "sec-abstract-operations-for-the-memory-model",
        "subs": [{
          "id": "sec-event-set",
          "subs": []
        }, {
          "id": "sec-sharedatablockeventset",
          "subs": []
        }, {
          "id": "sec-hosteventset",
          "subs": []
        }, {
          "id": "sec-composewriteeventbytes",
          "subs": []
        }, {
          "id": "sec-valueofreadevent",
          "subs": []
        }]
      }, {
        "id": "sec-relations-of-candidate-executions",
        "subs": [{
          "id": "sec-agent-order",
          "subs": []
        }, {
          "id": "sec-reads-bytes-from",
          "subs": []
        }, {
          "id": "sec-reads-from",
          "subs": []
        }, {
          "id": "sec-host-synchronizes-with",
          "subs": []
        }, {
          "id": "sec-synchronizes-with",
          "subs": []
        }, {
          "id": "sec-happens-before",
          "subs": []
        }]
      }, {
        "id": "sec-properties-of-valid-executions",
        "subs": [{
          "id": "sec-valid-chosen-reads",
          "subs": []
        }, {
          "id": "sec-coherent-reads",
          "subs": []
        }, {
          "id": "sec-tear-free-aligned-reads",
          "subs": []
        }, {
          "id": "sec-memory-order",
          "subs": []
        }, {
          "id": "sec-valid-executions",
          "subs": []
        }]
      }, {
        "id": "sec-races",
        "subs": []
      }, {
        "id": "sec-data-races",
        "subs": []
      }, {
        "id": "sec-data-race-freedom",
        "subs": []
      }, {
        "id": "sec-shared-memory-guidelines",
        "subs": []
      }]
    }]
  },
  "symbols": ["toPrimitive", "asyncIterator", "iterator", "search", "replace", "unscopables", "toStringTag", "matchAll", "isConcatSpreadable", "match", "REGISTRY", "species", "hasInstance", "split"],
  "version": "es2021"
}
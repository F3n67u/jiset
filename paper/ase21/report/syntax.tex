\section{Syntax}\label{sec:syntax}
We first define syntax of the modified $\ires$ as follows:
\[
  \vspace*{-1em}
  \begin{array}{l@{~}r@{~}c@{~}r@{~}r@{~}l}
    \text{Functions}
    &\funcset&\ni&\func&::=&\kwdef \; \x (\x^*, \kwsl \x^* \kwsr). \; \lab\\

    \text{Instructions}
    &\instset&\ni&\inst&::=&
    \kwlet \; \x = \expr \mid
    \x = \kwrl \expr \; \expr^* \kwrr \mid
    \kwassert \; \expr \\

    &&&&\mid&
    \kwif \; \expr \; \lab \; \lab \mid
    \kwreturn \; \expr \mid
    \refer = \expr \\

    \text{References}
    &&&\refer&::=&
    \x \mid
    \refer \kwsl \expr \kwsr \\

    \text{Expressions}
    &&&\expr&::=&
    \tname \; \kwcl [\x: \expr]^* \kwcr \mid
    \clist{\expr^*} \mid
    \expr: \ty \mid
    \refer \kwexists \\

    &&&&\mid&
    \expr \bop \expr \mid
    \uop \; \expr \mid
    \refer \mid
    \const \mid
    \prim \\

    \text{Primitives}
    &\primset&\ni&\prim&::=&
    \undefval \mid \nullval \mid \bool \mid
    \num \mid \bigint \mid \str \mid \symb \\

    \text{Types} &\tyset&\ni&\ty&::=&\tname \mid \clist{} \mid \clist{\ty} \mid
    \tjs \mid \tprim\\

    &&&&\mid&
    \undefval \mid \nullval \mid \tbool \mid \tnumeric\\

    &&&&\mid&
    \tnum \mid \tbigint \mid \tstr \mid \tsymb \\
    \vspace*{1em}
  \end{array}
\]
A modified $\ires$ program $\prog = (\getfunc, \getinst, \getnext)$ consists of
three mappings;  $\getfunc: \labset \rightarrow \funcset$ maps labels to their
functions, $\getinst: \labset \rightarrow \instset$ maps labels to their
instructions, and $\getnext: \labset \rightarrow \labset$ maps labels to their
next labels, where a label $\lab \in \labset$ denotes a program point. A
function $\kwdef \; \f (\x^*, \kwsl \y^* \kwsr). \; \lab \in \funcset$ consists
of its name $\f$, normal parameters $\x^*$, optional parameters $\y^*$, and a
body label $\lab$.  For presentation brevity, we assume that no global variables
exist in this paper.  An instruction $\inst$ is a variable declaration, a
function call, an assertion, a branch, a return, or a reference update.  An
invocation of an abstract algorithm in ECMAScript is compiled to a function call
instruction with a new temporary variable.  We represent loops using branch
instructions with cyclic pointing of labels in $\getnext$.  A reference $\refer$
is a variable $\x$ or a field access $\refer \kwsl \expr \kwsr$.  We write
$\refer.\f$ to briefly represent $\refer \kwsl \code{"f"} \kwsr$. An expression
$\expr$ is a record, a list, a type check, an existence check, a binary
operation, a unary operation, a reference, a constant, or a primitive, which is
either $\undefval$, $\nullval$, a \jscode{Boolean} $\bool$, a \jscode{Number}
$\num$, a \jscode{BigInt} $\bigint$, a \jscode{String} $\str$, or a
\jscode{Symbol} $\symb$.

A type $\ty \in \tyset$ is either a nominal type $\tname$, an empty list type
$\clist{}$, a parametric list type $\clist{\ty}$, a JavaScript type $\tjs$, a
primitive type $\tprim$, a numeric type $\tnumeric$, $\tnum$, $\tbigint$,
$\tstr$, or $\tsymb$.  The subtype relation $\subtype \subseteq \tyset \times
\tyset$ between types is reflexive and transitive.

def [BUILTIN] SubscriptionObserverPrototype.next(value) = 0:{
  0:let O = this
  1:if (! (= (typeof O) Object)) 1:throw TypeError else 1:{}
  2:??? "If id:{O} does not have all of the internal slots of a Subscription Observer instance , throw a value:{TypeError} exception ."
  3:let subscription = O.Subscription
  4:app __x0__ = (SubscriptionClosed subscription)
  4:if (= __x0__ true) 4:return undefined else 4:{}
  5:let observer = subscription.Observer
  6:assert (= (typeof observer) Object)
  7:app __x1__ = (GetMethod observer "next")
  7:let nextMethodResult = __x1__
  8:if (= nextMethodResult.Type ~normal~) 8:{
    9:let nextMethod = nextMethodResult.Value
    10:if (! (= nextMethod undefined)) 10:{
      11:??? "Let id:{result} be Call ( id:{nextMethod} , id:{observer} , « ‍ id:{value} » ) ."
      12:app __x2__ = (IsAbruptCompletion result)
      12:if __x2__ 12:{
        12:app __x3__ = (HostReportErrors (new [result.Value]))
        12:__x3__
      } else 12:{}
    } else 10:{}
  } else 8:if (= nextMethodResult.Type ~throw~) 11:{
    11:app __x4__ = (HostReportErrors (new [nextMethodResult.Value]))
    11:__x4__
  } else 8:{}
  14:return undefined
}
- id: "subscription-observer-prototype-next"
- code:
            1. Let _O_ be the *this* value.
            1. If Type(_O_) is not Object, throw a *TypeError* exception.
            1. If _O_ does not have all of the internal slots of a Subscription Observer instance, throw a *TypeError* exception.
            1. Let _subscription_ be the value of _O_'s [[Subscription]] internal slot.
            1. If SubscriptionClosed(_subscription_) is *true*, return *undefined*.
            1. Let _observer_ be the value of _subscription_'s [[Observer]] internal slot.
            1. Assert: Type(_observer_) is Object.
            1. Let _nextMethodResult_ be GetMethod(_observer_, `"next"`).
            1. If _nextMethodResult_.[[Type]] is ~normal~, then
              1. Let _nextMethod_ be _nextMethodResult_.[[Value]].
              1. If _nextMethod_ is not *undefined*, then
                1. Let _result_ be Call(_nextMethod_, _observer_, « ‍_value_ »).
                1. If _result_ is an abrupt completion, perform HostReportErrors(« _result_.[[Value]] »).
            1. Else if _nextMethodResult_.[[Type]] is ~throw~, then perform HostReportErrors(« _nextMethodResult_.[[Value]] »).
            1. Return *undefined*.
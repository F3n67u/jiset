{
  [0] let module = this
  [2] assert (! (= module.Realm undefined))
  [3] if (= module.Evaluated true) {
    app __x0__ = (WrapCompletion undefined)
    return __x0__
  } else [12] {}
  [4] module.Evaluated = true
  [5] let __x1__ = module.RequestedModules
  [5] let __x2__ = 0i
  [5] while (< __x2__ __x1__.length) {
    let required = __x1__[__x2__]
    [6] app __x3__ = (HostResolveImportedModule module required)
    [6] if (is-completion __x3__) if (= __x3__.Type CONST_normal) __x3__ = __x3__.Value else return __x3__ else [12] {}
    [6] let requiredModule = __x3__
    [7] app __x4__ = (requiredModule.ModuleEvaluation requiredModule)
    [7] if (is-completion __x4__) if (= __x4__.Type CONST_normal) __x4__ = __x4__.Value else return __x4__ else [12] {}
    [7] __x4__
    __x2__ = (+ __x2__ 1i)
  }
  [8] let moduleCxt = (new ExecutionContext("SubMap" -> (new SubMap())))
  [9] moduleCxt.Function = null
  [10] moduleCxt.Realm = module.Realm
  [11] moduleCxt.ScriptOrModule = module
  [13] moduleCxt.VariableEnvironment = module.Environment
  [14] moduleCxt.LexicalEnvironment = module.Environment
  [15] GLOBAL_context = null
  [16] append moduleCxt -> GLOBAL_executionStack
  [16] GLOBAL_context = GLOBAL_executionStack[(- GLOBAL_executionStack.length 1i)]
  [17] access __x5__ = (module.ECMAScriptCode "Evaluation")
  [17] let result = __x5__
  [18] GLOBAL_context = null
  [18] if (= GLOBAL_executionStack[(- GLOBAL_executionStack.length 1i)] moduleCxt) (pop GLOBAL_executionStack (- GLOBAL_executionStack.length 1i)) else [12] {}
  [19] ??? "Resume the context that is now on the top of the execution context stack as the running execution context ."
  [20] app __x6__ = (Completion result)
  [20] app __x7__ = (WrapCompletion __x6__)
  [20] return __x7__
}
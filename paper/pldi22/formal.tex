\section{JavaScript Semantics Specialization with Syntactic Views}\label{sec:formal}

We first define $\ires$ as a specification language to describe JavaScript
semantics.  Then, we introduce a general formalization of function
specialization in $\ires$. Finally, we define a constant propagation
specialization as its an instance to reduce JavaScript semantics using given
syntactic views. We also prove its semantics preservation under an observational
semantics.

\subsection{$\ires$: Intermediate Representations for ECMAScript}

We first introduce $\ires$, an \textbf{I}ntermediate \textbf{R}epresentations
for \textbf{E}CMA\textbf{S}cript, as a specification language for JavaScript to
describe JavaScript semantics. We define its abstract syntax, states, and
concrete semantics in the remainder of this section.

\subsubsection{Abstract Syntax}

\[
  \begin{array}{lr@{~}c@{~}c@{~}c@{~}l}
    \text{Functions} & \funcset &\ni& \func &::=&
    \kwdef \; \varx \; \kwrl \varx^* \kwrr \; \lab\\

    \text{Variables} & \varset &\ni& \varx\\

    \text{Labels} & \labset &\ni& \lab\\

    \text{Instructions} & \instset &\ni& \inst &::=&
    \refer = \expr \mid
    \varx = \expr \kwrl \expr^* \kwrr \mid
    \kwif \; \expr \; \lab \; \lab \mid
    \kwret \; \expr\\

    \text{Expressions} & \exprset &\ni& \expr &::=&
    \pval \mid
    \op \kwrl \expr^* \kwrr \mid
    \kwcl \kwcr \mid
    \refer\\

    \text{References} & \referset &\ni& \refer &::=&
    \varx \mid \refer \kwsl \expr \kwsr\\
  \end{array}
\]

An $\ires$ program $\prog = (\istset, \getinst, \getnext)$ consists of initial
states and two mappings; $\getinst: \labset \rightarrow \instset$ maps labels to
their instructions, and $\getnext: \labset \rightarrow \labset$ maps labels to
their next labels, where a label $\lab \in \labset$ denotes a program point.  A
function $\func \in \funcset$ is defined with its name, parameters, and body
label.  For presentation brevity, we assume that no global variables exist in
this paper.  An instruction $\inst \in \instset$ is an assignment $\refer =
\expr$, a function call $x = \expr \kwrl \expr^* \kwrr$, a branch $\kwif \;
\expr \; \lab \; \lab$, or a return instruction $\kwret \; \expr$.  An
invocation of an abstract algorithm in ECMAScript is compiled to a function call
instruction with a new temporary variable.  We represent loops using branch
instructions with cyclic pointing of labels in $\getnext$.  An expression is a
primitive value $\pval$, an operation $\op \kwrl \expr^* \kwrr$, an object
allocation $\kwcl \kwcr$, or a reference $\refer$.  A reference is a variable
$x$ or an object field $\refer \kwsl \expr \kwsr$.  We write $\refer.\varf$ to
briefly represent $\refer \kwsl \code{"f"} \kwsr$.


\subsubsection{States}

\[
  \begin{array}{lr@{~}c@{~}l@{~}c@{~}l}
    \text{States} & \st &\in& \stset &=&
    \labset \times \ctxtset^* \times \heapset \times \envset\\

    \text{Calling Contexts} & \ctxt &\in& \ctxtset &=&
    \labset \times \envset \times \varset\\

    \text{Heaps} & \heap &\in& \heapset &=&
    \addrset \finmap \objset\\

    \text{Objects} & \obj &\in& \objset &=&
    \strset \finmap \valset\\

    \text{Environments} & \env &\in& \envset &=&
    \varset \finmap \valset\\

    \text{Values} & \val &\in& \valset &=&
    \pvalset \uplus \addrset \uplus \treeset \uplus \funcset\\

    \text{Primive Values} & \pval &\in& \pvalset &=&
    \boolset \uplus \strset \uplus \cdots\\

    \text{JavaScript ASTs} & \tree &\in& \treeset\\
  \end{array}
\]

States $\stset$ consist of labels $\labset$, calling context stacks
$\ctxtset^*$, heaps $\heapset$, and environments $\envset$.  A calling context
$\ctxt \in \ctxtset$ consists of a label denoting the return point, a caller's
environment, and a return variable.  A heap $\heap \in \heapset$ is a finite
mapping from addresses to objects, and an object $\obj \in \objset$ is a finite
mappings from strings to values.  Each object allocation $\kwcl \kwcr$ creates a
unique address $\addr \in \addrset$ different from existing addresses.  An
environment $\env \in \envset$ is a finite mapping from variables to values. A
value $\val \in \valset$ is a primitive value $\pval \in \pvalset$ (e.g., a
boolean value $\bool \in \boolset$ or a string value $\str \in \strset$), an
address $\addr \in \addrset$, a JavaScript AST $\tree \in \treeset$, or a
function $f \in \funcset$.

\subsubsection{Concrete Semantics}

The concrete semantics $\sem{\prog}$ of an $\ires$ program $\prog = (\istset, \getinst,
\getnext)$ is defined as follows:
\[
  \sem{\prog} = \{ \st \in \stset \mid \ist \in \istset \wedge \ist \trans^* \st \}
\]
where $\trans^*$ denotes one or more repetition of $\trans$, and $\st \trans
\st$ if and only if $\st = (\lab, \_, \_, \_)$ and $\sem{\getinst(\lab)}(\st) =
\st'$. Now, we define the denotational semantics of instructions $\sem{\inst}:
\stset \rightarrow \stset$, expressions $\sem{\expr}: \stset \rightarrow \stset
\times \valset$, and references $\sem{\refer}: \stset \rightarrow \stset \times
\valset$.

\paragraph{Instructions: $\framebox{$\sem{\inst}: \stset \rightarrow \stset$}$}
\begin{itemize}
  \item \underline{Variable Assignments}:
    \[
      \sem{\varx = \expr}(\st) =
      (\getnext(\lab), \ctxts, \heap, \env[\varx \mapsto \val])
    \]
    where
    \[
      \sem{\expr}(\st) = ((\lab, \ctxts, \heap, \env), \val)
    \]

  \item \underline{Field Assignments}:
    \[
      \sem{\refer \kwsl \expr_0 \kwsr = \expr_1}(\st) =
      (\getnext(\lab), \ctxts, \heap[\addr \mapsto \obj'], \env)
    \]
    where
    \[
      \begin{array}{l@{~}c@{~}ll}
        \sem{\refer}(\st) &=& (\st', \addr) &\wedge\\
        \sem{\expr_0}(\st') &=& (\st'', \str) &\wedge\\
        \sem{\expr_1}(\st'') &=& ((\lab, \ctxts, \heap, \env), \val) &\wedge\\
        \obj &=& \heap(\addr) &\wedge\\
        \obj' &=& \obj[\str \mapsto \val]\\
      \end{array}
    \]

  \item \underline{Function Calls}:
    \[
      \sem{\varx = \expr \kwrl \expr_1 \cdots \expr_n \kwrr}(\st) =
      (\lab_\varf, \ctxt :: \ctxts, \heap, \env')
    \]
    where
    \[
      \begin{array}{l@{~}c@{~}ll}
        \sem{\expr} &=& (\st_0, \kwdef \; \varf \; \kwrl \varp_1, \cdots,
        \varp_n \kwrr \; \lab_\varf) &\wedge\\
        \sem{\expr_k}(\st_{k-1}) &=& (\st_k, \val_k) \; \forall 1 \leq k \leq n
        &\wedge\\
        \st_n &=& (\lab, \ctxts, \heap, \env) &\wedge\\
        \env' &=& [\varp_1 \mapsto \val_1, \cdots, \varp_n \mapsto \val_n]
        &\wedge\\
        \ctxt &=& (\getnext(\lab), \env, \varx)\\
      \end{array}
    \]

  \item \underline{Branches}:
    \[
      \sem{\kwif \; \expr \; \lab_\vart \; \lab_\varf}(\st) =
      \left\{
        \begin{array}{ll}
          (\lab_\vart, \ctxts, \heap, \env) & \text{if} \; \val = \true\\
          (\lab_\varf, \ctxts, \heap, \env) & \text{if} \; \val = \false\\
        \end{array}
      \right.
    \]
    where
    \[
      \sem{\expr}(\st) = ((\lab, \ctxts, \heap, \env), \val)
    \]

  \item \underline{Returns}:
    \[
      \sem{\kwret \; \expr}(\st) = (\lab, \ctxts, \heap, \env[\varx \mapsto
      \val])
    \]
    where
    \[
      \sem{\expr}(\st) = ((\_, (\lab, \env, \varx) :: \ctxts, \heap, \_), \val)
    \]
\end{itemize}

\paragraph{Expressions: $\framebox{$\sem{\expr}: \stset \rightarrow \stset
\times \valset$}$}
\begin{itemize}
  \item \underline{Primive Values}:
    \[
      \sem{\pval}(\st) = \todo
    \]
  \item \underline{Operations}:
    \[
      \sem{\op \kwrl \expr^* \kwrr}(\st) = \todo
    \]
  \item \underline{Object Allocations}:
    \[
      \sem{\kwcl \kwcr}(\st) = \todo
    \]
  \item \underline{References}:
    \[
      \sem{\refer}(\st) = \todo
    \]
\end{itemize}

\paragraph{References: $\framebox{$\sem{\refer}: \stset \rightarrow \stset
\times \valset$}$}
\begin{itemize}
  \item \underline{Variable Lookups}:
    \[
      \sem{\varx}(\st) = \todo
    \]
  \item \underline{Field Lookups}:
    \[
      \sem{\refer \kwsl \expr \kwsr}(\st) = \todo
    \]
\end{itemize}





\subsection{Function Specialization}

\todo

A function specialization is defined with the following three components:
\begin{itemize}
  \item Restriction $\restrictset$
  \item Concretization $\gamma: \restrictset \rightarrow \powerset{\stset
    \times \valset^*}$
  \item Transformation $\transform: \restrictset \rightarrow \funcset
    \rightarrow \funcset$.
\end{itemize}

\todo



\subsubsection{Constant Propagation Specialization}
\begin{itemize}
  \item Restriction $\cprestrictset = (\valoptset)^* =
    (\valset \uplus \{ \top \})^*$
  \item Concretization $\cpgamma: (\valoptset)^* \rightarrow \powerset{\stset
    \times \valset^*}$ s.t.
    \[
      \cpgamma(\valopt_1, \cdots, \valopt_n) = \stset \times (V_1 \times \cdots
      \times V_n)
    \]
    where $V_i = \left\{
      \begin{array}{ll}
        \valset & \text{if} \; \valopt_i = \top\\
        \{ \valopt_i \} & \text{otherwise}\\
      \end{array}
    \right.$
  \item Transformation $\cptransform: (\valoptset)^* \rightarrow \funcset
    \rightarrow \funcset$
\end{itemize}
In the constant propagation specialization, a restriction is a sequences of
static values $\valset$ or a dynamic value $\top$.

\[
  \begin{array}{lr@{~}c@{~}l@{~}c@{~}l}
    \text{Symbolic Environments} & \senv &\in& \senvset &=&
    \varset \finmap \svalset\\
    \text{Symbolic Values} & \sval &\in& \svalset &=&
    \valoptset \times \exprset\\
  \end{array}
\]

\[
  \framebox{$\cptransforme: \exprset \times \senvset \rightarrow \svalset$}
\]

\[
  \begin{array}{lcl}
    \cptransforme(\pval, \env) &=& \pval\\
    \cptransforme(\op \kwrl \expr^* \kwrr, \env) &=& \todo\\
    \cptransforme(\kwcl \kwcr, \env) &=& \todo\\
    \cptransforme(\refer, \env) &=& \todo\\
  \end{array}
\]

\[
  \framebox{$\cptransformi: \instset \times \senvset \rightarrow \instset \times
  \senvset$}
\]

\todo

\[
  \framebox{$\cptransform: (\valoptset)^* \rightarrow \funcset \rightarrow
  \funcset$}
\]

\todo





% \subsubsection{Redundancy Elimination Transformation}
% 
% \[
%   \begin{array}{lr@{~}c@{~}l}
%     \text{Restrictions} &\{ \top \}\\
%     \text{Concretization} & \gamma(\top) &=& \stset \times \valset^*\\
%   \end{array}
% \]
% 
% The redundancy elimination transformation is defined without any restriction,
% which means its restriction set consists of a single element $\top$
% representing all possible cases.  Therefore, we omit the restriction part in
% this transformation for the brevity.
% 
% \[
%   \framebox{$\transformref: \funcset \rightarrow \funcset$}
% \]
% 
% \todo








\subsection{Proof of Semantics Preservation}

\todo

\subsubsection{Observational Semantics}

\todo





\subsection{JavaScript Semantics Specialization}

\todo

\subsubsection{Syntatic Views}

\todo

\subsubsection{Specialization with Syntatic Views}

\todo

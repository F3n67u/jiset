\documentclass[11pt]{article}
\usepackage[a4paper,left=20mm,right=20mm,top=30mm,bottom=25mm]{geometry}

\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{mathpartir}
\usepackage{verbatim}
\usepackage{hyperref}
\usepackage{xspace}
\usepackage{stmaryrd}
\usepackage{tikz}
\usepackage{dirtree}
\usepackage{multicol}
\usepackage{array}

\usetikzlibrary{arrows}
\tikzset{
  treenode/.style = {align=center, inner sep=0pt, text centered},
  arn_n/.style = {treenode, circle, black, draw=black, text width=1.5em},
}

% style
\newcommand{\irnameb}[0]{\textbf{IR\textsubscript{ES}}\xspace}
\newcommand{\irname}[0]{IR\textsubscript{ES}\xspace}
\newcommand{\Acd}[1]{\mathsf{#1}}
\newcommand{\Term}[1]{\texttt{#1}}
\newcommand{\dom}[1]{\mathit{Domain}(#1)}
\newcommand{\cs}[0]{\quad}
\newcommand{\inred}[1]{{\color{red}{#1}}}

% symbols
\newcommand{\symstate}[0]{\sigma}
\newcommand{\symctx}[0]{C}
\newcommand{\symctxstack}[0]{C^*}
\newcommand{\symglb}[0]{\mathbb{G}}
\newcommand{\symenv}[0]{E}
\newcommand{\symheap}[0]{H}
\newcommand{\symuop}[0]{\odot}
\newcommand{\symbop}[0]{\oplus}
\newcommand{\symast}[0]{ASTVal}
\newcommand{\symastm}[0]{ASTMethod}
\newcommand{\symrefv}[0]{rv}
\newcommand{\symstatetuple}[4]{(#1,\ #2,\ #3,\ #4)}
\newcommand{\symstdef}[0]
{\symstatetuple{\symctx}{\symctxstack}{\symenv}{\symheap}}
\newcommand{\symctxtuple}[4]{(#1,\ #2,\ #3,\ #4)}
\newcommand{\symctxdef}[0]{\symctxtuple{x}{s}{i^*}{E}}
\newcommand{\symlist}[1]{\Term{<} #1 \Term{>}}
\newcommand{\symmap}[3]{#1\ \Term{\{} [#2 \mapsto #3]^* \Term{\}}}
% \newcommand{\symconv}][0]{$\triangleright$}

% value
\newcommand{\valfunc}[4]{\lambda \Term{(} #1,\ #2,\ #3,\ #4 \Term{)}}
\newcommand{\valcont}[4]{\kappa \Term{(} #1,\ #2,\ #3,\ #4 \Term{)}}
\newcommand{\valast}[4]{\symast \Term{(} \Term{)}}

% evaluation
\newcommand{\evaluop}[2]{\symuop #1 \Rightarrow #2}
\newcommand{\evalbop}[3]{#1 \symbop #2 \Rightarrow #3}
\newcommand{\evalinst}[3]{#1 \vdash #2 \Rightarrow #3}
\newcommand{\evalexpr}[4]{#1 \vdash #2 \Rightarrow #3,\ #4}
\newcommand{\evalescexpr}[4]{#1 \vdash_{escape} #2 \Rightarrow #3,\ #4}
\newcommand{\evalref}[4]{#1 \vdash #2 \Rightarrow #3,\ #4}
\newcommand{\evalrefv}[4]{#1 \vdash #2 \Rightarrow #3,\ #4}

% helper function
\newcommand{\hdefine}[4]{\Term{define}(#1,\ #2,\ #3) = #4}
\newcommand{\hupdated}[4]{\Term{updated}(#1,\ #2,\ #3) = #4}
\newcommand{\hdeleted}[3]{\Term{deleted}(#1,\ #2) = #3}
\newcommand{\happend}[4]{\Term{append}(#1,\ #2,\ #3) = #4}
\newcommand{\hprepend}[4]{\Term{prepend}(#1,\ #2,\ #3) = #4}
\newcommand{\hreturn}[3]{\Term{return}(#1,\ #2) = #3}
\newcommand{\hgethprop}[4]{\Term{getHeapProp}(#1,\ #2,\ #3) = #4}
\newcommand{\hgetsprop}[3]{\Term{getStringProp}(#1,\ #2) = #3}
\newcommand{\hcharat}[3]{\Term{charAt}(#1,\ #2) = #3}
\newcommand{\htoint}[2]{\Term{toInt}(#1) = #2}
\newcommand{\hgettype}[2]{\Term{getType}(#1) = #2}
\newcommand{\hallocsym}[4]{\Term{allocSymbol}(#1,\ #2) = (#3,\ #4)}
\newcommand{\halloclist}[4]{\Term{allocList}(#1,\ #2) = (#3,\ #4)}
\newcommand{\hallocmap}[4]{\Term{allocMap}(#1,\ #2) = (#3,\ #4)}

%etc
\newcommand{\mathlen}[1]{|#1|}

\begin{document}

% \title{\irname : Intermediate Representation for ECMAScript Specification}
% \maketitle

% This document explains abstract syntax and operational semantic of \irnameb.


\section{Abstract Syntax}

This section explains abstract syntax of \irname.

% Domain
\[
\begin{array}{rrl}
n & \in & \textit{FloatingPoint} \\
d & \in & \textit{Integer} \\
s & \in & \textit{String} \\
b & \in & \textit{Boolean} \\
r & \in & \textit{Reference} \\
x & \in & \textit{Identifier} \\
t & \in & \textit{Type} \\
\end{array}
\]

% Abstract Syntax
\[
\begin{array}{rrrll}
\text{Program} & p & ::= & i\Term{;}\ \cdots \Term{;}\ i & \\
\\

\text{Instruction} & i & ::= & e & \text{(expression)} \\
&&|& \Term{let}\ x\ \Term{=}\ e & \text{(let)}\\
&&|& r \Term{:=} e & \text{(assign)}\\
&&|& \Term{delete}\ r & \text{(delete)}\\
&&|& \Term{append}\ e\ \gets\ e & \text{(append)}\\
&&|& \Term{prepend}\ e\ \to\ e & \text{(prepend)}\\
&&|& \Term{return}\ e & \text{(return)}\\
&&|& \Term{if}\ e\ i\ i\ & \text{(if-then-else)}\\
&&|& \Term{while}\ e\ i & \text{(while)}\\
% &&|& \{ i\Term{;}\ \cdots\ i\Term{;}  \} & \text{(sequence)}\\
&&|& \{ i^* \} & \text{(sequence)}\\
&&|& \Term{assert}\ e & \text{(assert)}\\
&&|& \Term{print}\ e & \text{(print)}\\
&&|& \Term{app}\ x\ \Term{=}\ (e\ e^*) & \text{(function application)}\\
&&|& \Term{access}\ x\ \Term{=}\ (e\ e) & \text{(access)}\\
&&|& \Term{withcont}\ x\ (x^*)\ =\ i & \text{(continuation)}\\ 
\\

\text{Reference} & r & ::= & x & \text{(identifier)}\\
&&|& r\Term{[} e \Term{]} & \text{(reference to value of field in heap)}\\
\\
\end{array}
\]

\newpage

\[
\begin{array}{rrrll}
\text{Expression} & e & ::= & n & \text{(floating point number)}\\
&&|& d & \text{(integer)}\\
&&|& s & \text{(string)}\\
&&|& b & \text{(boolean)}\\
&&|& r & \text{(reference)}\\
&&|& \Term{undefined} & \text{(undefined)}\\
&&|& \Term{null} & \text{(null)}\\
&&|& \Term{absent} & \text{(absent)}\\
&&|& \Term{new}\ e & \text{(symbol)}\\ % ESymbol
&&|& \Term{new}\ \Term{<} e^* \Term{>} & \text{(list)}\\ %EList
&&|& \Term{new}\ t\ \Term{\{} [e\ \mapsto\ e]^* \Term{\}} & \text{(map)}\\ %EMap
&&|& \Term{pop}\ e\ e & \text{(pop)}\\
&&|& \Term{typeof}\ e & \text{(typeof)}\\
&&|& \Term{is-instance-of}\ e\ s& \text{(is-instance-of)}\\
&&|& \Term{get-elems}\ e\ s& \text{(get-elements)}\\
&&|& \Term{get-syntax}\ e& \text{(get-syntax)}\\
&&|& \Term{parse-syntax}\ e\ e\ e^*\ & \text{(parse-syntax)}\\
&&|& \Term{convert}\ e\ \triangleright\ e^*& \text{(convert)}\\
&&|& \Term{contains}\ e\ e& \text{(contains)}\\
&&|& \Term{copy-obj}\ e& \text{(copy-object)}\\
&&|& \Term{map-keys}\ e& \text{(map-keys)}\\
&&|& \Term{!!!}\ s& \text{(not supported)}\\
&&|& \odot\ e& \text{(unary operation)}\\ %Uop
&&|& e\ \oplus\ e& \text{(binary operation)}\\ %Bop
&&|& \Term{(} x^* \Term{)}\ \Term{[} \Rightarrow \Term{]}\ i
& \text{(continuation)}\\ %Cont\\
\\

\end{array}
\]

\newpage

\[
\begin{array}{rrrll}
\text{UnaryOperator}& \odot & ::=
& \Term{-} & \text{(negation)}\\
&&|& \Term{!} & \text{(boolean not)}\\
&&|& \sim & \text{(bitwise not)}\\
\\

\text{BinaryOperator}& \oplus & ::=
& \Term{+} & \text{(addition)}\\
&&|& \Term{-} & \text{(subtraction)}\\
&&|& \Term{*} & \text{(multiplication)}\\
&&|& \Term{**} & \text{(power)}\\
&&|& \Term{/} & \text{(division)}\\
&&|& \verb|%| & \text{(modulo)}\\
&&|& \verb|%| & \text{(modulo)}\\
&&|& \Term{=} & \text{(equals)}\\
&&|& \verb|&&| & \text{(boolean and)}\\
&&|& \Term{||} & \text{(boolean or)}\\
&&|& \verb|^^| & \text{(boolean xor)}\\
&&|& \verb|&| & \text{(bitwise and)}\\
&&|& \Term{|} & \text{(bitwise or)}\\
&&|& \verb|^| & \text{(bitwise xor)}\\
&&|& \verb|<<| & \text{(shift left)}\\
&&|& \Term{<} & \text{(less-then)}\\
&&|& \verb|>>>| & \text{(unsigned shift right)}\\
&&|& \verb|>>| & \text{(shift right)}\\
\\

\text{ConvertOperator} & \triangleright
& ::= & \Term{str2num}& \text{(string to number)}\\
&&|& \Term{num2str} & \text{(number to string)}\\
&&|& \Term{num2int} & \text{(number to integer)}\\
\\
\end{array}
\]

\newpage

\section{Operational Semantic}

This section explains operational semantic of \irname.

\subsection{Domain}

Semantic domain of \irname.

\[
\begin{array}{rrrl}
%State
\text{State} &
\symstate &
\in &
\mbox{Context}\ \times\ \mbox{Context}^*\
\times\ \mbox{Environment}\ \times\ \mbox{Heap}
\\
%Context
\text{Context} & \symctx & \in &
\mbox{Identifier}\ \times\ \mbox{String}\
\times\ \mbox{Instruction}^*\ \times\ \mbox{Environment}
\\
%Environment
\text{Environment} & \symenv & \in &
\mbox{Identifier}\ \to\ \mbox{Value}
\\
%Heap
\text{Heap} & \symheap & \in &
\mbox{Address}\ \to\ \mbox{Object}
\\
%Value
\text{Value} & v & \in & \mbox{Value}
\\
%Address
\text{Address} & a & \in & \mbox{Address}
\\
%Object
\text{Object} & o & \in & \mbox{Object}
\\

\end{array}
\]

\[
\begin{array}{ccccccccc}
%State
\text{State} & \symstate & ::= & \symstdef &  &
%Contxt
\text{Context} & \symctx & ::= & \symctxdef \\
\end{array}
\]

\[
\begin{array}{rrrll}
%Constant
\text{Constant} & c & ::= & n\ |\ d\ |\ s\ |\ b\ |\
\Term{undefined}\ |\ \Term{null}\ |\ \Term{absent}\ & \\
% \\
% %Address
% \text{Address} & a & ::= & s & \text{(named address)} \\
% &&|& d & \text{(dynamic address)}\\
\\
%Object
\text{Object} & o & ::= & \Term{symbol}\ v & \text{(symbol)}\\
&&|& t\ \Term{\{} [v\ \mapsto\ v]^* \Term{\}} & \text{(map)}\\
&&|& \symlist{v^*} & \text{(list)}\\
&&|& \Term{not-supported}\ s & \text{(not supported)}\\
\\
%Value
\text{Value} & v & ::= & a & \text{(address)} \\
&&|& c & \text{(constant)}\\
% &&|& s\ \Term{(} x^*,\ \Term{[}x\Term{]} \Term{)}\ \Rightarrow\ i
% & \text{(function)}\\
&&|& \valfunc{s}{x^*}{x}{i} & \text{(function)} \\
% &&|& \symctx,\ \symctxstack,\ x^*\ \Term{[} \Rightarrow \Term{]}\ i
% & \text{(continuation)}\\
&&|& \valcont{\symctx}{\symctxstack}{x^*}{i} & \text{(continuation)} \\
&&|& \symast & \text{(AST value)}\\
&&|& \Term{ASTMethod}\ \valfunc{s}{x^*}{x}{i}\ E & \text{(AST method)}\\
\\

%RefValue
\text{RefValue} & \symrefv & ::= & x & \text{(identifier)}\\
&&|& a\Term{[} v \Term{]} & \text{(reference to value of map in heap)}\\
&&|& s\Term{.}v & \text{(reference to string field)}\\
\\

% \textit{RefValue} & rv & ::= & id & \text{(id)}\\
% &&|& prop & \text{(prop)}\\
% &&|& string & \text{(string)}\\
% \\

\end{array}
\]

TODO

ASTValue notation

change ASTMethod notation

% \subsubsection{Global, Environment, Heap Description}

% .

% [[description of initial configuration of \irname]]

% Heap = (Base + Built-in) $\rightarrow$ named addr + Dynamic $\rightarrow$
% dynamic addr

% [[description of operators used in state, context, heap]]

\newpage

\subsection{Semantic of \irname}

\begin{itemize}
  \item program : [[description of program execution]]
  \item instruction : $\evalinst{\symstate}{i}{\symstate}$
  \item expression : $\evalexpr{\symstate}{e}{v}{\symstate}$
  \item expression - escape completion :
  $\evalescexpr{\symstate}{e}{v}{\symstate}$
  \item reference : $\evalref{\symstate}{r}{rv}{\symstate}$
  \item reference value : $\evalrefv{\symstate}{rv}{v}{\symstate}$
  \item unary operator : $\evaluop{v}{v}$
  \item binary operator : $\evalbop{v}{v}{v}$
\end{itemize}

% [[description of semantic relation]] 

% [[description of escape completion]] : result of abstract algorithm in ECMAScript
% is represented by completion record. "Escape completion" means "use value of 
% completion record(\irname object), instead of record itself".

% \subsubsection{State Helper Function}
% [[description of state function]]

\newpage

\subsubsection{Instruction}

% instruction semantic rule
\[
\begin{array}{c}
\multicolumn{1}{c}{\begin{array}{ccccc}
\fbox{$\evalinst{\symstate}{i}{\symstate}$}
&
\cs
&
% expression
\infer
{ \evalexpr{\symstate}{e}{v}{\symstate_0} }
{ \evalinst{\symstate}{e}{\symstate_0} }
&
\cs
&
% let
\infer
{ \evalexpr{\symstate}{e}{v}{\symstate_0}\ \ \ \
\hdefine{\symstate_0}{x}{v}{\symstate_1}}
{ \evalinst{\symstate}{\Term{let}\ x\ \Term{=}\ e}{\symstate_1} }
\end{array}}
\\ \\
% assign - refv:id
\infer
{ \evalref{\symstate}{r}{x}{\symstate_0}\ \ \ \
\evalexpr{\symstate_0}{e}{v}{\symstate_1}\ \ \ \
\hupdated{\symstate_1}{x}{v}{\symstate_2}}
{ \evalinst{\symstate}{r \Term{:=}\ e}{\symstate_2} }
\\ \\
% assign - refv:prop
\infer
{ \evalref{\symstate}{r}{a\Term{[} v \Term{]}}{\symstate_0}\ \ \ \
\evalescexpr{\symstate_0}{e}{v_0}{\symstate_1}\ \ \ \
\hupdated{\symstate_1}{a\Term{[} v \Term{]}}{v_0}{\symstate_2}}
{ \evalinst{\symstate}{r \Term{:=}\ e}{\symstate_2} }
% \\ \\
% % assign - refv:str - impossible
% \infer
% { \evalref{\symstate}{r}{s\Term{.}v}{\symstate_0}\ \ \ \
% \evalescexpr{\symstate_0}{e}{v_0}{\symstate_1}\ \ \ \
% \Term{updated}(\symstate_1,\ s\Term{.}v,\ v_0 ) = \symstate_2}
% { \evalinst{\symstate}{r \Term{:=}\ e}{\symstate_2} }
\\ \\
\multicolumn{1}{c}{\begin{array}{ccc}
% delete - id
\infer
{ \evalref{\symstate}{r}{x}{\symstate_0}\ \ \ \
\hdeleted{\symstate_0}{x}{\symstate_1}}
{ \evalinst{\symstate}{\Term{delete}\ r}{\symstate_1} }
& \cs &
% delete - prop
\infer
{ \evalref{\symstate}{r}{a\Term{[} v \Term{]}}{\symstate_0}\ \ \ \
\hdeleted{\symstate_0}{a\Term{[} v \Term{]}}{\symstate_1}}
{ \evalinst{\symstate}{\Term{delete}\ r}{\symstate_1} }
\end{array}}
\\ \\
% append
\infer
{ \evalescexpr{\symstate}{e_0}{v}{\symstate_0}\ \ \ \
\evalescexpr{\symstate_0}{e_1}{a}{\symstate_1}\ \ \ \
\happend{\symstate_1}{a}{v}{\symstate_2}}
{ \evalinst{\symstate}{\Term{append}\ e_0 \leftarrow e_1}{\symstate_2} }
\\ \\
% prepend
\infer
{ \evalescexpr{\symstate}{e_0}{v}{\symstate_0}\ \ \ \
\evalescexpr{\symstate_0}{e_1}{a}{\symstate_1}\ \ \ \
\hprepend{\symstate_1}{a}{v}{\symstate_2}}
{ \evalinst{\symstate}{\Term{prepend}\ e_0 \to e_1}{\symstate_2} }
\\ \\
% return
\infer
{ \evalexpr{\symstate}{e}{v}{\symstate_0}\ \ \ \
\hreturn{\symstate_0}{v}{\symstate_1}}
{ \evalinst{\symstate}{\Term{return}\ e}{\symstate_1} }
\\ \\
% if - true
\infer
{ \evalescexpr{\symstate}{e}{\Term{true}}{\symstate_0}\ \ \ \
\symstate_0 = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap}\ \ \ \
\symctx = \symctxtuple{x}{s}{i^*}{\symenv_L}
\\ \\
\symctx_0 = \symctxtuple{x}{s}{ \inred{i_0\ \Term{+:}\ i^*}}{\symenv_L}\ \ \ \
\symstate_1 = \symstatetuple{\symctx_0}{\symctxstack}{\symenv_G}{\symheap}}
{ \evalinst{\symstate}{\Term{if}\ e\ i_0\ i_1}{\symstate_1} }
\\ \\
% if - false
\infer
{ \evalescexpr{\symstate}{e}{\Term{false}}{\symstate_0}\ \ \ \
\symstate_0 = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap}\ \ \ \
\symctx = \symctxtuple{x}{s}{i^*}{\symenv_L}
\\ \\
\symctx_0 = \symctxtuple{x}{s}{\inred{i_1\ \Term{+:}\ i^*}}{\symenv_L}\ \ \ \
\symstate_1 = \symstatetuple{\symctx_0}{\symctxstack}{\symenv_G}{\symheap}}
{ \evalinst{\symstate}{\Term{if}\ e\ i_0\ i_1}{\symstate_1} }
\\ \\
% while - true
\infer
{ \evalescexpr{\symstate}{e}{\Term{true}}{\symstate_0}\ \ \ \
\symstate_0 = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap}\ \ \ \
\symctx = \symctxtuple{x}{s}{i^*}{\symenv_L}
\\ \\
\symctx_0 = \symctxtuple{x}{s}{\inred{i_b\ \Term{+:}\ i^*}}{\symenv_L}\ \ \ \
\symstate_1 = \symstatetuple{\symctx_0}{\symctxstack}{\symenv_G}{\symheap} }
{ \evalinst{\symstate}{\Term{while}\ e\ i_b}{\symstate_1} }
\\ \\

\multicolumn{1}{c}{\begin{array}{ccccc}
% while - false
\infer
{ \evalescexpr{\symstate}{e}{\Term{false}}{\symstate_0} }
{ \evalinst{\symstate}{\Term{while}\ e\ i_b}{\symstate_0} }
& \cs & 
% assert
\infer
{ \evalexpr{\symstate}{e}{\Term{true}}{\symstate_0} }
{ \evalinst{\symstate}{\Term{assert}\ e}{\symstate_0} }
&
\cs
&
% print
\infer
{ \evalexpr{\symstate}{e}{v}{\symstate_0}}
%  \ \ \ \ \Term{print}(v) }
{ \evalinst{\symstate}{\Term{print}\ e}{\symstate_0} }
\end{array}}
\\ \\
% seq 
\infer
{ \symstate = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap}\ \ \ \
\symctx = \symctxtuple{x}{s}{i^*}{\symenv_L}
\\ \\
\symctx_0 = \symctxtuple{x}{s}{\inred{i_s^*\ \Term{++}\ i^*}}{\symenv_L}\ \ \ \
\symstate_0 = \symstatetuple{\symctx_0}{\symctxstack}{\symenv_G}{\symheap} }
{ \evalinst{\symstate}{\{ i_s^* \}}{\symstate_0} }
\\ \\
% with cont
\infer
{ \symstate = \symstdef \ \ \ \
\Term{define}(\symstate,\ x_{id},\
\valcont{\symctx}{\symctxstack}{x^*}{i}) = \symstate_0 }
{ \evalinst
{\symstate}
{\Term{withcont}\ x_{id}\ \Term{(}x^*\Term{)}\ \Term{=}\ i}
{\symstate_0} }
% end of array
\end{array}
\]

\newpage
% instruction semantic rule cont
\[
\begin{array}{c}
% app - function
% TODO : handle varoption
\infer
{ \evalexpr{\symstate}{e_{f}}{v_f}{\symstate_f} \ \ \ \ \ \ \
v_f = \valfunc{s_{\lambda}}{x^*}{x_{var}}{i_{\lambda}}
\\ \\ 
\evalexpr{\symstate_f}{e_0}{v_0}{\symstate_0}\ \ \ \ \cdots\ \ \ \
\evalexpr{\symstate_{n-1}}{e_n}{v_n}{\symstate_n}\ \ \ \
\\ \\
\symstate_n = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap}\ \ \ \
\symctx = \symctxtuple{x_{ret}}{s}{i^*}{\symenv_L}\ \ \ \ 
\symctx_0 = \symctxtuple{x_f}{s}{i^*}{\symenv_L}
\\ \\
\symenv_{L_1} = [x \mapsto v]^*\ \ \ \
x_1 \in \mbox{Identifier}\ \ \ \
\symctx_1 = \symctxtuple{x_1}{s_{\lambda}}{i_{\lambda}}{\symenv_{L_1}}\ \ \ \
\symstate_{next} = \symstatetuple
{\symctx_1}{\inred{\symctx_0\ \Term{+:}\ \symctxstack}}{\symenv_G}{\symheap}}
{ \evalinst{\symstate}
{\Term{app}\ x_f\ \Term{=}\ (e_{f}\ e_0\ \cdots\ e_n)}
{\symstate_{next}} }
\\ \\
% app - AST method
\infer
{ \evalexpr{\symstate}{e_{f}}{v_f}{\symstate_f} \ \ \ \ \ \ \
v_f = \Term{ASTMethod}\ \valfunc{s_\lambda}{x^*}{x_{var}}{i_\lambda}\ E_\lambda
\\ \\
\evalexpr{\symstate_f}{e_0}{v_0}{\symstate_0}\ \ \ \ \cdots\ \ \ \
\evalexpr{\symstate_{n-1}}{e_n}{v_n}{\symstate_n}\ \ \ \
\\ \\
\symstate_n = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap}\ \ \ \
\symctx = \symctxtuple{x_{ret}}{s}{i^*}{\symenv_L}\ \ \ \ 
\symctx_0 = \symctxtuple{x_f}{s}{i^*}{\symenv_L}
\\ \\
\inred{\symenv_{L_1} = \symenv_\lambda + [x \mapsto v]^*}\ \ \ \
x_1 \in \mbox{Identifier}\ \ \ \
\symctx_1 = \symctxtuple{x_1}{s_{\lambda}}{i_{\lambda}}{\symenv_{L_1}}\ \ \ \
\symstate_{next} = \symstatetuple
{\symctx_1}{\inred{\symctx_0\ \Term{+:}\ \symctxstack}}{\symenv_G}{\symheap}}
{ \evalinst
{\symstate}
{\Term{app}\ x_f\ \Term{=}\ (e_{f}\ e_0\ \cdots\ e_n)}
{\symstate_{next}} }
\\ \\
% app - continuation
\infer
{ \evalexpr{\symstate}{e_{f}}{v_f}{\symstate_f} \ \ \ \
v_f = \valcont{\symctx}{\symctxstack}{x^*}{i}\ \ \ \
\symctx = \symctxtuple{x_c}{s}{i_c^*}{\symenv_L}
\\ \\ 
\evalexpr{\symstate_f}{e_0}{v_0}{\symstate_0}\ \ \ \ \cdots\ \ \ \
\evalexpr{\symstate_{n-1}}{e_n}{v_n}{\symstate_n}\ \ \ \
\symstate_n = \symstatetuple{\symctx_n}{\symctxstack_n}{\symenv_G}{\symheap}
\\ \\
\inred{\symenv_{L_0} = \symenv_L + [x \mapsto v]^*}\ \ \ \
\symctx_0 = \symctxtuple{x_c}{s}{i}{\symenv_{L_0}}\ \ \  \
\symstate_{next} = \symstatetuple{\symctx_0}{\symctxstack}{\symenv_G}{\symheap}}
{ \evalinst
{\symstate}
{\Term{app}\ x_f\ \Term{=}\ (e_{f}\ e_0\ \cdots\ e_n)}
{\symstate_{next}} }
\\ \\
% access - string
\infer
{ \evalexpr{\symstate}{e_b}{s}{\symstate_0}\ \ \ \
\evalescexpr{\symstate_0}{e}{v_p}{\symstate_1}\ \ \ \
\\ \\
\hgetsprop{s}{v_p}{v_0}\ \ \ \
\Term{define}(\symstate_1,\ x,\ v_0) = \symstate_2
}
{ \evalinst{\symstate}{\Term{access}\ x\ \Term{=}\ (e_b\ e)}{\symstate_2} }
\\ \\
% access - address - symbol, list
\infer
{ \evalexpr{\symstate}{e_b}{a}{\symstate_0}\ \ \ \
\evalescexpr{\symstate_0}{e}{v_p}{\symstate_1}\ \ \ \
\symstate_1 = \symstdef\ \ \ \
\\ \\
a \in \Term{Dom}(\symheap)\ \ \ \
\symheap(a) = \Term{symbol}\ v_s\ \ \ \
\Term{getHeapProp}(\symheap,\ a,\ v_p) = v_0\ \ \ \
\\ \\
\Term{define}(\symstate_1,\ x,\ v_0) = \symstate_2 }
{ \evalinst{\symstate}{\Term{access}\ x\ \Term{=}\ (e_b\ e)}{\symstate_2} }
\\ \\
% access - address - list
\infer
{ \evalexpr{\symstate}{e_b}{a}{\symstate_0}\ \ \ \
\evalescexpr{\symstate_0}{e}{v_p}{\symstate_1}\ \ \ \
\symstate_1 = \symstdef\ \ \ \
\\ \\
a \in \Term{Dom}(\symheap)\ \ \ \ \
\symheap(a) = \symlist{v^*}\ \ \ \ \
\Term{getHeapProp}(\symheap,\ a,\ v_p) = v_0\ \ \ \ \
\\ \\ \\
\Term{define}(\symstate_1,\ x,\ v_0) = \symstate_2 }
{ \evalinst{\symstate}{\Term{access}\ x\ \Term{=}\ (e_b\ e)}{\symstate_2} }
\\ \\
% access - address - map and not completion
\infer
{ \evalexpr{\symstate}{e_b}{a}{\symstate_0}\ \ \ \
\evalescexpr{\symstate_0}{e}{v_p}{\symstate_1}\ \ \ \
\symstate_1 = \symstdef\ \ \ \
\\ \\
a \in \Term{Dom}(\symheap)\ \ \ \
\symheap(a) = t\ \Term{\{} [v_k\ \mapsto\ v_v]^* \Term{\}}\ \ \ \
t \neq t_{completion}
\\ \\ \\
\Term{getHeapProp}(\symheap,\ a,\ v_p) = v_0\ \ \ \
\Term{define}(\symstate_1,\ x,\ v_0) = \symstate_2 }
{ \evalinst{\symstate}{\Term{access}\ x\ \Term{=}\ (e_b\ e)}{\symstate_2} }
\\ \\
% access - address - map and completion and contains
\infer
{ \evalexpr{\symstate}{e_b}{a}{\symstate_0}\ \ \ \
\evalescexpr{\symstate_0}{e}{v_p}{\symstate_1}\ \ \ \
\symstate_1 = \symstdef\ \ \ \
\\ \\
a \in \Term{Dom}(\symheap)\ \ \ \
\symheap(a) = t\ \Term{\{} [v_k\ \mapsto\ v_v]^* \Term{\}}\ \ \ \
t = t_{completion}\ \ \ \
v_p \in \{v_k\}
\\ \\ \\
\Term{getHeapProp}(\symheap,\ a,\ v_p) = v_0\ \ \ \
\Term{define}(\symstate_1,\ x,\ v_0) = \symstate_2 }
{ \evalinst{\symstate}{\Term{access}\ x\ \Term{=}\ (e_b\ e)}{\symstate_2} }
\\ \\
\end{array}
\]

\newpage

\[\begin{array}{c}
% access - address - completion and contains value - address
\infer
{ \evalexpr{\symstate}{e_b}{a}{\symstate_0}\ \ \ \
\evalescexpr{\symstate_0}{e}{v_p}{\symstate_1}\ \ \ \
\symstate_1 = \symstdef\ \ \ \
\\ \\
a \in \Term{Dom}(\symheap)\ \ \ \
\symheap(a) = t\ \Term{\{} [v_k\ \mapsto\ v_v]^* \Term{\}}\ \ \ \
t = t_{completion}\ \ \ \
\\ \\
v_p \notin \{v_k\}\ \ \ \
\Term{"Value"} \in \{v_k\}\ \ \ \
\inred{[v_k\ \mapsto\ v_v]^*(\Term{"Value"}) = a_0}\ \ \ \
\\ \\
\Term{getHeapProp}(\symheap,\ a_0,\ v_p) = v_0\ \ \ \
\Term{define}(\symstate_1,\ x,\ v_0) = \symstate_2 }
{ \evalinst{\symstate}{\Term{access}\ x\ \Term{=}\ (e_b\ e)}{\symstate_2} }
\\ \\
% access - address - completion and contains value - string
\infer
{ \evalexpr{\symstate}{e_b}{a}{\symstate_0}\ \ \ \
\evalescexpr{\symstate_0}{e}{v_p}{\symstate_1}\ \ \ \
\symstate_1 = \symstdef\ \ \ \
\\ \\
a \in \Term{Dom}(\symheap)\ \ \ \
\symheap(a) = t\ \Term{\{} [v_k\ \mapsto\ v_v]^* \Term{\}}\ \ \ \
t = t_{completion}\ \ \ \
\\ \\
v_p \notin \{v_k\}\ \ \ \
\Term{"Value"} \in \{v_k\}\ \ \ \
\inred{[v_k\ \mapsto\ v_v]^*(\Term{"Value"}) = s}\ \ \ \
\\ \\
\Term{getStringProp}(\symheap,\ s,\ v_p) = v_0\ \ \ \
\Term{define}(\symstate_1,\ x,\ v_0) = \symstate_2 }
{ \evalinst{\symstate}{\Term{access}\ x\ \Term{=}\ (e_b\ e)}{\symstate_2} }

\end{array}
\]

TODO

access - ASTVal - Lexical

access - ASTVal

\newpage

\subsubsection{Expression}

\[
\begin{array}{c}
\multicolumn{1}{c}{\begin{array}{ccccccccc}
\fbox{$\evalexpr{\symstate}{e}{v}{\symstate}$}
&
\cs
&
% number
\evalexpr{\symstate}{n}{n}{\symstate}
&
\cs
&
% integer
\evalexpr{\symstate}{d}{d}{\symstate}
&
\cs
&
% string
\evalexpr{\symstate}{s}{s}{\symstate}
&
\cs
&
% boolean
\evalexpr{\symstate}{b}{b}{\symstate}
\end{array}}
\\ \\
\multicolumn{1}{c}{\begin{array}{ccccc}
% undefined
\evalexpr{\symstate}{\Term{undefined}}{\Term{undefined}}{\symstate}
&
\cs
&
% null
\evalexpr{\symstate}{\Term{null}}{\Term{null}}{\symstate}
&
\cs
&
% absent
\evalexpr{\symstate}{\Term{absent}}{\Term{absent}}{\symstate}
\end{array}}
\\ \\
\multicolumn{1}{c}{\begin{array}{ccc}
% uop
\infer
{\evalescexpr{\symstate}{e}{v}{\symstate_0}\ \ \ \
\evaluop{v}{v_0}}
{\evalexpr{\symstate}{\odot\ e}{v_0}{\symstate_0}}
&
\cs
&
% bop
\infer
{\evalescexpr{\symstate}{e_0}{v_0}{\symstate_0}\ \ \ \
\evalescexpr{\symstate_0}{e_1}{v_1}{\symstate_1}\ \ \ \
\evalbop{v_0}{v_1}{v_2}}
{\evalexpr{\symstate}{e_0\ \oplus\ e_1}{v_2}{\symstate_1}}
\end{array}}
\\ \\
% reference - not escapeCompletion
\infer
{\evalref{\symstate}{r}{\symrefv}{\symstate_0}\ \ \ \
\evalrefv{\symstate_0}{\symrefv}{v}{\symstate_1}}
{\evalexpr{\symstate}{r}{v}{\symstate_1}}
\\ \\
% reference - escapeCompletion
\infer
{\evalref{\symstate}{r}{\symrefv}{\symstate_0}\ \ \ \
\evalrefv{\symstate_0}{\symrefv}{a}{\symstate_1}\ \ \ \
\symstate_1 = \symstdef\ \ \ \
\inred{\Term{assertDynamicAddr}(a)}
\\ \\
a \in \Term{Dom}(\symheap)\ \ \ \
\symheap(a) = t\ \Term{\{} [v_k\ \mapsto\ v_v]^* \Term{\}}\ \ \ \ 
t = t_{completion}\ \ \ \
\inred{[v_k\ \mapsto\ v_v]^*(\Term{"Value"}) = v}}
{\evalescexpr{\symstate}{r}{v}{\symstate_1}}
\\ \\
\multicolumn{1}{c}{\begin{array}{ccc}
% continuation
\infer
{\symstate = \symstdef\ \ \ \ }
{\evalexpr
{\symstate}
{\Term{(} x^* \Term{)}\ \Term{[} \Rightarrow \Term{]}\ i}
{\valcont{\symctx}{\symctxstack}{x^*}{i}}
{\symstate}}
&
\cs
&
% typeof
\infer
{\evalexpr{\symstate}{e}{v}{\symstate_0}\ \ \ \
\inred{\hgettype{v}{s_{type}}}}
{\evalexpr{\symstate}{\Term{typeof}\ e}{s_{type}}{\symstate_0}}
\end{array}}
\\ \\
% symbol - str
\infer
{\evalescexpr{\symstate}{e}{v}{\symstate_0}\ \ \ \
\symstate_0 = \symstdef\ \ \ \
\\ \\
\hallocsym{\symheap}{v}{a}{\symheap_0}\ \ \ \
\symstate_1 = \symstatetuple{\symctx}{\symctxstack}{\symenv}{\symheap_0}}
{\evalexpr{\symstate}{\Term{new}\ e}{a}{\symstate_1}}
\\ \\
% list 
\infer
{ \evalexpr{\symstate}{e_0}{v_0}{\symstate_0}\ \ \ \ \cdots\ \ \ \
\evalexpr{\symstate_{n-1}}{e_n}{v_n}{\symstate_n}\ \ \ \
\symstate_n = \symstdef
\\ \\
\halloclist{\symheap}{\inred{v^*}}{a}{\symheap_0}\ \ \ \
\symstate_{next} = \symstatetuple{\symctx}{\symctxstack}{\symenv}{\symheap_0}}
{ \evalexpr{\symstate}
{\Term{new}\ \Term{[} e_0,\ \cdots,\ e_n \Term{]}}{a}{\symstate_{next}} }
\\ \\
% map
\infer
{\symstate = \symstdef\ \ \ \
\hallocmap{\symheap}{t}{a}{\symheap_0}\ \ \ \
\symstate_t = \symstatetuple{\symctx}{\symctxstack}{\symenv}{\symheap_0}
\\ \\
\evalescexpr{\symstate_t}{e_{k_0}}{v_{k_0}}{\symstate_{0_k}}\ \ \ \
\evalexpr{\symstate_{0_k}}{e_{v_0}}{v_{v_0}}{\symstate_{0_v}}\ \ \ \
\Term{updated}(\symstate_{0_v},\ a \Term{[} v_{k_0} \Term{]},\ v_{v_0}) = \symstate_0\ \ \ \
\\ \\ 
\ \ \ \ \ \cdots\ \ \ \ \ \
\\ \\ 
\evalescexpr{\symstate_{n-1}}{e_{k_n}}{v_{k_n}}{\symstate_{n_k}}\ \ \ \
\evalexpr{\symstate_{n_k}}{e_{v_n}}{v_{v_n}}{\symstate_{n_v}}\ \ \ \
\Term{updated}(\symstate_{n_v},\ a \Term{[} v_{k_n} \Term{]},\ v_{v_n}) = \symstate_n}
{ \evalexpr{\symstate}
{\Term{new}\ t\ \Term{(} e_{k_0}\ \mapsto\ e_{v_0},\ \cdots,\
e_{k_n}\ \mapsto\ e_{v_n} \Term{)}}
{a}{\symstate_{n}} }
\\ \\
% pop
\infer
{\evalescexpr{\symstate}{e_0}{a}{\symstate_0}\ \ \ \
\evalescexpr{\symstate_0}{e_1}{d}{\symstate_1}\ \ \ \
\symstate_1 = \symstdef\ \ \ \
a \in \Term{Dom}(\symheap)
\\ \\
\symheap(a) = \symlist{v^*}\ \ \ \
d_l = \mathlen{\symlist{v^*}}\ \ \ \ 
0 \le d < d_l\ \ \ \
\symlist{v^*}(d) = v_0\ \ \ \
\inred{o = \symlist{v^*}[0..d]\ \Term{++}\ \symlist{v^*}[(d+1)..d_l]}
\\ \\
\inred{\symheap_0 = \symheap + (a \mapsto o)}\ \ \ \
\symstate_2 = \symstatetuple{\symctx}{\symctxstack}{\symenv}{\symheap_0}}
{\evalexpr{\symstate}{\Term{pop}\ e_0\ e_1}{v_0}{\symstate_2}}
\\ \\
% copy-obj
\infer
{\evalescexpr{\symstate}{e}{a}{\symstate_0}\ \ \ \
\symstate_0 = \symstdef\ \ \ \
a \in \Term{Dom}(\symheap)\ \ \ \
a_0 \notin \Term{Dom}(\symheap)\ \ \ \
\\ \\
\symheap(a) = o\ \ \ \
\inred{\symheap_0 = \symheap + (a_0 \mapsto o)}\ \ \ \
\symstate_1 = \symstatetuple{\symctx}{\symctxstack}{\symenv}{\symheap_0}}
{\evalexpr{\symstate}{\Term{copy-obj}\ e}{a_0}{\symstate_1}}
\\ \\
% map-keys
\infer
{\evalescexpr{\symstate}{e}{a}{\symstate_0}\ \ \ \
\symstate_0 = \symstdef\ \ \ \
a \in \Term{Dom}(\symheap)\ \ \ \
\symheap(a) = \symmap{t}{v_k}{v_v}
\\ \\
a_0 \notin \Term{Dom}(\symheap)\ \ \ \
\inred{o = \symlist{v_k^*}}\ \ \ \
\inred{\symheap_0 = \symheap + (a_0 \mapsto o)}\ \ \ \
\symstate_1 = \symstatetuple{\symctx}{\symctxstack}{\symenv}{\symheap_0}}
{\evalexpr{\symstate}{\Term{map-keys}\ e}{a_1}{\symstate_1}}
\end{array}
\]

\newpage

\[ \begin{array}{c}
% contains - true
\infer
{\evalescexpr{\symstate}{e_0}{a}{\symstate_0}\ \ \ \
\evalescexpr{\symstate_0}{e_1}{v_0}{\symstate_1}\ \ \ \
\symstate_1 = \symstdef\ \ \ \
\\ \\
a \in \symheap\ \ \ \
\inred{\symheap(a) = \symlist{v^*}}\ \ \ \
v_0 \in \Term{\{}v\Term{\}}}
{\evalexpr{\symstate}{\Term{contains}\ e_0\ e_1}{\Term{true}}{\symstate_1}}
\\ \\
% contains - false
\infer
{\evalescexpr{\symstate}{e_0}{a}{\symstate_0}\ \ \ \
\evalescexpr{\symstate_0}{e_1}{v_0}{\symstate_1}\ \ \ \
\symstate_1 = \symstdef\ \ \ \
\\ \\
a \in \symheap\ \ \ \
\symheap(a) = \symlist{v^*}\ \ \ \
\inred{v_0 \notin \Term{\{}v\Term{\}}}}
{\evalexpr{\symstate}{\Term{contains}\ e_0\ e_1}{\Term{false}}{\symstate_1}}
\\ \\
% convert
\infer
{\evalescexpr{\symstate}{e}{s}{\symstate_0}\ \ \ \
\inred{\Term{convert}(\triangleright,\ s,\ e^*) = (v,\ \symstate_1)}}
{\evalexpr{\symstate}{\Term{convert}\ e\ \triangleright\ e^*}{v}{\symstate_1}}
\\ \\
\multicolumn{1}{c}{\begin{array}{ccc}
% is-instance-of - str - true
\infer
{\evalescexpr{\symstate}{e}{s_0}{\symstate_0}\ \ \ \
s_0 = s }
{\evalexpr{\symstate}{\Term{is-instance-of}\ e\ s}{\Term{true}}{\symstate_0}}
& \cs &
% is-instance-of - str - false
\infer
{\evalescexpr{\symstate}{e}{s_0}{\symstate_0}\ \ \ \
s_0 \neq s }
{\evalexpr{\symstate}{\Term{is-instance-of}\ e\ s}{\Term{false}}{\symstate_0}}
\end{array}}
\\ \\
% is-instance-of - AST value
\infer
{\evalescexpr{\symstate}{e}{\symast}{\symstate_0}\ \ \ \
\Term{isKindOf}(\symast,\ s) = b }
{\evalexpr{\symstate}{\Term{is-instance-of}\ e\ s}{b}{\symstate_0}}

\\ \\
% get syntax
\infer
{\evalescexpr{\symstate}{e}{\symast}{\symstate_0}\ \ \ \
\Term{toString}(\symast) = s }
{\evalexpr{\symstate}{\Term{get-syntax}\ e}{s}{\symstate_0}}
\\ \\
% get elems
\infer
{\evalescexpr{\symstate}{e}{\symast}{\symstate_0}\ \ \ \
\Term{getElems}(\symast) = v^* \ \ \ \
\Term{allocList}(\symstate_0,\ v^*) = (a,\ \symstate_1) }
{\evalexpr{\symstate}{\Term{get-elems}\ e\ s}{a}{\symstate_1}}
\\ \\
% parse syntax - AST
\infer
{\evalescexpr{\symstate}{e_c}{\symast}{\symstate_0}\ \ \ \
\evalescexpr{\symstate_0}{e_r}{s}{\symstate_1}\ \ \ \
\Term{assertValidParseRule}(s)
\\ \\
\Term{getNewValue}(\symast,\ s) = v}
{\evalexpr{\symstate}{\Term{parse-syntax}\ e_c\ e_r\ e^*}{v}{\symstate_1}}
\\ \\ 
% parse syntax - string
\infer
{\evalescexpr{\symstate}{e_c}{s_c}{\symstate_c}\ \ \ \
\evalescexpr{\symstate_c}{e_r}{s_r}{\symstate_r}\ \ \ \
\\ \\
\evalexpr{\symstate_r}{e_0}{b_0}{\symstate_0}\ \ \ \ \cdots\ \ \ \
\evalexpr{\symstate_{n-1}}{e_n}{b_n}{\symstate_n}\ \ \ \
\Term{getNewValue}(s_c,\ s_r,\ b^*) = v}
{\evalexpr
{\symstate}
{\Term{parse-syntax}\ e_c\ e_r\ e_0\ \cdots\ e_n}
{v}{\symstate_n}}
\end{array}\]

TODO

fix rule related to AST value

\begin{itemize}
  \item is-instance-of AST
  \item get-syntax
  \item get-elems
  \item parse-syntax
\end{itemize}

\newpage

\subsubsection{Reference}

\[
\begin{array}{c}
\multicolumn{1}{c}{\begin{array}{ccc}
\fbox{$\evalref{\symstate}{r}{\symrefv}{\symstate}$}
& \cs &
% ref - id
\evalref{\symstate}{x}{x}{\symstate}
\end{array}}
\\ \\
% ref - prop - string
\infer
{\evalref{\symstate}{r}{\symrefv}{\symstate_0}\ \ \ \
\evalrefv{\symstate_0}{\symrefv}{s}{\symstate_1}\ \ \ \
\evalescexpr{\symstate_1}{e}{v}{\symstate_2}}
{\evalref{\symstate}{r\Term{[} e \Term{]}}{s\Term{.}v}{\symstate_2}}
\\ \\
% ref - prop - address - not contains in heap
\infer
{\evalref{\symstate}{r}{\symrefv}{\symstate_0}\ \ \ \
\evalrefv{\symstate_0}{\symrefv}{a}{\symstate_1}\ \ \ \
\evalescexpr{\symstate_1}{e}{v}{\symstate_2}\ \ \ \
\symstate_2 = \symstdef\ \ \ \
a \notin \Term{Dom}(\symheap)}
{\evalref{\symstate}{r\Term{[} e \Term{]}}{a\Term{[} v \Term{]}}{\symstate_2}}
\\ \\
% ref - prop - address - symbol
\infer
{\evalref{\symstate}{r}{\symrefv}{\symstate_0}\ \ \ \
\evalrefv{\symstate_0}{\symrefv}{a}{\symstate_1}\ \ \ \
\evalescexpr{\symstate_1}{e}{v}{\symstate_2}\ \ \ \
\symstate_2 = \symstdef\ \ \ \
\\ \\
a \in \Term{Dom}(\symheap)\ \ \ \
\symheap(a) = \Term{symbol}\ v_s}
{\evalref{\symstate}{r\Term{[} e \Term{]}}{a\Term{[} v \Term{]}}{\symstate_2}}
\\ \\
% ref - prop - address - list
\infer
{\evalref{\symstate}{r}{\symrefv}{\symstate_0}\ \ \ \
\evalrefv{\symstate_0}{\symrefv}{a}{\symstate_1}\ \ \ \
\evalescexpr{\symstate_1}{e}{v}{\symstate_2}\ \ \ \
\symstate_2 = \symstdef\ \ \ \
\\ \\
a \in \Term{Dom}(\symheap)\ \ \ \
\symheap(a) = \symlist{v^*}}
{\evalref{\symstate}{r\Term{[} e \Term{]}}{a\Term{[} v \Term{]}}{\symstate_2}}
\\ \\
% ref - prop - address - not completion
\infer
{\evalref{\symstate}{r}{\symrefv}{\symstate_0}\ \ \ \
\evalrefv{\symstate_0}{\symrefv}{a}{\symstate_1}\ \ \ \
\evalescexpr{\symstate_1}{e}{v}{\symstate_2}\ \ \ \
\symstate_2 = \symstdef\ \ \ \
\\ \\
a \in \Term{Dom}(\symheap)\ \ \ \
\symheap(a) = t\ \Term{\{} [v_k\ \mapsto\ v_v]^* \Term{\}}\ \ \ \
t \neq t_{completion}}
{\evalref{\symstate}{r\Term{[} e \Term{]}}{a\Term{[} v \Term{]}}{\symstate_2}}
\\ \\
% ref - prop - address - completion and contains
\infer
{\evalref{\symstate}{r}{\symrefv}{\symstate_0}\ \ \ \
\evalrefv{\symstate_0}{\symrefv}{a}{\symstate_1}\ \ \ \
\evalescexpr{\symstate_1}{e}{v}{\symstate_2}\ \ \ \
\symstate_2 = \symstdef\ \ \ \
\\ \\
a \in \Term{Dom}(\symheap)\ \ \ \
\symheap(a) = t\ \Term{\{} [v_k\ \mapsto\ v_v]^* \Term{\}}\ \ \ \
t = t_{completion}\ \ \ \
v \in \{v_k\} \ \ \ \ }
{\evalref{\symstate}{r\Term{[} e \Term{]}}{a\Term{[} v \Term{]}}{\symstate_2}}
\\ \\
% ref - prop - address - completion - prop
\infer
{\evalref{\symstate}{r}{\symrefv}{\symstate_0}\ \ \ \
\evalrefv{\symstate_0}{\symrefv}{a}{\symstate_1}\ \ \ \
\evalescexpr{\symstate_1}{e}{v}{\symstate_2}\ \ \ \
\symstate_2 = \symstdef\ \ \ \
\\ \\
a \in \Term{Dom}(\symheap)\ \ \ \
\symheap(a) = t\ \Term{\{} [v_k\ \mapsto\ v_v]^* \Term{\}}\ \ \ \
t = t_{completion}\ \ \ \
v \notin \{v_k\}\ \ \ \
\Term{"Value"} \in \{v_k\}
\\ \\
[v_k\ \mapsto\ v_v]^*(\Term{"Value"}) = a_0 }
{\evalref{\symstate}{r\Term{[} e \Term{]}}{a_0\Term{[} v \Term{]}}{\symstate_2}}
\\ \\
% ref - prop - address - completion - str
\infer
{\evalref{\symstate}{r}{\symrefv}{\symstate_0}\ \ \ \
\evalrefv{\symstate_0}{\symrefv}{a}{\symstate_1}\ \ \ \
\evalescexpr{\symstate_1}{e}{v}{\symstate_2}\ \ \ \
\symstate_2 = \symstdef\ \ \ \
\\ \\
a \in \Term{Dom}(\symheap)\ \ \ \
\symheap(a) = t\ \Term{\{} [v_k\ \mapsto\ v_v]^* \Term{\}}\ \ \ \
t = t_{completion}\ \ \ \
v \notin \{v_k\}\ \ \ \
\Term{"Value"} \in \{v_k\}
\\ \\
[v_k\ \mapsto\ v_v]^*(\Term{"Value"}) = s }
{\evalref{\symstate}{r\Term{[} e \Term{]}}{s\Term{.} v}{\symstate_2}}
\end{array}  
\]

\newpage

\subsubsection{Reference Value}
\[
\begin{array}{c}
\multicolumn{1}{c}{\begin{array}{ccc}
\fbox{$\evalrefv{\symstate}{\symrefv}{v}{\symstate}$}
& \cs &
% refv - id - local
\infer
{\symstate = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap} \ \ \ \
\symctx = \symctxtuple{x_{ret}}{s}{i^*}{\symenv_L}\ \ \ \
x \in \Term{Dom}(\symenv_L)\ \ \ \
\symenv_L (x) = v }
{\evalrefv{\symstate}{x}{v}{\symstate}}
\end{array}}
\\ \\
% refv - id - global
\infer
{\symstate = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap} \ \ \ \
\symctx = \symctxtuple{x_{ret}}{s}{i^*}{\symenv_L}\ \ \ \
x \notin \Term{Dom}(\symenv_L)\ \ \ \
x \in \Term{Dom}(\symenv_G)\ \ \ \
\symenv_G (x) = v }
{\evalrefv{\symstate}{x}{v}{\symstate}}
\\ \\
% refv - id - absent
\infer
{\symstate = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap} \ \ \ \
\symctx = \symctxtuple{x_{ret}}{s}{i^*}{\symenv_L}\ \ \ \
x \notin \Term{Dom}(\symenv_L)\ \ \ \
x \notin \Term{Dom}(\symenv_G)}
{\evalrefv{\symstate}{x}{\Term{absent}}{\symstate}}
\\ \\
% refv - prop
\infer
{\symstate = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap} \ \ \ \
a \in \Term{Dom}(\symheap)\ \ \ \
\hgethprop{\symheap}{a}{v}{v_0}}
{\evalrefv{\symstate}{a\Term{[} v \Term{]}}{v_0}{\symstate}}
\\ \\
% refv - str
\infer
{\hgetsprop{s}{v}{v_0}}
{\evalrefv{\symstate}{s\Term{.}v}{v_0}{\symstate}}

\end{array}
\]

\newpage

\subsubsection{Helper Function}

\[\begin{array}{c}
% define
\infer
{\symstate = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap}\ \ \ \
\symctx = \symctxtuple{x_{ret}}{s}{i^*}{\symenv_L}\ \ \ \
\\ \\
\inred{\symenv_0 = \symenv_L + (x \mapsto v)}\ \ \ \
\symctx_0 = \symctxtuple{x_{ret}}{s}{i^*}{\symenv_0}\ \ \ \
\symstate_0 = \symstatetuple{\symctx_0}{\symctxstack}{\symenv_G}{\symheap}}
{\hdefine{\symstate}{x}{v}{\symstate_0}}
\\ \\
% update - refv:id - global
\infer
{\symstate = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap}\ \ \ \
\inred{\Term{assertGlobalId}(x)}\ \ \ \ 
\inred{\symenv_0 = \symenv_G + (x \mapsto v)}\ \ \ \
\symstate_0 = \symstatetuple{\symctx}{\symctxstack}{\symenv_0}{\symheap}}
{\hupdated{\symstate}{x}{v}{\symstate_0}}
\\ \\
% update - refv:id - local
\infer
{\inred{\Term{assertLocalId}(x)}\ \ \ \
\hdefine{\symstate}{x}{v}{\symstate_0}}
{\hupdated{\symstate}{x}{v}{\symstate_0}}
\\ \\
% update - refv:prop
\infer
{\symstate = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap}\ \ \ \
a \in \Term{Dom}(\symheap)\ \ \ \
\symheap(a) = t\ \Term{\{} [v_k\ \mapsto\ v_v]^* \Term{\}}\ \ \ \
\inred{o = t\ \Term{\{} [v_k\ \mapsto\ v_v]^* + (v_0 \mapsto v_1) \Term{\}}}
\\ \\
\inred{\symheap_0 = \symheap + (a \mapsto o)}\ \ \ \
\symstate_0 = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap_0}}
{\hupdated{\symstate}{a\Term{[} v_0 \Term{]}}{v_1}{\symstate_0}}
\\ \\
% delete - id
\infer
{\symstate = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap}\ \ \ \
\symctx = \symctxtuple{x_{ret}}{s}{i^*}{\symenv_L}\ \ \ \
\\ \\
\inred{\symenv_0 = \symenv_L - x}\ \ \ \
\symctx_0 = \symctxtuple{x_{ret}}{s}{i^*}{\symenv_0}\ \ \ \
\symstate_0 = \symstatetuple{\symctx_0}{\symctxstack}{\symenv_G}{\symheap}}
{\hdeleted{\symstate}{x}{\symstate_0}}
\\ \\
% delete - refv:prop
\infer
{\symstate = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap}\ \ \ \
a \in \Term{Dom}(\symheap)\ \ \ \
\symheap(a) = t\ \Term{\{} [v_k\ \mapsto\ v_v]^* \Term{\}}\ \ \ \
\inred{o = t\ \Term{\{} [v_k\ \mapsto\ v_v]^* - v_0 \Term{\}}}
\\ \\
\inred{\symheap_0 = \symheap + (a \mapsto o)}\ \ \ \
\symstate_0 = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap_0}}
{\hdeleted{\symstate}{a\Term{[} v_0 \Term{]}}{\symstate_0}}
\\ \\
% append
\infer
{\symstate = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap}\ \ \ \
a \in \Term{Dom}(\symheap)\ \ \ \
\symheap(a) = \symlist{v^*}\ \ \ \
\inred{o = \symlist{v^*}\ \Term{:+}\ v_0}
\\ \\
\inred{\symheap_0 = \symheap + (a \mapsto o)}\ \ \ \
\symstate_0 = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap_0}}
{\happend{\symstate}{a}{v_0}{\symstate_0}}
\\ \\
% prepend
\infer
{\symstate = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap}\ \ \ \
a \in \Term{Dom}(\symheap)\ \ \ \
\symheap(a) = \symlist{v^*}\ \ \ \
\inred{o = v_0\ \Term{+:}\ \symlist{v^*}}
\\ \\
\inred{\symheap_0 = \symheap + (a \mapsto o)}\ \ \ \
\symstate_0 = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap_0}}
{\hprepend{\symstate}{a}{v_0}{\symstate_0}}
\\ \\
% return - ctx stack empty
\infer
{\symstate = \symstatetuple{\symctx}{\inred{\Term{Nil}}}{\symenv_G}{\symheap}\ \ \ \
\symctx = \symctxtuple{x_{ret}}{s}{i^*}{\symenv_L}\ \ \ \
\\ \\
\inred{\symenv_0 = \symenv_L + (x_{ret} \mapsto v)}\ \ \ \
\symctx_0 = \symctxtuple{x_{ret}}{s}{\Term{Nil}}{\symenv_0}\ \ \ \
\symstate_0 = \symstatetuple{\symctx_0}{\symctxstack}{\symenv_G}{\symheap}}
{\hreturn{\symstate}{v}{\symstate_0}}
\\ \\
% return - ctx stack not empty
\infer
{\symstate = \symstatetuple
{\symctx}{\inred{\symctx_0\ \Term{+:}\ \symctxstack}}{\symenv_G}{\symheap}\ \ \ \
\symctx_0 = \symctxtuple{x_{ret}}{s}{i^*}{\symenv_{L}}\ \ \ \
\\ \\
\inred{\symenv_0 = \symenv_L + (x_{ret} \mapsto v)}\ \ \ \
\symctx_1 = \symctxtuple{x_{ret}}{s}{i^*}{\symenv_0}\ \ \ \
\symstate_0 = \symstatetuple{\symctx_1}{\symctxstack}{\symenv_G}{\symheap}}
{\hreturn{\symstate}{v}{\symstate_0}}
\end{array}\]

\newpage

\[\begin{array}{c}
% prop - symbol
\infer
{a \in \Term{Dom}(\symheap)\ \ \ \
s = "\Term{Description}"\ \ \ \
\symheap(a) = \Term{symbol}\ v}
{\hgethprop{\symheap}{a}{s}{v}}
\\ \\
% prop - map - absent
\infer
{a \in \Term{Dom}(\symheap)\ \ \ \
\symheap(a) = \symmap{t}{v_k}{v_v}\ \ \ \
v \notin \{ v_k \}}
{\hgethprop{\symheap}{a}{v}{\Term{absent}}}
\\ \\
% prop - map - not absent
\infer
{a \in \Term{Dom}(\symheap)\ \ \ \
\symheap(a) = \symmap{t}{v_k}{v_v}\ \ \ \
v_p \in \{ v_k \} \ \ \ \
\inred{[v_k\ \mapsto\ v_v]^*(v_p) = v} }
{\hgethprop{\symheap}{a}{v_p}{v}}
\\ \\
% prop - list - length
\infer
{a \in \Term{Dom}(\symheap)\ \ \ \
s = "\Term{length}"\ \ \ \
\symheap(a) = \symlist{v^*} \ \ \ \
\mathlen{\symlist{v^*}} = d}
{\hgethprop{\symheap}{a}{s}{d}}
\\ \\
\multicolumn{1}{c}{\begin{array}{ccc}
% prop - list - integer - not valid - negative
\infer
{a \in \Term{Dom}(\symheap)\ \ \ \
\symheap(a) = \symlist{v^*} \ \ \ \
d < 0}
{\hgethprop{\symheap}{a}{d}{\Term{absent}}}
& \cs &
% prop - list - integer - not valid - ge length
\infer
{a \in \Term{Dom}(\symheap)\ \ \ \
\symheap(a) = \symlist{v^*} \ \ \ \
\mathlen{\symlist{v^*}} = d_0\ \ \ \
d \ge d_0}
{\hgethprop{\symheap}{a}{d}{\Term{absent}}}
\end{array}}
\\ \\
% prop - list - integer - valid
\infer
{a \in \Term{Dom}(\symheap)\ \ \ \
\symheap(a) = \symlist{v^*} \ \ \ \
\mathlen{\symlist{v^*}} = d_0\ \ \ \
0 \le d < d_0\ \ \ \
\inred{\symlist{v^*}(d) = v_0}}
{\hgethprop{\symheap}{a}{d}{v_0}}
\\ \\
\multicolumn{1}{c}{\begin{array}{ccccc}
% str prop - length
\infer
{s_p = \Term{"length"}\ \ \ \
v = \mathlen{s}}
{\hgetsprop{s}{s_p}{v}}
& \cs &
% str prop - floating point
\infer
{\htoint{n}{d}\ \ \ \
\inred{\hcharat{s}{d}{s_0}}}
{\hgetsprop{s}{n}{s_0}}
& \cs &
% str prop - integer
\infer
{\inred{\hcharat{s}{d}{s_0}}}
{\hgetsprop{s}{d}{s_0}}
\end{array}}
\\ \\
% alloc symbol - string
\infer
{a \notin \Term{Dom}(\symheap)\ \ \ \
o = \Term{symbol}\ s\ \ \ \
\inred{\symheap_0 = \symheap + (a \mapsto o)}}
{\hallocsym{\symheap}{s}{a}{\symheap_0}}
\\ \\
% alloc symbol - undef
\infer
{a \notin \Term{Dom}(\symheap)\ \ \ \
o = \Term{symbol}\ \Term{undefined}\ \ \ \
\inred{\symheap_0 = \symheap + (a \mapsto o)}}
{\hallocsym{\symheap}{\Term{undefined}}{a}{\symheap_0}}
\\ \\
% alloc map
\infer
{a \notin \Term{Dom}(\symheap)\ \ \ \
\inred{o = t\ \Term{\{} {\emptyset} \Term{\}}}\ \ \ \
\inred{\symheap_0 = \symheap + (a \mapsto o)}}
{\hallocmap{\symheap}{t}{a}{\symheap_0}}
\\ \\
% alloc list
\infer
{a \notin \Term{Dom}(\symheap)\ \ \ \
o = \symlist{v^*}\ \ \ \
\inred{\symheap_0 = \symheap + (a \mapsto o)}}
{\halloclist{\symheap}{v^*}{a}{\symheap_0}}
\end{array}\]

TODO

getType

getElmes

isKindOf

toString

getNewValue

assertValidParseRule

\end{document}

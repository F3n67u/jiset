\section{JavaScript Semantics Specialization with Syntactic Views}\label{sec:formal}

We first define $\ires$ as a specification language to describe JavaScript
semantics.  Then, we introduce a general formalization of function
specialization in $\ires$. Finally, we define a constant propagation
specialization as its an instance to reduce JavaScript semantics using given
syntactic views. We also prove its semantics preservation under an observational
semantics.

\subsection{$\ires$: Intermediate Representations for ECMAScript}

We first introduce $\ires$, an \textbf{I}ntermediate \textbf{R}epresentations
for \textbf{E}CMA\textbf{S}cript, as a specification language for JavaScript to
describe JavaScript semantics. We define its abstract syntax, states, and
concrete semantics in the remainder of this section.

\subsubsection{Abstract Syntax}

\[
  \begin{array}{lr@{~}c@{~}c@{~}c@{~}l}
    \text{Functions} & \funcset &\ni& \func &::=&
    \kwdef \; x \; \kwrl x^* \kwrr \; \kwcl [\lab: \inst]^* \kwcr\\

    \text{Variables} & \varset &\ni& x\\

    \text{Labels} & \labset &\ni& \lab\\

    \text{Instructions} & \instset &\ni& \inst &::=&
    \refer = \expr \mid
    x = \expr \kwrl \expr^* \kwrr \mid
    \kwif \; \expr \; \lab \; \lab \mid
    \kwret \; \expr\\

    \text{Expressions} & \exprset &\ni& \expr &::=&
    \pval \mid
    \op \kwrl \expr^* \kwrr \mid
    \kwcl \kwcr \mid
    \refer\\

    \text{References} & \referset &\ni& \refer &::=&
    x \mid \refer \kwsl \expr \kwsr\\
  \end{array}
\]

\todo update explanation

A function $\func \in \funcset$ is defined with its name, parameters, and body
instructions with labels $\labset$.  An instruction $\inst \in \instset$ is
a primitive value assignment $x = \pval$,
an operation between values $x = \op \kwrl x^* \kwrr$,
a function call $x = x \kwrl x^* \kwrr$,
a object allocation $x = \kwcl \kwcr$,
a field access $x = x \kwsl x \kwsr$,
a field assignment $x \kwsl x \kwsr = x$,
a conditional branch $\kwif \; x \; \lab \; \lab$,
or a return instruction $\kwret \; x$.


\subsubsection{States}

\[
  \begin{array}{lr@{~}c@{~}l@{~}c@{~}l}
    \text{States} & \st &\in& \stset &=&
    \labset \times \ctxtset^* \times \heapset \times \envset\\

    \text{Calling Contexts} & \ctxt &\in& \ctxtset &=&
    \labset \times \envset \times \varset\\

    \text{Heaps} & \heap &\in& \heapset &=&
    \addrset \finmap \objset\\

    \text{Environments} & \env &\in& \envset &=&
    \varset \finmap \valset\\

    \text{Values} & \val &\in& \valset &=&
    \pvalset \uplus \addrset \uplus \treeset \uplus \funcset\\

    \text{Primive Values} & \pval &\in& \pvalset &=&
    \strset \uplus \cdots\\

    \text{JavaScript ASTs} & \tree &\in& \treeset\\

    \text{Objects} & \obj &\in& \objset &=&
    \strset \finmap \valset\\
  \end{array}
\]

\todo
% States $\stset$ consist of heaps $\heapset$ and contexts $\ctxtset$.  A heap
% $\heap \in \heapset$ is a finite mapping from addresses to objects.  Each object
% allocation instruction $x = \kwcl \kwcr$ creates a unique address $\addr \in
% \addrset$ different from existing addresses.  A context $\ctxt \in \ctxtset$ is
% a triple of a label, a environment, and an optional calling context $\ctxtopt
% \in \ctxtoptset = \ctxtset \uplus \{ \bot \}$.  An environment $\env \in
% \envset$ is a finite mapping from variables to values. A value $\val \in
% \valset$ is a primitive value $\pval \in \pvalset$ (e.g., a string value $\str
% \in \strset$), an address $\addr \in \addrset$, a JavaScript AST $\tree \in
% \treeset$, or a function $f \in \funcset$.  A object $\obj \in \objset$ is a
% finite mappings from strings to values.

\subsubsection{Concrete Semantics of Functions}

\[
  \framebox{$\sem{\func}: \stset \times \valset^* \rightarrow \stset \times
  \valset$}
\]

\todo

\subsubsection{Concrete Semantics of Instructions}

\[
  \framebox{$\sem{\inst}: \stset \rightarrow \stset$}
\]

\todo
% \[
%   \begin{array}{l}
%     \sem{x = \pval}(\heap, (\lab, \env, \ctxtopt)) =\\
%     \qquad (\heap, (\lab, \env[x \mapsto \pval], \ctxtopt)) \\
%     \\
% 
%     \sem{x = \op \kwrl x_1, \cdots, x_n \kwrr}(\heap, (\lab, \env, \ctxtopt)) =\\
%     \qquad (\heap, (\lab, \env[x \mapsto \sem{\op}(x_1, \cdots, x_n)], \ctxtopt)) \\
%     \\
% 
%     \sem{x = x \kwrl x^* \kwrr}(\heap, (\lab, \env, \ctxtopt)) =\\
%     \qquad \todo \\
%     \\
% 
%     \sem{x = \kwcl \kwcr}(\heap, (\lab, \env, \ctxtopt)) =\\
%     \qquad \todo \\
%     \\
% 
%     \sem{x = x \kwsl x \kwsr}(\heap, (\lab, \env, \ctxtopt)) =\\
%     \qquad \todo \\
%     \\
% 
%     \sem{x \kwsl x \kwsr = x}(\heap, (\lab, \env, \ctxtopt)) =\\
%     \qquad \todo \\
%     \\
% 
%     \sem{\kwif \; x \; \lab \; \lab}(\heap, (\lab, \env, \ctxtopt)) =\\
%     \qquad \todo \\
%     \\
% 
%     \sem{\kwret \; x}(\heap, (\lab, \env, \ctxtopt)) =\\
%     \qquad \todo \\
% 
%   \end{array}
% \]

\subsubsection{Concrete Semantics of Expressions}

\[
  \framebox{$\sem{\expr}: \stset \rightarrow \stset \times \valset$}
\]

\todo



\subsubsection{Concrete Semantics of References}

\[
  \framebox{$\sem{\refer}: \stset \rightarrow \stset \times \valset$}
\]

\todo





\subsection{Function Specialization}

\todo

A function specialization is defined with the following three components:
\begin{itemize}
  \item Restriction $\restrictset$
  \item Concretization $\gamma: \restrictset \rightarrow \powerset{\stset
    \times \valset^*}$
  \item Transformation $\trans: \restrictset \rightarrow \funcset \rightarrow
    \funcset$.
\end{itemize}

\todo



\subsubsection{Constant Propagation Specialization}
\begin{itemize}
  \item Restriction $\cprestrictset = (\valoptset)^* =
    (\valset \uplus \{ \top \})^*$
  \item Concretization $\cpgamma: (\valoptset)^* \rightarrow \powerset{\stset
    \times \valset^*}$ s.t.
    \[
      \cpgamma(\valopt_1, \cdots, \valopt_n) = \stset \times (V_1 \times \cdots
      \times V_n)
    \]
    where $V_i = \left\{
      \begin{array}{ll}
        \valset & \text{if} \; \valopt_i = \top\\
        \{ \valopt_i \} & \text{otherwise}\\
      \end{array}
    \right.$
  \item Transformation $\cptrans: (\valoptset)^* \rightarrow \funcset
    \rightarrow \funcset$
\end{itemize}
In the constant propagation specialization, a restriction is a sequences of
static values $\valset$ or a dynamic value $\top$.

\[
  \begin{array}{lr@{~}c@{~}l@{~}c@{~}l}
    \text{Symbolic Environments} & \senv &\in& \senvset &=&
    \varset \finmap \svalset\\
    \text{Symbolic Values} & \sval &\in& \svalset &=&
    \valoptset \times \exprset\\
  \end{array}
\]

\[
  \framebox{$\cptranse: \exprset \times \senvset \rightarrow \svalset$}
\]

\[
  \begin{array}{lcl}
    \cptranse(\pval, \env) &=& \pval\\
    \cptranse(\op \kwrl \expr^* \kwrr, \env) &=& \todo\\
    \cptranse(\kwcl \kwcr, \env) &=& \todo\\
    \cptranse(\refer, \env) &=& \todo\\
  \end{array}
\]

\[
  \framebox{$\cptransi: \instset \times \senvset \rightarrow \instset \times
  \senvset$}
\]

\todo

\[
  \framebox{$\cptrans: (\valoptset)^* \rightarrow \funcset \rightarrow
  \funcset$}
\]

\todo





% \subsubsection{Redundancy Elimination Transformation}
% 
% \[
%   \begin{array}{lr@{~}c@{~}l}
%     \text{Restrictions} &\{ \top \}\\
%     \text{Concretization} & \gamma(\top) &=& \stset \times \valset^*\\
%   \end{array}
% \]
% 
% The redundancy elimination transformation is defined without any restriction,
% which means its restriction set consists of a single element $\top$
% representing all possible cases.  Therefore, we omit the restriction part in
% this transformation for the brevity.
% 
% \[
%   \framebox{$\transref: \funcset \rightarrow \funcset$}
% \]
% 
% \todo








\subsection{Proof of Semantics Preservation}

\todo

\subsubsection{Observational Semantics}

\todo





\subsection{JavaScript Semantics Specialization}

\todo

\subsubsection{Syntatic Views}

\todo

\subsubsection{Specialization with Syntatic Views}

\todo

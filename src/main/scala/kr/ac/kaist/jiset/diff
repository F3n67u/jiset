diff --git a/src/main/scala/kr/ac/kaist/jiset/analyzer/AbsSemantics.scala b/src/main/scala/kr/ac/kaist/jiset/analyzer/AbsSemantics.scala
index 2926bb039..601c4b1ba 100644
--- a/src/main/scala/kr/ac/kaist/jiset/analyzer/AbsSemantics.scala
+++ b/src/main/scala/kr/ac/kaist/jiset/analyzer/AbsSemantics.scala
@@ -1,30 +1,23 @@
 package kr.ac.kaist.jiset.analyzer
 
 import kr.ac.kaist.jiset.LINE_SEP
+import kr.ac.kaist.jiset.cfg._
 import kr.ac.kaist.jiset.analyzer.domain._
 import kr.ac.kaist.jiset.analyzer.domain.Beautifier._
 
 class AbsSemantics {
-  // internal view-wise abstract states
-  private var map: Map[View, AbsState] = Map()
+  // internal map from control points to abstract states
+  private var cpMap: Map[Node, Map[View, AbsState]] = Map()
 
   // lookup
-  def apply(view: View): AbsState = map.getOrElse(view, AbsState.Bot)
-
-  // update view-wise abstract states
-  def +=(pair: (View, AbsState)): Unit = map += pair
-
-  // return edges
-  private var returnMap: Map[View, List[View]] = Map()
-
-  // lookup return edges
-  def getRetEdges(view: View): List[View] = returnMap.getOrElse(view, Nil)
-
-  // update return edges
-  def /=(pair: (View, List[View])): Unit = returnMap += pair
-
-  // conversion to string
-  override def toString: String = map.map {
-    case (view, st) => s"$view -> ${beautify(st)}"
-  }.mkString(LINE_SEP)
+  def apply(node: Node): Map[View, AbsState] =
+    cpMap.getOrElse(node, Map())
+  def apply(cp: ControlPoint): AbsState =
+    this(cp.node).getOrElse(cp.view, AbsState.Bot)
+
+  // update internal map
+  def +=(pair: (ControlPoint, AbsState)): Unit = {
+    val (ControlPoint(node, view), st) = pair
+    cpMap += node -> (this(node) + (view -> st))
+  }
 }
diff --git a/src/main/scala/kr/ac/kaist/jiset/analyzer/AbsTransfer.scala b/src/main/scala/kr/ac/kaist/jiset/analyzer/AbsTransfer.scala
index a1bc4c3d0..d28aac158 100644
--- a/src/main/scala/kr/ac/kaist/jiset/analyzer/AbsTransfer.scala
+++ b/src/main/scala/kr/ac/kaist/jiset/analyzer/AbsTransfer.scala
@@ -5,97 +5,97 @@ import kr.ac.kaist.jiset.cfg._
 import domain._
 
 // abstract transfer function
-class AbsTransfer(
-  cfg: CFG,
-  sem: AbsSemantics
-) {
-  // transfer function for control points
-  def apply(st: AbsState, cp: ControlPoint): List[Result[ControlPoint]] = {
-    val ControlPoint(node, view) = cp
-    val cur = Result(node, st)
-    for {
-      next <- apply(cur)
-      nextView = view.next(cur, next)
-      cp = ControlPoint(next.elem, nextView)
-    } yield Result(cp, next.st)
+object AbsTransfer {
+  def apply(cp: ControlPoint, st: AbsState)(
+    implicit
+    cfg: CFG,
+    sem: AbsSemantics
+  ): List[(ControlPoint, AbsState)] = {
+    val aux = new Aux(cp, st, cfg, sem)
+    (aux.next, aux.ret)
   }
 
-  // transfer function for nodes
-  def apply(result: Result[Node]): List[Result[Node]] = apply(result.st, result.elem)
-  def apply(st: AbsState, node: Node): List[Result[Node]] = node match {
-    case Entry() => cfg.nextNodes(node).toList.map(Result(_, st))
-    case Exit() => Nil // TODO handle inter-procedural cases
-    case Block(insts) =>
-      val nextSt = insts.foldLeft(st)(apply)
-      val nexts =
-        if (nextSt.isBottom) Nil
-        else cfg.nextNodes(node).toList.map(Result(_, nextSt))
-      handleReturn(node, nexts)
-    case Call(inst) => ???
-    case branch @ Branch(expr) => ???
-  }
+  private class Aux(
+    cp: ControlPoint,
+    st: AbsState,
+    cfg: CFG,
+    sem: AbsSemantics
+  ) {
+    lazy val (next, ret) = {
+      val next: List[(ControlPoint, AbsState)] = cp.node match {
+        case (entry: Entry) =>
+          cfg.next(entry).map(ControlPoint(_, view) -> st)
+        case (exit: Exit) => Nil // TODO handle inter-procedural cases
+        case block @ Block(insts) =>
+          val nextSt = insts.foldLeft(st)(apply)
+          if (nextSt.isBottom) Nil
+          else cfg.next(block).map(ControlPoint(_, view) -> nextSt)
+        case call @ Call(inst) => ???
+        case branch @ Branch(expr) => ???
+      }
+      val ret: (AbsState, AbsValue) = (retSt, retVal)
+      (next, ret)
+    }
+
+    // return states handler
+    private var retSt: AbsState = AbsState.Bot
+    private var retVal: AbsValue = AbsAbsent.Top
+
+    // next control points with abstract states
+    lazy val next: List[(ControlPoint, AbsState)] = 
 
-  // handle return
-  private var retSt: AbsState = AbsState.Bot
-  def handleReturn(node: Node, list: List[Result[Node]]): List[Result[Node]] =
-    if (retSt.isBottom) list else {
-      val result = Result(node.func.exit, retSt)
-      val newNexts = result :: list
-      retSt = AbsState.Bot
-      newNexts
+    // transfer function for instructions
+    private def apply(st: AbsState, inst: NormalInst): AbsState = inst match {
+      case IExpr(expr) => ???
+      case ILet(id, expr) => ???
+      case IAssign(ref, expr) => ???
+      case IDelete(ref) => ???
+      case IAppend(expr, list) => ???
+      case IPrepend(expr, list) => ???
+      case IReturn(expr) =>
+        val (s0, v) = apply(st, expr)
+        retSt ⊔= s0.doReturn(v)
+        AbsState.Bot
+      case IThrow(id) => ???
+      case IAssert(expr) => ???
+      case IPrint(expr) => ???
+      case IWithCont(id, params, bodyInst) => ???
+      case ISetType(expr, ty) => ???
     }
 
-  // transfer function for instructions
-  def apply(st: AbsState, inst: NormalInst): AbsState = inst match {
-    case IExpr(expr) => ???
-    case ILet(id, expr) => ???
-    case IAssign(ref, expr) => ???
-    case IDelete(ref) => ???
-    case IAppend(expr, list) => ???
-    case IPrepend(expr, list) => ???
-    case IReturn(expr) =>
-      val (s0, v) = apply(st, expr)
-      retSt ⊔= s0.doReturn(v)
-      AbsState.Bot
-    case IThrow(id) => ???
-    case IAssert(expr) => ???
-    case IPrint(expr) => ???
-    case IWithCont(id, params, bodyInst) => ???
-    case ISetType(expr, ty) => ???
-  }
+    // transfer function for expressions
+    private def apply(st: AbsState, expr: Expr): (AbsState, AbsValue) = expr match {
+      case ENum(n) => (st, AbsNum(n))
+      case EINum(n) => (st, AbsINum(n))
+      case EBigINum(b) => (st, AbsBigINum(b))
+      case EStr(str) => (st, AbsStr(str))
+      case EBool(b) => (st, AbsBool(b))
+      case EUndef => (st, AbsUndef.Top)
+      case ENull => (st, AbsNull.Top)
+      case EAbsent => (st, AbsAbsent.Top)
+      case EMap(ty, props) => ???
+      case EList(exprs) => ???
+      case ESymbol(desc) => ???
+      case EPop(list, idx) => ???
+      case ERef(ref) => ???
+      case ECont(params, body) => ???
+      case EUOp(uop, expr) => ???
+      case EBOp(bop, left, right) => ???
+      case ETypeOf(expr) => ???
+      case EIsCompletion(expr) => ???
+      case EIsInstanceOf(base, name) => ???
+      case EGetElems(base, name) => ???
+      case EGetSyntax(base) => ???
+      case EParseSyntax(code, rule, flags) => ???
+      case EConvert(source, target, flags) => ???
+      case EContains(list, elem) => ???
+      case EReturnIfAbrupt(expr, check) => ???
+      case ECopy(obj) => ???
+      case EKeys(mobj) => ???
+      case ENotSupported(msg) => ???
+    }
 
-  // transfer function for expressions
-  def apply(st: AbsState, expr: Expr): (AbsState, AbsValue) = expr match {
-    case ENum(n) => (st, AbsNum(n))
-    case EINum(n) => (st, AbsINum(n))
-    case EBigINum(b) => (st, AbsBigINum(b))
-    case EStr(str) => (st, AbsStr(str))
-    case EBool(b) => (st, AbsBool(b))
-    case EUndef => (st, AbsUndef.Top)
-    case ENull => (st, AbsNull.Top)
-    case EAbsent => (st, AbsAbsent.Top)
-    case EMap(ty, props) => ???
-    case EList(exprs) => ???
-    case ESymbol(desc) => ???
-    case EPop(list, idx) => ???
-    case ERef(ref) => ???
-    case ECont(params, body) => ???
-    case EUOp(uop, expr) => ???
-    case EBOp(bop, left, right) => ???
-    case ETypeOf(expr) => ???
-    case EIsCompletion(expr) => ???
-    case EIsInstanceOf(base, name) => ???
-    case EGetElems(base, name) => ???
-    case EGetSyntax(base) => ???
-    case EParseSyntax(code, rule, flags) => ???
-    case EConvert(source, target, flags) => ???
-    case EContains(list, elem) => ???
-    case EReturnIfAbrupt(expr, check) => ???
-    case ECopy(obj) => ???
-    case EKeys(mobj) => ???
-    case ENotSupported(msg) => ???
+    // pruning abstract states using conditions
+    private def prune(st: AbsState, expr: Expr, cond: Boolean): AbsState = ???
   }
-
-  // pruning abstract states using conditions
-  def prune(st: AbsState, expr: Expr, cond: Boolean): AbsState = ???
 }
diff --git a/src/main/scala/kr/ac/kaist/jiset/analyzer/ControlPoint.scala b/src/main/scala/kr/ac/kaist/jiset/analyzer/ControlPoint.scala
index 005ef0094..5c1e49f67 100644
--- a/src/main/scala/kr/ac/kaist/jiset/analyzer/ControlPoint.scala
+++ b/src/main/scala/kr/ac/kaist/jiset/analyzer/ControlPoint.scala
@@ -5,3 +5,12 @@ import domain._
 
 // control points
 case class ControlPoint(node: Node, view: View)
+
+// parameter type sensitive view
+case class View(tys: List[Type]) {
+  // conversion to string
+  override def toString: String = tys.mkString("[", ", ", "]")
+}
+object View {
+  def apply(seq: Type*): View = View(seq.toList)
+}
diff --git a/src/main/scala/kr/ac/kaist/jiset/analyzer/Fixpoint.scala b/src/main/scala/kr/ac/kaist/jiset/analyzer/Fixpoint.scala
index fbb38e792..e54f427c7 100644
--- a/src/main/scala/kr/ac/kaist/jiset/analyzer/Fixpoint.scala
+++ b/src/main/scala/kr/ac/kaist/jiset/analyzer/Fixpoint.scala
@@ -3,42 +3,37 @@ package kr.ac.kaist.jiset.analyzer
 import kr.ac.kaist.jiset.cfg.CFG
 import kr.ac.kaist.jiset.spec.algorithm._
 
-class Fixpoint(
-  cfg: CFG,
-  worklist: Worklist[ControlPoint],
-  sem: AbsSemantics
-) {
+class Fixpoint(cfg: CFG) {
+  // worklist for control points
+  val worklist = new StackWorklist[ControlPoint]
+
   // initial worklist
   cfg.allFunctions.foreach(func => func.algo.head match {
     case (head: SyntaxDirectedHead) if head.withParams.isEmpty =>
       val entry = func.entry
       Initialize(head).foreach {
         case (types, st) =>
-          val view = View(entry, types)
+          val view = View(types)
           val cp = ControlPoint(entry, view)
-          sem += view -> st
-          worklist.push(cp)
+          sem += cp -> st
+          worklist += cp
       }
     case _ =>
   })
 
-  // abstract transfer function
-  val transfer = new AbsTransfer(cfg, sem)
-
   // fixpoint computation
   def compute: Unit = while (!worklist.isEmpty) step
 
   // abstract one-step execution using worklist
   def step: Unit = {
     val cp = worklist.pop
-    val st = sem(cp.view)
-    transfer(st, cp).foreach {
-      case Result(cp, newSt) =>
-        val view = cp.view
-        val oldSt = sem(view)
-        if (!(newSt ⊑ oldSt)) {
-          sem += view -> (oldSt ⊔ newSt)
-          worklist.push(cp)
+    val st = sem(cp)
+    AbsTransfer(cp, st).foreach {
+      case (nextCP, nextSt) =>
+        val oldSt = sem(nextCP)
+        if (!(nextSt ⊑ oldSt)) {
+          sem += nextCP -> (oldSt ⊔ nextSt)
+          worklist += nextCP
         }
     }
   }
diff --git a/src/main/scala/kr/ac/kaist/jiset/analyzer/Result.scala b/src/main/scala/kr/ac/kaist/jiset/analyzer/Result.scala
deleted file mode 100644
index c8be5b4c2..000000000
--- a/src/main/scala/kr/ac/kaist/jiset/analyzer/Result.scala
+++ /dev/null
@@ -1,7 +0,0 @@
-package kr.ac.kaist.jiset.analyzer
-
-import domain.AbsState
-
-case class Result[+T](elem: T, st: AbsState) {
-  def toPair: (T, AbsState) = (elem, st)
-}
diff --git a/src/main/scala/kr/ac/kaist/jiset/analyzer/View.scala b/src/main/scala/kr/ac/kaist/jiset/analyzer/View.scala
deleted file mode 100644
index 42d72a561..000000000
--- a/src/main/scala/kr/ac/kaist/jiset/analyzer/View.scala
+++ /dev/null
@@ -1,45 +0,0 @@
-package kr.ac.kaist.jiset.analyzer
-
-import kr.ac.kaist.jiset.cfg._
-import domain._
-
-// view abstraction
-trait View {
-  // find next views and refined abstract states
-  def next(cur: Result[Node], next: Result[Node]): View = this match {
-    case MultiView(list) => MultiView(list.map(_.next(cur, next)))
-    case FlowView(_) => FlowView(next.elem)
-    case ParamTypeView(_) => next.elem match {
-      case (entry: Entry) => ???
-      case _ => this
-    }
-  }
-
-  // conversion to string
-  override def toString: String = (this match {
-    case MultiView(list) => list.mkString("x")
-    case FlowView(node) => s"$node"
-    case ParamTypeView(types) => types.mkString("[", ", ", "]")
-  })
-}
-object View {
-  val Nil = MultiView()
-  def apply(seq: View*): MultiView = MultiView(seq.toList)
-  implicit def node2view(node: Node) = FlowView(node)
-  implicit def types2view(tys: List[Type]) = ParamTypeView(tys)
-}
-
-// multiple view
-case class MultiView(list: List[View]) extends View {
-  // view production
-  def ::[W <: View](view: View): MultiView = MultiView(view :: list)
-}
-object MultiView {
-  def apply(seq: View*): MultiView = MultiView(seq.toList)
-}
-
-// flow sensitive view
-case class FlowView(node: Node) extends View
-
-// parameter type sensitive view
-case class ParamTypeView(tys: List[Type]) extends View
diff --git a/src/main/scala/kr/ac/kaist/jiset/analyzer/Worklist.scala b/src/main/scala/kr/ac/kaist/jiset/analyzer/Worklist.scala
index 9a2042dc4..7a5bb1f95 100644
--- a/src/main/scala/kr/ac/kaist/jiset/analyzer/Worklist.scala
+++ b/src/main/scala/kr/ac/kaist/jiset/analyzer/Worklist.scala
@@ -4,10 +4,9 @@ import scala.collection.mutable.{ Stack, Queue }
 
 // worklist
 trait Worklist[T] {
-  def push(x: T): Unit
+  def +=(x: T): Unit
   def isEmpty: Boolean
-  def pop: T
-  def head: T
+  def pop: Option[T]
   def has(x: T): Boolean
 }
 
@@ -15,20 +14,34 @@ trait Worklist[T] {
 class StackWorklist[T] extends Worklist[T] {
   private var set: Set[T] = Set()
   private var stack: Stack[T] = Stack()
-  def push(x: T): Unit = if (!set.contains(x)) { stack.push(x); set += x; }
-  def isEmpty: Boolean = stack.isEmpty
-  def pop: T = { val x = stack.pop; set -= x; x }
-  def head: T = stack.head
-  def has(x: T): Boolean = set.contains(x)
+  def +=(x: T): Unit = if (!set.contains(x)) {
+    stack.push(x)
+    set += x
+  }
+  def isEmpty: Boolean = set.isEmpty
+  def pop: Option[T] = if (isEmpty) None else {
+    val x = stack.pop
+    set -= x
+    Some(x)
+  }
+  def head: T = stack.headOption
+  def has(x: T): Boolean = set contains x
 }
 
 // queue-based worklist
 class QueueWorklist[T] extends Worklist[T] {
   private var set: Set[T] = Set()
   private var queue: Queue[T] = Queue()
-  def push(x: T): Unit = if (!set.contains(x)) { queue.enqueue(x); set += x; }
-  def isEmpty: Boolean = queue.isEmpty
-  def pop: T = { val x = queue.dequeue; set -= x; x }
-  def head: T = queue.head
+  def +=(x: T): Unit = if (!set.contains(x)) {
+    queue.enqueue(x)
+    set += x
+  }
+  def isEmpty: Boolean = set.isEmpty
+  def pop: Option[T] = if (isEmpty) None else {
+    val x = queue.dequeue
+    set -= x
+    Some(x)
+  }
+  def head: T = queue.headOption
   def has(x: T): Boolean = set.contains(x)
 }
diff --git a/src/main/scala/kr/ac/kaist/jiset/analyzer/domain/state/BasicDomain.scala b/src/main/scala/kr/ac/kaist/jiset/analyzer/domain/state/BasicDomain.scala
index 1e972cf90..8c27647f2 100644
--- a/src/main/scala/kr/ac/kaist/jiset/analyzer/domain/state/BasicDomain.scala
+++ b/src/main/scala/kr/ac/kaist/jiset/analyzer/domain/state/BasicDomain.scala
@@ -24,9 +24,13 @@ object BasicDomain extends state.Domain {
   ) extends ElemTrait {
     // partial order
     def ⊑(that: Elem): Boolean = (
-      this.env ⊑ that.env &&
-      this.heap ⊑ that.heap &&
-      this.retVal ⊑ that.retVal
+      (this eq that) ||
+      this.isBottom ||
+      !that.isBottom && (
+        this.env ⊑ that.env &&
+        this.heap ⊑ that.heap &&
+        this.retVal ⊑ that.retVal
+      )
     )
 
     // join operator
@@ -43,6 +47,9 @@ object BasicDomain extends state.Domain {
       this.retVal ⊓ that.retVal
     ).normalized
 
+    // bottom check
+    override def isBottom: Boolean = (this eq Bot) || (this == Bot)
+
     // concretization function
     def gamma: concrete.Set[State] = Infinite
 
diff --git a/src/main/scala/kr/ac/kaist/jiset/analyzer/domain/value/ProdDomain.scala b/src/main/scala/kr/ac/kaist/jiset/analyzer/domain/value/ProdDomain.scala
index 28e93f064..fee34c89b 100644
--- a/src/main/scala/kr/ac/kaist/jiset/analyzer/domain/value/ProdDomain.scala
+++ b/src/main/scala/kr/ac/kaist/jiset/analyzer/domain/value/ProdDomain.scala
@@ -85,5 +85,13 @@ object ProdDomain extends value.Domain {
       this.ast.getSingle ++
       this.prim.getSingle
     )
+
+    // abstract equality
+    def =^=(that: Elem): AbsBool =
+      (this.getSingle, that.getSingle) match {
+        case (Zero, _) | (_, Zero) => AbsBool.Bot
+        case (One(x), One(y)) => AbsBool(x == y)
+        case _ => AbsBool.Top
+      }
   }
 }
diff --git a/src/main/scala/kr/ac/kaist/jiset/cfg/CFG.scala b/src/main/scala/kr/ac/kaist/jiset/cfg/CFG.scala
index 065ec6181..c540d7be8 100644
--- a/src/main/scala/kr/ac/kaist/jiset/cfg/CFG.scala
+++ b/src/main/scala/kr/ac/kaist/jiset/cfg/CFG.scala
@@ -23,15 +23,13 @@ class CFG extends UId {
   def allFunctions: Set[Function] = funcs
   def allNodes: Set[Node] = nodes
 
-  // getters for forward edges
-  def next(node: Node): Set[(Edge, Node)] = forwards.getOrElse(node, Set())
-  def nextNode(branch: Branch, cond: Boolean): Node =
-    next(branch).find(_._1 == CondEdge(cond)).get._2
-  def nextNodes(node: Node): Set[Node] = next(node).map(_._2)
+  // getters for forward nodes
+  def next(node: Node): List[Node] =
+    forwards.getOrElse(node, Set()).map(_._2).toList
 
-  // getters for backward edges
-  def prev(node: Node): Set[(Edge, Node)] = backwards.getOrElse(node, Set())
-  def prevNodes(node: Node): Set[Node] = prev(node).map(_._2)
+  // getters for backward nodes
+  def prev(node: Node): List[Node] =
+    backwards.getOrElse(node, Set()).map(_._2).toList
 }
 object CFG {
   def apply(spec: ECMAScript): CFG = {
diff --git a/src/main/scala/kr/ac/kaist/jiset/phase/Analyze.scala b/src/main/scala/kr/ac/kaist/jiset/phase/Analyze.scala
index f67f17b1e..e4637b3b5 100644
--- a/src/main/scala/kr/ac/kaist/jiset/phase/Analyze.scala
+++ b/src/main/scala/kr/ac/kaist/jiset/phase/Analyze.scala
@@ -17,12 +17,10 @@ case object Analyze extends PhaseObj[ECMAScript, AnalyzeConfig, AbsSemantics] {
   ): AbsSemantics = {
     println(s"--------------------------------------------------")
     println(s"analyzing specification...")
-    val cfg = CFG(spec)
-    val worklist = new StackWorklist[ControlPoint]
-    val sem = new AbsSemantics
-    val fixpoint = new Fixpoint(cfg, worklist, sem)
+    implicit val cfg = CFG(spec)
+    implicit val sem = new AbsSemantics
+    val fixpoint = new Fixpoint
     fixpoint.compute
-    println(sem)
     sem
   }
 
diff --git a/src/main/scala/kr/ac/kaist/jiset/phase/Parse.scala b/src/main/scala/kr/ac/kaist/jiset/phase/Parse.scala
index 3c0ac255a..a05fb6adc 100644
--- a/src/main/scala/kr/ac/kaist/jiset/phase/Parse.scala
+++ b/src/main/scala/kr/ac/kaist/jiset/phase/Parse.scala
@@ -19,7 +19,9 @@ case object Parse extends PhaseObj[Unit, ParseConfig, ECMAScript] {
   ): ECMAScript = {
     println(s"--------------------------------------------------")
     val spec = config.load match {
-      case Some(filename) => readJson[ECMAScript](filename)
+      case Some(filename) =>
+        println(s"loading ECMAScript from $filename...")
+        readJson[ECMAScript](filename)
       case None =>
         val version = config.version.getOrElse("recent")
         val query = config.query.getOrElse("")
diff --git a/src/main/scala/kr/ac/kaist/jiset/spec/ECMAScript.scala b/src/main/scala/kr/ac/kaist/jiset/spec/ECMAScript.scala
index 108e092fa..df5eabe32 100644
--- a/src/main/scala/kr/ac/kaist/jiset/spec/ECMAScript.scala
+++ b/src/main/scala/kr/ac/kaist/jiset/spec/ECMAScript.scala
@@ -29,8 +29,12 @@ case class ECMAScript(
   )
 
   // target algorithms
+  val names = Set(
+    "Literal[0,0].Evaluation",
+  // TODO "Literal[1,0].Evaluation",
+  )
   def targetAlgos: List[Algo] =
-    algos.filter(_.name == "Literal[0,0].Evaluation")
+    algos.filter(names contains _.name)
 
   // arity counter of algorithms
   lazy val arities: Map[String, (InfNum, InfNum)] =

\documentclass[acmsmall,screen]{acmart}

\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{mathpartir}
\usepackage{verbatim}
\usepackage{hyperref}
\usepackage{xspace}
\usepackage{stmaryrd}
\usepackage{tikz}
\usepackage{dirtree}
\usepackage{multicol}
\usepackage{array}

\usetikzlibrary{arrows}
\tikzset{
  treenode/.style = {align=center, inner sep=0pt, text centered},
  arn_n/.style = {treenode, circle, black, draw=black, text width=1.5em},
}

\newcommand{\irnameb}[0]{\textbf{IR\textsubscript{ES}}\xspace}
\newcommand{\irname}[0]{IR\textsubscript{ES}\xspace}
\newcommand{\Acd}[1]{\mathsf{#1}}
\newcommand{\Cd}[1]{\texttt{#1}}
\newcommand{\primitive}[1]{ \Cd{#1}}
\newcommand{\uexpr}[2]{\primitive{#1} #2}
\newcommand{\ibexpr}[3]{#2 \primitive{#1} #3}
\newcommand{\prebexpr}[3]{\primitive{#1} #2 #3}
\newcommand{\postbexpr}[3]{#2 #3 \primitive{#1}}
\newcommand{\subsc}[2]{#1\textsubscript{#2}}


\begin{document}

% \title{\irname : Intermediate Representation for ECMAScript Specification}
% \maketitle

% This document explains abstract syntax and operational semantic of \irnameb.


\section{Abstract Syntax}

This section explains syntax of \irname.

% Domain
\[
\begin{array}{rrl}
n & \in & \textit{Real Number} \\
i & \in & \textit{Integer} \\
s & \in & \textit{String} \\
b & \in & \{\textit{true}, \textit{false}\} \\
r & \in & \textit{Reference} \\
id & \in & \textit{Id} \\
t & \in & \textit{Type} \\
\end{array}
\]

asdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasf
asdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasf
asdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasf
asdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasf
asdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasf
asdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasf
asdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasf
asdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasf
asdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasf
asdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasf
asdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasf
asdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasf
asdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasf
asdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasf
asdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasf
asdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasf
asdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasf
asdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasfasdfasf

% Abstract Syntax
\[
\begin{array}{rrrll}
\text{Program} & p & ::= & Inst;\ \dots ;\ Inst & \\
\\

\text{Instruction} & Inst & ::= & e & \text{(expression)} \\
&&|& \Cd{let}\ id\ =\ e & \text{(let)}\\
&&|& r := e & \text{(assign)}\\
&&|& \Cd{delete}\ e & \text{(delete)}\\
&&|& \Cd{append}\ e\ \to\ l & \text{(append)}\\
&&|& \Cd{prepend}\ e\ \to\ l & \text{(prepend)}\\
&&|& \Cd{return}\ e & \text{(return)}\\
&&|& \Cd{if}\ e\ \Cd{then}\ \subsc{Inst}{then}\
\Cd{else}\ \subsc{Inst}{else} & \text{(if-then-else)}\\
&&|& \Cd{while}\ e\ Inst & \text{(while)}\\
&&|& \{ Inst;\ \dots\ Inst;  \} & \text{(sequence)}\\
&&|& \Cd{assert}\ e & \text{(assert)}\\
&&|& \Cd{print}\ e & \text{(print)}\\
&&|& \Cd{app}\ id\ =\ (\subsc{e}{function}\ \subsc{e}{1}\ \dots\
\subsc{e}{n}) & \text{(function application)}\\
&&|& \Cd{access}\ id\ =\ (\subsc{e}{cond}\ e) & \text{(access)}\\
&&|& \Cd{withcont}\ id\ (\subsc{id}{1},\ \dots,\ \subsc{id}{n})\ =\ Inst
& \text{(continuation)}\\ 
\\
\end{array}
\]

\[
\begin{array}{rrrll}
\text{Expression} & e & ::= & n & \text{(number)}\\
&&|& i & \text{(integer)}\\
&&|& s & \text{(string)}\\
&&|& b & \text{(boolean)}\\
&&|& r & \text{(reference)}\\
&&|& l & \text{(list)}\\
&&|& m & \text{(map)}\\
&&|& \primitive{"undefined"} & \text{(undefined)}\\
&&|& \primitive{"null"} & \text{(null)}\\
&&|& \primitive{"absent"} & \text{(absent)}\\
&&|& (\Cd{"new"}\ s) & \text{(symbol)}\\ % ESymbol
&&|& \Cd{"pop"}\ l\ i & \text{(pop)}\\
&&|& \Cd{"typeof"}\ e& \text{(typeof)}\\
&&|& \Cd{"is-instance-of"}\ e\ s& \text{(is-instance-of)}\\
&&|& \Cd{"get-elems"}\ e\ s& \text{(get-elements)}\\
&&|& \Cd{"get-syntax"}\ e& \text{(get-syntax)}\\
&&|& \Cd{"parse-syntax"}\ \subsc{e}{code}\ \subsc{e}{rule}\ 
\subsc{l}{flags}& \text{(parse-syntax)}\\
&&|& \Cd{"convert"}\ e\ \Longrightarrow \ \subsc{l}{flags}& \text{(convert)}\\
&&|& \Cd{"contains"}\ l\ e& \text{(contains)}\\
&&|& \Cd{"copy-obj"}\ e& \text{(copy-object)}\\
&&|& \Cd{"map-keys"}\ m& \text{(map-keys)}\\
&&|& \Cd{"!!!"}\ s& \text{(not supported)}\\
&&|& \odot\ e& \text{(unary operator)}\\ %Uop
&&|& \subsc{e}{1}\ \oplus\ \subsc{e}{2}& \text{(binary operator)}\\ %Bop
&&|& (\subsc{id}{1},\ \dots,\ \subsc{id}{n})\ [\Rightarrow]\ Inst
& \text{(continuation)}\\ %Cont\\
\\

& l & ::= & (\Cd{"new"}\ [\subsc{e}{1},\dots,\subsc{e}{n}]\ )
& \text{(list)}\\
\\

& m & ::= & (\Cd{"new"}\ t\
(\subsc{e}{\subsc{k}{1}}\ \to \subsc{e}{\subsc{v}{1}}, \dots
, \subsc{e}{\subsc{k}{n}}\ \to\ \subsc{e}{\subsc{v}{n}}))
& \text{(map)}\\
\\

\text{Value} & v & ::= & value & \text{(value)}\\
\\
\end{array}
\]

\begin{figure}[t]
\[
\begin{array}{rrrll}
\text{UnaryOperator}& \odot & ::= & - & \text{(negation)}\\
&&|& ! & \text{(boolean not)}\\
&&|& ~ & \text{(bitwise not)}\\
\\

\text{BinaryOperator}& \oplus & ::= & + & \text{(addition)}\\
&&|& - & \text{(subtraction)}\\
&&|& * & \text{(multiplication)}\\
&&|& ** & \text{(power)}\\
&&|& / & \text{(division)}\\
&&|& \%\% & \text{(unsigned modulo?)}\\
&&|& \% & \text{(modulo)}\\
&&|& = & \text{(equals)}\\
&&|& \&\& & \text{(boolean and)}\\
&&|& || & \text{(boolean or)}\\
&&|& \^{e}\^{e} & \text{(boolean xor)}\\
&&|& \& & \text{(bitwise and)}\\
&&|& | & \text{(bitwise or)}\\
&&|& \^{e} & \text{(bitwise xor)}\\
&&|& \ll & \text{(shift left)}\\
&&|& < & \text{(less-then)}\\
&&|& \ggg & \text{(unsigned shift right)}\\
&&|& \gg & \text{(shift right)}\\
\\

\text{ConvertOperator} & \Longrightarrow
& ::= & \primitive{"str2num"}& \text{(string to number)}\\
&&|& \primitive{"num2str"} & \text{(number to string)}\\
&&|& \primitive{"num2int"} & \text{(number to integer)}\\
\\
\end{array}
\]
\caption{Operator of \irname}
\label{fig:op}
\end{figure}

% &&|& \uexpr{NotSupported}{s} & \text{(not supported)}\\
% &&|& \uexpr{UnaryOp}{e} & \text{(unary operation)}\\
% &&|& \prebexpr{Pop}{l}{i} & \text{(pop)}\\
% &&|& \ibexpr{IsInstanceOf}{e}{s} & \text{(is instance of)} \\
% &&|& \ibexpr{GetElement}{e}{s} & \text{(get element)}\\
% &&|& \ibexpr{Contains}{l}{e} & \text{(contains)}\\
% &&|& \prebexpr{BinaryOp}{e1}{e2} & \text{(binary operation)}\\
% &&|& \prebexpr{ConvertOp}{e}{l} & \text{(convert)}\\
% &&|& \prebexpr{ParseSyntax}{e1}{e2} l & \text{(parse syntax)}\\
% \\

% \text{ListExpression} & l & ::= & \Acd{Nil} & \text{(nil)}\\
% &&|& e :: l & \text{(cons)}\\
% \\

% \text{MapExpression} & m & ::= & \Acd{Nil} & \text{(nil)}\\
% &&|& e :: l & \text{(cons)}\\
% \\
% Figure~\ref{fig:domain}, Figure~\ref{fig:expr}, Figure~\ref{fig:op}
% describes the abstract syntax of \irname.

% \section{Operational Semantic}

\end{document}
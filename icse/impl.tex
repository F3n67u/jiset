\section{Implementation}\label{sec:impl}

In this section, we demonstrate the implementation detail of \( \tool \).
We target to extract JavaScript syntax and semantics from
ECMAScript 2020 specification. It is the next ECMAScript version
that is actively updated in GitHub repository~\cite{es2020}
to be released in the next year. Moreover, Ecma Technical Committee 39 (TC39)
officially provides the conformance test suite, test262, for ECMAScript 2020.

\subsection{Excluded Language Features}
We decide to not support several language features in ECMAScript 2020:

\paragraph{No-Strict Mode}
Since ECMAScript 5, JavaScript introduced strict mode to \textit{intentianally} provide
slightly different semantics. It provides more stable semantics by preventing
unsafe actions or throwing originally ignored errors.
However, ECMAScript specification says:
``Strict mode does not restrict or modify any aspect of the ECMAScript semantics
that must operate consistently across multiple source text units.''
Thus, we decide to only support strict mode JavaScript to reduce the labors.

\paragraph{Intricate Built-ins}
JavaScript provides various built-in object to support helper functions in standard.
However, several built-in libraries are orthogonal but labor-intensive
to be manually modeled. Thus, we decide to not support
four orgothonoal libraries; \( \code{Math} \), \( \code{Date} \),
\( \code{RegExp} \), and \( \code{JSON} \).

\paragraph{Modules}
Moreover, we also do not support modules introduced since ES6 (ECMAScript 2015).
With the \( \code{import} \) keyword, a JavaScript program
imports other JavaScript components defined with the \( \code{export} \)
keyword in modules. In order to support modules in semantics, we should
model the functionality to communicate with file system to access
JavaScript module files. However, modules do not critically affect
the overall semantics. Thus, we decide to not support modules.


\subsection{Comple Rules for ECMAScript}

\begin{table}
  \centering
  \[
    \begin{array}{c|r|r|r|r|r|r|r}
      \text{name}
      & \multicolumn{1}{c|}{\code{Stmt}}
      & \multicolumn{1}{c|}{\code{Expr}}
      & \multicolumn{1}{c|}{\code{Cond}}
      & \multicolumn{1}{c|}{\code{Value}}
      & \multicolumn{1}{c|}{\code{Ty}}
      & \multicolumn{1}{c|}{\code{Ref}}
      & \multicolumn{1}{c}{\code{SecNo}}\\\hline
      \text{\# rules}
      & \inred{XX}
      & \inred{XX}
      & \inred{XX}
      & \inred{XX}
      & \inred{XX}
      & \inred{XX}
      & \inred{XX}\\\hline
    \end{array}
  \]
  \caption{The compile rules for ECMAScript specifications.}
  \label{table:rules}
\end{table}

The \textsf{Algorithm Compiler} requires compile rules to compile
given abstract algorithms into \( \ires \) functions.
We define compiler rules for ECMAScript specifications
and Table~\ref{table:rules} describes them.
The statement compile rule \( \code{Stmt} \) contains
\inred{XX} compile rules and generates \( \ires \) instructions.
The \( \code{Expr} \), \( \code{Cond} \), and \( \code{Value} \)
compile rules denote expressions, conditions, and values, respectively.
While all of them generates \( \ires \) expressions,
we discriminate them because they have different use cases.
The \( \code{Ty} \) denotes type names and generates
string primitives in \( \ires \). The \( \code{Ref} \)
represents the references including identifiers lookups or
member accesses of map-like structures. It generates
\( \ires \) reference expressions.
Finally, the Section number \( \code{SecNo} \) compile rule
represents sections numbers such as \( \code{9.4.1.1} \),
and it converts such numbers into the corresponding name strings
such as \( \code{"BoundFunctionObject.Call"} \).


\subsection{Global Setting}

We manually implemented \textsf{Global Setting} for ECMAScript 2020.
It consists of the structure of built-in objects and ECMAScript data types.

\subsubsection{ECMAScript Data Types}

In ECMAScript, the Section \textsf{6 ECMAScript Data Types and Values} describes
data types used in ECMAScript specifications. They not only represent
data types explicitely exposed into JavaScript evaluations, but also
represent all internal data types used in the specification.
For example, the Environement Records are record types from identifiers
into bindings for values. They are not explicitely accessed in JavaScript
programs but defined internally in the specification.

Each ECMAScript data type consists of several fields to store relevant values.
Thus, we should implement such structures to correctly evaluate JavaScript
programs. Moreover, some fields of ECMAScript data types might be
abstract algorithms. We call them as \textit{method-like abstract algorithms}
and they have implicitly get reciever object as an argument.
In order to mimic such implicit behaviors, we added a special variable
\( \code{this} \) as the first parameter. And we modify algorithm compiler
to detect cases and pass the receiver object into the method-like abstract
algorithms. For example, an Environement Record has the \textsf{DeleteBinding (N)}
abstract algorithm as one of its fields. Then, it has two parameters the special
parameter \( \code{this} \) and normal one \( \code{N} \).
The following algorithm step is compiled into the \( \ires \) instruction
\( \code{return DclRec.DeleteBinding(DclRec, N)} \).
\begin{center}
  \includegraphics[width=0.3\textwidth]{img/method-like-example.png}
\end{center}


\subsubsection{Built-in Objects}
In ECMAScript, built-in objects are pre-defined functions with several
built-in functions. For example, the array object \( \code{Array} \)
is the constructor of array objects, and its prototype property
\( \code{Array.prototype} \) has built-in functions for array objects.
For example, \( \code{[1,2,3].flat()} \) calls the
\( \code{Array.prototype.flat} \) built-in function with the array
\( \code{[1,2,3]} \). Built-in functions are also abstract algorithms
thus each of them is automatically converted into an \( \ires \) function.
However, the structured of built-in objects should be implemented manually.
Thus, we implement built-in objects in Scala and connect their properties
with the extracted \( \ires \) functions.

Some built-in objects are named as intrinsic objects when they are
are explicitly referenced in abstrat algorithms.
Intrinsic objects have their own names as aliases in the table
of the Section \textsf{6.1.7.4 Well-known Intrinsic Objects}.
Thus, we extract such alias information into \textsf{Global Setting}
to utilize it during evaluations.

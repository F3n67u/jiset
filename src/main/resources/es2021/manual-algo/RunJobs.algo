def RunJobs() = 0:{
  0:app __x0__ = (InitializeHostDefinedRealm)
  0:[? __x0__]
  3:app __x1__ = (EnqueueJob "ScriptJobs" ScriptEvaluationJob (new [SCRIPT_BODY, HOST_DEFINED]))
  6:while true 6:{
    7:if (= EXECUTION_STACK[(- EXECUTION_STACK.length 1i)] CONTEXT) 7:{
      7:let __x2__ = (- EXECUTION_STACK.length 1i)
      7:(pop EXECUTION_STACK __x2__)
      7:if (= EXECUTION_STACK.length 0i) 7:CONTEXT = null else 7:CONTEXT = EXECUTION_STACK[(- EXECUTION_STACK.length 1i)]
    } else 7:CONTEXT = null
    9:if (= JOB_QUEUE.length 0.0) 9:return undefined else 9:{}
    9:let nextQueue = JOB_QUEUE
    10:let nextPending = (pop nextQueue 0i)
    11:let newContext = (new ExecutionContext("SubMap" -> (new SubMap())))
    12:newContext.Function = null
    13:newContext.Realm = nextPending.Realm
    14:newContext.ScriptOrModule = nextPending.ScriptOrModule
    15:append newContext -> EXECUTION_STACK
    15:CONTEXT = EXECUTION_STACK[(- EXECUTION_STACK.length 1i)]
    17:let job = nextPending.Job
    17:let args = nextPending.Arguments
    17:if (= args absent) 17:app __x3__ = (job)
    else 17:if (= args.length 1i) 17:app __x3__ = (job args[0i])
    else 17:if (= args.length 2i) 17:app __x3__ = (job args[0i] args[1i])
    else 17:app __x3__ = (job args[0i] args[1i] args[2i])
    17:let result = __x3__
    18:app __x4__ = (IsAbruptCompletion result)
    18:if __x4__ 18:return result else 18:{}
  }
}
- id: ""
- code:
      1. Perform ? InitializeHostDefinedRealm().
      1. In an implementation-dependent manner, obtain the ECMAScript source texts (see clause <emu-xref href="#sec-ecmascript-language-source-code"></emu-xref>) and any associated host-defined values for zero or more ECMAScript scripts and/or ECMAScript modules. For each such _sourceText_ and _hostDefined_, do
        1. If _sourceText_ is the source code of a script, then
          1. Perform EnqueueJob(`"ScriptJobs"`, ScriptEvaluationJob, « _sourceText_, _hostDefined_ »).
        1. Else _sourceText_ is the source code of a module,
          1. Perform EnqueueJob(`"ScriptJobs"`, TopLevelModuleEvaluationJob, « _sourceText_, _hostDefined_ »).
      1. Repeat,
        1. Suspend the running execution context and remove it from the execution context stack.
        1. Assert: The execution context stack is now empty.
        1. Let _nextQueue_ be a non-empty Job Queue chosen in an implementation-defined manner. If all Job Queues are empty, the result is implementation-defined.
        1. Let _nextPending_ be the PendingJob record at the front of _nextQueue_. Remove that record from _nextQueue_.
        1. Let _newContext_ be a new execution context.
        1. Set _newContext_'s Function to *null*.
        1. Set _newContext_'s Realm to _nextPending_.[[Realm]].
        1. Set _newContext_'s ScriptOrModule to _nextPending_.[[ScriptOrModule]].
        1. Push _newContext_ onto the execution context stack; _newContext_ is now the running execution context.
        1. Perform any implementation or host environment defined job initialization using _nextPending_.
        1. Let _result_ be the result of performing the abstract operation named by _nextPending_.[[Job]] using the elements of _nextPending_.[[Arguments]] as its arguments.
        1. If _result_ is an abrupt completion, perform HostReportErrors(« _result_.[[Value]] »).

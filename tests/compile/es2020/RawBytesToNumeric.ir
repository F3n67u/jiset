{
  [0] ??? "Let id:{elementSize} be the Element Size value specified in link:{} for Element Type id:{type} ."
  [1] ??? "If id:{isLittleEndian} is value:{false} , reverse the order of the elements of id:{rawBytes} ."
  [2] if (= type CONST_Float32) {
    [3] ??? "Let id:{value} be the byte elements of id:{rawBytes} concatenated and interpreted as a little - endian bit string encoding of an IEEE 754 - 2019 binary32 value ."
    [4] ??? "If id:{value} is an IEEE 754 - 2019 binary32 NaN value , return the value:{NaN} Number value ."
    [5] app __x0__ = (WrapCompletion value)
    [5] return __x0__
  } else [0] {}
  [6] if (= type CONST_Float64) {
    [7] ??? "Let id:{value} be the byte elements of id:{rawBytes} concatenated and interpreted as a little - endian bit string encoding of an IEEE 754 - 2019 binary64 value ."
    [8] ??? "If id:{value} is an IEEE 754 - 2019 binary64 NaN value , return the value:{NaN} Number value ."
    [9] app __x1__ = (WrapCompletion value)
    [9] return __x1__
  } else [0] {}
  [12] app __x2__ = (IsUnsignedElementType type)
  [12] if (is-completion __x2__) if (= __x2__.Type CONST_normal) __x2__ = __x2__.Value else return __x2__ else [0] {}
  [12] if (= __x2__ true) ??? "Let id:{intValue} be the byte elements of id:{rawBytes} concatenated and interpreted as a bit string encoding of an unsigned little - endian binary number ." else ??? "Let id:{intValue} be the byte elements of id:{rawBytes} concatenated and interpreted as a bit string encoding of a binary little - endian 2 ' s complement number of bit length id:{elementSize} Ã— 8 ."
  [14] ??? "If ! IsBigIntElementType ( id:{type} ) is value:{true} , return the BigInt value that corresponds to id:{intValue} ."
  [15] ??? "Otherwise , return the Number value that corresponds to id:{intValue} ."
}
\section{Introduction}\label{sec:intro}

JavaScript is one of the most popular programming languages.  According to the
2020 State of the Octoverse\footnote{https://octoverse.github.com/},
the annual report of GitHub, the most dominating programming language in GitHub
repositories was JavaScript since 2014 to 2020.  While JavaScript was initially
designed for client-side programming in web browsers, it is now widely used in
server-side programming~\cite{nodejs} and even in embedded
systems~\cite{espruino, tessel2, moddable}.  Developers in diverse fields
build and maintain JavaScript engines conforming to ECMAScript, the
JavaScript standard specification, which describes the syntax and semantics of
JavaScript in a natural language.

The correctness of ECMAScript is critical because an incorrect
description in the specification can lead to wrong
implementations of JavaScript engines in various fields.  However,
all the specification updates are currently manually reviewed by the Ecma
Technical Committee 39 (TC39) without any automated tools.
Such a manual review process is inherently labor-intensive and error-prone,
making ECMAScript vulnerable to specification bugs.
Besides, in late 2014, the committee announced the yearly release cadence and open development
process of ECMAScript to quickly adapt to evolving development environments.
According to Park et al.~\cite{jiset}, the average number of updated steps of abstract
algorithms between consecutive releases from ECMAScript 2016 (ES7) to 2019 (ES10) is 9645.5.
In the official ECMAScript repository, 1,355 pull
requests and 2,005 commits exist in the master branch.
Therefore, manually checking all the frequent specification updates is
a challenging task.

Unfortunately, no existing tools can automatically detect bugs in
rapidly evolving JavaScript specifications written in English. Thus,
the ECMAScript committee has pursued various manual annotations in
abstract algorithms to reduce specification bugs.
First, the committee has introduced two kinds of annotations: 1)
\textit{assertions} to denote assumptions at specific points of abstract
algorithms and 2) two \textit{prefixes} \textbf{?} and \textbf{!} to
represent whether the execution of an abstract algorithm completes
abruptly or not. For example, ``Assert: Type(\textit{O}) is Object'' denotes that
the variable $\textit{O}$ always has an \jscode{Object} value at the
point of the assertion, and ``\textbf{?} \textbf{GetV}(\textit{V}, \textit{P})'' denotes that
the execution of \textbf{GetV}(\textit{V}, \textit{P}) may complete abruptly.
Such annotations help readers understand specifications clearly, and
they are also helpful for specification-based
tools\footnote{https://github.com/tc39/ecmarkup/issues/173} such as JavaScript
engines~\cite{v8, graaljs, qjs, moddable}, debuggers~\cite{jsexplain}, static
analyzers~\cite{safe, tajs, jsai, wala}, and verification tools~\cite{javert,
javert2}.
Second, the committee has started internal discussions on type
annotations for variables, parameters, and return values of abstract
algorithms\footnote{https://github.com/tc39/ecma262/pull/545\#issuecomment-559292107}.
However, any kinds of manual annotations are labor-intensive and
error-prone, and they do not provide any automatic mechanism to detect
specification bugs.

To alleviate this problem, we propose a novel tool $\tool$, a \textbf{J}avaScript
\textbf{S}pecification \textbf{T}ype \textbf{A}nalyzer using
\textbf{R}efinement. The main challenge of ECMAScript type analysis to
statically detect type-related specification bugs automatically is
that ECMAScript describes abstract algorithms in a natural language,
English.  While researchers~\cite{lambdajs, jscert, kjs}
have formally defined various JavaScript semantics for different
versions of ECMAScript by hand, manual formalization is not suitable for
automatically detecting bugs in rapidly evolving JavaScript specifications. 
Thus, recent approaches in diverse fields such as system architectures~\cite{x86, arm},
network protocols~\cite{basespec}, and language specifications~\cite{spectest, javadoc}
have utilized information directly extracted from specifications written in a natural language
to lessen such burdens.
Among them, $\jiset$~\cite{jiset} compiles ECMAScript abstract algorithms written in
a structured natural language to functions in $\ires$, an untyped
intermediate representation for ECMAScript.
Therefore, $\tool$ leverages $\jiset$ to mechanically handle JavaScript specifications.


$\tool$ takes mechanized JavaScript specifications from $\jiset$ and performs
a type analysis of compiled functions using \textit{specification types}
defined in ECMAScript.  ECMAScript contains not only JavaScript
language types but also specification types such as abstract syntax
trees (ASTs), internal list-like structures, and internal records
including environments, completions, and property descriptors.
We define their type hierarchies based on subtype relations.
For records and AST types, we also define their fields.
Using such type information, $\tool$ performs a type analysis and detects specification bugs using
a \textit{bug detector} consisting of four checkers: 1) a reference
checker, 2) an arity checker, 3) an assertion checker, and 4) an operand checker.
$\tool$ also uses a \textit{condition-based refinement} for type
analysis, which prunes out infeasible parts in abstract states by using conditions
of assertions and branches to improve the precision of type analysis.
We evaluated $\tool$ with all 864 versions in the official
ECMAScript repository for the recent three years from 2018 to 2021.
The experiments showed that the refinement technique could reduce the number of
false-positive bugs caused by spurious types inferred by imprecise type analysis.

The main contributions of this paper are as follows:
\begin{itemize}
  \item We present $\tool$, the first tool that performs a \textit{type
    analysis} on ECMAScript written in a natural language to check the correctness of JavaScript language
    specifications.  $\tool$ automatically detects type-related specification
    bugs such as unknown variables, duplicated variables, missing
    parameters, assertion failures, ill-typed operands, and unchecked
    abrupt completion bugs.
  \item We present a \textit{condition-based refinement} for type analysis of
    ECMAScript to reduce the number of false-positive bugs by enhancing the analysis
    precision.  We show that the refinement technique increases the analysis
    precision from 33.0\% to 59.2\% by removing 122
    false bugs and detecting one more true bug.
  \item We demonstrate the practicality of $\tool$. It takes 137.3
    seconds on average to perform a type analysis for each version of ECMAScript and detected
    157 type-related specification bugs with 59.2\% precision;
    93 out of 157 bugs are true bugs.  Among them, $\tool$
    newly detected 14 bugs, and the ECMAScript committee confirmed them all.
\end{itemize}

digraph {
  node15009 [shape=cds, label=<<font color="black">app F = (GetArgument argumentsList 1i)</font>> color="black" fillcolor="white" style=filled]
  node15008 [shape=cds, label=<<font color="black">app P = (GetArgument argumentsList 0i)</font>> color="black" fillcolor="white" style=filled]
  node15006 [shape=circle label=" " color="black" fillcolor="white" style=filled]
  node15007 [shape=circle label=" " color="black" fillcolor="white" style=filled]
  node15010 [shape=none, margin=0, label=<<font color="black">
    <table border="0" cellborder="1" cellspacing="0" cellpadding="10">
      <tr><td align="left">0:??? &quot;Let id:{S} be a String in the form of a nt:{Pattern[~U]} ( nt:{Pattern[+U]} if id:{F} contains value:{\&quot;u\&quot;} ) equivalent to id:{P} interpreted as UTF - 16 encoded Unicode code points ( link:{unhandled: sec-ecmascript-language-types-string-type} ) , in which certain code points are escaped as described below . id:{S} may or may not be identical to id:{P} ; however , the abstract closure that would result from evaluating id:{S} as a nt:{Pattern[~U]} ( nt:{Pattern[+U]} if id:{F} contains value:{\&quot;u\&quot;} ) must behave identically to the abstract closure given by the constructed object ' s [ [ RegExpMatcher ] ] internal slot . Multiple calls to this abstract operation using the same values for id:{P} and id:{F} must produce identical results .&quot;</td></tr>
      <tr><td align="left">1:??? &quot;The code points code:{/} or any nt:{LineTerminator} occurring in the pattern shall be escaped in id:{S} as necessary to ensure that the string - concatenation of value:{\&quot;/\&quot;} , id:{S} , value:{\&quot;/\&quot;} , and id:{F} can be parsed ( in an appropriate lexical context ) as a nt:{RegularExpressionLiteral} that behaves identically to the constructed regular expression . For example , if id:{P} is value:{\&quot;/\&quot;} , then id:{S} could be value:{\&quot;/\&quot;} or value:{\&quot;u002F\&quot;} , among other possibilities , but not value:{\&quot;/\&quot;} , because code:{///} followed by id:{F} would be parsed as a nt:{SingleLineComment} rather than a nt:{RegularExpressionLiteral} . If id:{P} is the empty String , this specification can be met by letting id:{S} be value:{\&quot;(?:)\&quot;} .&quot;</td></tr>
      <tr><td align="left">2:return S</td></tr>
    </table>
  </font>> color="black" fillcolor="white" style=filled]
  node15006 -> node15008 [ color="black"]
  node15008 -> node15009 [ color="black"]
  node15009 -> node15010 [ color="black"]
  node15010 -> node15007 [ color="black"]
}

\section{JavaScript Semantics Specialization with Syntactic Views}\label{sec:formal}

We first define $\ires$ as a specification language to describe JavaScript
semantics.  Then, we define a function specialization in $\ires$ with two
different source-to-source transformations: a constant propagation
transformation and a redundancy elimination transformation.  We prove the
semantics preservation of function specialization under an observational
semantics.  Finally, we define the JavaScript semantics specialization with
syntactic views using function specialization.

\subsection{$\ires$: Intermediate Representations for ECMAScript}

We first introduce $\ires$, an \textbf{I}ntermediate \textbf{R}epresentations
for \textbf{E}CMA\textbf{S}cript, as a specification language for JavaScript to
describe JavaScript semantics. We define its abstract syntax, states, and
concrete semantics in the remainder of this section.

\subsubsection{Abstract Syntax}

\[
  \begin{array}{lr@{~}c@{~}c@{~}c@{~}l}
    \text{Functions} & \funcset &\ni& \func &::=&
    \kwdef \; x \; \kwrl x^* \kwrr \; \kwcl [\lab: \inst]^* \kwcr\\

    \text{Variables} & \varset &\ni& x\\

    \text{Labels} & \labset &\ni& \lab\\

    \text{Instructions} & \instset &\ni& \inst &::=&
    \refer = \expr \mid
    x = \expr \kwrl \expr^* \kwrr \mid
    \kwif \; \expr \; \lab \; \lab \mid
    \kwret \; \expr\\

    \text{Expressions} & \exprset &\ni& \expr &::=&
    \pval \mid
    \op \kwrl \expr^* \kwrr \mid
    \kwcl \kwcr \mid
    \refer\\

    \text{References} & \referset &\ni& \refer &::=&
    x \mid \refer \kwsl \expr \kwsr\\
  \end{array}
\]

\todo update explanation

A function $\func \in \funcset$ is defined with its name, parameters, and body
instructions with labels $\labset$.  An instruction $\inst \in \instset$ is
a primitive value assignment $x = \pval$,
an operation between values $x = \op \kwrl x^* \kwrr$,
a function call $x = x \kwrl x^* \kwrr$,
a object allocation $x = \kwcl \kwcr$,
a field access $x = x \kwsl x \kwsr$,
a field assignment $x \kwsl x \kwsr = x$,
a conditional branch $\kwif \; x \; \lab \; \lab$,
or a return instruction $\kwret \; x$.


\subsubsection{States}

\[
  \begin{array}{lr@{~}c@{~}l@{~}c@{~}l}
    \text{States} & \st &\in& \stset &=&
    \labset \times \ctxtset^* \times \heapset \times \envset\\

    \text{Calling Contexts} & \ctxt &\in& \ctxtset &=&
    \labset \times \envset \times \varset\\

    \text{Heaps} & \heap &\in& \heapset &=&
    \addrset \finmap \objset\\

    \text{Environments} & \env &\in& \envset &=&
    \varset \finmap \valset\\

    \text{Values} & \val &\in& \valset &=&
    \pvalset \uplus \addrset \uplus \treeset \uplus \funcset\\

    \text{Primive Values} & \pval &\in& \pvalset &=&
    \strset \uplus \cdots\\

    \text{JavaScript ASTs} & \tree &\in& \treeset\\

    \text{Objects} & \obj &\in& \objset &=&
    \strset \finmap \valset\\
  \end{array}
\]

\todo
% States $\stset$ consist of heaps $\heapset$ and contexts $\ctxtset$.  A heap
% $\heap \in \heapset$ is a finite mapping from addresses to objects.  Each object
% allocation instruction $x = \kwcl \kwcr$ creates a unique address $\addr \in
% \addrset$ different from existing addresses.  A context $\ctxt \in \ctxtset$ is
% a triple of a label, a environment, and an optional calling context $\ctxtopt
% \in \ctxtoptset = \ctxtset \uplus \{ \bot \}$.  An environment $\env \in
% \envset$ is a finite mapping from variables to values. A value $\val \in
% \valset$ is a primitive value $\pval \in \pvalset$ (e.g., a string value $\str
% \in \strset$), an address $\addr \in \addrset$, a JavaScript AST $\tree \in
% \treeset$, or a function $f \in \funcset$.  A object $\obj \in \objset$ is a
% finite mappings from strings to values.

\subsubsection{Concrete Semantics of Functions}

\[
  \framebox{$\sem{\func}: \stset \times \valset^* \rightarrow \stset \times
  \valset$}
\]

\todo

\subsubsection{Concrete Semantics of Instructions}

\[
  \framebox{$\sem{\inst}: \stset \rightarrow \stset$}
\]

\todo
% \[
%   \begin{array}{l}
%     \sem{x = \pval}(\heap, (\lab, \env, \ctxtopt)) =\\
%     \qquad (\heap, (\lab, \env[x \mapsto \pval], \ctxtopt)) \\
%     \\
% 
%     \sem{x = \op \kwrl x_1, \cdots, x_n \kwrr}(\heap, (\lab, \env, \ctxtopt)) =\\
%     \qquad (\heap, (\lab, \env[x \mapsto \sem{\op}(x_1, \cdots, x_n)], \ctxtopt)) \\
%     \\
% 
%     \sem{x = x \kwrl x^* \kwrr}(\heap, (\lab, \env, \ctxtopt)) =\\
%     \qquad \todo \\
%     \\
% 
%     \sem{x = \kwcl \kwcr}(\heap, (\lab, \env, \ctxtopt)) =\\
%     \qquad \todo \\
%     \\
% 
%     \sem{x = x \kwsl x \kwsr}(\heap, (\lab, \env, \ctxtopt)) =\\
%     \qquad \todo \\
%     \\
% 
%     \sem{x \kwsl x \kwsr = x}(\heap, (\lab, \env, \ctxtopt)) =\\
%     \qquad \todo \\
%     \\
% 
%     \sem{\kwif \; x \; \lab \; \lab}(\heap, (\lab, \env, \ctxtopt)) =\\
%     \qquad \todo \\
%     \\
% 
%     \sem{\kwret \; x}(\heap, (\lab, \env, \ctxtopt)) =\\
%     \qquad \todo \\
% 
%   \end{array}
% \]

\subsubsection{Concrete Semantics of Expressions}

\[
  \framebox{$\sem{\expr}: \stset \rightarrow \stset \times \valset$}
\]

\todo



\subsubsection{Concrete Semantics of References}

\[
  \framebox{$\sem{\refer}: \stset \rightarrow \stset \times \valset$}
\]

\todo





\subsection{Function Specialization}

\todo

A source-to-source transformation is defined with parameteric restrictions
$\restrictset$ and its concretization $\gamma: \restrictset \rightarrow
\powerset{\stset \times \valset^*}$.
\[
  \framebox{$\transf: \funcset \times \restrictset \rightarrow \funcset$}
\]

\todo



\subsubsection{Constant Propagation Transformation}
\[
  \begin{array}{lr@{~}c@{~}l}
    \text{Restrictions} & (\valoptset)^* &=& (\valset \uplus \{ \top \})^*\\
    \text{Concretization} & \gamma(\valopt_1, \cdots, \valopt_n) &=& \\
    \multicolumn{4}{l}{\qquad \{
      (\st, (\val_1, \cdots, \val_n)) \mid
      \val_i \in \left\{
        \begin{array}{ll}
          \valset & \text{if} \; \valopt_i = \top\\
          \{ \valopt_i \} & \text{otherwise}\\
        \end{array}
      \right.
    \}}\\
  \end{array}
\]

In the constant propagation transformation, restrictions $(\valoptset)^*$ are
sequences of static values $\valset$ or a dynamic value $\top$.

\[
  \framebox{$\transcpe: \exprset \times \envset \rightarrow \exprset$}
\]

\todo

\[
  \framebox{$\transcpi: \instset \times \envset \rightarrow \instset \times
  \envset$}
\]

\todo

\[
  \framebox{$\transcpf: \funcset \times (\valoptset)^* \rightarrow \funcset$}
\]

\todo


\subsubsection{Redundancy Elimination Transformation}

\todo

\[
  \begin{array}{lr@{~}c@{~}l}
    \text{Restrictions} &\{ \top \}\\
    \text{Concretization} & \gamma(\top) &=& \stset \times \valset^*\\
  \end{array}
\]

The redundancy elimination transformation is defined without any restriction,
which means its restriction set consists of a single element $\top$
representing all possible cases.  Therefore, we omit the restriction part in
this transformation for the brevity.

\[
  \framebox{$\transref: \funcset \rightarrow \funcset$}
\]

\todo








\subsection{Proof of Semantics Preservation}

\todo

\subsubsection{Observational Semantics}

\todo





\subsection{JavaScript Semantics Specialization}

\todo

\subsubsection{Syntatic Views}

\todo

\subsubsection{Specialization with Syntatic Views}

\todo

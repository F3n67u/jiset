[
  {
    "tokens": "Let id:{idTextUnescaped} be the result of replacing any occurrences of code:{\\\\} nt:{UnicodeEscapeSequence} in id:{idText} with the code point represented by the nt:{UnicodeEscapeSequence} .",
    "inst": "let idTextUnescaped = AnyStr"
  },
  {
    "tokens": "Let id:{idTextUnescaped} be the result of replacing any occurrences of code:{\\\\} nt:{RegExpUnicodeEscapeSequence} in id:{idText} with the code point represented by the nt:{RegExpUnicodeEscapeSequence} .",
    "inst": "let idTextUnescaped = AnyStr"
  },
  {
    "tokens": "If no such execution context exists , return value:{null} . Otherwise , return id:{ec} ' s ScriptOrModule .",
    "inst": "return ec.ScriptOrModule"
  },
  {
    "tokens": "Create an immutable binding in id:{envRec} for id:{N} and record that it is uninitialized . If id:{S} is value:{true} , record that the newly created binding is a strict binding .",
    "inst": "envRec.SubMap[N] = absent"
  },
  {
    "tokens": "Let id:{internalSlotsList} be the internal slots listed in link:{unhandled: table-internal-slots-of-ecmascript-function-objects} .",
    "inst": "let internalSlotsList = (new [AnyStr])"
  },
  {
    "tokens": "Let id:{ec} be the topmost execution context on the execution context stack whose ScriptOrModule component is not value:{null} .",
    "inst": "let ec = GLOBAL_executionStack[(- GLOBAL_executionStack 1i)]"
  },
  {
    "tokens": "Return the String value consisting of the code units of the digits of the decimal representation of id:{x} .",
    "inst": "return (convert x num2str)"
  },
  {
    "tokens": "Return the source text that was recognized as nt:{RegularExpressionBody} .",
    "inst": "return AnyStr"
  },
  {
    "tokens": "Return the source text that was recognized as nt:{RegularExpressionFlags} .",
    "inst": "return AnyStr"
  },
  {
    "tokens": "If FlagText of id:{literal} contains any code points other than code:{g} , code:{i} , code:{m} , code:{s} , code:{u} , or code:{y} , or if it contains the same code point more than once , return value:{false} .",
    "inst": "if AnyBool return false else {}"
  },
  {
    "tokens": "Let id:{constructorText} be the source text in:{} out:{}",
    "inst": "let constructorText = AnyStr"
  },
  {
    "tokens": "Set id:{constructor} to ParseText ( id:{constructorText} , | MethodDefinition [ ~ Yield , ~ Await ] | ) .",
    "inst": "constructor = (parse-syntax constructorText \"MethodDefinition\" (new [false, false]))"
  },
  {
    "tokens": "If id:{declarationNames} does not include the element value:{\"*default*\"} , append value:{\"*default*\"} to id:{declarationNames} .",
    "inst": "if (contains declarationNames \"*default*\") {} else append \"*default*\" -> declarationNames"
  },
  {
    "tokens": "Append to id:{moduleNames} each element of id:{additionalNames} that is not already an element of id:{moduleNames} .",
    "inst": "{ let __i__ = 0i while (< __i__ additionalNames.length) if (contains moduleNames additionalNames[__i__]) {} else append additionalNames[__i__] -> moduleNames }"
  },
  {
    "tokens": "If id:{envRec} has a binding for the name that is the value of id:{N} , return value:{true} .",
    "inst": "if (= envRec.SubMap[N] absent) {} else return true"
  },
  {
    "tokens": "Let id:{n} be the number of code points in nt:{DecimalDigits} , excluding all occurrences of nt:{NumericLiteralSeparator} .",
    "inst": "let n = AnyNum"
  },
  {
    "tokens": "Let id:{mv} be ( the MV of nt:{NonZeroDigit} Ã— 10 ) plus the MV of nt:{DecimalDigits} .",
    "inst": "{ access __nzd__ = (NonZeroDigit \"MV\") access __dds__ = (DecimalDigits \"MV\") let mv = (+ (* __nzd__ 10) __dds__) }"
  },
  {
    "tokens": "Return the Number value that results from rounding the MV of nt:{NonDecimalIntegerLiteral} as described below .",
    "inst": "return AnyNum"
  },
  {
    "tokens": "Set id:{proto} to id:{realm} ' s intrinsic object named id:{intrinsicDefaultProto} .",
    "inst": "proto = GLOBAL_intrinsic[intrinsicDefaultProto]"
  },
  {
    "tokens": "If id:{F} contains any code unit other than value:{\"g\"} , value:{\"i\"} , value:{\"m\"} , value:{\"s\"} , value:{\"u\"} , or value:{\"y\"} or if it contains the same code unit more than once , throw a value:{SyntaxError} exception .",
    "inst": "if AnyBool throw SyntaxError else {}"
  },
  {
    "tokens": "Let id:{patternText} be the result of interpreting each of id:{P} ' s 16 - bit elements as a Unicode BMP code point . UTF - 16 decoding is not applied to the elements .",
    "inst": "let patternText = AnyStr"
  },
  {
    "tokens": "Let id:{patternCharacters} be a List whose elements are the code unit elements of id:{P} .",
    "inst": "let patternCharacters = (new [AnyStr])"
  },
  {
    "tokens": "Let id:{patternCharacters} be a List whose elements are the code points of id:{patternText} .",
    "inst": "let patternCharacters = (new [AnyStr])"
  },
  {
    "tokens": "Let id:{parseResult} be ParseText ( id:{patternText} , | Pattern [ ~ U , ~ N ] | ) .",
    "inst": "let parseResult = (parse-syntax patternText \"Pattern\" (new [false, false]))"
  },
  {
    "tokens": "Let id:{parseResult} be ParseText ( id:{patternText} , | Pattern [ + U , + N ] | ) .",
    "inst": "let parseResult = (parse-syntax patternText \"Pattern\" (new [true, true]))"
  },
  {
    "tokens": "If id:{parseResult} is a Parse Node and id:{parseResult} contains a nt:{GroupName} , then in:{} out:{}",
    "inst": "parseResult = (parse-syntax patternText \"Pattern\" (new [false, true]))"
  },
  {
    "tokens": "If id:{parseResult} is a non - empty List of value:{SyntaxError} objects , throw a value:{SyntaxError} exception .",
    "inst": "if AnyBool throw SyntaxError else {}"
  },
  {
    "tokens": "Let id:{cp} be the code point whose numeric value is that of id:{first} .",
    "inst": "let cp = AnyNum"
  },
  {
    "tokens": "If id:{first} is not a link:{unhandled: leading-surrogate} or link:{unhandled: trailing-surrogate} , then in:{} out:{}",
    "inst": "if AnyBool return (new Record(\"CodePoint\" -> cp, \"CodeUnitCount\" -> 1i, \"IsUnpairedSurrogate\" -> false)) else {}"
  },
  {
    "tokens": "If id:{first} is a link:{unhandled: trailing-surrogate} or id:{position} + 1 = id:{size} , then in:{} out:{}",
    "inst": "if AnyBool return (new Record(\"CodePoint\" -> cp, \"CodeUnitCount\" -> 1i, \"IsUnpairedSurrogate\" -> true)) else {}"
  },
  {
    "tokens": "If id:{second} is not a link:{unhandled: trailing-surrogate} , then in:{} out:{}",
    "inst": "if AnyBool return (new Record(\"CodePoint\" -> cp, \"CodeUnitCount\" -> 1i, \"IsUnpairedSurrogate\" -> true)) else {}"
  },
  {
    "tokens": "If id:{O} is not value:{undefined} , create an own data property named id:{P} of object id:{O} whose [ [ Value ] ] , [ [ Writable ] ] , [ [ Enumerable ] ] , and [ [ Configurable ] ] attribute values are described by id:{Desc} . If the value of an attribute field of id:{Desc} is absent , the attribute of the newly created property is set to its < emu - xref href = \" # table - default - attribute - values \" > default value < / emu - xref > .",
    "inst": "if (= O undefined) {} else {}"
  },
  {
    "tokens": "If id:{O} is not value:{undefined} , create an own accessor property named id:{P} of object id:{O} whose [ [ Get ] ] , [ [ Set ] ] , [ [ Enumerable ] ] , and [ [ Configurable ] ] attribute values are described by id:{Desc} . If the value of an attribute field of id:{Desc} is absent , the attribute of the newly created property is set to its < emu - xref href = \" # table - default - attribute - values \" > default value < / emu - xref > .",
    "inst": "if (= O undefined) {} else {}"
  },
  {
    "tokens": "If id:{O} is not value:{undefined} , convert the property named id:{P} of object id:{O} from an accessor property to a data property . Preserve the existing values of the converted property ' s [ [ Configurable ] ] and [ [ Enumerable ] ] attributes and set the rest of the property ' s attributes to their < emu - xref href = \" # table - default - attribute - values \" > default values < / emu - xref > .",
    "inst": "if (= O undefined) {} else {}"
  },
  {
    "tokens": "If id:{O} is not value:{undefined} , convert the property named id:{P} of object id:{O} from a data property to an accessor property . Preserve the existing values of the converted property ' s [ [ Configurable ] ] and [ [ Enumerable ] ] attributes and set the rest of the property ' s attributes to their < emu - xref href = \" # table - default - attribute - values \" > default values < / emu - xref > .",
    "inst": "if (= O undefined) {} else {}"
  },
  {
    "tokens": "Set id:{obj} . [ [ RegExpMatcher ] ] to the Abstract Closure that evaluates id:{parseResult} by applying the semantics provided in link:{unhandled: sec-pattern-semantics} using id:{patternCharacters} as the pattern ' s List of nt:{SourceCharacter} values and id:{F} as the flag parameters .",
    "inst": "obj.RegExpMatcher = null"
  },
  {
    "tokens": "Let id:{name} be the string that is the only element of BoundNames of nt:{SingleNameBinding} .",
    "inst": "{ access __snb__ = (SingleNameBinding \"BoundNames\") let name = __snb__[0i] }"
  },
  {
    "tokens": "If nt:{ExportDeclaration} is code:{export} nt:{VariableStatement} , return VarScopedDeclarations of nt:{VariableStatement} .",
    "inst": "if AnyBool { let VariableStatement = ExportDeclaration.VariableStatement access __vs__ = (VariableStatement \"VarScopedDeclarations\") return __vs__ } else {}"
  },
  {
    "tokens": "If id:{symbol} is the nt:{ReservedWord} code:{super} , return value:{true} .",
    "inst": "if AnyBool return true else {}"
  },
  {
    "tokens": "If id:{argument} is value:{true} , return value:{1} . If id:{argument} is value:{false} , return value:{+0} .",
    "inst": "{if (= argument true) return 1i else {} if (= argument false) return 0i else {}}"
  },
  {
    "tokens": "If an implementation - defined debugging facility is available and enabled , then in:{} out:{}",
    "inst": "if AnyBool let result = CONST_empty else let result = CONST_empty"
  },
  {
    "tokens": "Let id:{formalParameterList} be an instance of the production grammar:{FormalParameters0, []} .",
    "inst": "let formalParameterList = (parse-syntax AnyStr \"FormalParameters\" (new []))"
  }
]

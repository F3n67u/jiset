\documentclass[sigconf,review,anonymous=true]{acmart}

\usepackage{kotex}
\usepackage[T1]{fontenc}
\usepackage{beramono}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{qtree}
\usepackage{ulem}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{listings}
\usepackage[noend]{algorithm,algpseudocode}

% removed ACM references
\settopmatter{printacmref=false}

% Scala code style
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstdefinestyle{myScalastyle}{
  frame=tb,
  language=scala,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=fixed,
  basicstyle={\footnotesize\ttfamily},
  numbers=none,
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  frame=single,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
}

% ECMAScript Intermediate Reprentations
\lstdefinestyle{ires}{
  frame=tb,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=fixed,
  basicstyle={\footnotesize\ttfamily},
  numbers=none,
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  frame=single,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
}

% JavaScript code style
\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstdefinestyle{myJSstyle}{
  language=JavaScript,
  extendedchars=true,
  basicstyle=\footnotesize\ttfamily,
  showstringspaces=false,
  showspaces=false,
  numbers=none,
  tabsize=2,
  breaklines=true,
  showtabs=false,
  captionpos=b
}

% load macros
\input{macros}

\begin{document}

\title{\( \tool \): JavaScript IR-based Semantics Extraction Toolchain}

\author{Jihyeok Park}
\email{jhpark0223@kaist.ac.kr}
\affiliation{\institution{KAIST}}

\author{Jihee Park}
\email{j31d0@kaist.ac.kr}
\affiliation{\institution{KAIST}}

\author{Sukyoung Ryu}
\email{sryu.cs@kaist.ac.kr}
\affiliation{\institution{KAIST}}

\begin{abstract}
While JavaScript is initially invented for client-side in web browsers,
JavaScript engines are now embedded in many other types of host software.
Despite its popularity, JavaScript semantics are complicated because of its
dynamic nature. Thus, the formal analysis and verification of JavaScript programs
require its formal semantics. Several researches proposed formal semantics
of JavaScript based on ECMAScript, the official specifications of JavaScript.
However, the existing approaches are fully manual and only target ECMAScript 5.1.
It is a critical problem to understand recent JavaScript programs
because ECMAScript is annually updated from 2015. Thus, already five more updates
after ECMAScript 5.1.

To alleviate such problems, we propose \( \tool \), a JavaScript IR-based Semantics
Extraction Toolchain. It automatically extracts JavaScript syntax and semantics from ECMAScript
specifications. \( \tool \) generates JavaScript parser for the given grammar written
in \( \bnfes \), an extended BNF used in ECMAScript specifications.
Our tool also converts each abstract algorithm written in structured natural
languages into functions written in \( \ires \), an Intermediate Representation
for ECMAScript specifications. The compilation from algorithms to \( \ires \) functions
is defined with \textit{compile rules}. We apply \( \tool \) into the next proposed
version, ECMAScript 2020. and the extracted semantics passes all \inred{XXXXX} tests
in test262, the official ECMAScript conformance test suite.
Moreover, \( \tool \) also successfully extracts semantics for \inred{XX} proposed features
by adding only \inred{XX} minor compile rules.
\end{abstract}

\keywords{
  JavaScript,
  mechanized formal semantics,
  recursive descent parsing
}

\maketitle

\input{intro}
\input{overview}
\input{parser}
\input{compiler}
\input{framework}
\input{eval}
\input{related}
\input{conclusion}

\bibliographystyle{ACM-Reference-Format}
\bibliography{ref}

\end{document}

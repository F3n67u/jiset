\section{Parser Generation}

\subsection{Predictive Parsers vs Recursive Descent Parsers}
\begin{itemize}
  \item Predictive parser
    \begin{itemize}
      \item PROS: widely-used (Yacc), linear time, lookahead for predictions, no backtrack
      \item CONS: need to restructure CFG, not easy to implement ES-BNF features
    \end{itemize}
  \item Recursive descent parsers
    \begin{itemize}
      \item PROS: Scala-supported (Scala parser combinators), easily support ES-BNF features, no need to re-structure CFG
      \item CONS: PEG not CFG, exponential time for bactkracing.
    \end{itemize}
\end{itemize}

\subsection{Packrat Parsers with Lookaheads}
combination of recursive descent parsers with predictive parsers
implicit lookaheads

\subsection{Generating Parsers for \( \bnfes \)}
How to handle each \( \bnfes \) features
\begin{itemize}
  \item \( \code{T}_\code{opt} \): optional term
  \item \( \code{T but not one of T}^\code{*} \): filtering out
  \item \( \code{[lookahead} \in \code{T]} \): positive lookahead condition
  \item \( \code{[lookahead} \not\in \code{T]} \): negative lookahead condition
  \item \( \code{T[P}^\code{*}\code{]} \): parameters
    \begin{itemize}
      \item \( \code{?P} \): passing argument \( \code{P} \)
      \item \( \code{+P} \): \( \kwtrue \)
      \item \( \code{\textasciitilde}\code{P} \): \( \kwfalse \)
    \end{itemize}
  \item \; \( \code{[+P] T} \): if \( \code{P} \) is \( \kwtrue \), added \( \code{T} \)
  \item \; \( \code{[\textasciitilde}\code{P] T} \): if \( \code{P} \) is \( \kwfalse \), added \( \code{T} \)
\end{itemize}

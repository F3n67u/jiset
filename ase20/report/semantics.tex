\section{Semantics of \( \ires \)}\label{sec:semantics}

\subsection{Notations}

\[
  \begin{array}{lr@{~}c@{~}l@{~}c@{~}l}
    \text{States} & (\ctxt, \ctxtstack, \env, \heap) = \st &\in& \stset &=&
    \ctxtset \times \ctxtset^* \times \envset \times \heapset\\
    \text{Contexts} & (\id, \insts, \env) = \ctxt &\in& \ctxtset &=&
    \idset \times \instset^* \times \envset\\
    \text{Environments} & \env &\in& \envset &=&
    \idset \finmap \valset\\
    \text{Heaps} & \heap &\in& \heapset &=&
    \addrset \finmap \objset\\
    \text{Values} & \val &\in& \valset\\
    \text{Addresses} & \addr &\in& \addrset\\
    \text{Objects} & \obj &\in& \objset\\
    \text{Reference Values} & \refval &\in& \refvalset\\
  \end{array}
\]

\[
  \begin{array}{lrclrll}
    \text{Values} & \valset &\ni& \val &
    ::= & \double \mid \intvalue \mid \str \mid \bool \mid
          \C{undefined} \mid \C{null} \mid \C{absent}        & \text{(primitives)}\\
    &&&&\mid& \addr                                          & \text{(addresses)}\\
    &&&&\mid& \AST                                           & \text{(ECMAScript ASTs)}\\
    &&&&\mid& \langle \lambda \C{(}\id^*
              [\C{..}\id]^?\C{)}.\ \inst, \env \rangle      & \text{(closures)}\\
    &&&&\mid& \langle \kappa \C{(}\id^*
              \C{)}.\ \inst, \ctxt, \ctxtstack \rangle       & \text{(continuations)}\\
    \\
    \text{Objects} & \objset &\ni& \obj &
    ::= & \str\ \C{\{} [\val\mapsto\val]^*\C{\}}             & \text{(maps)}\\
    &&&&\mid& \C{[} \val^* \C{]}                             & \text{(lists)}\\
    &&&&\mid& \C{symbol}\ \val                               & \text{(symbols)}\\
    \\
    \text{Reference Values} & \refvalset &\ni& \refval &
    ::= & \id                                                & \text{(identifiers)}\\
    &&&&\mid& \addr \C{[} \val \C{]}                         & \text{(address fields)}\\
    &&&&\mid& \str \C{[} \val \C{]}                          & \text{(string fields)}\\
  \end{array}
\]

\subsection{Semantics of Programs}

The semantics of an \( \ires \) program \( \pr \) is defined with a state
transition system \( (\stset, \trans, \stinit) \). The transition relation
\( \trans \subseteq \stset \times \stset \) describes how states are transformed
into other states defined with as follows:
\[
  \infer
  { \st = (\ctxt, \_, \_, \_) \quad
    \ctxt = (\_, \insts = \langle \inst_0, \inst_1, \cdots, \inst_n \rangle, \_)
    \\\\
    \ctxt' = \ctxt[\insts / \langle \inst_1, \cdots, \inst_n \rangle] \quad
    \st' = \st[\ctxt / \ctxt'] \quad
    \evalinst{\st'}{\inst_0}{\st''}}
  { \st \trans \st'' }
\]
where \( x[y / z] \) denotes the substitutions of the component \( y \) in \( x
\) with \( z \).  The notation \( \transrep \) is zero or more repetitions of
the transition relation \( \trans \). The initial state \( \stinit \) is defined
as follows:
\[
  \begin{array}{r@{~}c@{~}l}
    \stinit   &=& (\ctxtinit, \epsilon, \envinit, \heapinit)\\
    \ctxtinit &=& (\idret, \pr, \epsilon)\\
    \envinit  &=& \text{an initial global environment given by \( \tool \).}\\
    \heapinit &=& \text{an initial heap given by \( \tool \).}\\
    \pr       &=& \text{a given program.}\\
    \idret    &=& \text{a special identifier for return instructions.}\\
  \end{array}
\]
The collecting semantics \( \sem{p} \) of the program \( \pr \) is defined as
follows:
\[
  \sem{p} = \{ \st \mid \stinit \transrep \st \}
\]
Now, we define operational semantics of each \( \ires \) component:
(instructions in Section~\ref{sec:inst}, expressions in Section~\ref{sec:expr},
references in Section~\ref{sec:refer} and reference values in
Section~\ref{sec:refer-val}. We utilize several helper functions in
Section~\ref{sec:helper}

\newpage

\subsection{
  Semantics of Instructions: \fbox{\( \evalinst{\st}{\inst}{\st} \)}
}\label{sec:inst}

\begin{itemize}
  \item expressions:
    \[
      \infer
      { \evalexpr{\st}{\expr}{\val}{\st_0} }
      { \evalinst{\st}{\expr}{\st_0} }
    \]
  \item let bindings:
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val}{\st_0} \quad
        \hdefine{\st_0}{\id}{\val}{\st_1}
      }
      { \evalinst{\st}{\C{let}\ \id\ \C{=}\ \expr }{\st_1} }
    \]
  \item assignments:
    \[
      \infer
      {
        \evalref{\st}{\refer}{\refval}{\st_0} \quad
        \evalexpr{\st_0}{\expr}{\val}{\st_1} \quad
        \hupdated{\st_1}{\refval}{\val}{\st_2}
      }
      { \evalinst{\st}{\refer\ \C{:=}\ \expr }{\st_2} }
    \]
  \item deletions:
    \[
      \infer
      {
        \evalref{\st}{\refer}{\refval}{\st_0} \quad
        \hdeleted{\st_0}{\refval}{\st_1}
      }
      { \evalinst{\st}{\C{delete}\ \refer }{\st_1} }
    \]
  \item append instructions:
    \[
      \infer
      {
        \evalexpr{\st}{\expr_0}{\val_0}{\st_0} \quad
        \hescape{\val_0}{\st_0}{\addr} \\\\
        \evalexpr{\st_0}{\expr_1}{\val_1}{\st_1} \quad
        \hescape{\val_1}{\st_1}{\val_2} \quad
        \happend{\st_1}{\addr}{\val_2}{\st_2}
      }
      { \evalinst{\st}{\C{append}\ \expr_0\ \leftarrow\ \expr_1}{\st_2}}
    \]
  \item prepend instructions:
    \[
      \infer
      {
        \evalexpr{\st}{\expr_0}{\val_0}{\st_0} \quad
        \hescape{\val_0}{\st_0}{\val_1} \\\\
        \evalexpr{\st_0}{\expr_1}{\val_2}{\st_1} \quad
        \hescape{\val_2}{\st_1}{\addr} \quad
        \hprepend{\st_1}{\addr}{\val_1}{\st_2}
      }
      { \evalinst{\st}{\C{prepend}\ \expr_0\ \rightarrow\ \expr_1}{\st_2}}
    \]
  \item return instructions:
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val}{\st_0} \quad
        \hreturn{\st_0}{\val}{\st_1}
      }
      { \evalinst{\st}{\C{return}\ \expr}{\st_1}}
    \]
  \item branches:
    \[
      \infer
      {
        \evalexpr{\st_0}{\expr}{\val}{\st_0} \quad
        \hescape{\val}{\st_0}{\C{true}} \quad
        \st_0 = (\ctxt_0, \_, \_, \_) \\\\
        \ctxt_0 = (\_, \insts = \langle \inst_0, \cdots, \inst_n \rangle, \_) \quad
        \ctxt_1 = \ctxt_0[\insts / \langle \inst_\C{then}, \inst_0, \cdots, \inst_n \rangle] \quad
        \st_1 = \st_0[\ctxt_0 / \ctxt_1]
      }
      { \evalinst{\st}{\C{if}\ \expr\ \inst_\C{then}\ \inst_\C{else}}{\st_1}}
    \]
    \[
      \infer
      {
        \evalexpr{\st_0}{\expr}{\val}{\st_0} \quad
        \hescape{\val}{\st_0}{\C{false}} \quad
        \st_0 = (\ctxt_0, \_, \_, \_) \\\\
        \ctxt_0 = (\_, \insts = \langle \inst_0, \cdots, \inst_n \rangle, \_) \quad
        \ctxt_1 = \ctxt_0[\insts / \langle \inst_\C{else}, \inst_0, \cdots, \inst_n \rangle] \quad
        \st_1 = \st_0[\ctxt_0 / \ctxt_1]
      }
      { \evalinst{\st}{\C{if}\ \expr\ \inst_\C{then}\ \inst_\C{else}}{\st_1}}
    \]
  \item loops:
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val}{\st_0} \quad
        \hescape{\val}{\st_0}{\C{true}} \quad
        \st_0 = (\ctxt_0, \_, \_, \_) \\\\
        \ctxt_0 = (\_, \insts = \langle \inst_0, \cdots, \inst_n \rangle, \_) \quad
        \ctxt_1 = \ctxt_0[\insts / \langle \inst, \C{while}\ \expr\ \inst, \inst_0, \cdots, \inst_n \rangle] \quad
        \st_1 = \st_0[\ctxt_0 / \ctxt_1]
      }
      { \evalinst{\st}{\C{while}\ \expr\ \inst}{\st_1}}
    \]
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val}{\st_0} \quad
        \hescape{\val}{\st_0}{\C{false}} \quad
      }
      { \evalinst{\st}{\C{while}\ \expr\ \inst}{\st_0}}
    \]
  \item sequences:
    \[
      \infer
      {
        \st = (\ctxt, \_, \_, \_) \\\\
        \ctxt = (\_, \insts' = \langle \inst'_0, \cdots, \inst'_m \rangle, \_) \quad
        \ctxt_0 = \ctxt[\insts' / \langle \inst_0, \cdots, \inst_n,
                          \inst'_0, \cdots, \inst'_m \rangle] \quad
        \st_0 = \st[\ctxt / \ctxt_0]
      }
      { \evalinst{\st}{\C{\{}\ \inst_0 \cdots \inst_n\ \C{\}}}{\st_0}}
    \]
  \item assertions:
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val}{\st_0} \quad
        \hescape{\val}{\st_0}{\C{true}}
      }
      { \evalinst{\st}{\C{assert}\ \expr}{\st_0}}
    \]
  \item print instructions:
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val}{\st_0} \quad
        \hprint{\val}
      }
      { \evalinst{\st}{\C{print}\ \expr}{\st_0}}
    \]
  \item function calls:
    \[
      \infer
      {
        \evalexpr{\st}{\expr_0}{
          \langle \lambda \C{(}\id_1, \cdots, \id_m\C{)}.\ \inst_\C{body},
          \env \rangle
        }{\st_0} \\\\
        \evalexpr{\st_0}{\expr_1}{\val_1}{\st_1} \quad
        \cdots \quad
        \evalexpr{\st_{n-1}}{\expr_n}{\val_n}{\st_n} \\\\
        \env_0 = \env[\id_1 \mapsto \val_1, \cdots, \id_m \mapsto \val_m] \quad
        \st_n = (\ctxt, \ctxtstack' = \langle \ctxt'_0, \cdots, \ctxt'_k \rangle, \_, \_)\quad
        \ctxt = (\id_\C{ret}, \_, \_) \\\\
        \ctxt_0 = \ctxt[\id_\C{ret} / \id] \quad
        \ctxt_1 = (\idret, \langle \inst_\C{body} \rangle, \env_1) \quad
        \st' = \st_n[\ctxt / \ctxt_1]
                    [\ctxtstack' / \langle \ctxt_0, \ctxt'_0, \cdots, \ctxt'_k \rangle]
      }
      { \evalinst{\st}{\C{call}\ \id\ \C{=}\ \expr_0 \C{(} \expr_1, \cdots, \expr_n \C{)} }{\st'}}
    \]
    \[
      \infer
      {
        \evalexpr{\st}{\expr_0}{
          \langle \lambda \C{(}\id_1, \cdots, \id_m, \C{..}\id'\C{)}.\ \inst_\C{body},
          \env \rangle
        }{\st_0} \\\\
        \evalexpr{\st_0}{\expr_1}{\val_1}{\st_1} \quad
        \cdots \quad
        \evalexpr{\st_{n-1}}{\expr_n}{\val_n}{\st_n} \\\\
        \env_0 = \env[\id_1 \mapsto \val_1, \cdots, \id_m \mapsto \val_m] \quad
        \env_1 = \env_0[\id' \mapsto \code{[}\val_{m+1}, \cdots, \val_n \code{]}]\\\
        \st_n = (\ctxt, \ctxtstack' = \langle \ctxt'_0, \cdots, \ctxt'_k \rangle, \_, \_)\quad
        \ctxt = (\id_\C{ret}, \_, \_) \\\\
        \ctxt_0 = \ctxt[\id_\C{ret} / \id] \quad
        \ctxt_1 = (\idret, \langle \inst_\C{body} \rangle, \env_1) \quad
        \st' = \st_n[\ctxt / \ctxt_1]
                    [\ctxtstack' / \langle \ctxt_0, \ctxt'_0, \cdots, \ctxt'_k \rangle]
      }
      { \evalinst{\st}{\C{call}\ \id\ \C{=}\ \expr_0 \C{(} \expr_1, \cdots, \expr_n \C{)} }{\st'}}
    \]
    \[
      \infer
      {
        \evalexpr{\st}{\expr_0}{
          \langle \kappa \C{(}\id_1, \cdots, \id_m\C{)}.\ \inst_\C{body},
          \ctxt, \ctxtstack \rangle
        }{\st_0} \\\\
        \evalexpr{\st_0}{\expr_1}{\val_1}{\st_1} \quad
        \cdots \quad
        \evalexpr{\st_{n-1}}{\expr_n}{\val_n}{\st_n} \\\\
        \st_n = (\ctxt', \ctxtstack', \_, \_) \quad
        \ctxt = (\_, \insts, \env) \\\\
        \env_0 = \env[\id_1 \mapsto \val_1, \cdots, \id_m \mapsto \val_m] \quad
        \ctxt_0 = \ctxt[\insts / \langle \inst_\C{body} \rangle][\env / \env_0] \quad
        \st' = \st_n[\ctxt' / \ctxt_0][\ctxtstack' / \ctxtstack]
      }
      { \evalinst{\st}{\C{call}\ \id\ \C{=}\ \expr_0 \C{(} \expr_1, \cdots, \expr_n \C{)} }{\st'}}
    \]
  \item field accesses:
    \[
      \infer
      {
        \evalexpr{\st}{\expr_0}{\val_0}{\st_0} \quad
        \hescape{\val_0}{\st_0}{\addr} \quad
        \evalexpr{\st_0}{\expr_1}{\val_1}{\st_1} \quad
        \hescape{\val_1}{\st_1}{\val_2} \\\\
        \hgetaddrfield{\st_1}{\addr}{\val_2}{\val'} \quad
        \hdefine{\st_1}{\id}{\val'}{\st_2}
      }
      { \evalinst{\st}{\C{access}\ \id\ \C{=}\ \expr_0 \C{[} \expr_1 \C{]} }{\st_2}}
    \]
    \[
      \infer
      {
        \evalexpr{\st}{\expr_0}{\val_0}{\st_0} \quad
        \hescape{\val_0}{\st_0}{\str} \quad
        \evalexpr{\st_0}{\expr_1}{\val_1}{\st_1} \quad
        \hescape{\val_1}{\st_1}{\val_2} \\\\
        \hgetstrfield{\str}{\val_2}{\val'} \quad
        \hdefine{\st_1}{\id}{\val'}{\st_2}
      }
      { \evalinst{\st}{\C{access}\ \id\ \C{=}\ \expr_0 \C{[} \expr_1 \C{]} }{\st_2}}
    \]
    \[
      \infer
      {
        \evalexpr{\st}{\expr_0}{\val_0}{\st_0} \quad
        \hescape{\val_0}{\st_0}{\AST} \quad
        \evalexpr{\st_0}{\expr_1}{\val_1}{\st_1} \quad
        \hescape{\val_1}{\st_1}{\val_2} \\\\
        \hgetastfield{\AST}{\val_2}{\val'} \quad
        \hdefine{\st_1}{\id}{\val'}{\st_2}
      }
      { \evalinst{\st}{\C{access}\ \id\ \C{=}\ \expr_0 \C{[} \expr_1 \C{]} }{\st_2}}
    \]
  \item continuation bindings:
    \[
      \infer
      {
        \st = (\ctxt, \ctxtstack, \_, \_) \quad
        \hdefine{\st}{\id_0}{
          \langle \kappa \C{(}\id_1, \cdots, \id_n\C{)}.\ \inst, \ctxt, \ctxtstack \rangle
        }{\st_0}
      }
      { \evalinst{\st}{\C{withcont}\ \id_0 \C{(} \id_1, \cdots, \id_n \C{)}\ \C{=}\ \inst}{\st_0} }
    \]
\end{itemize}

\newpage


\subsection{
  Semantics of Expressions: \fbox{\( \evalexpr{\st}{\expr}{\val}{\st} \)}
}\label{sec:expr}

\begin{itemize}
  \item primitives:
    \[
      \evalexpr{\st}{\double}{\double}{\st} \quad
      \evalexpr{\st}{\intvalue}{\intvalue}{\st} \quad
      \evalexpr{\st}{\str}{\str}{\st} \quad
      \evalexpr{\st}{\bool}{\bool}{\st}
    \]
    \[
      \evalexpr{\st}{\C{undefined}}{\C{undefined}}{\st} \quad
      \evalexpr{\st}{\C{null}}{\C{null}}{\st} \quad
      \evalexpr{\st}{\C{absent}}{\C{absent}}{\st}
    \]
  \item maps:
    \[
      \infer
      {
        \hallocmap{\st}{\str}{\addr}{\st_0} \\\\
        \evalexpr{\st_0}{\expr_{k_1}}{\val_{k_1}}{\sigma_{k_1}}\quad
        \hescape{\val_{k_1}}{\sigma_{k_1}}{\val'_{k_1}} \\\\
        \evalexpr{\st_{k_1}}{\expr_{v_1}}{\val_{v_1}}{\sigma_{v_1}} \quad
        \hupdated{\st_{v_1}}{\addr\C{[}\val_{k_0}\C{]}}{\val_{v_n}}{\st_1} \\\\
        \cdots \\\\
        \evalexpr{\st_{n-1}}{\expr_{k_n}}{\val_{k_n}}{\sigma_{k_n}}\quad
        \hescape{\val_{k_n}}{\sigma_{k_n}}{\val'_{k_n}} \\\\
        \evalexpr{\st_{k_n}}{\expr_{v_n}}{\val_{v_n}}{\sigma_{v_n}} \quad
        \hupdated{\st_{v_n}}{\addr\C{[}\val_{k_0}\C{]}}{\val_{v_n}}{\st_n}
      }
      {\evalexpr{\st}{\C{new}\ \str\ \C{\{}\expr_{k_1} \mapsto \expr_{v_1},
      \cdots, \expr_{k_n} \mapsto \expr_{v_n}\C{\}}}{\addr}{\st_n}}
    \]
  \item lists:
    \[
      \infer
      {
        \evalexpr{\st}{\expr_0}{\val_0}{\st_0} \quad
        \cdots \quad
        \evalexpr{\st_{n-1}}{\expr_n}{\val_n}{\st_n} \quad
        \halloclist{\st_n}{\langle \val_0, \cdots, \val_n \rangle}{\addr}{\st'} \quad
      }
      {\evalexpr{\st}{\C{new}\ \C{[} \expr_0, \cdots, \expr_n \C{]}}{\addr}{\st'}}
    \]
  \item symbols:
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val}{\st_0} \quad
        \hescape{\val}{\st_0}{\val'} \quad
        \hallocsym{\st_0}{\val'}{\addr}{\st'} \quad
      }
      {\evalexpr{\st}{\C{new}\ \expr}{\addr}{\st'}}
    \]
  \item pop expressions:
    \[
      \infer
      {
        \evalexpr{\st}{\expr_0}{\val_0}{\st_0} \quad
        \hescape{\val_0}{\st_0}{\addr} \\\\
        \evalexpr{\st_0}{\expr_1}{\val_1}{\st_1} \quad
        \hescape{\val_1}{\st_1}{\intvalue} \quad
        \hpop{\st_1}{\addr}{\intvalue}{\val'}{\st'}
      }
      {\evalexpr{\st}{\C{pop}\ \expr_0\ \expr_1}{\val'}{\st'}}
    \]
  \item references:
    \[
      \infer
      {
        \evalref{\st}{\refer}{\refval}{\st_0} \quad
        \evalrefv{\st_0}{\refval}{\val}{\st_1}
      }
      {\evalexpr{\st}{\refer}{\val}{\st_1}}
    \]
  \item continuations:
    \[
      \infer
      {
        \st = (\ctxt, \ctxtstack, \_, \_)
      }
      {\evalexpr{\st}{\C{(} \id_0, \cdots, \id_n \C{)}\ \C{[=>]}\ \inst}{
          \langle \kappa \C{(}\id_0, \cdots, \id_n  \C{)}.\ \inst, \ctxt, \ctxtstack \rangle
      }{\st}}
    \]
  \item unary operations:
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val}{\st'}
      }
      {\evalexpr{\st}{\uop\ \expr}{\uop\ \val}{\st'}}
    \]
  \item binary operations:
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val_0}{\st_0} \quad
        \evalexpr{\st_0}{\expr}{\val_1}{\st_1} \quad
      }
      {\evalexpr{\st}{\expr_0 \bop \expr_1}{\val_0 \bop \val_1}{\st_1}}
    \]
  \item typeof expressions:
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val}{\st'} \quad
        \hgettype{\st'}{\expr}{\str}
      }
      {\evalexpr{\st}{\C{typeof}\ \expr}{\str}{\st'}}
    \]
  \item completion checks:
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val}{\st'} \quad
        \hiscompletion{\st'}{\val}{\bool}
      }
      {\evalexpr{\st}{\C{is-completion}\ \expr}{\bool}{\st'}}
    \]
  \item instance checks:
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val}{\st'} \quad
        \hescape{\val}{\st'}{\val'} \quad
        \hisinstanceof{\val'}{\str}{\bool}
      }
      {\evalexpr{\st}{\C{is-instance-of}\ \expr\ \str}{\bool}{\st'}}
    \]
  \item element getters:
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val}{\st_0} \quad
        \hescape{\val}{\st_0}{\AST} \quad
        \hgetelems{\st_0}{\AST}{\str}{\addr}{\st_1}
      }
      {\evalexpr{\st}{\C{get-elems}\ \expr\ \str}{\addr}{\st_1}}
    \]
  \item syntax getters:
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val}{\st'} \quad
        \hescape{\st'}{\val}{\AST} \quad
        \hgetsytax{\AST}{\str}
      }
      {\evalexpr{\st}{\C{get-syntax}\ \expr}{\str}{\st'}}
    \]
  \item parse expressions:
    \[
      \infer
      {
        \evalexpr{\st}{\expr_\C{code}}{\val_\C{code}}{\st_0} \quad
        \hescape{\st_0}{\val_\C{code}}{\val} \quad
        \evalexpr{\st_0}{\expr_\C{rule}}{\val_\C{rule}}{\st_1} \quad
        \hescape{\st_1}{\val_\C{rule}}{\str} \\\\
        \evalexpr{\st_1}{\expr_1}{\bool_1}{\st_2} \quad
        \cdots \quad
        \evalexpr{\st_n}{\expr_n}{\bool_n}{\st'} \quad
        \hparse{\val}{\str}{\langle \bool_1, \cdots, \bool_n \rangle}{\AST}
      }
      {\evalexpr{\st}{\C{parse-syntax}\ \expr_\C{code}\ \expr_\C{rule}\ \expr_1 \cdots \expr_n}{\AST}{\st'}}
    \]
  \item conversions:
    \[
      \infer
      {
        \evalexpr{\st}{\expr_0}{\val_0}{\st_0} \quad
        \hescape{\val_0}{\st_0}{\val'_0} \quad
        \evalexpr{\st_0}{\expr_1}{\val_1}{\st_1} \quad
        \hescape{\val_1}{\st_1}{\val'_1} \\\\
        \hconvert{\C{num2str}}{\val'_0}{\val'_1}{\str}
      }
      {\evalexpr{\st}{\C{convert}\ \expr_0\ \C{num2str}\ \expr_1}{\str}{\st_1}}
    \]
    \[
      \infer
      {
        \evalexpr{\st}{\expr_0}{\val_0}{\st_0} \quad
        \hescape{\val_0}{\st_0}{\val_1} \quad
        \cop \neq \C{num2str} \quad
        \hconvert{\cop}{\val_1}{\C{absent}}{\val}
      }
      {\evalexpr{\st}{\C{convert}\ \expr_0\ \cop}{\val}{\st_0}}
    \]
  \item contain checks:
    \[
      \infer
      {
        \evalexpr{\st}{\expr_0}{\val_0}{\st_0} \quad
        \hescape{\val_0}{\st_0}{\addr} \quad
        \evalexpr{\st_0}{\expr_1}{\val_1}{\st_1} \quad
        \hescape{\val_1}{\st_1}{\val} \\\\
        \hcontains{\st_1}{\addr}{\val}{\bool}
      }
      {\evalexpr{\st}{\C{contains}\ \expr_0\ \expr_1}{\bool}{\st_1}}
    \]
  \item object copies:
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val}{\st_0} \quad
        \hescape{\val}{\st_0}{\addr} \quad
        \st_0 = (\_, \_, \_, \heap) \quad
        \addr' \not\in \dom{\heap} \\\\
        \heap' = \heap[\addr' \mapsto \heap(\addr)] \quad
        \st' = \st_0[\heap / \heap']
      }
      {\evalexpr{\st}{\C{copy}\ \expr}{\addr'}{\st'}}
    \]
  \item key collections:
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val}{\st_0} \quad
        \hescape{\val}{\st_0}{\addr} \quad
        \hkeys{\st_0}{\addr}{\addr'}{\st'}
      }
      {\evalexpr{\st}{\C{keys}\ \expr}{\addr'}{\st'}}
    \]
\end{itemize}

\newpage


\subsection{
  Semantics of References: \fbox{\( \evalref{\st}{\refer}{\refval}{\st} \)}
}\label{sec:refer}

\begin{itemize}
  \item identifier references:
    \[
      \evalref{\st}{\id}{\id}{\st}
    \]
  \item field references:
    \[
      \infer
      {
        \evalref{\st}{\refer}{\refval}{\st_0} \quad
        \evalrefv{\st_0}{\refval}{\val_0}{\st_1} \quad
        \hescape{\val_0}{\st_1}{\addr} \\\\
        \evalexpr{\st_1}{\expr}{\val_1}{\st_2} \quad
        \hescape{\val_1}{\st_2}{\val}
      }
      {\evalref{\st}{\refer \C{[} \expr \C{]}}{\addr \C{[} \val \C{]}}{\st_2}}
    \]
    \[
      \infer
      {
        \evalref{\st}{\refer}{\refval}{\st_0} \quad
        \evalrefv{\st_0}{\refval}{\val_0}{\st_1} \quad
        \hescape{\val_0}{\st_1}{\str} \\\\
        \evalexpr{\st_1}{\expr}{\val_1}{\st_2} \quad
        \hescape{\val_1}{\st_2}{\val}
      }
      {\evalref{\st}{\refer \C{[} \expr \C{]}}{\str \C{[} \val \C{]}}{\st_2}}
    \]
\end{itemize}


\subsection{
  Semantics of Reference Values: \fbox{\( \evalrefv{\st}{\refval}{\val}{\st} \)}
}\label{sec:refer}

\begin{itemize}
  \item identifiers:
    \[
      \infer
      {
        \hlookup{\st}{\id}{\val}
      }
      {\evalrefv{\st}{\id}{\val}{\st}}
    \]
  \item address fields:
    \[
      \infer
      {
        \hgetaddrfield{\st}{\addr}{\val}{\val'} \quad
      }
      {\evalrefv{\st}{\addr \C{[} \val \C{]}}{\val'}{\st}}
    \]
  \item string fields:
    \[
      \infer
      {
        \hgetstrfield{\st}{\str}{\val}{\val'}
      }
      {\evalrefv{\st}{\str \C{[} \val \C{]}}{\val'}{\st}}
    \]
\end{itemize}

\newpage


\subsection{Helper Functions}\label{sec:helper}

\[\begin{array}{c}
% define
\infer
{\st = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap}\ \ \ \
\symctx = \symctxtuple{x_{ret}}{s}{i^*}{\symenv_L}\ \ \ \
\\ \\
\inred{\symenv_0 = \symenv_L + (x \mapsto v)}\ \ \ \
\symctx_0 = \symctxtuple{x_{ret}}{s}{i^*}{\symenv_0}\ \ \ \
\st_0 = \symstatetuple{\symctx_0}{\symctxstack}{\symenv_G}{\symheap}}
{\hdefine{\st}{x}{v}{\st_0}}
\\ \\
% update - refv:id - global
\infer
{\st = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap}\ \ \ \
\inred{\code{assertGlobalId}(x)}\ \ \ \ 
\inred{\symenv_0 = \symenv_G + (x \mapsto v)}\ \ \ \
\st_0 = \symstatetuple{\symctx}{\symctxstack}{\symenv_0}{\symheap}}
{\hupdated{\st}{x}{v}{\st_0}}
\\ \\
% update - refv:id - local
\infer
{\inred{\code{assertLocalId}(x)}\ \ \ \
\hdefine{\st}{x}{v}{\st_0}}
{\hupdated{\st}{x}{v}{\st_0}}
\\ \\
% update - refv:prop
\infer
{\st = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap}\ \ \ \
a \in \code{Dom}(\symheap)\ \ \ \
\symheap(a) = t\ \code{\{} [v_k\ \mapsto\ v_v]^* \code{\}}\ \ \ \
\inred{o = t\ \code{\{} [v_k\ \mapsto\ v_v]^* + (v_0 \mapsto v_1) \code{\}}}
\\ \\
\inred{\symheap_0 = \symheap + (a \mapsto o)}\ \ \ \
\st_0 = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap_0}}
{\hupdated{\st}{a\code{[} v_0 \code{]}}{v_1}{\st_0}}
\\ \\
% delete - id
\infer
{\st = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap}\ \ \ \
\symctx = \symctxtuple{x_{ret}}{s}{i^*}{\symenv_L}\ \ \ \
\\ \\
\inred{\symenv_0 = \symenv_L - x}\ \ \ \
\symctx_0 = \symctxtuple{x_{ret}}{s}{i^*}{\symenv_0}\ \ \ \
\st_0 = \symstatetuple{\symctx_0}{\symctxstack}{\symenv_G}{\symheap}}
{\hdeleted{\st}{x}{\st_0}}
\\ \\
% delete - refv:prop
\infer
{\st = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap}\ \ \ \
a \in \code{Dom}(\symheap)\ \ \ \
\symheap(a) = t\ \code{\{} [v_k\ \mapsto\ v_v]^* \code{\}}\ \ \ \
\inred{o = t\ \code{\{} [v_k\ \mapsto\ v_v]^* - v_0 \code{\}}}
\\ \\
\inred{\symheap_0 = \symheap + (a \mapsto o)}\ \ \ \
\st_0 = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap_0}}
{\hdeleted{\st}{a\code{[} v_0 \code{]}}{\st_0}}
\\ \\
% append
\infer
{\st = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap}\ \ \ \
a \in \code{Dom}(\symheap)\ \ \ \
\symheap(a) = \symlist{v^*}\ \ \ \
\inred{o = \symlist{v^*}\ \code{:+}\ v_0}
\\ \\
\inred{\symheap_0 = \symheap + (a \mapsto o)}\ \ \ \
\st_0 = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap_0}}
{\happend{\st}{a}{v_0}{\st_0}}
\\ \\
% prepend
\infer
{\st = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap}\ \ \ \
a \in \code{Dom}(\symheap)\ \ \ \
\symheap(a) = \symlist{v^*}\ \ \ \
\inred{o = v_0\ \code{+:}\ \symlist{v^*}}
\\ \\
\inred{\symheap_0 = \symheap + (a \mapsto o)}\ \ \ \
\st_0 = \symstatetuple{\symctx}{\symctxstack}{\symenv_G}{\symheap_0}}
{\hprepend{\st}{a}{v_0}{\st_0}}
\\ \\
% return - ctx stack empty
\infer
{\st = \symstatetuple{\symctx}{\inred{\code{Nil}}}{\symenv_G}{\symheap}\ \ \ \
\symctx = \symctxtuple{x_{ret}}{s}{i^*}{\symenv_L}\ \ \ \
\\ \\
\inred{\symenv_0 = \symenv_L + (x_{ret} \mapsto v)}\ \ \ \
\symctx_0 = \symctxtuple{x_{ret}}{s}{\code{Nil}}{\symenv_0}\ \ \ \
\st_0 = \symstatetuple{\symctx_0}{\symctxstack}{\symenv_G}{\symheap}}
{\hreturn{\st}{v}{\st_0}}
\\ \\
% return - ctx stack not empty
\infer
{\st = \symstatetuple
{\symctx}{\inred{\symctx_0\ \code{+:}\ \symctxstack}}{\symenv_G}{\symheap}\ \ \ \
\symctx_0 = \symctxtuple{x_{ret}}{s}{i^*}{\symenv_{L}}\ \ \ \
\\ \\
\inred{\symenv_0 = \symenv_L + (x_{ret} \mapsto v)}\ \ \ \
\symctx_1 = \symctxtuple{x_{ret}}{s}{i^*}{\symenv_0}\ \ \ \
\st_0 = \symstatetuple{\symctx_1}{\symctxstack}{\symenv_G}{\symheap}}
{\hreturn{\st}{v}{\st_0}}
\end{array}\]

\newpage

\[\begin{array}{c}
% prop - symbol
\infer
{a \in \code{Dom}(\symheap)\ \ \ \
s = "\code{Description}"\ \ \ \
\symheap(a) = \code{symbol}\ v}
{\hgetaddrfield{\symheap}{a}{s}{v}}
\\ \\
% prop - map - absent
\infer
{a \in \code{Dom}(\symheap)\ \ \ \
\symheap(a) = \symmap{t}{v_k}{v_v}\ \ \ \
v \notin \{ v_k \}}
{\hgetaddrfield{\symheap}{a}{v}{\code{absent}}}
\\ \\
% prop - map - not absent
\infer
{a \in \code{Dom}(\symheap)\ \ \ \
\symheap(a) = \symmap{t}{v_k}{v_v}\ \ \ \
v_p \in \{ v_k \} \ \ \ \
\inred{[v_k\ \mapsto\ v_v]^*(v_p) = v} }
{\hgetaddrfield{\symheap}{a}{v_p}{v}}
\\ \\
% prop - list - length
\infer
{a \in \code{Dom}(\symheap)\ \ \ \
s = "\code{length}"\ \ \ \
\symheap(a) = \symlist{v^*} \ \ \ \
\mathlen{\symlist{v^*}} = d}
{\hgetaddrfield{\symheap}{a}{s}{d}}
\\ \\
\multicolumn{1}{c}{\begin{array}{ccc}
% prop - list - integer - not valid - negative
\infer
{a \in \code{Dom}(\symheap)\ \ \ \
\symheap(a) = \symlist{v^*} \ \ \ \
d < 0}
{\hgetaddrfield{\symheap}{a}{d}{\code{absent}}}
& \cs &
% prop - list - integer - not valid - ge length
\infer
{a \in \code{Dom}(\symheap)\ \ \ \
\symheap(a) = \symlist{v^*} \ \ \ \
\mathlen{\symlist{v^*}} = d_0\ \ \ \
d \ge d_0}
{\hgetaddrfield{\symheap}{a}{d}{\code{absent}}}
\end{array}}
\\ \\
% prop - list - integer - valid
\infer
{a \in \code{Dom}(\symheap)\ \ \ \
\symheap(a) = \symlist{v^*} \ \ \ \
\mathlen{\symlist{v^*}} = d_0\ \ \ \
0 \le d < d_0\ \ \ \
\inred{\symlist{v^*}(d) = v_0}}
{\hgetaddrfield{\symheap}{a}{d}{v_0}}
\\ \\
\multicolumn{1}{c}{\begin{array}{ccccc}
% str prop - length
\infer
{s_p = \code{"length"}\ \ \ \
v = \mathlen{s}}
{\hgetstrfield{s}{s_p}{v}}
& \cs &
% str prop - floating point
\infer
{\htoint{n}{d}\ \ \ \
\inred{\hcharat{s}{d}{s_0}}}
{\hgetstrfield{s}{n}{s_0}}
& \cs &
% str prop - integer
\infer
{\inred{\hcharat{s}{d}{s_0}}}
{\hgetstrfield{s}{d}{s_0}}
\end{array}}
\\ \\
% alloc symbol - string
\infer
{a \notin \code{Dom}(\symheap)\ \ \ \
o = \code{symbol}\ s\ \ \ \
\inred{\symheap_0 = \symheap + (a \mapsto o)}}
{\hallocsym{\symheap}{s}{a}{\symheap_0}}
\\ \\
% alloc symbol - undef
\infer
{a \notin \code{Dom}(\symheap)\ \ \ \
o = \code{symbol}\ \code{undefined}\ \ \ \
\inred{\symheap_0 = \symheap + (a \mapsto o)}}
{\hallocsym{\symheap}{\code{undefined}}{a}{\symheap_0}}
\\ \\
% alloc map
\infer
{a \notin \code{Dom}(\symheap)\ \ \ \
\inred{o = t\ \code{\{} {\emptyset} \code{\}}}\ \ \ \
\inred{\symheap_0 = \symheap + (a \mapsto o)}}
{\hallocmap{\symheap}{t}{a}{\symheap_0}}
\\ \\
% alloc list
\infer
{a \notin \code{Dom}(\symheap)\ \ \ \
o = \symlist{v^*}\ \ \ \
\inred{\symheap_0 = \symheap + (a \mapsto o)}}
{\halloclist{\symheap}{v^*}{a}{\symheap_0}}
\end{array}\]

TODO

getType

getElmes

isKindOf

toString

getNewValue

assertValidParseRule

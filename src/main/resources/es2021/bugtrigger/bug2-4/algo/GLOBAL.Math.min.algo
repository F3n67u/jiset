def [BUILTIN] Math.min(value1, value2, ...values) = 0:{
  0:??? "Let id:{args} be a List containing id:{value1} , id:{value2} , and the elements of id:{values} in List order ."
  1:let coerced = (new [])
  2:let __x0__ = args
  2:let __x1__ = 0i
  2:while (< __x1__ __x0__.length) 2:{
    2:let arg = __x0__[__x1__]
    2:__x1__ = (+ __x1__ 1i)
    3:app __x2__ = (ToNumber arg)
    3:let n = [? __x2__]
    4:append n -> coerced
  }
  5:let lowest = Infinity
  6:let __x3__ = coerced
  6:let __x4__ = 0i
  6:while (< __x4__ __x3__.length) 6:{
    6:let number = __x3__[__x4__]
    6:__x4__ = (+ __x4__ 1i)
    7:if (= number NaN) 7:return NaN else 7:{}
    8:if (&& (= number -0.0) (= lowest 0i)) 8:lowest = -0.0 else 8:{}
    9:if (< number lowest) 9:lowest = number else 9:{}
  }
  10:return lowest
}
- id: "sec-math.min"
- code:
          1. Let _args_ be a List containing _value1_, _value2_, and the elements of _values_ in List order.
          1. Let _coerced_ be a new empty List.
          1. For each element _arg_ of _args_, do
            1. Let _n_ be ? ToNumber(_arg_).
            1. Append _n_ to _coerced_.
          1. Let _lowest_ be *+∞*<sub>𝔽</sub>.
          1. For each element _number_ of _coerced_, do
            1. If _number_ is *NaN*, return *NaN*.
            1. If _number_ is *-0*<sub>𝔽</sub> and _lowest_ is *+0*<sub>𝔽</sub>, set _lowest_ to *-0*<sub>𝔽</sub>.
            1. If _number_ < _lowest_, set _lowest_ to _number_.
          1. Return _lowest_.
[
  {
    "tokens": "Let id:{idTextUnescaped} be the result of replacing any occurrences of code:{\\\\} nt:{UnicodeEscapeSequence} in id:{idText} with the code point represented by the nt:{UnicodeEscapeSequence} .",
    "inst": "let idTextUnescaped = AnyStr"
  },
  {
    "tokens": "Let id:{idTextUnescaped} be the result of replacing any occurrences of code:{\\\\} nt:{RegExpUnicodeEscapeSequence} in id:{idText} with the code point represented by the nt:{RegExpUnicodeEscapeSequence} .",
    "inst": "let idTextUnescaped = AnyStr"
  },
  {
    "tokens": "If no such execution context exists , return value:{null} . Otherwise , return id:{ec} ' s ScriptOrModule .",
    "inst": "return ec.ScriptOrModule"
  },
  {
    "tokens": "Create an immutable binding in id:{envRec} for id:{N} and record that it is uninitialized . If id:{S} is value:{true} , record that the newly created binding is a strict binding .",
    "inst": "envRec.SubMap[N] = absent"
  },
  {
    "tokens": "Let id:{internalSlotsList} be the internal slots listed in link:{unhandled: table-internal-slots-of-ecmascript-function-objects} .",
    "inst": "let internalSlotsList = (new [AnyStr])"
  },
  {
    "tokens": "Let id:{ec} be the topmost execution context on the execution context stack whose ScriptOrModule component is not value:{null} .",
    "inst": "let ec = GLOBAL_executionStack[(- GLOBAL_executionStack 1i)]"
  },
  {
    "tokens": "Return the String value consisting of the code units of the digits of the decimal representation of id:{x} .",
    "inst": "return (convert x num2str)"
  },
  {
    "tokens": "Return the source text that was recognized as nt:{RegularExpressionBody} .",
    "inst": "return AnyStr"
  },
  {
    "tokens": "Return the source text that was recognized as nt:{RegularExpressionFlags} .",
    "inst": "return AnyStr"
  },
  {
    "tokens": "If FlagText of id:{literal} contains any code points other than code:{g} , code:{i} , code:{m} , code:{s} , code:{u} , or code:{y} , or if it contains the same code point more than once , return value:{false} .",
    "inst": "if AnyBool return false else {}"
  },
  {
    "tokens": "Let id:{constructorText} be the source text in:{} out:{}",
    "inst": "let constructorText = AnyStr"
  },
  {
    "tokens": "Set id:{constructor} to ParseText ( id:{constructorText} , | MethodDefinition [ ~ Yield , ~ Await ] | ) .",
    "inst": "constructor = (parse-syntax constructorText \"MethodDefinition\" (new [false, false]))"
  },
  {
    "tokens": "If id:{declarationNames} does not include the element value:{\"*default*\"} , append value:{\"*default*\"} to id:{declarationNames} .",
    "inst": "if (contains declarationNames \"*default*\") {} else append \"*default*\" -> declarationNames"
  },
  {
    "tokens": "Append to id:{moduleNames} each element of id:{additionalNames} that is not already an element of id:{moduleNames} .",
    "inst": "{ let __i__ = 0i while (< __i__ additionalNames.length) if (contains moduleNames additionalNames[__i__]) {} else append additionalNames[__i__] -> moduleNames }"
  },
  {
    "tokens": "If id:{envRec} has a binding for the name that is the value of id:{N} , return value:{true} .",
    "inst": "if (= envRec.SubMap[N] absent) {} else return true"
  },
  {
    "tokens": "Let id:{n} be the number of code points in nt:{DecimalDigits} , excluding all occurrences of nt:{NumericLiteralSeparator} .",
    "inst": "let n = AnyInt"
  },
  {
    "tokens": "Let id:{mv} be ( the MV of nt:{NonZeroDigit} Ã— 10 ) plus the MV of nt:{DecimalDigits} .",
    "inst": "{ access __nzd__ = (NonZeroDigit \"MV\") access __dds__ = (DecimalDigits \"MV\") let mv = (+ (* __nzd__ 10) __dds__) }"
  },
  {
    "tokens": "Return the Number value that results from rounding the MV of nt:{NonDecimalIntegerLiteral} as described below .",
    "inst": "return AnyNum"
  }
]

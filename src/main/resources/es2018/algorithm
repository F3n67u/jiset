<step-list>
  <step>Top-level step   <step-list>
    <step>Substep.</step>
    <step>Substep.     <step-list>
      <step>Subsubstep.       <step-list>
        <step>Subsubsubstep         <step-list>
          <step>Subsubsubsubstep           <step-list>
            <step>Subsubsubsubsubstep</step>
          </step-list></step>
        </step-list></step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>status</id> be the result of performing SyntaxDirectedOperation of SomeNonTerminal .</step>
  <step>Let <id>someParseNode</id> be the parse of some source text.</step>
  <step>Perform SyntaxDirectedOperation of <id>someParseNode</id> .</step>
  <step>Perform SyntaxDirectedOperation of <id>someParseNode</id> passing <value>"value"</value> as the argument.</step>
</step-list>
<step-list>
  <step>Return the result of evaluating StatementList .</step>
</step-list>
<step-list>
  <step>Return <value>"Infinity"</value> .</step>
</step-list>
<step-list>
  <step>Return NormalCompletion ( <value>"Infinity"</value> ).</step>
</step-list>
<step-list>
  <step>Assert : <id>completionRecord</id> is a Completion Record .</step>
  <step>Return <id>completionRecord</id> as the Completion Record of this abstract operation.</step>
</step-list>
<step-list>
  <step>Return NormalCompletion ( <value>undefined</value> ).</step>
</step-list>
<step-list>
  <step>Throw a <value>TypeError</value> exception.</step>
</step-list>
<step-list>
  <step>Return ThrowCompletion (a newly created <value>TypeError</value> object).</step>
</step-list>
<step-list>
  <step>ReturnIfAbrupt ( <id>argument</id> ).</step>
</step-list>
<step-list>
  <step>If <id>argument</id> is an abrupt completion , return <id>argument</id> .</step>
  <step>Else if <id>argument</id> is a Completion Record , let <id>argument</id> be <id>argument</id> .[[Value]].</step>
</step-list>
<step-list>
  <step>ReturnIfAbrupt (AbstractOperation()).</step>
</step-list>
<step-list>
  <step>Let <id>hygienicTemp</id> be AbstractOperation().</step>
  <step>If <id>hygienicTemp</id> is an abrupt completion , return <id>hygienicTemp</id> .</step>
  <step>Else if <id>hygienicTemp</id> is a Completion Record , let <id>hygienicTemp</id> be <id>hygienicTemp</id> .[[Value]].</step>
</step-list>
<step-list>
  <step>Let <id>result</id> be AbstractOperation( ReturnIfAbrupt ( <id>argument</id> )).</step>
</step-list>
<step-list>
  <step>If <id>argument</id> is an abrupt completion , return <id>argument</id> .</step>
  <step>If <id>argument</id> is a Completion Record , let <id>argument</id> be <id>argument</id> .[[Value]].</step>
  <step>Let <id>result</id> be AbstractOperation( <id>argument</id> ).</step>
</step-list>
<step-list>
  <step>? OperationName().</step>
</step-list>
<step-list>
  <step>ReturnIfAbrupt (OperationName()).</step>
</step-list>
<step-list>
  <step>? <id>someValue</id> .OperationName().</step>
</step-list>
<step-list>
  <step>ReturnIfAbrupt ( <id>someValue</id> .OperationName()).</step>
</step-list>
<step-list>
  <step>Let <id>val</id> be ! OperationName().</step>
</step-list>
<step-list>
  <step>Let <id>val</id> be OperationName().</step>
  <step>Assert : <id>val</id> is never an abrupt completion .</step>
  <step>If <id>val</id> is a Completion Record , set <id>val</id> to <id>val</id> .[[Value]].</step>
</step-list>
<step-list>
  <step>Perform ! SyntaxDirectedOperation of NonTerminal .</step>
</step-list>
<step-list>
  <step>For each child node <id>child</id> of this Parse Node , do   <step-list>
    <step>If <id>child</id> is an instance of <id>symbol</id> , return <value>true</value> .</step>
    <step>If <id>child</id> is an instance of a nonterminal, then     <step-list>
      <step>Let <id>contained</id> be the result of <id>child</id> Contains <id>symbol</id> .</step>
      <step>If <id>contained</id> is <value>true</value> , return <value>true</value> .</step>
    </step-list></step>
  </step-list></step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>completion</id> be Await ( <id>promise</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>asyncContext</id> be the running execution context .</step>
  <step>Let <id>promiseCapability</id> be ! NewPromiseCapability ( %Promise% ).</step>
  <step>Perform ! Call ( <id>promiseCapability</id> .[[Resolve]], <value>undefined</value> , « <id>promise</id> »).</step>
  <step>Let <id>stepsFulfilled</id> be the algorithm steps defined in Await Fulfilled Functions .</step>
  <step>Let <id>onFulfilled</id> be CreateBuiltinFunction ( <id>stepsFulfilled</id> , « [[AsyncContext]] »).</step>
  <step>Set <id>onFulfilled</id> .[[AsyncContext]] to <id>asyncContext</id> .</step>
  <step>Let <id>stepsRejected</id> be the algorithm steps defined in Await Rejected Functions .</step>
  <step>Let <id>onRejected</id> be CreateBuiltinFunction ( <id>stepsRejected</id> , « [[AsyncContext]] »).</step>
  <step>Set <id>onRejected</id> .[[AsyncContext]] to <id>asyncContext</id> .</step>
  <step>Let <id>throwawayCapability</id> be ! NewPromiseCapability ( %Promise% ).</step>
  <step>Set <id>throwawayCapability</id> .[[Promise]].[[PromiseIsHandled]] to <value>true</value> .</step>
  <step>Perform ! PerformPromiseThen ( <id>promiseCapability</id> .[[Promise]], <id>onFulfilled</id> , <id>onRejected</id> , <id>throwawayCapability</id> ).</step>
  <step>Remove <id>asyncContext</id> from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context .</step>
  <step>Set the code evaluation state of <id>asyncContext</id> such that when evaluation is resumed with a Completion  <id>completion</id> , the following steps of the algorithm that invoked Await will be performed, with <id>completion</id> available.</step>
</step-list>
<step-list>
  <step>Let <id>value</id> be ? Await ( <id>promise</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>value</id> be Await ( <id>promise</id> ).</step>
  <step>ReturnIfAbrupt ( <id>value</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>asyncContext</id> be <id>F</id> .[[AsyncContext]].</step>
  <step>Let <id>prevContext</id> be the running execution context .</step>
  <step>Suspend  <id>prevContext</id> .</step>
  <step>Push <id>asyncContext</id> onto the execution context stack ; <id>asyncContext</id> is now the running execution context .</step>
  <step>Resume the suspended evaluation of <id>asyncContext</id> using NormalCompletion ( <id>value</id> ) as the result of the operation that suspended it.</step>
  <step>Assert : When we reach this step, <id>asyncContext</id> has already been removed from the execution context stack and <id>prevContext</id> is the currently running execution context .</step>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Let <id>asyncContext</id> be <id>F</id> .[[AsyncContext]].</step>
  <step>Let <id>prevContext</id> be the running execution context .</step>
  <step>Suspend  <id>prevContext</id> .</step>
  <step>Push <id>asyncContext</id> onto the execution context stack ; <id>asyncContext</id> is now the running execution context .</step>
  <step>Resume the suspended evaluation of <id>asyncContext</id> using ThrowCompletion ( <id>reason</id> ) as the result of the operation that suspended it.</step>
  <step>Assert : When we reach this step, <id>asyncContext</id> has already been removed from the execution context stack and <id>prevContext</id> is the currently running execution context .</step>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Return NormalCompletion ( <id>argument</id> ).</step>
</step-list>
<step-list>
  <step>Return Completion { [[Type]]: <value>normal</value> , [[Value]]: <id>argument</id> , [[Target]]: <value>empty</value> }.</step>
</step-list>
<step-list>
  <step>Return ThrowCompletion ( <id>argument</id> ).</step>
</step-list>
<step-list>
  <step>Return Completion { [[Type]]: <value>throw</value> , [[Value]]: <id>argument</id> , [[Target]]: <value>empty</value> }.</step>
</step-list>
<step-list>
  <step>Assert : If <id>completionRecord</id> .[[Type]] is either <value>return</value> or <value>throw</value> , then <id>completionRecord</id> .[[Value]] is not <value>empty</value> .</step>
  <step>If <id>completionRecord</id> .[[Value]] is not <value>empty</value> , return Completion ( <id>completionRecord</id> ).</step>
  <step>Return Completion { [[Type]]: <id>completionRecord</id> .[[Type]], [[Value]]: <id>value</id> , [[Target]]: <id>completionRecord</id> .[[Target]] }.</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>V</id> ) is Reference .</step>
  <step>Return the base value component of <id>V</id> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>V</id> ) is Reference .</step>
  <step>Return the referenced name component of <id>V</id> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>V</id> ) is Reference .</step>
  <step>Return the strict reference flag of <id>V</id> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>V</id> ) is Reference .</step>
  <step>If Type ( <id>V</id> 's base value component) is Boolean, String, Symbol, or Number, return <value>true</value> ; otherwise return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>V</id> ) is Reference .</step>
  <step>If either the base value component of <id>V</id> is an Object or HasPrimitiveBase ( <id>V</id> ) is <value>true</value> , return <value>true</value> ; otherwise return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>V</id> ) is Reference .</step>
  <step>If the base value component of <id>V</id> is <value>undefined</value> , return <value>true</value> ; otherwise return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>V</id> ) is Reference .</step>
  <step>If <id>V</id> has a thisValue component, return <value>true</value> ; otherwise return <value>false</value> .</step>
</step-list>
<step-list>
  <step>ReturnIfAbrupt ( <id>V</id> ).</step>
  <step>If Type ( <id>V</id> ) is not Reference , return <id>V</id> .</step>
  <step>Let <id>base</id> be GetBase ( <id>V</id> ).</step>
  <step>If IsUnresolvableReference ( <id>V</id> ) is <value>true</value> , throw a <value>ReferenceError</value> exception.</step>
  <step>If IsPropertyReference ( <id>V</id> ) is <value>true</value> , then   <step-list>
    <step>If HasPrimitiveBase ( <id>V</id> ) is <value>true</value> , then     <step-list>
      <step>Assert : In this case, <id>base</id> will never be <value>undefined</value> or <value>null</value> .</step>
      <step>Set <id>base</id> to ! ToObject ( <id>base</id> ).</step>
    </step-list></step>
    <step>Return ? <id>base</id> .[[Get]]( GetReferencedName ( <id>V</id> ), GetThisValue ( <id>V</id> )).</step>
  </step-list></step>
  <step>Else <id>base</id> must be an Environment Record ,   <step-list>
    <step>Return ? <id>base</id> .GetBindingValue( GetReferencedName ( <id>V</id> ), IsStrictReference ( <id>V</id> )) (see 8.1.1 ).</step>
  </step-list></step>
</step-list>
<step-list>
  <step>ReturnIfAbrupt ( <id>V</id> ).</step>
  <step>ReturnIfAbrupt ( <id>W</id> ).</step>
  <step>If Type ( <id>V</id> ) is not Reference , throw a <value>ReferenceError</value> exception.</step>
  <step>Let <id>base</id> be GetBase ( <id>V</id> ).</step>
  <step>If IsUnresolvableReference ( <id>V</id> ) is <value>true</value> , then   <step-list>
    <step>If IsStrictReference ( <id>V</id> ) is <value>true</value> , then     <step-list>
      <step>Throw a <value>ReferenceError</value> exception.</step>
    </step-list></step>
    <step>Let <id>globalObj</id> be GetGlobalObject ().</step>
    <step>Return ? Set ( <id>globalObj</id> , GetReferencedName ( <id>V</id> ), <id>W</id> , <value>false</value> ).</step>
  </step-list></step>
  <step>Else if IsPropertyReference ( <id>V</id> ) is <value>true</value> , then   <step-list>
    <step>If HasPrimitiveBase ( <id>V</id> ) is <value>true</value> , then     <step-list>
      <step>Assert : In this case, <id>base</id> will never be <value>undefined</value> or <value>null</value> .</step>
      <step>Set <id>base</id> to ! ToObject ( <id>base</id> ).</step>
    </step-list></step>
    <step>Let <id>succeeded</id> be ? <id>base</id> .[[Set]]( GetReferencedName ( <id>V</id> ), <id>W</id> , GetThisValue ( <id>V</id> )).</step>
    <step>If <id>succeeded</id> is <value>false</value> and IsStrictReference ( <id>V</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
    <step>Return.</step>
  </step-list></step>
  <step>Else <id>base</id> must be an Environment Record ,   <step-list>
    <step>Return ? <id>base</id> .SetMutableBinding( GetReferencedName ( <id>V</id> ), <id>W</id> , IsStrictReference ( <id>V</id> )) (see 8.1.1 ).</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Assert : IsPropertyReference ( <id>V</id> ) is <value>true</value> .</step>
  <step>If IsSuperReference ( <id>V</id> ) is <value>true</value> , then   <step-list>
    <step>Return the value of the thisValue component of the reference <id>V</id> .</step>
  </step-list></step>
  <step>Return GetBase ( <id>V</id> ).</step>
</step-list>
<step-list>
  <step>ReturnIfAbrupt ( <id>V</id> ).</step>
  <step>ReturnIfAbrupt ( <id>W</id> ).</step>
  <step>Assert : Type ( <id>V</id> ) is Reference .</step>
  <step>Assert : IsUnresolvableReference ( <id>V</id> ) is <value>false</value> .</step>
  <step>Let <id>base</id> be GetBase ( <id>V</id> ).</step>
  <step>Assert : <id>base</id> is an Environment Record .</step>
  <step>Return <id>base</id> .InitializeBinding( GetReferencedName ( <id>V</id> ), <id>W</id> ).</step>
</step-list>
<step-list>
  <step>If <id>Desc</id> is <value>undefined</value> , return <value>false</value> .</step>
  <step>If both <id>Desc</id> .[[Get]] and <id>Desc</id> .[[Set]] are absent, return <value>false</value> .</step>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>If <id>Desc</id> is <value>undefined</value> , return <value>false</value> .</step>
  <step>If both <id>Desc</id> .[[Value]] and <id>Desc</id> .[[Writable]] are absent, return <value>false</value> .</step>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>If <id>Desc</id> is <value>undefined</value> , return <value>false</value> .</step>
  <step>If IsAccessorDescriptor ( <id>Desc</id> ) and IsDataDescriptor ( <id>Desc</id> ) are both <value>false</value> , return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If <id>Desc</id> is <value>undefined</value> , return <value>undefined</value> .</step>
  <step>Let <id>obj</id> be ObjectCreate ( %ObjectPrototype% ).</step>
  <step>Assert : <id>obj</id> is an extensible ordinary object with no own properties.</step>
  <step>If <id>Desc</id> has a [[Value]] field, then   <step-list>
    <step>Perform CreateDataProperty ( <id>obj</id> , <value>"value"</value> , <id>Desc</id> .[[Value]]).</step>
  </step-list></step>
  <step>If <id>Desc</id> has a [[Writable]] field, then   <step-list>
    <step>Perform CreateDataProperty ( <id>obj</id> , <value>"writable"</value> , <id>Desc</id> .[[Writable]]).</step>
  </step-list></step>
  <step>If <id>Desc</id> has a [[Get]] field, then   <step-list>
    <step>Perform CreateDataProperty ( <id>obj</id> , <value>"get"</value> , <id>Desc</id> .[[Get]]).</step>
  </step-list></step>
  <step>If <id>Desc</id> has a [[Set]] field, then   <step-list>
    <step>Perform CreateDataProperty ( <id>obj</id> , <value>"set"</value> , <id>Desc</id> .[[Set]]).</step>
  </step-list></step>
  <step>If <id>Desc</id> has an [[Enumerable]] field, then   <step-list>
    <step>Perform CreateDataProperty ( <id>obj</id> , <value>"enumerable"</value> , <id>Desc</id> .[[Enumerable]]).</step>
  </step-list></step>
  <step>If <id>Desc</id> has a [[Configurable]] field, then   <step-list>
    <step>Perform CreateDataProperty ( <id>obj</id> , <value>"configurable"</value> , <id>Desc</id> .[[Configurable]]).</step>
  </step-list></step>
  <step>Assert : All of the above CreateDataProperty operations return <value>true</value> .</step>
  <step>Return <id>obj</id> .</step>
</step-list>
<step-list>
  <step>If Type ( <id>Obj</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>desc</id> be a new Property Descriptor that initially has no fields.</step>
  <step>Let <id>hasEnumerable</id> be ? HasProperty ( <id>Obj</id> , <value>"enumerable"</value> ).</step>
  <step>If <id>hasEnumerable</id> is <value>true</value> , then   <step-list>
    <step>Let <id>enum</id> be ToBoolean (? Get ( <id>Obj</id> , <value>"enumerable"</value> )).</step>
    <step>Set <id>desc</id> .[[Enumerable]] to <id>enum</id> .</step>
  </step-list></step>
  <step>Let <id>hasConfigurable</id> be ? HasProperty ( <id>Obj</id> , <value>"configurable"</value> ).</step>
  <step>If <id>hasConfigurable</id> is <value>true</value> , then   <step-list>
    <step>Let <id>conf</id> be ToBoolean (? Get ( <id>Obj</id> , <value>"configurable"</value> )).</step>
    <step>Set <id>desc</id> .[[Configurable]] to <id>conf</id> .</step>
  </step-list></step>
  <step>Let <id>hasValue</id> be ? HasProperty ( <id>Obj</id> , <value>"value"</value> ).</step>
  <step>If <id>hasValue</id> is <value>true</value> , then   <step-list>
    <step>Let <id>value</id> be ? Get ( <id>Obj</id> , <value>"value"</value> ).</step>
    <step>Set <id>desc</id> .[[Value]] to <id>value</id> .</step>
  </step-list></step>
  <step>Let <id>hasWritable</id> be ? HasProperty ( <id>Obj</id> , <value>"writable"</value> ).</step>
  <step>If <id>hasWritable</id> is <value>true</value> , then   <step-list>
    <step>Let <id>writable</id> be ToBoolean (? Get ( <id>Obj</id> , <value>"writable"</value> )).</step>
    <step>Set <id>desc</id> .[[Writable]] to <id>writable</id> .</step>
  </step-list></step>
  <step>Let <id>hasGet</id> be ? HasProperty ( <id>Obj</id> , <value>"get"</value> ).</step>
  <step>If <id>hasGet</id> is <value>true</value> , then   <step-list>
    <step>Let <id>getter</id> be ? Get ( <id>Obj</id> , <value>"get"</value> ).</step>
    <step>If IsCallable ( <id>getter</id> ) is <value>false</value> and <id>getter</id> is not <value>undefined</value> , throw a <value>TypeError</value> exception.</step>
    <step>Set <id>desc</id> .[[Get]] to <id>getter</id> .</step>
  </step-list></step>
  <step>Let <id>hasSet</id> be ? HasProperty ( <id>Obj</id> , <value>"set"</value> ).</step>
  <step>If <id>hasSet</id> is <value>true</value> , then   <step-list>
    <step>Let <id>setter</id> be ? Get ( <id>Obj</id> , <value>"set"</value> ).</step>
    <step>If IsCallable ( <id>setter</id> ) is <value>false</value> and <id>setter</id> is not <value>undefined</value> , throw a <value>TypeError</value> exception.</step>
    <step>Set <id>desc</id> .[[Set]] to <id>setter</id> .</step>
  </step-list></step>
  <step>If <id>desc</id> .[[Get]] is present or <id>desc</id> .[[Set]] is present, then   <step-list>
    <step>If <id>desc</id> .[[Value]] is present or <id>desc</id> .[[Writable]] is present, throw a <value>TypeError</value> exception.</step>
  </step-list></step>
  <step>Return <id>desc</id> .</step>
</step-list>
<step-list>
  <step>Assert : <id>Desc</id> is a Property Descriptor .</step>
  <step>Let <id>like</id> be Record { [[Value]]: <value>undefined</value> , [[Writable]]: <value>false</value> , [[Get]]: <value>undefined</value> , [[Set]]: <value>undefined</value> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>false</value> }.</step>
  <step>If IsGenericDescriptor ( <id>Desc</id> ) is <value>true</value> or IsDataDescriptor ( <id>Desc</id> ) is <value>true</value> , then   <step-list>
    <step>If <id>Desc</id> does not have a [[Value]] field, set <id>Desc</id> .[[Value]] to <id>like</id> .[[Value]].</step>
    <step>If <id>Desc</id> does not have a [[Writable]] field, set <id>Desc</id> .[[Writable]] to <id>like</id> .[[Writable]].</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>If <id>Desc</id> does not have a [[Get]] field, set <id>Desc</id> .[[Get]] to <id>like</id> .[[Get]].</step>
    <step>If <id>Desc</id> does not have a [[Set]] field, set <id>Desc</id> .[[Set]] to <id>like</id> .[[Set]].</step>
  </step-list></step>
  <step>If <id>Desc</id> does not have an [[Enumerable]] field, set <id>Desc</id> .[[Enumerable]] to <id>like</id> .[[Enumerable]].</step>
  <step>If <id>Desc</id> does not have a [[Configurable]] field, set <id>Desc</id> .[[Configurable]] to <id>like</id> .[[Configurable]].</step>
  <step>Return <id>Desc</id> .</step>
</step-list>
<step-list>
  <step>Assert : <id>size</id> ≥0.</step>
  <step>Let <id>db</id> be a new Data Block value consisting of <id>size</id> bytes. If it is impossible to create such a Data Block , throw a <value>RangeError</value> exception.</step>
  <step>Set all of the bytes of <id>db</id> to 0.</step>
  <step>Return <id>db</id> .</step>
</step-list>
<step-list>
  <step>Assert : <id>size</id> ≥0.</step>
  <step>Let <id>db</id> be a new Shared Data Block value consisting of <id>size</id> bytes. If it is impossible to create such a Shared Data Block , throw a <value>RangeError</value> exception.</step>
  <step>Let <id>execution</id> be the [[CandidateExecution]] field of the surrounding agent 's Agent Record .</step>
  <step>Let <id>eventList</id> be the [[EventList]] field of the element in <id>execution</id> .[[EventLists]] whose [[AgentSignifier]] is AgentSignifier ().</step>
  <step>Let <id>zero</id> be « 0 ».</step>
  <step>For each index <id>i</id> of <id>db</id> , do   <step-list>
    <step>Append WriteSharedMemory { [[Order]]: <value>"Init"</value> , [[NoTear]]: <value>true</value> , [[Block]]: <id>db</id> , [[ByteIndex]]: <id>i</id> , [[ElementSize]]: 1, [[Payload]]: <id>zero</id> } to <id>eventList</id> .</step>
  </step-list></step>
  <step>Return <id>db</id> .</step>
</step-list>
<step-list>
  <step>Assert : <id>fromBlock</id> and <id>toBlock</id> are distinct Data Block or Shared Data Block values.</step>
  <step>Assert : <id>fromIndex</id> , <id>toIndex</id> , and <id>count</id> are integer values ≥ 0.</step>
  <step>Let <id>fromSize</id> be the number of bytes in <id>fromBlock</id> .</step>
  <step>Assert : <id>fromIndex</id> + <id>count</id> ≤ <id>fromSize</id> .</step>
  <step>Let <id>toSize</id> be the number of bytes in <id>toBlock</id> .</step>
  <step>Assert : <id>toIndex</id> + <id>count</id> ≤ <id>toSize</id> .</step>
  <step>Repeat, while <id>count</id> >0   <step-list>
    <step>If <id>fromBlock</id> is a Shared Data Block , then     <step-list>
      <step>Let <id>execution</id> be the [[CandidateExecution]] field of the surrounding agent 's Agent Record .</step>
      <step>Let <id>eventList</id> be the [[EventList]] field of the element in <id>execution</id> .[[EventLists]] whose [[AgentSignifier]] is AgentSignifier ().</step>
      <step>Let <id>bytes</id> be a List of length 1 that contains a nondeterministically chosen byte value.</step>
      <step>NOTE: In implementations, <id>bytes</id> is the result of a non-atomic read instruction on the underlying 
hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.</step>
      <step>Let <id>readEvent</id> be ReadSharedMemory { [[Order]]: <value>"Unordered"</value> , [[NoTear]]: <value>true</value> , [[Block]]: <id>fromBlock</id> , [[ByteIndex]]: <id>fromIndex</id> , [[ElementSize]]: 1 }.</step>
      <step>Append <id>readEvent</id> to <id>eventList</id> .</step>
      <step>Append Chosen Value Record { [[Event]]: <id>readEvent</id> , [[ChosenValue]]: <id>bytes</id> } to <id>execution</id> .[[ChosenValues]].</step>
      <step>If <id>toBlock</id> is a Shared Data Block , then       <step-list>
        <step>Append WriteSharedMemory { [[Order]]: <value>"Unordered"</value> , [[NoTear]]: <value>true</value> , [[Block]]: <id>toBlock</id> , [[ByteIndex]]: <id>toIndex</id> , [[ElementSize]]: 1, [[Payload]]: <id>bytes</id> } to <id>eventList</id> .</step>
      </step-list></step>
      <step>Else,       <step-list>
        <step>Set <id>toBlock</id> [ <id>toIndex</id> ] to <id>bytes</id> [0].</step>
      </step-list></step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>Assert : <id>toBlock</id> is not a Shared Data Block .</step>
      <step>Set <id>toBlock</id> [ <id>toIndex</id> ] to <id>fromBlock</id> [ <id>fromIndex</id> ].</step>
    </step-list></step>
    <step>Increment <id>toIndex</id> and <id>fromIndex</id> each by 1.</step>
    <step>Decrement <id>count</id> by 1.</step>
  </step-list></step>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Assert : <id>input</id> is an ECMAScript language value .</step>
  <step>If Type ( <id>input</id> ) is Object, then   <step-list>
    <step>If <id>PreferredType</id> is not present, let <id>hint</id> be <value>"default"</value> .</step>
    <step>Else if <id>PreferredType</id> is hint String, let <id>hint</id> be <value>"string"</value> .</step>
    <step>Else <id>PreferredType</id> is hint Number, let <id>hint</id> be <value>"number"</value> .</step>
    <step>Let <id>exoticToPrim</id> be ? GetMethod ( <id>input</id> , @@toPrimitive).</step>
    <step>If <id>exoticToPrim</id> is not <value>undefined</value> , then     <step-list>
      <step>Let <id>result</id> be ? Call ( <id>exoticToPrim</id> , <id>input</id> , « <id>hint</id> »).</step>
      <step>If Type ( <id>result</id> ) is not Object, return <id>result</id> .</step>
      <step>Throw a <value>TypeError</value> exception.</step>
    </step-list></step>
    <step>If <id>hint</id> is <value>"default"</value> , set <id>hint</id> to <value>"number"</value> .</step>
    <step>Return ? OrdinaryToPrimitive ( <id>input</id> , <id>hint</id> ).</step>
  </step-list></step>
  <step>Return <id>input</id> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>O</id> ) is Object.</step>
  <step>Assert : Type ( <id>hint</id> ) is String and its value is either <value>"string"</value> or <value>"number"</value> .</step>
  <step>If <id>hint</id> is <value>"string"</value> , then   <step-list>
    <step>Let <id>methodNames</id> be « <value>"toString"</value> , <value>"valueOf"</value> ».</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>methodNames</id> be « <value>"valueOf"</value> , <value>"toString"</value> ».</step>
  </step-list></step>
  <step>For each <id>name</id> in <id>methodNames</id> in List order, do   <step-list>
    <step>Let <id>method</id> be ? Get ( <id>O</id> , <id>name</id> ).</step>
    <step>If IsCallable ( <id>method</id> ) is <value>true</value> , then     <step-list>
      <step>Let <id>result</id> be ? Call ( <id>method</id> , <id>O</id> ).</step>
      <step>If Type ( <id>result</id> ) is not Object, return <id>result</id> .</step>
    </step-list></step>
  </step-list></step>
  <step>Throw a <value>TypeError</value> exception.</step>
</step-list>
<step-list>
  <step>Let <id>primValue</id> be ? ToPrimitive ( <id>argument</id> , hint Number).</step>
  <step>Return ? ToNumber ( <id>primValue</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>number</id> be ? ToNumber ( <id>argument</id> ).</step>
  <step>If <id>number</id> is <value>NaN</value> , return <value>+0</value> .</step>
  <step>If <id>number</id> is <value>+0</value> , <value>-0</value> , <value>+∞</value> , or <value>-∞</value> , return <id>number</id> .</step>
  <step>Return the number value that is the same sign as <id>number</id> and whose magnitude is floor ( abs ( <id>number</id> )).</step>
</step-list>
<step-list>
  <step>Let <id>number</id> be ? ToNumber ( <id>argument</id> ).</step>
  <step>If <id>number</id> is <value>NaN</value> , <value>+0</value> , <value>-0</value> , <value>+∞</value> , or <value>-∞</value> , return <value>+0</value> .</step>
  <step>Let <id>int</id> be the mathematical value that is the same sign as <id>number</id> and whose magnitude is floor ( abs ( <id>number</id> )).</step>
  <step>Let <id>int32bit</id> be <id>int</id>  modulo 2 32 .</step>
  <step>If <id>int32bit</id> ≥ 2 31 , return <id>int32bit</id> - 2 32 ; otherwise return <id>int32bit</id> .</step>
</step-list>
<step-list>
  <step>Let <id>number</id> be ? ToNumber ( <id>argument</id> ).</step>
  <step>If <id>number</id> is <value>NaN</value> , <value>+0</value> , <value>-0</value> , <value>+∞</value> , or <value>-∞</value> , return <value>+0</value> .</step>
  <step>Let <id>int</id> be the mathematical value that is the same sign as <id>number</id> and whose magnitude is floor ( abs ( <id>number</id> )).</step>
  <step>Let <id>int32bit</id> be <id>int</id>  modulo 2 32 .</step>
  <step>Return <id>int32bit</id> .</step>
</step-list>
<step-list>
  <step>Let <id>number</id> be ? ToNumber ( <id>argument</id> ).</step>
  <step>If <id>number</id> is <value>NaN</value> , <value>+0</value> , <value>-0</value> , <value>+∞</value> , or <value>-∞</value> , return <value>+0</value> .</step>
  <step>Let <id>int</id> be the mathematical value that is the same sign as <id>number</id> and whose magnitude is floor ( abs ( <id>number</id> )).</step>
  <step>Let <id>int16bit</id> be <id>int</id>  modulo 2 16 .</step>
  <step>If <id>int16bit</id> ≥ 2 15 , return <id>int16bit</id> - 2 16 ; otherwise return <id>int16bit</id> .</step>
</step-list>
<step-list>
  <step>Let <id>number</id> be ? ToNumber ( <id>argument</id> ).</step>
  <step>If <id>number</id> is <value>NaN</value> , <value>+0</value> , <value>-0</value> , <value>+∞</value> , or <value>-∞</value> , return <value>+0</value> .</step>
  <step>Let <id>int</id> be the mathematical value that is the same sign as <id>number</id> and whose magnitude is floor ( abs ( <id>number</id> )).</step>
  <step>Let <id>int16bit</id> be <id>int</id>  modulo 2 16 .</step>
  <step>Return <id>int16bit</id> .</step>
</step-list>
<step-list>
  <step>Let <id>number</id> be ? ToNumber ( <id>argument</id> ).</step>
  <step>If <id>number</id> is <value>NaN</value> , <value>+0</value> , <value>-0</value> , <value>+∞</value> , or <value>-∞</value> , return <value>+0</value> .</step>
  <step>Let <id>int</id> be the mathematical value that is the same sign as <id>number</id> and whose magnitude is floor ( abs ( <id>number</id> )).</step>
  <step>Let <id>int8bit</id> be <id>int</id>  modulo 2 8 .</step>
  <step>If <id>int8bit</id> ≥ 2 7 , return <id>int8bit</id> - 2 8 ; otherwise return <id>int8bit</id> .</step>
</step-list>
<step-list>
  <step>Let <id>number</id> be ? ToNumber ( <id>argument</id> ).</step>
  <step>If <id>number</id> is <value>NaN</value> , <value>+0</value> , <value>-0</value> , <value>+∞</value> , or <value>-∞</value> , return <value>+0</value> .</step>
  <step>Let <id>int</id> be the mathematical value that is the same sign as <id>number</id> and whose magnitude is floor ( abs ( <id>number</id> )).</step>
  <step>Let <id>int8bit</id> be <id>int</id>  modulo 2 8 .</step>
  <step>Return <id>int8bit</id> .</step>
</step-list>
<step-list>
  <step>Let <id>number</id> be ? ToNumber ( <id>argument</id> ).</step>
  <step>If <id>number</id> is <value>NaN</value> , return <value>+0</value> .</step>
  <step>If <id>number</id> ≤ 0, return <value>+0</value> .</step>
  <step>If <id>number</id> ≥ 255, return 255.</step>
  <step>Let <id>f</id> be floor ( <id>number</id> ).</step>
  <step>If <id>f</id> + 0.5 < <id>number</id> , return <id>f</id> + 1.</step>
  <step>If <id>number</id> < <id>f</id> + 0.5, return <id>f</id> .</step>
  <step>If <id>f</id> is odd, return <id>f</id> + 1.</step>
  <step>Return <id>f</id> .</step>
</step-list>
<step-list>
  <step>Let <id>primValue</id> be ? ToPrimitive ( <id>argument</id> , hint String).</step>
  <step>Return ? ToString ( <id>primValue</id> ).</step>
</step-list>
<step-list>
  <step>If <id>m</id> is <value>NaN</value> , return the String <value>"NaN"</value> .</step>
  <step>If <id>m</id> is <value>+0</value> or <value>-0</value> , return the String <value>"0"</value> .</step>
  <step>If <id>m</id> is less than zero, return the string-concatenation of <value>"-"</value> and ! NumberToString (- <id>m</id> ).</step>
  <step>If <id>m</id> is <value>+∞</value> , return the String <value>"Infinity"</value> .</step>
  <step>Otherwise, let <id>n</id> , <id>k</id> , and <id>s</id> be integers such that <id>k</id> ≥ 1, 10 k-1 ≤ <id>s</id> < 10 k , the Number value for <id>s</id> × 10 n-k is <id>m</id> , and <id>k</id> is as small as possible. Note that <id>k</id> is the number of digits in the decimal representation of <id>s</id> , that <id>s</id> is not divisible by 10, and that the least significant digit of <id>s</id> is not necessarily uniquely determined by these criteria.</step>
  <step>If <id>k</id> ≤ <id>n</id> ≤ 21, return the string-concatenation of: the code units of the k digits of the decimal representation of s (in order, with no leading zeroes)
n-k occurrences of the code unit 0x0030 (DIGIT ZERO)</step>
  <step>If 0 < <id>n</id> ≤ 21, return the string-concatenation of: the code units of the most significant n digits of the decimal representation of s
the code unit 0x002E (FULL STOP)
the code units of the remaining k-n digits of the decimal representation of s</step>
  <step>If -6 < <id>n</id> ≤ 0, return the string-concatenation of: the code unit 0x0030 (DIGIT ZERO)
the code unit 0x002E (FULL STOP)
-n occurrences of the code unit 0x0030 (DIGIT ZERO)
the code units of the k digits of the decimal representation of s</step>
  <step>Otherwise, if <id>k</id> = 1, return the string-concatenation of: the code unit of the single digit of s
the code unit 0x0065 (LATIN SMALL LETTER E)
the code unit 0x002B (PLUS SIGN) or the code unit 0x002D (HYPHEN-MINUS) according to whether n-1 is positive or negative
the code units of the decimal representation of the integer abs(n-1) (with no leading zeroes)</step>
  <step>Return the string-concatenation of: the code units of the most significant digit of the decimal representation of s
the code unit 0x002E (FULL STOP)
the code units of the remaining k-1 digits of the decimal representation of s
the code unit 0x0065 (LATIN SMALL LETTER E)
the code unit 0x002B (PLUS SIGN) or the code unit 0x002D (HYPHEN-MINUS) according to whether n-1 is positive or negative
the code units of the decimal representation of the integer abs(n-1) (with no leading zeroes)</step>
</step-list>
<step-list>
  <step>Otherwise, let <id>n</id> , <id>k</id> , and <id>s</id> be integers such that <id>k</id> ≥ 1, 10 k-1 ≤ <id>s</id> < 10 k , the Number value for <id>s</id> × 10 n-k is <id>m</id> , and <id>k</id> is as small as possible. If there are multiple possibilities for <id>s</id> , choose the value of <id>s</id> for which <id>s</id> × 10 n-k is closest in value to <id>m</id> . If there are two such possible values of <id>s</id> , choose the one that is even. Note that <id>k</id> is the number of digits in the decimal representation of <id>s</id> and that <id>s</id> is not divisible by 10.</step>
</step-list>
<step-list>
  <step>Let <id>key</id> be ? ToPrimitive ( <id>argument</id> , hint String).</step>
  <step>If Type ( <id>key</id> ) is Symbol, then   <step-list>
    <step>Return <id>key</id> .</step>
  </step-list></step>
  <step>Return ! ToString ( <id>key</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>len</id> be ? ToInteger ( <id>argument</id> ).</step>
  <step>If <id>len</id> ≤ <value>+0</value> , return <value>+0</value> .</step>
  <step>Return min ( <id>len</id> , 2 53 -1).</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>argument</id> ) is String.</step>
  <step>If <id>argument</id> is <value>"-0"</value> , return <value>-0</value> .</step>
  <step>Let <id>n</id> be ! ToNumber ( <id>argument</id> ).</step>
  <step>If SameValue (! ToString ( <id>n</id> ), <id>argument</id> ) is <value>false</value> , return <value>undefined</value> .</step>
  <step>Return <id>n</id> .</step>
</step-list>
<step-list>
  <step>If <id>value</id> is <value>undefined</value> , then   <step-list>
    <step>Let <id>index</id> be 0.</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>integerIndex</id> be ? ToInteger ( <id>value</id> ).</step>
    <step>If <id>integerIndex</id> < 0, throw a <value>RangeError</value> exception.</step>
    <step>Let <id>index</id> be ! ToLength ( <id>integerIndex</id> ).</step>
    <step>If SameValueZero ( <id>integerIndex</id> , <id>index</id> ) is <value>false</value> , throw a <value>RangeError</value> exception.</step>
  </step-list></step>
  <step>Return <id>index</id> .</step>
</step-list>
<step-list>
  <step>If Type ( <id>argument</id> ) is not Object, return <value>false</value> .</step>
  <step>If <id>argument</id> is an Array exotic object , return <value>true</value> .</step>
  <step>If <id>argument</id> is a Proxy exotic object , then   <step-list>
    <step>If <id>argument</id> .[[ProxyHandler]] is <value>null</value> , throw a <value>TypeError</value> exception.</step>
    <step>Let <id>target</id> be <id>argument</id> .[[ProxyTarget]].</step>
    <step>Return ? IsArray ( <id>target</id> ).</step>
  </step-list></step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If Type ( <id>argument</id> ) is not Object, return <value>false</value> .</step>
  <step>If <id>argument</id> has a [[Call]] internal method, return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If Type ( <id>argument</id> ) is not Object, return <value>false</value> .</step>
  <step>If <id>argument</id> has a [[Construct]] internal method, return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>O</id> ) is Object.</step>
  <step>Return ? <id>O</id> .[[IsExtensible]]().</step>
</step-list>
<step-list>
  <step>If Type ( <id>argument</id> ) is not Number, return <value>false</value> .</step>
  <step>If <id>argument</id> is <value>NaN</value> , <value>+∞</value> , or <value>-∞</value> , return <value>false</value> .</step>
  <step>If floor ( abs ( <id>argument</id> )) ≠ abs ( <id>argument</id> ), return <value>false</value> .</step>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>If Type ( <id>argument</id> ) is String, return <value>true</value> .</step>
  <step>If Type ( <id>argument</id> ) is Symbol, return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If Type ( <id>argument</id> ) is not Object, return <value>false</value> .</step>
  <step>Let <id>matcher</id> be ? Get ( <id>argument</id> , @@match).</step>
  <step>If <id>matcher</id> is not <value>undefined</value> , return ToBoolean ( <id>matcher</id> ).</step>
  <step>If <id>argument</id> has a [[RegExpMatcher]] internal slot, return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>p</id> ) is String.</step>
  <step>Assert : Type ( <id>q</id> ) is String.</step>
  <step>If <id>q</id> can be the string-concatenation of <id>p</id> and some other String <id>r</id> , return <value>true</value> . Otherwise, return <value>false</value> .</step>
  <step>NOTE: Any String is a prefix of itself, because <id>r</id> may be the empty String.</step>
</step-list>
<step-list>
  <step>If Type ( <id>x</id> ) is different from Type ( <id>y</id> ), return <value>false</value> .</step>
  <step>If Type ( <id>x</id> ) is Number, then   <step-list>
    <step>If <id>x</id> is <value>NaN</value> and <id>y</id> is <value>NaN</value> , return <value>true</value> .</step>
    <step>If <id>x</id> is <value>+0</value> and <id>y</id> is <value>-0</value> , return <value>false</value> .</step>
    <step>If <id>x</id> is <value>-0</value> and <id>y</id> is <value>+0</value> , return <value>false</value> .</step>
    <step>If <id>x</id> is the same Number value as <id>y</id> , return <value>true</value> .</step>
    <step>Return <value>false</value> .</step>
  </step-list></step>
  <step>Return SameValueNonNumber ( <id>x</id> , <id>y</id> ).</step>
</step-list>
<step-list>
  <step>If Type ( <id>x</id> ) is different from Type ( <id>y</id> ), return <value>false</value> .</step>
  <step>If Type ( <id>x</id> ) is Number, then   <step-list>
    <step>If <id>x</id> is <value>NaN</value> and <id>y</id> is <value>NaN</value> , return <value>true</value> .</step>
    <step>If <id>x</id> is <value>+0</value> and <id>y</id> is <value>-0</value> , return <value>true</value> .</step>
    <step>If <id>x</id> is <value>-0</value> and <id>y</id> is <value>+0</value> , return <value>true</value> .</step>
    <step>If <id>x</id> is the same Number value as <id>y</id> , return <value>true</value> .</step>
    <step>Return <value>false</value> .</step>
  </step-list></step>
  <step>Return SameValueNonNumber ( <id>x</id> , <id>y</id> ).</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>x</id> ) is not Number.</step>
  <step>Assert : Type ( <id>x</id> ) is the same as Type ( <id>y</id> ).</step>
  <step>If Type ( <id>x</id> ) is Undefined, return <value>true</value> .</step>
  <step>If Type ( <id>x</id> ) is Null, return <value>true</value> .</step>
  <step>If Type ( <id>x</id> ) is String, then   <step-list>
    <step>If <id>x</id> and <id>y</id> are exactly the same sequence of code units (same length and same code units at corresponding indices), return <value>true</value> ; otherwise, return <value>false</value> .</step>
  </step-list></step>
  <step>If Type ( <id>x</id> ) is Boolean, then   <step-list>
    <step>If <id>x</id> and <id>y</id> are both <value>true</value> or both <value>false</value> , return <value>true</value> ; otherwise, return <value>false</value> .</step>
  </step-list></step>
  <step>If Type ( <id>x</id> ) is Symbol, then   <step-list>
    <step>If <id>x</id> and <id>y</id> are both the same Symbol value, return <value>true</value> ; otherwise, return <value>false</value> .</step>
  </step-list></step>
  <step>If <id>x</id> and <id>y</id> are the same Object value, return <value>true</value> . Otherwise, return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If the <id>LeftFirst</id> flag is <value>true</value> , then   <step-list>
    <step>Let <id>px</id> be ? ToPrimitive ( <id>x</id> , hint Number).</step>
    <step>Let <id>py</id> be ? ToPrimitive ( <id>y</id> , hint Number).</step>
  </step-list></step>
  <step>Else the order of evaluation needs to be reversed to preserve left to right evaluation,   <step-list>
    <step>Let <id>py</id> be ? ToPrimitive ( <id>y</id> , hint Number).</step>
    <step>Let <id>px</id> be ? ToPrimitive ( <id>x</id> , hint Number).</step>
  </step-list></step>
  <step>If Type ( <id>px</id> ) is String and Type ( <id>py</id> ) is String, then   <step-list>
    <step>If IsStringPrefix ( <id>py</id> , <id>px</id> ) is <value>true</value> , return <value>false</value> .</step>
    <step>If IsStringPrefix ( <id>px</id> , <id>py</id> ) is <value>true</value> , return <value>true</value> .</step>
    <step>Let <id>k</id> be the smallest nonnegative integer such that the code unit at index <id>k</id> within <id>px</id> is different from the code unit at index <id>k</id> within <id>py</id> . (There must be such a <id>k</id> , for neither String is a prefix of the other.)</step>
    <step>Let <id>m</id> be the integer that is the numeric value of the code unit at index <id>k</id> within <id>px</id> .</step>
    <step>Let <id>n</id> be the integer that is the numeric value of the code unit at index <id>k</id> within <id>py</id> .</step>
    <step>If <id>m</id> < <id>n</id> , return <value>true</value> . Otherwise, return <value>false</value> .</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>NOTE: Because <id>px</id> and <id>py</id> are primitive values evaluation order is not important.</step>
    <step>Let <id>nx</id> be ? ToNumber ( <id>px</id> ).</step>
    <step>Let <id>ny</id> be ? ToNumber ( <id>py</id> ).</step>
    <step>If <id>nx</id> is <value>NaN</value> , return <value>undefined</value> .</step>
    <step>If <id>ny</id> is <value>NaN</value> , return <value>undefined</value> .</step>
    <step>If <id>nx</id> and <id>ny</id> are the same Number value, return <value>false</value> .</step>
    <step>If <id>nx</id> is <value>+0</value> and <id>ny</id> is <value>-0</value> , return <value>false</value> .</step>
    <step>If <id>nx</id> is <value>-0</value> and <id>ny</id> is <value>+0</value> , return <value>false</value> .</step>
    <step>If <id>nx</id> is <value>+∞</value> , return <value>false</value> .</step>
    <step>If <id>ny</id> is <value>+∞</value> , return <value>true</value> .</step>
    <step>If <id>ny</id> is <value>-∞</value> , return <value>false</value> .</step>
    <step>If <id>nx</id> is <value>-∞</value> , return <value>true</value> .</step>
    <step>If the mathematical value of <id>nx</id> is less than the mathematical value of <id>ny</id> —note that these mathematical values are both finite and not both zero—return <value>true</value> . Otherwise, return <value>false</value> .</step>
  </step-list></step>
</step-list>
<step-list>
  <step>If Type ( <id>x</id> ) is the same as Type ( <id>y</id> ), then   <step-list>
    <step>Return the result of performing Strict Equality Comparison  <id>x</id> === <id>y</id> .</step>
  </step-list></step>
  <step>If <id>x</id> is <value>null</value> and <id>y</id> is <value>undefined</value> , return <value>true</value> .</step>
  <step>If <id>x</id> is <value>undefined</value> and <id>y</id> is <value>null</value> , return <value>true</value> .</step>
  <step>If Type ( <id>x</id> ) is Number and Type ( <id>y</id> ) is String, return the result of the comparison <id>x</id> == ! ToNumber ( <id>y</id> ).</step>
  <step>If Type ( <id>x</id> ) is String and Type ( <id>y</id> ) is Number, return the result of the comparison ! ToNumber ( <id>x</id> ) == <id>y</id> .</step>
  <step>If Type ( <id>x</id> ) is Boolean, return the result of the comparison ! ToNumber ( <id>x</id> ) == <id>y</id> .</step>
  <step>If Type ( <id>y</id> ) is Boolean, return the result of the comparison <id>x</id> == ! ToNumber ( <id>y</id> ).</step>
  <step>If Type ( <id>x</id> ) is either String, Number, or Symbol and Type ( <id>y</id> ) is Object, return the result of the comparison <id>x</id> == ToPrimitive ( <id>y</id> ).</step>
  <step>If Type ( <id>x</id> ) is Object and Type ( <id>y</id> ) is either String, Number, or Symbol, return the result of the comparison ToPrimitive ( <id>x</id> ) == <id>y</id> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If Type ( <id>x</id> ) is different from Type ( <id>y</id> ), return <value>false</value> .</step>
  <step>If Type ( <id>x</id> ) is Number, then   <step-list>
    <step>If <id>x</id> is <value>NaN</value> , return <value>false</value> .</step>
    <step>If <id>y</id> is <value>NaN</value> , return <value>false</value> .</step>
    <step>If <id>x</id> is the same Number value as <id>y</id> , return <value>true</value> .</step>
    <step>If <id>x</id> is <value>+0</value> and <id>y</id> is <value>-0</value> , return <value>true</value> .</step>
    <step>If <id>x</id> is <value>-0</value> and <id>y</id> is <value>+0</value> , return <value>true</value> .</step>
    <step>Return <value>false</value> .</step>
  </step-list></step>
  <step>Return SameValueNonNumber ( <id>x</id> , <id>y</id> ).</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>O</id> ) is Object.</step>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>Return ? <id>O</id> .[[Get]]( <id>P</id> , <id>O</id> ).</step>
</step-list>
<step-list>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>Let <id>O</id> be ? ToObject ( <id>V</id> ).</step>
  <step>Return ? <id>O</id> .[[Get]]( <id>P</id> , <id>V</id> ).</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>O</id> ) is Object.</step>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>Assert : Type ( <id>Throw</id> ) is Boolean.</step>
  <step>Let <id>success</id> be ? <id>O</id> .[[Set]]( <id>P</id> , <id>V</id> , <id>O</id> ).</step>
  <step>If <id>success</id> is <value>false</value> and <id>Throw</id> is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  <step>Return <id>success</id> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>O</id> ) is Object.</step>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>Let <id>newDesc</id> be the PropertyDescriptor { [[Value]]: <id>V</id> , [[Writable]]: <value>true</value> , [[Enumerable]]: <value>true</value> , [[Configurable]]: <value>true</value> }.</step>
  <step>Return ? <id>O</id> .[[DefineOwnProperty]]( <id>P</id> , <id>newDesc</id> ).</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>O</id> ) is Object.</step>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>Let <id>newDesc</id> be the PropertyDescriptor { [[Value]]: <id>V</id> , [[Writable]]: <value>true</value> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>true</value> }.</step>
  <step>Return ? <id>O</id> .[[DefineOwnProperty]]( <id>P</id> , <id>newDesc</id> ).</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>O</id> ) is Object.</step>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>Let <id>success</id> be ? CreateDataProperty ( <id>O</id> , <id>P</id> , <id>V</id> ).</step>
  <step>If <id>success</id> is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Return <id>success</id> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>O</id> ) is Object.</step>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>Let <id>success</id> be ? <id>O</id> .[[DefineOwnProperty]]( <id>P</id> , <id>desc</id> ).</step>
  <step>If <id>success</id> is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Return <id>success</id> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>O</id> ) is Object.</step>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>Let <id>success</id> be ? <id>O</id> .[[Delete]]( <id>P</id> ).</step>
  <step>If <id>success</id> is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Return <id>success</id> .</step>
</step-list>
<step-list>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>Let <id>func</id> be ? GetV ( <id>V</id> , <id>P</id> ).</step>
  <step>If <id>func</id> is either <value>undefined</value> or <value>null</value> , return <value>undefined</value> .</step>
  <step>If IsCallable ( <id>func</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Return <id>func</id> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>O</id> ) is Object.</step>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>Return ? <id>O</id> .[[HasProperty]]( <id>P</id> ).</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>O</id> ) is Object.</step>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>Let <id>desc</id> be ? <id>O</id> .[[GetOwnProperty]]( <id>P</id> ).</step>
  <step>If <id>desc</id> is <value>undefined</value> , return <value>false</value> .</step>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>If <id>argumentsList</id> is not present, set <id>argumentsList</id> to a new empty List .</step>
  <step>If IsCallable ( <id>F</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Return ? <id>F</id> .[[Call]]( <id>V</id> , <id>argumentsList</id> ).</step>
</step-list>
<step-list>
  <step>If <id>newTarget</id> is not present, set <id>newTarget</id> to <id>F</id> .</step>
  <step>If <id>argumentsList</id> is not present, set <id>argumentsList</id> to a new empty List .</step>
  <step>Assert : IsConstructor ( <id>F</id> ) is <value>true</value> .</step>
  <step>Assert : IsConstructor ( <id>newTarget</id> ) is <value>true</value> .</step>
  <step>Return ? <id>F</id> .[[Construct]]( <id>argumentsList</id> , <id>newTarget</id> ).</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>O</id> ) is Object.</step>
  <step>Assert : <id>level</id> is either <value>"sealed"</value> or <value>"frozen"</value> .</step>
  <step>Let <id>status</id> be ? <id>O</id> .[[PreventExtensions]]().</step>
  <step>If <id>status</id> is <value>false</value> , return <value>false</value> .</step>
  <step>Let <id>keys</id> be ? <id>O</id> .[[OwnPropertyKeys]]().</step>
  <step>If <id>level</id> is <value>"sealed"</value> , then   <step-list>
    <step>For each element <id>k</id> of <id>keys</id> , do     <step-list>
      <step>Perform ? DefinePropertyOrThrow ( <id>O</id> , <id>k</id> , PropertyDescriptor { [[Configurable]]: <value>false</value> }).</step>
    </step-list></step>
  </step-list></step>
  <step>Else <id>level</id> is <value>"frozen"</value> ,   <step-list>
    <step>For each element <id>k</id> of <id>keys</id> , do     <step-list>
      <step>Let <id>currentDesc</id> be ? <id>O</id> .[[GetOwnProperty]]( <id>k</id> ).</step>
      <step>If <id>currentDesc</id> is not <value>undefined</value> , then       <step-list>
        <step>If IsAccessorDescriptor ( <id>currentDesc</id> ) is <value>true</value> , then         <step-list>
          <step>Let <id>desc</id> be the PropertyDescriptor { [[Configurable]]: <value>false</value> }.</step>
        </step-list></step>
        <step>Else,         <step-list>
          <step>Let <id>desc</id> be the PropertyDescriptor { [[Configurable]]: <value>false</value> , [[Writable]]: <value>false</value> }.</step>
        </step-list></step>
        <step>Perform ? DefinePropertyOrThrow ( <id>O</id> , <id>k</id> , <id>desc</id> ).</step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>O</id> ) is Object.</step>
  <step>Assert : <id>level</id> is either <value>"sealed"</value> or <value>"frozen"</value> .</step>
  <step>Let <id>status</id> be ? IsExtensible ( <id>O</id> ).</step>
  <step>If <id>status</id> is <value>true</value> , return <value>false</value> .</step>
  <step>NOTE: If the object is extensible, none of its properties are examined.</step>
  <step>Let <id>keys</id> be ? <id>O</id> .[[OwnPropertyKeys]]().</step>
  <step>For each element <id>k</id> of <id>keys</id> , do   <step-list>
    <step>Let <id>currentDesc</id> be ? <id>O</id> .[[GetOwnProperty]]( <id>k</id> ).</step>
    <step>If <id>currentDesc</id> is not <value>undefined</value> , then     <step-list>
      <step>If <id>currentDesc</id> .[[Configurable]] is <value>true</value> , return <value>false</value> .</step>
      <step>If <id>level</id> is <value>"frozen"</value> and IsDataDescriptor ( <id>currentDesc</id> ) is <value>true</value> , then       <step-list>
        <step>If <id>currentDesc</id> .[[Writable]] is <value>true</value> , return <value>false</value> .</step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Assert : <id>elements</id> is a List whose elements are all ECMAScript language values.</step>
  <step>Let <id>array</id> be ! ArrayCreate (0).</step>
  <step>Let <id>n</id> be 0.</step>
  <step>For each element <id>e</id> of <id>elements</id> , do   <step-list>
    <step>Let <id>status</id> be CreateDataProperty ( <id>array</id> , ! ToString ( <id>n</id> ), <id>e</id> ).</step>
    <step>Assert : <id>status</id> is <value>true</value> .</step>
    <step>Increment <id>n</id> by 1.</step>
  </step-list></step>
  <step>Return <id>array</id> .</step>
</step-list>
<step-list>
  <step>If <id>elementTypes</id> is not present, set <id>elementTypes</id> to « Undefined, Null, Boolean, String, Symbol, Number, Object ».</step>
  <step>If Type ( <id>obj</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>len</id> be ? ToLength (? Get ( <id>obj</id> , <value>"length"</value> )).</step>
  <step>Let <id>list</id> be a new empty List .</step>
  <step>Let <id>index</id> be 0.</step>
  <step>Repeat, while <id>index</id> < <id>len</id>   <step-list>
    <step>Let <id>indexName</id> be ! ToString ( <id>index</id> ).</step>
    <step>Let <id>next</id> be ? Get ( <id>obj</id> , <id>indexName</id> ).</step>
    <step>If Type ( <id>next</id> ) is not an element of <id>elementTypes</id> , throw a <value>TypeError</value> exception.</step>
    <step>Append <id>next</id> as the last element of <id>list</id> .</step>
    <step>Set <id>index</id> to <id>index</id> + 1.</step>
  </step-list></step>
  <step>Return <id>list</id> .</step>
</step-list>
<step-list>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>If <id>argumentsList</id> is not present, set <id>argumentsList</id> to a new empty List .</step>
  <step>Let <id>func</id> be ? GetV ( <id>V</id> , <id>P</id> ).</step>
  <step>Return ? Call ( <id>func</id> , <id>V</id> , <id>argumentsList</id> ).</step>
</step-list>
<step-list>
  <step>If IsCallable ( <id>C</id> ) is <value>false</value> , return <value>false</value> .</step>
  <step>If <id>C</id> has a [[BoundTargetFunction]] internal slot, then   <step-list>
    <step>Let <id>BC</id> be <id>C</id> .[[BoundTargetFunction]].</step>
    <step>Return ? InstanceofOperator ( <id>O</id> , <id>BC</id> ).</step>
  </step-list></step>
  <step>If Type ( <id>O</id> ) is not Object, return <value>false</value> .</step>
  <step>Let <id>P</id> be ? Get ( <id>C</id> , <value>"prototype"</value> ).</step>
  <step>If Type ( <id>P</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Repeat,   <step-list>
    <step>Set <id>O</id> to ? <id>O</id> .[[GetPrototypeOf]]().</step>
    <step>If <id>O</id> is <value>null</value> , return <value>false</value> .</step>
    <step>If SameValue ( <id>P</id> , <id>O</id> ) is <value>true</value> , return <value>true</value> .</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>O</id> ) is Object.</step>
  <step>Let <id>C</id> be ? Get ( <id>O</id> , <value>"constructor"</value> ).</step>
  <step>If <id>C</id> is <value>undefined</value> , return <id>defaultConstructor</id> .</step>
  <step>If Type ( <id>C</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>S</id> be ? Get ( <id>C</id> , @@species).</step>
  <step>If <id>S</id> is either <value>undefined</value> or <value>null</value> , return <id>defaultConstructor</id> .</step>
  <step>If IsConstructor ( <id>S</id> ) is <value>true</value> , return <id>S</id> .</step>
  <step>Throw a <value>TypeError</value> exception.</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>O</id> ) is Object.</step>
  <step>Let <id>ownKeys</id> be ? <id>O</id> .[[OwnPropertyKeys]]().</step>
  <step>Let <id>properties</id> be a new empty List .</step>
  <step>For each element <id>key</id> of <id>ownKeys</id> in List order, do   <step-list>
    <step>If Type ( <id>key</id> ) is String, then     <step-list>
      <step>Let <id>desc</id> be ? <id>O</id> .[[GetOwnProperty]]( <id>key</id> ).</step>
      <step>If <id>desc</id> is not <value>undefined</value> and <id>desc</id> .[[Enumerable]] is <value>true</value> , then       <step-list>
        <step>If <id>kind</id> is <value>"key"</value> , append <id>key</id> to <id>properties</id> .</step>
        <step>Else,         <step-list>
          <step>Let <id>value</id> be ? Get ( <id>O</id> , <id>key</id> ).</step>
          <step>If <id>kind</id> is <value>"value"</value> , append <id>value</id> to <id>properties</id> .</step>
          <step>Else,           <step-list>
            <step>Assert : <id>kind</id> is <value>"key+value"</value> .</step>
            <step>Let <id>entry</id> be CreateArrayFromList (« <id>key</id> , <id>value</id> »).</step>
            <step>Append <id>entry</id> to <id>properties</id> .</step>
          </step-list></step>
        </step-list></step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
  <step>Order the elements of <id>properties</id> so they are in the same relative order as would be produced by the Iterator that would be returned if the EnumerateObjectProperties internal method were invoked with <id>O</id> .</step>
  <step>Return <id>properties</id> .</step>
</step-list>
<step-list>
  <step>Assert : <id>obj</id> is a callable object.</step>
  <step>If <id>obj</id> has a [[Realm]] internal slot, then   <step-list>
    <step>Return <id>obj</id> .[[Realm]].</step>
  </step-list></step>
  <step>If <id>obj</id> is a Bound Function exotic object , then   <step-list>
    <step>Let <id>target</id> be <id>obj</id> .[[BoundTargetFunction]].</step>
    <step>Return ? GetFunctionRealm ( <id>target</id> ).</step>
  </step-list></step>
  <step>If <id>obj</id> is a Proxy exotic object , then   <step-list>
    <step>If <id>obj</id> .[[ProxyHandler]] is <value>null</value> , throw a <value>TypeError</value> exception.</step>
    <step>Let <id>proxyTarget</id> be <id>obj</id> .[[ProxyTarget]].</step>
    <step>Return ? GetFunctionRealm ( <id>proxyTarget</id> ).</step>
  </step-list></step>
  <step>Return the current Realm Record .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>target</id> ) is Object.</step>
  <step>Assert : <id>excludedItems</id> is a List of property keys.</step>
  <step>If <id>source</id> is <value>undefined</value> or <value>null</value> , return <id>target</id> .</step>
  <step>Let <id>from</id> be ! ToObject ( <id>source</id> ).</step>
  <step>Let <id>keys</id> be ? <id>from</id> .[[OwnPropertyKeys]]().</step>
  <step>For each element <id>nextKey</id> of <id>keys</id> in List order, do   <step-list>
    <step>Let <id>excluded</id> be <value>false</value> .</step>
    <step>For each element <id>e</id> of <id>excludedItems</id> in List order, do     <step-list>
      <step>If SameValue ( <id>e</id> , <id>nextKey</id> ) is <value>true</value> , then       <step-list>
        <step>Set <id>excluded</id> to <value>true</value> .</step>
      </step-list></step>
    </step-list></step>
    <step>If <id>excluded</id> is <value>false</value> , then     <step-list>
      <step>Let <id>desc</id> be ? <id>from</id> .[[GetOwnProperty]]( <id>nextKey</id> ).</step>
      <step>If <id>desc</id> is not <value>undefined</value> and <id>desc</id> .[[Enumerable]] is <value>true</value> , then       <step-list>
        <step>Let <id>propValue</id> be ? Get ( <id>from</id> , <id>nextKey</id> ).</step>
        <step>Perform ! CreateDataProperty ( <id>target</id> , <id>nextKey</id> , <id>propValue</id> ).</step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
  <step>Return <id>target</id> .</step>
</step-list>
<step-list>
  <step>If <id>hint</id> is not present, set <id>hint</id> to <value>sync</value> .</step>
  <step>Assert : <id>hint</id> is either <value>sync</value> or <value>async</value> .</step>
  <step>If <id>method</id> is not present, then   <step-list>
    <step>If <id>hint</id> is <value>async</value> , then     <step-list>
      <step>Set <id>method</id> to ? GetMethod ( <id>obj</id> , @@asyncIterator).</step>
      <step>If <id>method</id> is <value>undefined</value> , then       <step-list>
        <step>Let <id>syncMethod</id> be ? GetMethod ( <id>obj</id> , @@iterator).</step>
        <step>Let <id>syncIteratorRecord</id> be ? GetIterator ( <id>obj</id> , <value>sync</value> , <id>syncMethod</id> ).</step>
        <step>Return ? CreateAsyncFromSyncIterator ( <id>syncIteratorRecord</id> ).</step>
      </step-list></step>
    </step-list></step>
    <step>Otherwise, set <id>method</id> to ? GetMethod ( <id>obj</id> , @@iterator).</step>
  </step-list></step>
  <step>Let <id>iterator</id> be ? Call ( <id>method</id> , <id>obj</id> ).</step>
  <step>If Type ( <id>iterator</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>nextMethod</id> be ? GetV ( <id>iterator</id> , <value>"next"</value> ).</step>
  <step>Let <id>iteratorRecord</id> be Record { [[Iterator]]: <id>iterator</id> , [[NextMethod]]: <id>nextMethod</id> , [[Done]]: <value>false</value> }.</step>
  <step>Return <id>iteratorRecord</id> .</step>
</step-list>
<step-list>
  <step>If <id>value</id> is not present, then   <step-list>
    <step>Let <id>result</id> be ? Call ( <id>iteratorRecord</id> .[[NextMethod]], <id>iteratorRecord</id> .[[Iterator]], « »).</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>result</id> be ? Call ( <id>iteratorRecord</id> .[[NextMethod]], <id>iteratorRecord</id> .[[Iterator]], « <id>value</id> »).</step>
  </step-list></step>
  <step>If Type ( <id>result</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Return <id>result</id> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>iterResult</id> ) is Object.</step>
  <step>Return ToBoolean (? Get ( <id>iterResult</id> , <value>"done"</value> )).</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>iterResult</id> ) is Object.</step>
  <step>Return ? Get ( <id>iterResult</id> , <value>"value"</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>result</id> be ? IteratorNext ( <id>iteratorRecord</id> ).</step>
  <step>Let <id>done</id> be ? IteratorComplete ( <id>result</id> ).</step>
  <step>If <id>done</id> is <value>true</value> , return <value>false</value> .</step>
  <step>Return <id>result</id> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>iteratorRecord</id> .[[Iterator]]) is Object.</step>
  <step>Assert : <id>completion</id> is a Completion Record .</step>
  <step>Let <id>iterator</id> be <id>iteratorRecord</id> .[[Iterator]].</step>
  <step>Let <id>return</id> be ? GetMethod ( <id>iterator</id> , <value>"return"</value> ).</step>
  <step>If <id>return</id> is <value>undefined</value> , return Completion ( <id>completion</id> ).</step>
  <step>Let <id>innerResult</id> be Call ( <id>return</id> , <id>iterator</id> , « »).</step>
  <step>If <id>completion</id> .[[Type]] is <value>throw</value> , return Completion ( <id>completion</id> ).</step>
  <step>If <id>innerResult</id> .[[Type]] is <value>throw</value> , return Completion ( <id>innerResult</id> ).</step>
  <step>If Type ( <id>innerResult</id> .[[Value]]) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Return Completion ( <id>completion</id> ).</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>iteratorRecord</id> .[[Iterator]]) is Object.</step>
  <step>Assert : <id>completion</id> is a Completion Record .</step>
  <step>Let <id>iterator</id> be <id>iteratorRecord</id> .[[Iterator]].</step>
  <step>Let <id>return</id> be ? GetMethod ( <id>iterator</id> , <value>"return"</value> ).</step>
  <step>If <id>return</id> is <value>undefined</value> , return Completion ( <id>completion</id> ).</step>
  <step>Let <id>innerResult</id> be Call ( <id>return</id> , <id>iterator</id> , « »).</step>
  <step>If <id>innerResult</id> .[[Type]] is <value>normal</value> , set <id>innerResult</id> to Await ( <id>innerResult</id> .[[Value]]).</step>
  <step>If <id>completion</id> .[[Type]] is <value>throw</value> , return Completion ( <id>completion</id> ).</step>
  <step>If <id>innerResult</id> .[[Type]] is <value>throw</value> , return Completion ( <id>innerResult</id> ).</step>
  <step>If Type ( <id>innerResult</id> .[[Value]]) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Return Completion ( <id>completion</id> ).</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>done</id> ) is Boolean.</step>
  <step>Let <id>obj</id> be ObjectCreate ( %ObjectPrototype% ).</step>
  <step>Perform CreateDataProperty ( <id>obj</id> , <value>"value"</value> , <id>value</id> ).</step>
  <step>Perform CreateDataProperty ( <id>obj</id> , <value>"done"</value> , <id>done</id> ).</step>
  <step>Return <id>obj</id> .</step>
</step-list>
<step-list>
  <step>Let <id>iterator</id> be ObjectCreate ( %IteratorPrototype% , « [[IteratedList]], [[ListIteratorNextIndex]] »).</step>
  <step>Set <id>iterator</id> .[[IteratedList]] to <id>list</id> .</step>
  <step>Set <id>iterator</id> .[[ListIteratorNextIndex]] to 0.</step>
  <step>Let <id>steps</id> be the algorithm steps defined in ListIterator <value>next</value> ( 7.4.9.1 ).</step>
  <step>Let <id>next</id> be CreateBuiltinFunction ( <id>steps</id> , « »).</step>
  <step>Return Record { [[Iterator]]: <id>iterator</id> , [[NextMethod]]: <id>next</id> , [[Done]]: <value>false</value> }.</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>Assert : Type ( <id>O</id> ) is Object.</step>
  <step>Assert : <id>O</id> has an [[IteratedList]] internal slot.</step>
  <step>Let <id>list</id> be <id>O</id> .[[IteratedList]].</step>
  <step>Let <id>index</id> be <id>O</id> .[[ListIteratorNextIndex]].</step>
  <step>Let <id>len</id> be the number of elements of <id>list</id> .</step>
  <step>If <id>index</id> ≥ <id>len</id> , then   <step-list>
    <step>Return CreateIterResultObject ( <value>undefined</value> , <value>true</value> ).</step>
  </step-list></step>
  <step>Set <id>O</id> .[[ListIteratorNextIndex]] to <id>index</id> +1.</step>
  <step>Return CreateIterResultObject ( <id>list</id> [ <id>index</id> ], <value>false</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the declarative Environment Record for which the method was invoked.</step>
  <step>If <id>envRec</id> has a binding for the name that is the value of <id>N</id> , return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the declarative Environment Record for which the method was invoked.</step>
  <step>Assert : <id>envRec</id> does not already have a binding for <id>N</id> .</step>
  <step>Create a mutable binding in <id>envRec</id> for <id>N</id> and record that it is uninitialized. If <id>D</id> is <value>true</value> , record that the newly created binding may be deleted by a subsequent DeleteBinding call.</step>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the declarative Environment Record for which the method was invoked.</step>
  <step>Assert : <id>envRec</id> does not already have a binding for <id>N</id> .</step>
  <step>Create an immutable binding in <id>envRec</id> for <id>N</id> and record that it is uninitialized. If <id>S</id> is <value>true</value> , record that the newly created binding is a strict binding.</step>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the declarative Environment Record for which the method was invoked.</step>
  <step>Assert : <id>envRec</id> must have an uninitialized binding for <id>N</id> .</step>
  <step>Set the bound value for <id>N</id> in <id>envRec</id> to <id>V</id> .</step>
  <step>Record that the binding for <id>N</id> in <id>envRec</id> has been initialized.</step>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the declarative Environment Record for which the method was invoked.</step>
  <step>If <id>envRec</id> does not have a binding for <id>N</id> , then   <step-list>
    <step>If <id>S</id> is <value>true</value> , throw a <value>ReferenceError</value> exception.</step>
    <step>Perform <id>envRec</id> .CreateMutableBinding( <id>N</id> , <value>true</value> ).</step>
    <step>Perform <id>envRec</id> .InitializeBinding( <id>N</id> , <id>V</id> ).</step>
    <step>Return NormalCompletion ( <value>empty</value> ).</step>
  </step-list></step>
  <step>If the binding for <id>N</id> in <id>envRec</id> is a strict binding, set <id>S</id> to <value>true</value> .</step>
  <step>If the binding for <id>N</id> in <id>envRec</id> has not yet been initialized, throw a <value>ReferenceError</value> exception.</step>
  <step>Else if the binding for <id>N</id> in <id>envRec</id> is a mutable binding, change its bound value to <id>V</id> .</step>
  <step>Else,   <step-list>
    <step>Assert : This is an attempt to change the value of an immutable binding.</step>
    <step>If <id>S</id> is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  </step-list></step>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the declarative Environment Record for which the method was invoked.</step>
  <step>Assert : <id>envRec</id> has a binding for <id>N</id> .</step>
  <step>If the binding for <id>N</id> in <id>envRec</id> is an uninitialized binding, throw a <value>ReferenceError</value> exception.</step>
  <step>Return the value currently bound to <id>N</id> in <id>envRec</id> .</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the declarative Environment Record for which the method was invoked.</step>
  <step>Assert : <id>envRec</id> has a binding for the name that is the value of <id>N</id> .</step>
  <step>If the binding for <id>N</id> in <id>envRec</id> cannot be deleted, return <value>false</value> .</step>
  <step>Remove the binding for <id>N</id> from <id>envRec</id> .</step>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the object Environment Record for which the method was invoked.</step>
  <step>Let <id>bindings</id> be the binding object for <id>envRec</id> .</step>
  <step>Let <id>foundBinding</id> be ? HasProperty ( <id>bindings</id> , <id>N</id> ).</step>
  <step>If <id>foundBinding</id> is <value>false</value> , return <value>false</value> .</step>
  <step>If the <id>withEnvironment</id> flag of <id>envRec</id> is <value>false</value> , return <value>true</value> .</step>
  <step>Let <id>unscopables</id> be ? Get ( <id>bindings</id> , @@unscopables).</step>
  <step>If Type ( <id>unscopables</id> ) is Object, then   <step-list>
    <step>Let <id>blocked</id> be ToBoolean (? Get ( <id>unscopables</id> , <id>N</id> )).</step>
    <step>If <id>blocked</id> is <value>true</value> , return <value>false</value> .</step>
  </step-list></step>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the object Environment Record for which the method was invoked.</step>
  <step>Let <id>bindings</id> be the binding object for <id>envRec</id> .</step>
  <step>Return ? DefinePropertyOrThrow ( <id>bindings</id> , <id>N</id> , PropertyDescriptor { [[Value]]: <value>undefined</value> , [[Writable]]: <value>true</value> , [[Enumerable]]: <value>true</value> , [[Configurable]]: <id>D</id> }).</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the object Environment Record for which the method was invoked.</step>
  <step>Assert : <id>envRec</id> must have an uninitialized binding for <id>N</id> .</step>
  <step>Record that the binding for <id>N</id> in <id>envRec</id> has been initialized.</step>
  <step>Return ? <id>envRec</id> .SetMutableBinding( <id>N</id> , <id>V</id> , <value>false</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the object Environment Record for which the method was invoked.</step>
  <step>Let <id>bindings</id> be the binding object for <id>envRec</id> .</step>
  <step>Return ? Set ( <id>bindings</id> , <id>N</id> , <id>V</id> , <id>S</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the object Environment Record for which the method was invoked.</step>
  <step>Let <id>bindings</id> be the binding object for <id>envRec</id> .</step>
  <step>Let <id>value</id> be ? HasProperty ( <id>bindings</id> , <id>N</id> ).</step>
  <step>If <id>value</id> is <value>false</value> , then   <step-list>
    <step>If <id>S</id> is <value>false</value> , return the value <value>undefined</value> ; otherwise throw a <value>ReferenceError</value> exception.</step>
  </step-list></step>
  <step>Return ? Get ( <id>bindings</id> , <id>N</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the object Environment Record for which the method was invoked.</step>
  <step>Let <id>bindings</id> be the binding object for <id>envRec</id> .</step>
  <step>Return ? <id>bindings</id> .[[Delete]]( <id>N</id> ).</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the object Environment Record for which the method was invoked.</step>
  <step>If the <id>withEnvironment</id> flag of <id>envRec</id> is <value>true</value> , return the binding object for <id>envRec</id> .</step>
  <step>Otherwise, return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the function Environment Record for which the method was invoked.</step>
  <step>Assert : <id>envRec</id> .[[ThisBindingStatus]] is not <value>"lexical"</value> .</step>
  <step>If <id>envRec</id> .[[ThisBindingStatus]] is <value>"initialized"</value> , throw a <value>ReferenceError</value> exception.</step>
  <step>Set <id>envRec</id> .[[ThisValue]] to <id>V</id> .</step>
  <step>Set <id>envRec</id> .[[ThisBindingStatus]] to <value>"initialized"</value> .</step>
  <step>Return <id>V</id> .</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the function Environment Record for which the method was invoked.</step>
  <step>If <id>envRec</id> .[[ThisBindingStatus]] is <value>"lexical"</value> , return <value>false</value> ; otherwise, return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the function Environment Record for which the method was invoked.</step>
  <step>If <id>envRec</id> .[[ThisBindingStatus]] is <value>"lexical"</value> , return <value>false</value> .</step>
  <step>If <id>envRec</id> .[[HomeObject]] has the value <value>undefined</value> , return <value>false</value> ; otherwise, return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the function Environment Record for which the method was invoked.</step>
  <step>Assert : <id>envRec</id> .[[ThisBindingStatus]] is not <value>"lexical"</value> .</step>
  <step>If <id>envRec</id> .[[ThisBindingStatus]] is <value>"uninitialized"</value> , throw a <value>ReferenceError</value> exception.</step>
  <step>Return <id>envRec</id> .[[ThisValue]].</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the function Environment Record for which the method was invoked.</step>
  <step>Let <id>home</id> be <id>envRec</id> .[[HomeObject]].</step>
  <step>If <id>home</id> has the value <value>undefined</value> , return <value>undefined</value> .</step>
  <step>Assert : Type ( <id>home</id> ) is Object.</step>
  <step>Return ? <id>home</id> .[[GetPrototypeOf]]().</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the global Environment Record for which the method was invoked.</step>
  <step>Let <id>DclRec</id> be <id>envRec</id> .[[DeclarativeRecord]].</step>
  <step>If <id>DclRec</id> .HasBinding( <id>N</id> ) is <value>true</value> , return <value>true</value> .</step>
  <step>Let <id>ObjRec</id> be <id>envRec</id> .[[ObjectRecord]].</step>
  <step>Return ? <id>ObjRec</id> .HasBinding( <id>N</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the global Environment Record for which the method was invoked.</step>
  <step>Let <id>DclRec</id> be <id>envRec</id> .[[DeclarativeRecord]].</step>
  <step>If <id>DclRec</id> .HasBinding( <id>N</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  <step>Return <id>DclRec</id> .CreateMutableBinding( <id>N</id> , <id>D</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the global Environment Record for which the method was invoked.</step>
  <step>Let <id>DclRec</id> be <id>envRec</id> .[[DeclarativeRecord]].</step>
  <step>If <id>DclRec</id> .HasBinding( <id>N</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  <step>Return <id>DclRec</id> .CreateImmutableBinding( <id>N</id> , <id>S</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the global Environment Record for which the method was invoked.</step>
  <step>Let <id>DclRec</id> be <id>envRec</id> .[[DeclarativeRecord]].</step>
  <step>If <id>DclRec</id> .HasBinding( <id>N</id> ) is <value>true</value> , then   <step-list>
    <step>Return <id>DclRec</id> .InitializeBinding( <id>N</id> , <id>V</id> ).</step>
  </step-list></step>
  <step>Assert : If the binding exists, it must be in the object Environment Record .</step>
  <step>Let <id>ObjRec</id> be <id>envRec</id> .[[ObjectRecord]].</step>
  <step>Return ? <id>ObjRec</id> .InitializeBinding( <id>N</id> , <id>V</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the global Environment Record for which the method was invoked.</step>
  <step>Let <id>DclRec</id> be <id>envRec</id> .[[DeclarativeRecord]].</step>
  <step>If <id>DclRec</id> .HasBinding( <id>N</id> ) is <value>true</value> , then   <step-list>
    <step>Return <id>DclRec</id> .SetMutableBinding( <id>N</id> , <id>V</id> , <id>S</id> ).</step>
  </step-list></step>
  <step>Let <id>ObjRec</id> be <id>envRec</id> .[[ObjectRecord]].</step>
  <step>Return ? <id>ObjRec</id> .SetMutableBinding( <id>N</id> , <id>V</id> , <id>S</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the global Environment Record for which the method was invoked.</step>
  <step>Let <id>DclRec</id> be <id>envRec</id> .[[DeclarativeRecord]].</step>
  <step>If <id>DclRec</id> .HasBinding( <id>N</id> ) is <value>true</value> , then   <step-list>
    <step>Return <id>DclRec</id> .GetBindingValue( <id>N</id> , <id>S</id> ).</step>
  </step-list></step>
  <step>Let <id>ObjRec</id> be <id>envRec</id> .[[ObjectRecord]].</step>
  <step>Return ? <id>ObjRec</id> .GetBindingValue( <id>N</id> , <id>S</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the global Environment Record for which the method was invoked.</step>
  <step>Let <id>DclRec</id> be <id>envRec</id> .[[DeclarativeRecord]].</step>
  <step>If <id>DclRec</id> .HasBinding( <id>N</id> ) is <value>true</value> , then   <step-list>
    <step>Return <id>DclRec</id> .DeleteBinding( <id>N</id> ).</step>
  </step-list></step>
  <step>Let <id>ObjRec</id> be <id>envRec</id> .[[ObjectRecord]].</step>
  <step>Let <id>globalObject</id> be the binding object for <id>ObjRec</id> .</step>
  <step>Let <id>existingProp</id> be ? HasOwnProperty ( <id>globalObject</id> , <id>N</id> ).</step>
  <step>If <id>existingProp</id> is <value>true</value> , then   <step-list>
    <step>Let <id>status</id> be ? <id>ObjRec</id> .DeleteBinding( <id>N</id> ).</step>
    <step>If <id>status</id> is <value>true</value> , then     <step-list>
      <step>Let <id>varNames</id> be <id>envRec</id> .[[VarNames]].</step>
      <step>If <id>N</id> is an element of <id>varNames</id> , remove that element from the <id>varNames</id> .</step>
    </step-list></step>
    <step>Return <id>status</id> .</step>
  </step-list></step>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the global Environment Record for which the method was invoked.</step>
  <step>Return <id>envRec</id> .[[GlobalThisValue]].</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the global Environment Record for which the method was invoked.</step>
  <step>Let <id>varDeclaredNames</id> be <id>envRec</id> .[[VarNames]].</step>
  <step>If <id>varDeclaredNames</id> contains <id>N</id> , return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the global Environment Record for which the method was invoked.</step>
  <step>Let <id>DclRec</id> be <id>envRec</id> .[[DeclarativeRecord]].</step>
  <step>Return <id>DclRec</id> .HasBinding( <id>N</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the global Environment Record for which the method was invoked.</step>
  <step>Let <id>ObjRec</id> be <id>envRec</id> .[[ObjectRecord]].</step>
  <step>Let <id>globalObject</id> be the binding object for <id>ObjRec</id> .</step>
  <step>Let <id>existingProp</id> be ? <id>globalObject</id> .[[GetOwnProperty]]( <id>N</id> ).</step>
  <step>If <id>existingProp</id> is <value>undefined</value> , return <value>false</value> .</step>
  <step>If <id>existingProp</id> .[[Configurable]] is <value>true</value> , return <value>false</value> .</step>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the global Environment Record for which the method was invoked.</step>
  <step>Let <id>ObjRec</id> be <id>envRec</id> .[[ObjectRecord]].</step>
  <step>Let <id>globalObject</id> be the binding object for <id>ObjRec</id> .</step>
  <step>Let <id>hasProperty</id> be ? HasOwnProperty ( <id>globalObject</id> , <id>N</id> ).</step>
  <step>If <id>hasProperty</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return ? IsExtensible ( <id>globalObject</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the global Environment Record for which the method was invoked.</step>
  <step>Let <id>ObjRec</id> be <id>envRec</id> .[[ObjectRecord]].</step>
  <step>Let <id>globalObject</id> be the binding object for <id>ObjRec</id> .</step>
  <step>Let <id>existingProp</id> be ? <id>globalObject</id> .[[GetOwnProperty]]( <id>N</id> ).</step>
  <step>If <id>existingProp</id> is <value>undefined</value> , return ? IsExtensible ( <id>globalObject</id> ).</step>
  <step>If <id>existingProp</id> .[[Configurable]] is <value>true</value> , return <value>true</value> .</step>
  <step>If IsDataDescriptor ( <id>existingProp</id> ) is <value>true</value> and <id>existingProp</id> has attribute values { [[Writable]]: <value>true</value> , [[Enumerable]]: <value>true</value> }, return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the global Environment Record for which the method was invoked.</step>
  <step>Let <id>ObjRec</id> be <id>envRec</id> .[[ObjectRecord]].</step>
  <step>Let <id>globalObject</id> be the binding object for <id>ObjRec</id> .</step>
  <step>Let <id>hasProperty</id> be ? HasOwnProperty ( <id>globalObject</id> , <id>N</id> ).</step>
  <step>Let <id>extensible</id> be ? IsExtensible ( <id>globalObject</id> ).</step>
  <step>If <id>hasProperty</id> is <value>false</value> and <id>extensible</id> is <value>true</value> , then   <step-list>
    <step>Perform ? <id>ObjRec</id> .CreateMutableBinding( <id>N</id> , <id>D</id> ).</step>
    <step>Perform ? <id>ObjRec</id> .InitializeBinding( <id>N</id> , <value>undefined</value> ).</step>
  </step-list></step>
  <step>Let <id>varDeclaredNames</id> be <id>envRec</id> .[[VarNames]].</step>
  <step>If <id>varDeclaredNames</id> does not contain <id>N</id> , then   <step-list>
    <step>Append <id>N</id> to <id>varDeclaredNames</id> .</step>
  </step-list></step>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the global Environment Record for which the method was invoked.</step>
  <step>Let <id>ObjRec</id> be <id>envRec</id> .[[ObjectRecord]].</step>
  <step>Let <id>globalObject</id> be the binding object for <id>ObjRec</id> .</step>
  <step>Let <id>existingProp</id> be ? <id>globalObject</id> .[[GetOwnProperty]]( <id>N</id> ).</step>
  <step>If <id>existingProp</id> is <value>undefined</value> or <id>existingProp</id> .[[Configurable]] is <value>true</value> , then   <step-list>
    <step>Let <id>desc</id> be the PropertyDescriptor { [[Value]]: <id>V</id> , [[Writable]]: <value>true</value> , [[Enumerable]]: <value>true</value> , [[Configurable]]: <id>D</id> }.</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>desc</id> be the PropertyDescriptor { [[Value]]: <id>V</id> }.</step>
  </step-list></step>
  <step>Perform ? DefinePropertyOrThrow ( <id>globalObject</id> , <id>N</id> , <id>desc</id> ).</step>
  <step>Record that the binding for <id>N</id> in <id>ObjRec</id> has been initialized.</step>
  <step>Perform ? Set ( <id>globalObject</id> , <id>N</id> , <id>V</id> , <value>false</value> ).</step>
  <step>Let <id>varDeclaredNames</id> be <id>envRec</id> .[[VarNames]].</step>
  <step>If <id>varDeclaredNames</id> does not contain <id>N</id> , then   <step-list>
    <step>Append <id>N</id> to <id>varDeclaredNames</id> .</step>
  </step-list></step>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Assert : <id>S</id> is <value>true</value> .</step>
  <step>Let <id>envRec</id> be the module Environment Record for which the method was invoked.</step>
  <step>Assert : <id>envRec</id> has a binding for <id>N</id> .</step>
  <step>If the binding for <id>N</id> is an indirect binding, then   <step-list>
    <step>Let <id>M</id> and <id>N2</id> be the indirection values provided when this binding for <id>N</id> was created.</step>
    <step>Let <id>targetEnv</id> be <id>M</id> .[[Environment]].</step>
    <step>If <id>targetEnv</id> is <value>undefined</value> , throw a <value>ReferenceError</value> exception.</step>
    <step>Let <id>targetER</id> be <id>targetEnv</id> 's EnvironmentRecord .</step>
    <step>Return ? <id>targetER</id> .GetBindingValue( <id>N2</id> , <value>true</value> ).</step>
  </step-list></step>
  <step>If the binding for <id>N</id> in <id>envRec</id> is an uninitialized binding, throw a <value>ReferenceError</value> exception.</step>
  <step>Return the value currently bound to <id>N</id> in <id>envRec</id> .</step>
</step-list>
<step-list>
  <step>Assert : This method is never invoked. See 12.5.3.1 .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be the module Environment Record for which the method was invoked.</step>
  <step>Assert : <id>envRec</id> does not already have a binding for <id>N</id> .</step>
  <step>Assert : <id>M</id> is a Module Record .</step>
  <step>Assert : When <id>M</id> .[[Environment]] is instantiated it will have a direct binding for <id>N2</id> .</step>
  <step>Create an immutable indirect binding in <id>envRec</id> for <id>N</id> that references <id>M</id> and <id>N2</id> as its target binding and record that the binding is initialized.</step>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>If <id>lex</id> is the value <value>null</value> , then   <step-list>
    <step>Return a value of type Reference whose base value component is <value>undefined</value> , whose referenced name component is <id>name</id> , and whose strict reference flag is <id>strict</id> .</step>
  </step-list></step>
  <step>Let <id>envRec</id> be <id>lex</id> 's EnvironmentRecord .</step>
  <step>Let <id>exists</id> be ? <id>envRec</id> .HasBinding( <id>name</id> ).</step>
  <step>If <id>exists</id> is <value>true</value> , then   <step-list>
    <step>Return a value of type Reference whose base value component is <id>envRec</id> , whose referenced name component is <id>name</id> , and whose strict reference flag is <id>strict</id> .</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>outer</id> be the value of <id>lex</id> 's outer environment reference.</step>
    <step>Return ? GetIdentifierReference ( <id>outer</id> , <id>name</id> , <id>strict</id> ).</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>env</id> be a new Lexical Environment .</step>
  <step>Let <id>envRec</id> be a new declarative Environment Record containing no bindings.</step>
  <step>Set <id>env</id> 's EnvironmentRecord to <id>envRec</id> .</step>
  <step>Set the outer lexical environment reference of <id>env</id> to <id>E</id> .</step>
  <step>Return <id>env</id> .</step>
</step-list>
<step-list>
  <step>Let <id>env</id> be a new Lexical Environment .</step>
  <step>Let <id>envRec</id> be a new object Environment Record containing <id>O</id> as the binding object.</step>
  <step>Set <id>env</id> 's EnvironmentRecord to <id>envRec</id> .</step>
  <step>Set the outer lexical environment reference of <id>env</id> to <id>E</id> .</step>
  <step>Return <id>env</id> .</step>
</step-list>
<step-list>
  <step>Assert : <id>F</id> is an ECMAScript function.</step>
  <step>Assert : Type ( <id>newTarget</id> ) is Undefined or Object.</step>
  <step>Let <id>env</id> be a new Lexical Environment .</step>
  <step>Let <id>envRec</id> be a new function Environment Record containing no bindings.</step>
  <step>Set <id>envRec</id> .[[FunctionObject]] to <id>F</id> .</step>
  <step>If <id>F</id> .[[ThisMode]] is <value>lexical</value> , set <id>envRec</id> .[[ThisBindingStatus]] to <value>"lexical"</value> .</step>
  <step>Else, set <id>envRec</id> .[[ThisBindingStatus]] to <value>"uninitialized"</value> .</step>
  <step>Let <id>home</id> be <id>F</id> .[[HomeObject]].</step>
  <step>Set <id>envRec</id> .[[HomeObject]] to <id>home</id> .</step>
  <step>Set <id>envRec</id> .[[NewTarget]] to <id>newTarget</id> .</step>
  <step>Set <id>env</id> 's EnvironmentRecord to <id>envRec</id> .</step>
  <step>Set the outer lexical environment reference of <id>env</id> to <id>F</id> .[[Environment]].</step>
  <step>Return <id>env</id> .</step>
</step-list>
<step-list>
  <step>Let <id>env</id> be a new Lexical Environment .</step>
  <step>Let <id>objRec</id> be a new object Environment Record containing <id>G</id> as the binding object.</step>
  <step>Let <id>dclRec</id> be a new declarative Environment Record containing no bindings.</step>
  <step>Let <id>globalRec</id> be a new global Environment Record .</step>
  <step>Set <id>globalRec</id> .[[ObjectRecord]] to <id>objRec</id> .</step>
  <step>Set <id>globalRec</id> .[[GlobalThisValue]] to <id>thisValue</id> .</step>
  <step>Set <id>globalRec</id> .[[DeclarativeRecord]] to <id>dclRec</id> .</step>
  <step>Set <id>globalRec</id> .[[VarNames]] to a new empty List .</step>
  <step>Set <id>env</id> 's EnvironmentRecord to <id>globalRec</id> .</step>
  <step>Set the outer lexical environment reference of <id>env</id> to <value>null</value> .</step>
  <step>Return <id>env</id> .</step>
</step-list>
<step-list>
  <step>Let <id>env</id> be a new Lexical Environment .</step>
  <step>Let <id>envRec</id> be a new module Environment Record containing no bindings.</step>
  <step>Set <id>env</id> 's EnvironmentRecord to <id>envRec</id> .</step>
  <step>Set the outer lexical environment reference of <id>env</id> to <id>E</id> .</step>
  <step>Return <id>env</id> .</step>
</step-list>
<step-list>
  <step>Let <id>realmRec</id> be a new Realm Record .</step>
  <step>Perform CreateIntrinsics ( <id>realmRec</id> ).</step>
  <step>Set <id>realmRec</id> .[[GlobalObject]] to <value>undefined</value> .</step>
  <step>Set <id>realmRec</id> .[[GlobalEnv]] to <value>undefined</value> .</step>
  <step>Set <id>realmRec</id> .[[TemplateMap]] to a new empty List .</step>
  <step>Return <id>realmRec</id> .</step>
</step-list>
<step-list>
  <step>Let <id>intrinsics</id> be a new Record .</step>
  <step>Set <id>realmRec</id> .[[Intrinsics]] to <id>intrinsics</id> .</step>
  <step>Let <id>objProto</id> be ObjectCreate ( <value>null</value> ).</step>
  <step>Set <id>intrinsics</id> .[[ %ObjectPrototype% ]] to <id>objProto</id> .</step>
  <step>Let <id>throwerSteps</id> be the algorithm steps specified in 9.2.9.1 for the %ThrowTypeError% function.</step>
  <step>Let <id>thrower</id> be CreateBuiltinFunction ( <id>throwerSteps</id> , « », <id>realmRec</id> , <value>null</value> ).</step>
  <step>Set <id>intrinsics</id> .[[ %ThrowTypeError% ]] to <id>thrower</id> .</step>
  <step>Let <id>noSteps</id> be an empty sequence of algorithm steps.</step>
  <step>Let <id>funcProto</id> be CreateBuiltinFunction ( <id>noSteps</id> , « », <id>realmRec</id> , <id>objProto</id> ).</step>
  <step>Set <id>intrinsics</id> .[[ %FunctionPrototype% ]] to <id>funcProto</id> .</step>
  <step>Call <id>thrower</id> .[[SetPrototypeOf]]( <id>funcProto</id> ).</step>
  <step>Perform AddRestrictedFunctionProperties ( <id>funcProto</id> , <id>realmRec</id> ).</step>
  <step>Set fields of <id>intrinsics</id> with the values listed in Table 7 that have not already been handled above. The field names are the names
 listed in column one of the table. The value of each field is a new 
object value fully and recursively populated with property values as 
defined by the specification of each object in clauses 18-26. All object
 property values are newly created object values. All values that are 
built-in function objects are created by performing CreateBuiltinFunction (<steps>, <slots>, <id>realmRec</id> ,
 <prototype>) where <steps> is the definition of that 
function provided by this specification, <slots> is a list of the 
names, if any, of the function's specified internal slots, and 
<prototype> is the specified value of the function's [[Prototype]]
 internal slot. The creation of the intrinsics and their properties must
 be ordered to avoid any dependencies upon objects that have not yet 
been created.</step>
  <step>Return <id>intrinsics</id> .</step>
</step-list>
<step-list>
  <step>If <id>globalObj</id> is <value>undefined</value> , then   <step-list>
    <step>Let <id>intrinsics</id> be <id>realmRec</id> .[[Intrinsics]].</step>
    <step>Set <id>globalObj</id> to ObjectCreate ( <id>intrinsics</id> .[[ %ObjectPrototype% ]]).</step>
  </step-list></step>
  <step>Assert : Type ( <id>globalObj</id> ) is Object.</step>
  <step>If <id>thisValue</id> is <value>undefined</value> , set <id>thisValue</id> to <id>globalObj</id> .</step>
  <step>Set <id>realmRec</id> .[[GlobalObject]] to <id>globalObj</id> .</step>
  <step>Let <id>newGlobalEnv</id> be NewGlobalEnvironment ( <id>globalObj</id> , <id>thisValue</id> ).</step>
  <step>Set <id>realmRec</id> .[[GlobalEnv]] to <id>newGlobalEnv</id> .</step>
  <step>Return <id>realmRec</id> .</step>
</step-list>
<step-list>
  <step>Let <id>global</id> be <id>realmRec</id> .[[GlobalObject]].</step>
  <step>For each property of the Global Object specified in clause 18 , do   <step-list>
    <step>Let <id>name</id> be the String value of the property name .</step>
    <step>Let <id>desc</id> be the fully populated data property descriptor for the property containing the specified attributes for the property. For properties listed in 18.2 , 18.3 , or 18.4 the value of the [[Value]] attribute is the corresponding intrinsic object from <id>realmRec</id> .</step>
    <step>Perform ? DefinePropertyOrThrow ( <id>global</id> , <id>name</id> , <id>desc</id> ).</step>
  </step-list></step>
  <step>Return <id>global</id> .</step>
</step-list>
<step-list>
  <step>If the execution context stack is empty, return <value>null</value> .</step>
  <step>Let <id>ec</id> be the topmost execution context on the execution context stack whose ScriptOrModule component is not <value>null</value> .</step>
  <step>If no such execution context exists, return <value>null</value> . Otherwise, return <id>ec</id> 's ScriptOrModule component.</step>
</step-list>
<step-list>
  <step>If <id>env</id> is not present or if <id>env</id> is <value>undefined</value> , then   <step-list>
    <step>Set <id>env</id> to the running execution context 's LexicalEnvironment.</step>
  </step-list></step>
  <step>Assert : <id>env</id> is a Lexical Environment .</step>
  <step>If the code matching the syntactic production that is being evaluated is contained in strict mode code , let <id>strict</id> be <value>true</value> , else let <id>strict</id> be <value>false</value> .</step>
  <step>Return ? GetIdentifierReference ( <id>env</id> , <id>name</id> , <id>strict</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>lex</id> be the running execution context 's LexicalEnvironment.</step>
  <step>Repeat,   <step-list>
    <step>Let <id>envRec</id> be <id>lex</id> 's EnvironmentRecord .</step>
    <step>Let <id>exists</id> be <id>envRec</id> .HasThisBinding().</step>
    <step>If <id>exists</id> is <value>true</value> , return <id>envRec</id> .</step>
    <step>Let <id>outer</id> be the value of <id>lex</id> 's outer environment reference.</step>
    <step>Assert : <id>outer</id> is not <value>null</value> .</step>
    <step>Set <id>lex</id> to <id>outer</id> .</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be GetThisEnvironment ().</step>
  <step>Return ? <id>envRec</id> .GetThisBinding().</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be GetThisEnvironment ().</step>
  <step>Assert : <id>envRec</id> has a [[NewTarget]] field.</step>
  <step>Return <id>envRec</id> .[[NewTarget]].</step>
</step-list>
<step-list>
  <step>Let <id>ctx</id> be the running execution context .</step>
  <step>Let <id>currentRealm</id> be <id>ctx</id> 's Realm .</step>
  <step>Return <id>currentRealm</id> .[[GlobalObject]].</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>queueName</id> ) is String and its value is the name of a Job Queue recognized by this implementation.</step>
  <step>Assert : <id>job</id> is the name of a Job.</step>
  <step>Assert : <id>arguments</id> is a List that has the same number of elements as the number of parameters required by <id>job</id> .</step>
  <step>Let <id>callerContext</id> be the running execution context .</step>
  <step>Let <id>callerRealm</id> be <id>callerContext</id> 's Realm .</step>
  <step>Let <id>callerScriptOrModule</id> be <id>callerContext</id> 's ScriptOrModule.</step>
  <step>Let <id>pending</id> be PendingJob { [[Job]]: <id>job</id> , [[Arguments]]: <id>arguments</id> , [[Realm]]: <id>callerRealm</id> , [[ScriptOrModule]]: <id>callerScriptOrModule</id> , [[HostDefined]]: <value>undefined</value> }.</step>
  <step>Perform any implementation or host environment defined processing of <id>pending</id> . This may include modifying the [[HostDefined]] field or any other field of <id>pending</id> .</step>
  <step>Add <id>pending</id> at the back of the Job Queue named by <id>queueName</id> .</step>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>realm</id> be CreateRealm ().</step>
  <step>Let <id>newContext</id> be a new execution context .</step>
  <step>Set the Function of <id>newContext</id> to <value>null</value> .</step>
  <step>Set the Realm of <id>newContext</id> to <id>realm</id> .</step>
  <step>Set the ScriptOrModule of <id>newContext</id> to <value>null</value> .</step>
  <step>Push <id>newContext</id> onto the execution context stack ; <id>newContext</id> is now the running execution context .</step>
  <step>If the host requires use of an exotic object to serve as <id>realm</id> 's global object , let <id>global</id> be such an object created in an implementation-defined manner. Otherwise, let <id>global</id> be <value>undefined</value> , indicating that an ordinary object should be created as the global object .</step>
  <step>If the host requires that the <value>this</value> binding in <id>realm</id> 's global scope return an object other than the global object , let <id>thisValue</id> be such an object created in an implementation-defined manner. Otherwise, let <id>thisValue</id> be <value>undefined</value> , indicating that <id>realm</id> 's global <value>this</value> binding should be the global object .</step>
  <step>Perform SetRealmGlobalObject ( <id>realm</id> , <id>global</id> , <id>thisValue</id> ).</step>
  <step>Let <id>globalObj</id> be ? SetDefaultGlobalBindings ( <id>realm</id> ).</step>
  <step>Create any implementation-defined global object properties on <id>globalObj</id> .</step>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Perform ? InitializeHostDefinedRealm ().</step>
  <step>In an implementation-dependent manner, obtain the ECMAScript source texts (see clause 10 ) and any associated host-defined values for zero or more ECMAScript scripts and/or ECMAScript modules. For each such <id>sourceText</id> and <id>hostDefined</id> , do   <step-list>
    <step>If <id>sourceText</id> is the source code of a script, then     <step-list>
      <step>Perform EnqueueJob ( <value>"ScriptJobs"</value> , ScriptEvaluationJob , « <id>sourceText</id> , <id>hostDefined</id> »).</step>
    </step-list></step>
    <step>Else <id>sourceText</id> is the source code of a module,     <step-list>
      <step>Perform EnqueueJob ( <value>"ScriptJobs"</value> , TopLevelModuleEvaluationJob , « <id>sourceText</id> , <id>hostDefined</id> »).</step>
    </step-list></step>
  </step-list></step>
  <step>Repeat,   <step-list>
    <step>Suspend the running execution context and remove it from the execution context stack .</step>
    <step>Assert : The execution context stack is now empty.</step>
    <step>Let <id>nextQueue</id> be a non-empty Job Queue chosen in an implementation-defined manner. If
 all Job Queues are empty, the result is implementation-defined.</step>
    <step>Let <id>nextPending</id> be the PendingJob record at the front of <id>nextQueue</id> . Remove that record from <id>nextQueue</id> .</step>
    <step>Let <id>newContext</id> be a new execution context .</step>
    <step>Set <id>newContext</id> 's Function to <value>null</value> .</step>
    <step>Set <id>newContext</id> 's Realm to <id>nextPending</id> .[[Realm]].</step>
    <step>Set <id>newContext</id> 's ScriptOrModule to <id>nextPending</id> .[[ScriptOrModule]].</step>
    <step>Push <id>newContext</id> onto the execution context stack ; <id>newContext</id> is now the running execution context .</step>
    <step>Perform any implementation or host environment defined job initialization using <id>nextPending</id> .</step>
    <step>Let <id>result</id> be the result of performing the abstract operation named by <id>nextPending</id> .[[Job]] using the elements of <id>nextPending</id> .[[Arguments]] as its arguments.</step>
    <step>If <id>result</id> is an abrupt completion , perform HostReportErrors (« <id>result</id> .[[Value]] »).</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>AR</id> be the Agent Record of the surrounding agent .</step>
  <step>Return <id>AR</id> .[[Signifier]].</step>
</step-list>
<step-list>
  <step>Let <id>AR</id> be the Agent Record of the surrounding agent .</step>
  <step>Return <id>AR</id> .[[CanBlock]].</step>
</step-list>
<step-list>
  <step>Return ! OrdinaryGetPrototypeOf ( <id>O</id> ).</step>
</step-list>
<step-list>
  <step>Return <id>O</id> .[[Prototype]].</step>
</step-list>
<step-list>
  <step>Return ! OrdinarySetPrototypeOf ( <id>O</id> , <id>V</id> ).</step>
</step-list>
<step-list>
  <step>Assert : Either Type ( <id>V</id> ) is Object or Type ( <id>V</id> ) is Null.</step>
  <step>Let <id>extensible</id> be <id>O</id> .[[Extensible]].</step>
  <step>Let <id>current</id> be <id>O</id> .[[Prototype]].</step>
  <step>If SameValue ( <id>V</id> , <id>current</id> ) is <value>true</value> , return <value>true</value> .</step>
  <step>If <id>extensible</id> is <value>false</value> , return <value>false</value> .</step>
  <step>Let <id>p</id> be <id>V</id> .</step>
  <step>Let <id>done</id> be <value>false</value> .</step>
  <step>Repeat, while <id>done</id> is <value>false</value> ,   <step-list>
    <step>If <id>p</id> is <value>null</value> , set <id>done</id> to <value>true</value> .</step>
    <step>Else if SameValue ( <id>p</id> , <id>O</id> ) is <value>true</value> , return <value>false</value> .</step>
    <step>Else,     <step-list>
      <step>If <id>p</id> .[[GetPrototypeOf]] is not the ordinary object internal method defined in 9.1.1 , set <id>done</id> to <value>true</value> .</step>
      <step>Else, set <id>p</id> to <id>p</id> .[[Prototype]].</step>
    </step-list></step>
  </step-list></step>
  <step>Set <id>O</id> .[[Prototype]] to <id>V</id> .</step>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return ! OrdinaryIsExtensible ( <id>O</id> ).</step>
</step-list>
<step-list>
  <step>Return <id>O</id> .[[Extensible]].</step>
</step-list>
<step-list>
  <step>Return ! OrdinaryPreventExtensions ( <id>O</id> ).</step>
</step-list>
<step-list>
  <step>Set <id>O</id> .[[Extensible]] to <value>false</value> .</step>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return ! OrdinaryGetOwnProperty ( <id>O</id> , <id>P</id> ).</step>
</step-list>
<step-list>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>If <id>O</id> does not have an own property with key <id>P</id> , return <value>undefined</value> .</step>
  <step>Let <id>D</id> be a newly created Property Descriptor with no fields.</step>
  <step>Let <id>X</id> be <id>O</id> 's own property whose key is <id>P</id> .</step>
  <step>If <id>X</id> is a data property , then   <step-list>
    <step>Set <id>D</id> .[[Value]] to the value of <id>X</id> 's [[Value]] attribute.</step>
    <step>Set <id>D</id> .[[Writable]] to the value of <id>X</id> 's [[Writable]] attribute.</step>
  </step-list></step>
  <step>Else <id>X</id> is an accessor property ,   <step-list>
    <step>Set <id>D</id> .[[Get]] to the value of <id>X</id> 's [[Get]] attribute.</step>
    <step>Set <id>D</id> .[[Set]] to the value of <id>X</id> 's [[Set]] attribute.</step>
  </step-list></step>
  <step>Set <id>D</id> .[[Enumerable]] to the value of <id>X</id> 's [[Enumerable]] attribute.</step>
  <step>Set <id>D</id> .[[Configurable]] to the value of <id>X</id> 's [[Configurable]] attribute.</step>
  <step>Return <id>D</id> .</step>
</step-list>
<step-list>
  <step>Return ? OrdinaryDefineOwnProperty ( <id>O</id> , <id>P</id> , <id>Desc</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>current</id> be ? <id>O</id> .[[GetOwnProperty]]( <id>P</id> ).</step>
  <step>Let <id>extensible</id> be <id>O</id> .[[Extensible]].</step>
  <step>Return ValidateAndApplyPropertyDescriptor ( <id>O</id> , <id>P</id> , <id>extensible</id> , <id>Desc</id> , <id>current</id> ).</step>
</step-list>
<step-list>
  <step>Return ValidateAndApplyPropertyDescriptor ( <value>undefined</value> , <value>undefined</value> , <id>Extensible</id> , <id>Desc</id> , <id>Current</id> ).</step>
</step-list>
<step-list>
  <step>Assert : If <id>O</id> is not <value>undefined</value> , then IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>If <id>current</id> is <value>undefined</value> , then   <step-list>
    <step>If <id>extensible</id> is <value>false</value> , return <value>false</value> .</step>
    <step>Assert : <id>extensible</id> is <value>true</value> .</step>
    <step>If IsGenericDescriptor ( <id>Desc</id> ) is <value>true</value> or IsDataDescriptor ( <id>Desc</id> ) is <value>true</value> , then     <step-list>
      <step>If <id>O</id> is not <value>undefined</value> , create an own data property named <id>P</id> of object <id>O</id> whose [[Value]], [[Writable]], [[Enumerable]] and [[Configurable]] attribute values are described by <id>Desc</id> . If the value of an attribute field of <id>Desc</id> is absent, the attribute of the newly created property is set to its default value.</step>
    </step-list></step>
    <step>Else <id>Desc</id> must be an accessor Property Descriptor ,     <step-list>
      <step>If <id>O</id> is not <value>undefined</value> , create an own accessor property named <id>P</id> of object <id>O</id> whose [[Get]], [[Set]], [[Enumerable]] and [[Configurable]] attribute values are described by <id>Desc</id> . If the value of an attribute field of <id>Desc</id> is absent, the attribute of the newly created property is set to its default value.</step>
    </step-list></step>
    <step>Return <value>true</value> .</step>
  </step-list></step>
  <step>If every field in <id>Desc</id> is absent, return <value>true</value> .</step>
  <step>If <id>current</id> .[[Configurable]] is <value>false</value> , then   <step-list>
    <step>If <id>Desc</id> .[[Configurable]] is present and its value is <value>true</value> , return <value>false</value> .</step>
    <step>If <id>Desc</id> .[[Enumerable]] is present and the [[Enumerable]] fields of <id>current</id> and <id>Desc</id> are the Boolean negation of each other, return <value>false</value> .</step>
  </step-list></step>
  <step>If IsGenericDescriptor ( <id>Desc</id> ) is <value>true</value> , no further validation is required.</step>
  <step>Else if IsDataDescriptor ( <id>current</id> ) and IsDataDescriptor ( <id>Desc</id> ) have different results, then   <step-list>
    <step>If <id>current</id> .[[Configurable]] is <value>false</value> , return <value>false</value> .</step>
    <step>If IsDataDescriptor ( <id>current</id> ) is <value>true</value> , then     <step-list>
      <step>If <id>O</id> is not <value>undefined</value> , convert the property named <id>P</id> of object <id>O</id> from a data property to an accessor property .
 Preserve the existing values of the converted property's 
[[Configurable]] and [[Enumerable]] attributes and set the rest of the 
property's attributes to their default values.</step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>If <id>O</id> is not <value>undefined</value> , convert the property named <id>P</id> of object <id>O</id> from an accessor property to a data property .
 Preserve the existing values of the converted property's 
[[Configurable]] and [[Enumerable]] attributes and set the rest of the 
property's attributes to their default values.</step>
    </step-list></step>
  </step-list></step>
  <step>Else if IsDataDescriptor ( <id>current</id> ) and IsDataDescriptor ( <id>Desc</id> ) are both <value>true</value> , then   <step-list>
    <step>If <id>current</id> .[[Configurable]] is <value>false</value> and <id>current</id> .[[Writable]] is <value>false</value> , then     <step-list>
      <step>If <id>Desc</id> .[[Writable]] is present and <id>Desc</id> .[[Writable]] is <value>true</value> , return <value>false</value> .</step>
      <step>If <id>Desc</id> .[[Value]] is present and SameValue ( <id>Desc</id> .[[Value]], <id>current</id> .[[Value]]) is <value>false</value> , return <value>false</value> .</step>
      <step>Return <value>true</value> .</step>
    </step-list></step>
  </step-list></step>
  <step>Else IsAccessorDescriptor ( <id>current</id> ) and IsAccessorDescriptor ( <id>Desc</id> ) are both <value>true</value> ,   <step-list>
    <step>If <id>current</id> .[[Configurable]] is <value>false</value> , then     <step-list>
      <step>If <id>Desc</id> .[[Set]] is present and SameValue ( <id>Desc</id> .[[Set]], <id>current</id> .[[Set]]) is <value>false</value> , return <value>false</value> .</step>
      <step>If <id>Desc</id> .[[Get]] is present and SameValue ( <id>Desc</id> .[[Get]], <id>current</id> .[[Get]]) is <value>false</value> , return <value>false</value> .</step>
      <step>Return <value>true</value> .</step>
    </step-list></step>
  </step-list></step>
  <step>If <id>O</id> is not <value>undefined</value> , then   <step-list>
    <step>For each field of <id>Desc</id> that is present, set the corresponding attribute of the property named <id>P</id> of object <id>O</id> to the value of the field.</step>
  </step-list></step>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return ? OrdinaryHasProperty ( <id>O</id> , <id>P</id> ).</step>
</step-list>
<step-list>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>Let <id>hasOwn</id> be ? <id>O</id> .[[GetOwnProperty]]( <id>P</id> ).</step>
  <step>If <id>hasOwn</id> is not <value>undefined</value> , return <value>true</value> .</step>
  <step>Let <id>parent</id> be ? <id>O</id> .[[GetPrototypeOf]]().</step>
  <step>If <id>parent</id> is not <value>null</value> , then   <step-list>
    <step>Return ? <id>parent</id> .[[HasProperty]]( <id>P</id> ).</step>
  </step-list></step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return ? OrdinaryGet ( <id>O</id> , <id>P</id> , <id>Receiver</id> ).</step>
</step-list>
<step-list>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>Let <id>desc</id> be ? <id>O</id> .[[GetOwnProperty]]( <id>P</id> ).</step>
  <step>If <id>desc</id> is <value>undefined</value> , then   <step-list>
    <step>Let <id>parent</id> be ? <id>O</id> .[[GetPrototypeOf]]().</step>
    <step>If <id>parent</id> is <value>null</value> , return <value>undefined</value> .</step>
    <step>Return ? <id>parent</id> .[[Get]]( <id>P</id> , <id>Receiver</id> ).</step>
  </step-list></step>
  <step>If IsDataDescriptor ( <id>desc</id> ) is <value>true</value> , return <id>desc</id> .[[Value]].</step>
  <step>Assert : IsAccessorDescriptor ( <id>desc</id> ) is <value>true</value> .</step>
  <step>Let <id>getter</id> be <id>desc</id> .[[Get]].</step>
  <step>If <id>getter</id> is <value>undefined</value> , return <value>undefined</value> .</step>
  <step>Return ? Call ( <id>getter</id> , <id>Receiver</id> ).</step>
</step-list>
<step-list>
  <step>Return ? OrdinarySet ( <id>O</id> , <id>P</id> , <id>V</id> , <id>Receiver</id> ).</step>
</step-list>
<step-list>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>Let <id>ownDesc</id> be ? <id>O</id> .[[GetOwnProperty]]( <id>P</id> ).</step>
  <step>Return OrdinarySetWithOwnDescriptor ( <id>O</id> , <id>P</id> , <id>V</id> , <id>Receiver</id> , <id>ownDesc</id> ).</step>
</step-list>
<step-list>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>If <id>ownDesc</id> is <value>undefined</value> , then   <step-list>
    <step>Let <id>parent</id> be ? <id>O</id> .[[GetPrototypeOf]]().</step>
    <step>If <id>parent</id> is not <value>null</value> , then     <step-list>
      <step>Return ? <id>parent</id> .[[Set]]( <id>P</id> , <id>V</id> , <id>Receiver</id> ).</step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>Set <id>ownDesc</id> to the PropertyDescriptor { [[Value]]: <value>undefined</value> , [[Writable]]: <value>true</value> , [[Enumerable]]: <value>true</value> , [[Configurable]]: <value>true</value> }.</step>
    </step-list></step>
  </step-list></step>
  <step>If IsDataDescriptor ( <id>ownDesc</id> ) is <value>true</value> , then   <step-list>
    <step>If <id>ownDesc</id> .[[Writable]] is <value>false</value> , return <value>false</value> .</step>
    <step>If Type ( <id>Receiver</id> ) is not Object, return <value>false</value> .</step>
    <step>Let <id>existingDescriptor</id> be ? <id>Receiver</id> .[[GetOwnProperty]]( <id>P</id> ).</step>
    <step>If <id>existingDescriptor</id> is not <value>undefined</value> , then     <step-list>
      <step>If IsAccessorDescriptor ( <id>existingDescriptor</id> ) is <value>true</value> , return <value>false</value> .</step>
      <step>If <id>existingDescriptor</id> .[[Writable]] is <value>false</value> , return <value>false</value> .</step>
      <step>Let <id>valueDesc</id> be the PropertyDescriptor { [[Value]]: <id>V</id> }.</step>
      <step>Return ? <id>Receiver</id> .[[DefineOwnProperty]]( <id>P</id> , <id>valueDesc</id> ).</step>
    </step-list></step>
    <step>Else <id>Receiver</id> does not currently have a property <id>P</id> ,     <step-list>
      <step>Return ? CreateDataProperty ( <id>Receiver</id> , <id>P</id> , <id>V</id> ).</step>
    </step-list></step>
  </step-list></step>
  <step>Assert : IsAccessorDescriptor ( <id>ownDesc</id> ) is <value>true</value> .</step>
  <step>Let <id>setter</id> be <id>ownDesc</id> .[[Set]].</step>
  <step>If <id>setter</id> is <value>undefined</value> , return <value>false</value> .</step>
  <step>Perform ? Call ( <id>setter</id> , <id>Receiver</id> , « <id>V</id> »).</step>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return ? OrdinaryDelete ( <id>O</id> , <id>P</id> ).</step>
</step-list>
<step-list>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>Let <id>desc</id> be ? <id>O</id> .[[GetOwnProperty]]( <id>P</id> ).</step>
  <step>If <id>desc</id> is <value>undefined</value> , return <value>true</value> .</step>
  <step>If <id>desc</id> .[[Configurable]] is <value>true</value> , then   <step-list>
    <step>Remove the own property with name <id>P</id> from <id>O</id> .</step>
    <step>Return <value>true</value> .</step>
  </step-list></step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return ! OrdinaryOwnPropertyKeys ( <id>O</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>keys</id> be a new empty List .</step>
  <step>For each own property key <id>P</id> of <id>O</id> that is an integer index , in ascending numeric index order, do   <step-list>
    <step>Add <id>P</id> as the last element of <id>keys</id> .</step>
  </step-list></step>
  <step>For each own property key <id>P</id> of <id>O</id> that is a String but is not an integer index , in ascending chronological order of property creation, do   <step-list>
    <step>Add <id>P</id> as the last element of <id>keys</id> .</step>
  </step-list></step>
  <step>For each own property key <id>P</id> of <id>O</id> that is a Symbol, in ascending chronological order of property creation, do   <step-list>
    <step>Add <id>P</id> as the last element of <id>keys</id> .</step>
  </step-list></step>
  <step>Return <id>keys</id> .</step>
</step-list>
<step-list>
  <step>If <id>internalSlotsList</id> is not present, set <id>internalSlotsList</id> to a new empty List .</step>
  <step>Let <id>obj</id> be a newly created object with an internal slot for each name in <id>internalSlotsList</id> .</step>
  <step>Set <id>obj</id> 's essential internal methods to the default ordinary object definitions specified in 9.1 .</step>
  <step>Set <id>obj</id> .[[Prototype]] to <id>proto</id> .</step>
  <step>Set <id>obj</id> .[[Extensible]] to <value>true</value> .</step>
  <step>Return <id>obj</id> .</step>
</step-list>
<step-list>
  <step>Assert : <id>intrinsicDefaultProto</id> is a String value that is this specification's name of an intrinsic 
object. The corresponding object must be an intrinsic that is intended 
to be used as the [[Prototype]] value of an object.</step>
  <step>Let <id>proto</id> be ? GetPrototypeFromConstructor ( <id>constructor</id> , <id>intrinsicDefaultProto</id> ).</step>
  <step>Return ObjectCreate ( <id>proto</id> , <id>internalSlotsList</id> ).</step>
</step-list>
<step-list>
  <step>Assert : <id>intrinsicDefaultProto</id> is a String value that is this specification's name of an intrinsic 
object. The corresponding object must be an intrinsic that is intended 
to be used as the [[Prototype]] value of an object.</step>
  <step>Assert : IsCallable ( <id>constructor</id> ) is <value>true</value> .</step>
  <step>Let <id>proto</id> be ? Get ( <id>constructor</id> , <value>"prototype"</value> ).</step>
  <step>If Type ( <id>proto</id> ) is not Object, then   <step-list>
    <step>Let <id>realm</id> be ? GetFunctionRealm ( <id>constructor</id> ).</step>
    <step>Set <id>proto</id> to <id>realm</id> 's intrinsic object named <id>intrinsicDefaultProto</id> .</step>
  </step-list></step>
  <step>Return <id>proto</id> .</step>
</step-list>
<step-list>
  <step>Assert : <id>F</id> is an ECMAScript function object .</step>
  <step>If <id>F</id> .[[FunctionKind]] is <value>"classConstructor"</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>callerContext</id> be the running execution context .</step>
  <step>Let <id>calleeContext</id> be PrepareForOrdinaryCall ( <id>F</id> , <value>undefined</value> ).</step>
  <step>Assert : <id>calleeContext</id> is now the running execution context .</step>
  <step>Perform OrdinaryCallBindThis ( <id>F</id> , <id>calleeContext</id> , <id>thisArgument</id> ).</step>
  <step>Let <id>result</id> be OrdinaryCallEvaluateBody ( <id>F</id> , <id>argumentsList</id> ).</step>
  <step>Remove <id>calleeContext</id> from the execution context stack and restore <id>callerContext</id> as the running execution context .</step>
  <step>If <id>result</id> .[[Type]] is <value>return</value> , return NormalCompletion ( <id>result</id> .[[Value]]).</step>
  <step>ReturnIfAbrupt ( <id>result</id> ).</step>
  <step>Return NormalCompletion ( <value>undefined</value> ).</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>newTarget</id> ) is Undefined or Object.</step>
  <step>Let <id>callerContext</id> be the running execution context .</step>
  <step>Let <id>calleeContext</id> be a new ECMAScript code execution context .</step>
  <step>Set the Function of <id>calleeContext</id> to <id>F</id> .</step>
  <step>Let <id>calleeRealm</id> be <id>F</id> .[[Realm]].</step>
  <step>Set the Realm of <id>calleeContext</id> to <id>calleeRealm</id> .</step>
  <step>Set the ScriptOrModule of <id>calleeContext</id> to <id>F</id> .[[ScriptOrModule]].</step>
  <step>Let <id>localEnv</id> be NewFunctionEnvironment ( <id>F</id> , <id>newTarget</id> ).</step>
  <step>Set the LexicalEnvironment of <id>calleeContext</id> to <id>localEnv</id> .</step>
  <step>Set the VariableEnvironment of <id>calleeContext</id> to <id>localEnv</id> .</step>
  <step>If <id>callerContext</id> is not already suspended, suspend <id>callerContext</id> .</step>
  <step>Push <id>calleeContext</id> onto the execution context stack ; <id>calleeContext</id> is now the running execution context .</step>
  <step>NOTE: Any exception objects produced after this point are associated with <id>calleeRealm</id> .</step>
  <step>Return <id>calleeContext</id> .</step>
</step-list>
<step-list>
  <step>Let <id>thisMode</id> be <id>F</id> .[[ThisMode]].</step>
  <step>If <id>thisMode</id> is <value>lexical</value> , return NormalCompletion ( <value>undefined</value> ).</step>
  <step>Let <id>calleeRealm</id> be <id>F</id> .[[Realm]].</step>
  <step>Let <id>localEnv</id> be the LexicalEnvironment of <id>calleeContext</id> .</step>
  <step>If <id>thisMode</id> is <value>strict</value> , let <id>thisValue</id> be <id>thisArgument</id> .</step>
  <step>Else,   <step-list>
    <step>If <id>thisArgument</id> is <value>undefined</value> or <value>null</value> , then     <step-list>
      <step>Let <id>globalEnv</id> be <id>calleeRealm</id> .[[GlobalEnv]].</step>
      <step>Let <id>globalEnvRec</id> be <id>globalEnv</id> 's EnvironmentRecord .</step>
      <step>Assert : <id>globalEnvRec</id> is a global Environment Record .</step>
      <step>Let <id>thisValue</id> be <id>globalEnvRec</id> .[[GlobalThisValue]].</step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>Let <id>thisValue</id> be ! ToObject ( <id>thisArgument</id> ).</step>
      <step>NOTE: ToObject produces wrapper objects using <id>calleeRealm</id> .</step>
    </step-list></step>
  </step-list></step>
  <step>Let <id>envRec</id> be <id>localEnv</id> 's EnvironmentRecord .</step>
  <step>Assert : <id>envRec</id> is a function Environment Record .</step>
  <step>Assert : The next step never returns an abrupt completion because <id>envRec</id> .[[ThisBindingStatus]] is not <value>"initialized"</value> .</step>
  <step>Return <id>envRec</id> .BindThisValue( <id>thisValue</id> ).</step>
</step-list>
<step-list>
  <step>Return the result of EvaluateBody of the parsed code that is <id>F</id> .[[ECMAScriptCode]] passing <id>F</id> and <id>argumentsList</id> as the arguments.</step>
</step-list>
<step-list>
  <step>Assert : <id>F</id> is an ECMAScript function object .</step>
  <step>Assert : Type ( <id>newTarget</id> ) is Object.</step>
  <step>Let <id>callerContext</id> be the running execution context .</step>
  <step>Let <id>kind</id> be <id>F</id> .[[ConstructorKind]].</step>
  <step>If <id>kind</id> is <value>"base"</value> , then   <step-list>
    <step>Let <id>thisArgument</id> be ? OrdinaryCreateFromConstructor ( <id>newTarget</id> , <value>"%ObjectPrototype%"</value> ).</step>
  </step-list></step>
  <step>Let <id>calleeContext</id> be PrepareForOrdinaryCall ( <id>F</id> , <id>newTarget</id> ).</step>
  <step>Assert : <id>calleeContext</id> is now the running execution context .</step>
  <step>If <id>kind</id> is <value>"base"</value> , perform OrdinaryCallBindThis ( <id>F</id> , <id>calleeContext</id> , <id>thisArgument</id> ).</step>
  <step>Let <id>constructorEnv</id> be the LexicalEnvironment of <id>calleeContext</id> .</step>
  <step>Let <id>envRec</id> be <id>constructorEnv</id> 's EnvironmentRecord .</step>
  <step>Let <id>result</id> be OrdinaryCallEvaluateBody ( <id>F</id> , <id>argumentsList</id> ).</step>
  <step>Remove <id>calleeContext</id> from the execution context stack and restore <id>callerContext</id> as the running execution context .</step>
  <step>If <id>result</id> .[[Type]] is <value>return</value> , then   <step-list>
    <step>If Type ( <id>result</id> .[[Value]]) is Object, return NormalCompletion ( <id>result</id> .[[Value]]).</step>
    <step>If <id>kind</id> is <value>"base"</value> , return NormalCompletion ( <id>thisArgument</id> ).</step>
    <step>If <id>result</id> .[[Value]] is not <value>undefined</value> , throw a <value>TypeError</value> exception.</step>
  </step-list></step>
  <step>Else, ReturnIfAbrupt ( <id>result</id> ).</step>
  <step>Return ? <id>envRec</id> .GetThisBinding().</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>functionPrototype</id> ) is Object.</step>
  <step>Assert : <id>functionKind</id> is either <value>"normal"</value> , <value>"non-constructor"</value> , <value>"generator"</value> , <value>"async"</value> , or <value>"async generator"</value> .</step>
  <step>If <id>functionKind</id> is <value>"normal"</value> , let <id>needsConstruct</id> be <value>true</value> .</step>
  <step>Else, let <id>needsConstruct</id> be <value>false</value> .</step>
  <step>If <id>functionKind</id> is <value>"non-constructor"</value> , set <id>functionKind</id> to <value>"normal"</value> .</step>
  <step>Let <id>F</id> be a newly created ECMAScript function object with the internal slots listed in Table 27 . All of those internal slots are initialized to <value>undefined</value> .</step>
  <step>Set <id>F</id> 's essential internal methods to the default ordinary object definitions specified in 9.1 .</step>
  <step>Set <id>F</id> .[[Call]] to the definition specified in 9.2.1 .</step>
  <step>If <id>needsConstruct</id> is <value>true</value> , then   <step-list>
    <step>Set <id>F</id> .[[Construct]] to the definition specified in 9.2.2 .</step>
    <step>Set <id>F</id> .[[ConstructorKind]] to <value>"base"</value> .</step>
  </step-list></step>
  <step>Set <id>F</id> .[[Strict]] to <id>strict</id> .</step>
  <step>Set <id>F</id> .[[FunctionKind]] to <id>functionKind</id> .</step>
  <step>Set <id>F</id> .[[Prototype]] to <id>functionPrototype</id> .</step>
  <step>Set <id>F</id> .[[Extensible]] to <value>true</value> .</step>
  <step>Set <id>F</id> .[[Realm]] to the current Realm Record .</step>
  <step>Return <id>F</id> .</step>
</step-list>
<step-list>
  <step>Let <id>len</id> be the ExpectedArgumentCount of <id>ParameterList</id> .</step>
  <step>Perform ! SetFunctionLength ( <id>F</id> , <id>len</id> ).</step>
  <step>Let <id>Strict</id> be <id>F</id> .[[Strict]].</step>
  <step>Set <id>F</id> .[[Environment]] to <id>Scope</id> .</step>
  <step>Set <id>F</id> .[[FormalParameters]] to <id>ParameterList</id> .</step>
  <step>Set <id>F</id> .[[ECMAScriptCode]] to <id>Body</id> .</step>
  <step>Set <id>F</id> .[[ScriptOrModule]] to GetActiveScriptOrModule ().</step>
  <step>If <id>kind</id> is <value>Arrow</value> , set <id>F</id> .[[ThisMode]] to <value>lexical</value> .</step>
  <step>Else if <id>Strict</id> is <value>true</value> , set <id>F</id> .[[ThisMode]] to <value>strict</value> .</step>
  <step>Else, set <id>F</id> .[[ThisMode]] to <value>global</value> .</step>
  <step>Return <id>F</id> .</step>
</step-list>
<step-list>
  <step>If <id>prototype</id> is not present, then   <step-list>
    <step>Set <id>prototype</id> to the intrinsic object %FunctionPrototype% .</step>
  </step-list></step>
  <step>If <id>kind</id> is not <value>Normal</value> , let <id>allocKind</id> be <value>"non-constructor"</value> .</step>
  <step>Else, let <id>allocKind</id> be <value>"normal"</value> .</step>
  <step>Let <id>F</id> be FunctionAllocate ( <id>prototype</id> , <id>Strict</id> , <id>allocKind</id> ).</step>
  <step>Return FunctionInitialize ( <id>F</id> , <id>kind</id> , <id>ParameterList</id> , <id>Body</id> , <id>Scope</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>functionPrototype</id> be the intrinsic object %Generator% .</step>
  <step>Let <id>F</id> be FunctionAllocate ( <id>functionPrototype</id> , <id>Strict</id> , <value>"generator"</value> ).</step>
  <step>Return FunctionInitialize ( <id>F</id> , <id>kind</id> , <id>ParameterList</id> , <id>Body</id> , <id>Scope</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>functionPrototype</id> be the intrinsic object %AsyncGenerator% .</step>
  <step>Let <id>F</id> be ! FunctionAllocate ( <id>functionPrototype</id> , <id>Strict</id> , <value>"generator"</value> ).</step>
  <step>Return ! FunctionInitialize ( <id>F</id> , <id>kind</id> , <id>ParameterList</id> , <id>Body</id> , <id>Scope</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>functionPrototype</id> be the intrinsic object %AsyncFunctionPrototype% .</step>
  <step>Let <id>F</id> be ! FunctionAllocate ( <id>functionPrototype</id> , <id>Strict</id> , <value>"async"</value> ).</step>
  <step>Return ! FunctionInitialize ( <id>F</id> , <id>kind</id> , <id>parameters</id> , <id>body</id> , <id>Scope</id> ).</step>
</step-list>
<step-list>
  <step>Assert : <id>realm</id> .[[Intrinsics]].[[ %ThrowTypeError% ]] exists and has been initialized.</step>
  <step>Let <id>thrower</id> be <id>realm</id> .[[Intrinsics]].[[ %ThrowTypeError% ]].</step>
  <step>Perform ! DefinePropertyOrThrow ( <id>F</id> , <value>"caller"</value> , PropertyDescriptor { [[Get]]: <id>thrower</id> , [[Set]]: <id>thrower</id> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>true</value> }).</step>
  <step>Return ! DefinePropertyOrThrow ( <id>F</id> , <value>"arguments"</value> , PropertyDescriptor { [[Get]]: <id>thrower</id> , [[Set]]: <id>thrower</id> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>true</value> }).</step>
</step-list>
<step-list>
  <step>Throw a <value>TypeError</value> exception.</step>
</step-list>
<step-list>
  <step>Assert : <id>F</id> is an ECMAScript function object .</step>
  <step>Assert : IsConstructor ( <id>F</id> ) is <value>true</value> .</step>
  <step>Assert : <id>F</id> is an extensible object that does not have a <value>prototype</value> own property.</step>
  <step>If <id>writablePrototype</id> is not present, set <id>writablePrototype</id> to <value>true</value> .</step>
  <step>If <id>prototype</id> is not present, then   <step-list>
    <step>Set <id>prototype</id> to ObjectCreate ( %ObjectPrototype% ).</step>
    <step>Perform ! DefinePropertyOrThrow ( <id>prototype</id> , <value>"constructor"</value> , PropertyDescriptor { [[Value]]: <id>F</id> , [[Writable]]: <id>writablePrototype</id> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>true</value> }).</step>
  </step-list></step>
  <step>Perform ! DefinePropertyOrThrow ( <id>F</id> , <value>"prototype"</value> , PropertyDescriptor { [[Value]]: <id>prototype</id> , [[Writable]]: <id>writablePrototype</id> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>false</value> }).</step>
  <step>Return NormalCompletion ( <value>undefined</value> ).</step>
</step-list>
<step-list>
  <step>Assert : <id>F</id> is an ECMAScript function object .</step>
  <step>Assert : <id>F</id> .[[FunctionKind]] is <value>"normal"</value> .</step>
  <step>Set <id>F</id> .[[FunctionKind]] to <value>"classConstructor"</value> .</step>
  <step>Return NormalCompletion ( <value>undefined</value> ).</step>
</step-list>
<step-list>
  <step>Assert : <id>F</id> is an ECMAScript function object .</step>
  <step>Assert : Type ( <id>homeObject</id> ) is Object.</step>
  <step>Set <id>F</id> .[[HomeObject]] to <id>homeObject</id> .</step>
  <step>Return NormalCompletion ( <value>undefined</value> ).</step>
</step-list>
<step-list>
  <step>Assert : <id>F</id> is an extensible object that does not have a <value>name</value> own property.</step>
  <step>Assert : Type ( <id>name</id> ) is either Symbol or String.</step>
  <step>Assert : If <id>prefix</id> is present, then Type ( <id>prefix</id> ) is String.</step>
  <step>If Type ( <id>name</id> ) is Symbol, then   <step-list>
    <step>Let <id>description</id> be <id>name</id> 's [[Description]] value.</step>
    <step>If <id>description</id> is <value>undefined</value> , set <id>name</id> to the empty String.</step>
    <step>Else, set <id>name</id> to the string-concatenation of <value>"["</value> , <id>description</id> , and <value>"]"</value> .</step>
  </step-list></step>
  <step>If <id>prefix</id> is present, then   <step-list>
    <step>Set <id>name</id> to the string-concatenation of <id>prefix</id> , the code unit 0x0020 (SPACE), and <id>name</id> .</step>
  </step-list></step>
  <step>Return ! DefinePropertyOrThrow ( <id>F</id> , <value>"name"</value> , PropertyDescriptor { [[Value]]: <id>name</id> , [[Writable]]: <value>false</value> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>true</value> }).</step>
</step-list>
<step-list>
  <step>Assert : <id>F</id> is an extensible object that does not have a <value>length</value> own property.</step>
  <step>Assert : Type ( <id>length</id> ) is Number.</step>
  <step>Assert : <id>length</id> ≥ 0 and ! ToInteger ( <id>length</id> ) is equal to <id>length</id> .</step>
  <step>Return ! DefinePropertyOrThrow ( <id>F</id> , <value>"length"</value> , PropertyDescriptor { [[Value]]: <id>length</id> , [[Writable]]: <value>false</value> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>true</value> }).</step>
</step-list>
<step-list>
  <step>Let <id>calleeContext</id> be the running execution context .</step>
  <step>Let <id>env</id> be the LexicalEnvironment of <id>calleeContext</id> .</step>
  <step>Let <id>envRec</id> be <id>env</id> 's EnvironmentRecord .</step>
  <step>Let <id>code</id> be <id>func</id> .[[ECMAScriptCode]].</step>
  <step>Let <id>strict</id> be <id>func</id> .[[Strict]].</step>
  <step>Let <id>formals</id> be <id>func</id> .[[FormalParameters]].</step>
  <step>Let <id>parameterNames</id> be the BoundNames of <id>formals</id> .</step>
  <step>If <id>parameterNames</id> has any duplicate entries, let <id>hasDuplicates</id> be <value>true</value> . Otherwise, let <id>hasDuplicates</id> be <value>false</value> .</step>
  <step>Let <id>simpleParameterList</id> be IsSimpleParameterList of <id>formals</id> .</step>
  <step>Let <id>hasParameterExpressions</id> be ContainsExpression of <id>formals</id> .</step>
  <step>Let <id>varNames</id> be the VarDeclaredNames of <id>code</id> .</step>
  <step>Let <id>varDeclarations</id> be the VarScopedDeclarations of <id>code</id> .</step>
  <step>Let <id>lexicalNames</id> be the LexicallyDeclaredNames of <id>code</id> .</step>
  <step>Let <id>functionNames</id> be a new empty List .</step>
  <step>Let <id>functionsToInitialize</id> be a new empty List .</step>
  <step>For each <id>d</id> in <id>varDeclarations</id> , in reverse list order, do   <step-list>
    <step>If <id>d</id> is neither a VariableDeclaration nor a ForBinding nor a BindingIdentifier , then     <step-list>
      <step>Assert : <id>d</id> is either a FunctionDeclaration , a GeneratorDeclaration , an AsyncFunctionDeclaration , or an AsyncGeneratorDeclaration .</step>
      <step>Let <id>fn</id> be the sole element of the BoundNames of <id>d</id> .</step>
      <step>If <id>fn</id> is not an element of <id>functionNames</id> , then       <step-list>
        <step>Insert <id>fn</id> as the first element of <id>functionNames</id> .</step>
        <step>NOTE: If there are multiple function declarations for the same name, the last declaration is used.</step>
        <step>Insert <id>d</id> as the first element of <id>functionsToInitialize</id> .</step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
  <step>Let <id>argumentsObjectNeeded</id> be <value>true</value> .</step>
  <step>If <id>func</id> .[[ThisMode]] is <value>lexical</value> , then   <step-list>
    <step>NOTE: Arrow functions never have an arguments objects.</step>
    <step>Set <id>argumentsObjectNeeded</id> to <value>false</value> .</step>
  </step-list></step>
  <step>Else if <value>"arguments"</value> is an element of <id>parameterNames</id> , then   <step-list>
    <step>Set <id>argumentsObjectNeeded</id> to <value>false</value> .</step>
  </step-list></step>
  <step>Else if <id>hasParameterExpressions</id> is <value>false</value> , then   <step-list>
    <step>If <value>"arguments"</value> is an element of <id>functionNames</id> or if <value>"arguments"</value> is an element of <id>lexicalNames</id> , then     <step-list>
      <step>Set <id>argumentsObjectNeeded</id> to <value>false</value> .</step>
    </step-list></step>
  </step-list></step>
  <step>For each String <id>paramName</id> in <id>parameterNames</id> , do   <step-list>
    <step>Let <id>alreadyDeclared</id> be <id>envRec</id> .HasBinding( <id>paramName</id> ).</step>
    <step>NOTE:
 Early errors ensure that duplicate parameter names can only occur in 
non-strict functions that do not have parameter default values or rest 
parameters.</step>
    <step>If <id>alreadyDeclared</id> is <value>false</value> , then     <step-list>
      <step>Perform ! <id>envRec</id> .CreateMutableBinding( <id>paramName</id> , <value>false</value> ).</step>
      <step>If <id>hasDuplicates</id> is <value>true</value> , then       <step-list>
        <step>Perform ! <id>envRec</id> .InitializeBinding( <id>paramName</id> , <value>undefined</value> ).</step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
  <step>If <id>argumentsObjectNeeded</id> is <value>true</value> , then   <step-list>
    <step>If <id>strict</id> is <value>true</value> or if <id>simpleParameterList</id> is <value>false</value> , then     <step-list>
      <step>Let <id>ao</id> be CreateUnmappedArgumentsObject ( <id>argumentsList</id> ).</step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>NOTE:
 mapped argument object is only provided for non-strict functions that 
don't have a rest parameter, any parameter default value initializers, 
or any destructured parameters.</step>
      <step>Let <id>ao</id> be CreateMappedArgumentsObject ( <id>func</id> , <id>formals</id> , <id>argumentsList</id> , <id>envRec</id> ).</step>
    </step-list></step>
    <step>If <id>strict</id> is <value>true</value> , then     <step-list>
      <step>Perform ! <id>envRec</id> .CreateImmutableBinding( <value>"arguments"</value> , <value>false</value> ).</step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>Perform ! <id>envRec</id> .CreateMutableBinding( <value>"arguments"</value> , <value>false</value> ).</step>
    </step-list></step>
    <step>Call <id>envRec</id> .InitializeBinding( <value>"arguments"</value> , <id>ao</id> ).</step>
    <step>Let <id>parameterBindings</id> be a new List of <id>parameterNames</id> with <value>"arguments"</value> appended.</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>parameterBindings</id> be <id>parameterNames</id> .</step>
  </step-list></step>
  <step>Let <id>iteratorRecord</id> be CreateListIteratorRecord ( <id>argumentsList</id> ).</step>
  <step>If <id>hasDuplicates</id> is <value>true</value> , then   <step-list>
    <step>Perform ? IteratorBindingInitialization for <id>formals</id> with <id>iteratorRecord</id> and <value>undefined</value> as arguments.</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Perform ? IteratorBindingInitialization for <id>formals</id> with <id>iteratorRecord</id> and <id>env</id> as arguments.</step>
  </step-list></step>
  <step>If <id>hasParameterExpressions</id> is <value>false</value> , then   <step-list>
    <step>NOTE: Only a single lexical environment is needed for the parameters and top-level vars.</step>
    <step>Let <id>instantiatedVarNames</id> be a copy of the List  <id>parameterBindings</id> .</step>
    <step>For each <id>n</id> in <id>varNames</id> , do     <step-list>
      <step>If <id>n</id> is not an element of <id>instantiatedVarNames</id> , then       <step-list>
        <step>Append <id>n</id> to <id>instantiatedVarNames</id> .</step>
        <step>Perform ! <id>envRec</id> .CreateMutableBinding( <id>n</id> , <value>false</value> ).</step>
        <step>Call <id>envRec</id> .InitializeBinding( <id>n</id> , <value>undefined</value> ).</step>
      </step-list></step>
    </step-list></step>
    <step>Let <id>varEnv</id> be <id>env</id> .</step>
    <step>Let <id>varEnvRec</id> be <id>envRec</id> .</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>NOTE: A separate Environment Record is needed to ensure that closures created by expressions in the formal 
parameter list do not have visibility of declarations in the function 
body.</step>
    <step>Let <id>varEnv</id> be NewDeclarativeEnvironment ( <id>env</id> ).</step>
    <step>Let <id>varEnvRec</id> be <id>varEnv</id> 's EnvironmentRecord .</step>
    <step>Set the VariableEnvironment of <id>calleeContext</id> to <id>varEnv</id> .</step>
    <step>Let <id>instantiatedVarNames</id> be a new empty List .</step>
    <step>For each <id>n</id> in <id>varNames</id> , do     <step-list>
      <step>If <id>n</id> is not an element of <id>instantiatedVarNames</id> , then       <step-list>
        <step>Append <id>n</id> to <id>instantiatedVarNames</id> .</step>
        <step>Perform ! <id>varEnvRec</id> .CreateMutableBinding( <id>n</id> , <value>false</value> ).</step>
        <step>If <id>n</id> is not an element of <id>parameterBindings</id> or if <id>n</id> is an element of <id>functionNames</id> , let <id>initialValue</id> be <value>undefined</value> .</step>
        <step>Else,         <step-list>
          <step>Let <id>initialValue</id> be ! <id>envRec</id> .GetBindingValue( <id>n</id> , <value>false</value> ).</step>
        </step-list></step>
        <step>Call <id>varEnvRec</id> .InitializeBinding( <id>n</id> , <id>initialValue</id> ).</step>
        <step>NOTE:
 vars whose names are the same as a formal parameter, initially have the
 same value as the corresponding initialized parameter.</step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
  <step>NOTE: Annex B.3.3.1 adds additional steps at this point.</step>
  <step>If <id>strict</id> is <value>false</value> , then   <step-list>
    <step>Let <id>lexEnv</id> be NewDeclarativeEnvironment ( <id>varEnv</id> ).</step>
    <step>NOTE: Non-strict functions use a separate lexical Environment Record for top-level lexical declarations so that a direct eval can determine whether any var scoped declarations introduced by the 
eval code conflict with pre-existing top-level lexically scoped 
declarations. This is not needed for strict functions because a strict direct eval always places all declarations into a new Environment Record .</step>
  </step-list></step>
  <step>Else, let <id>lexEnv</id> be <id>varEnv</id> .</step>
  <step>Let <id>lexEnvRec</id> be <id>lexEnv</id> 's EnvironmentRecord .</step>
  <step>Set the LexicalEnvironment of <id>calleeContext</id> to <id>lexEnv</id> .</step>
  <step>Let <id>lexDeclarations</id> be the LexicallyScopedDeclarations of <id>code</id> .</step>
  <step>For each element <id>d</id> in <id>lexDeclarations</id> , do   <step-list>
    <step>NOTE:
 A lexically declared name cannot be the same as a function/generator 
declaration, formal parameter, or a var name. Lexically declared names 
are only instantiated here but not initialized.</step>
    <step>For each element <id>dn</id> of the BoundNames of <id>d</id> , do     <step-list>
      <step>If IsConstantDeclaration of <id>d</id> is <value>true</value> , then       <step-list>
        <step>Perform ! <id>lexEnvRec</id> .CreateImmutableBinding( <id>dn</id> , <value>true</value> ).</step>
      </step-list></step>
      <step>Else,       <step-list>
        <step>Perform ! <id>lexEnvRec</id> .CreateMutableBinding( <id>dn</id> , <value>false</value> ).</step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
  <step>For each Parse Node  <id>f</id> in <id>functionsToInitialize</id> , do   <step-list>
    <step>Let <id>fn</id> be the sole element of the BoundNames of <id>f</id> .</step>
    <step>Let <id>fo</id> be the result of performing InstantiateFunctionObject for <id>f</id> with argument <id>lexEnv</id> .</step>
    <step>Perform ! <id>varEnvRec</id> .SetMutableBinding( <id>fn</id> , <id>fo</id> , <value>false</value> ).</step>
  </step-list></step>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>callerContext</id> be the running execution context .</step>
  <step>If <id>callerContext</id> is not already suspended, suspend <id>callerContext</id> .</step>
  <step>Let <id>calleeContext</id> be a new ECMAScript code execution context .</step>
  <step>Set the Function of <id>calleeContext</id> to <id>F</id> .</step>
  <step>Let <id>calleeRealm</id> be <id>F</id> .[[Realm]].</step>
  <step>Set the Realm of <id>calleeContext</id> to <id>calleeRealm</id> .</step>
  <step>Set the ScriptOrModule of <id>calleeContext</id> to <id>F</id> .[[ScriptOrModule]].</step>
  <step>Perform any necessary implementation-defined initialization of <id>calleeContext</id> .</step>
  <step>Push <id>calleeContext</id> onto the execution context stack ; <id>calleeContext</id> is now the running execution context .</step>
  <step>Let <id>result</id> be the Completion Record that is the result of evaluating <id>F</id> in an implementation-defined manner that conforms to the specification of <id>F</id> . <id>thisArgument</id> is the <value>this</value> value, <id>argumentsList</id> provides the named parameters, and the NewTarget value is <value>undefined</value> .</step>
  <step>Remove <id>calleeContext</id> from the execution context stack and restore <id>callerContext</id> as the running execution context .</step>
  <step>Return <id>result</id> .</step>
</step-list>
<step-list>
  <step>Let <id>result</id> be the Completion Record that is the result of evaluating <id>F</id> in an implementation-defined manner that conforms to the specification of <id>F</id> . The <value>this</value> value is uninitialized, <id>argumentsList</id> provides the named parameters, and <id>newTarget</id> provides the NewTarget value.</step>
</step-list>
<step-list>
  <step>Assert : <id>steps</id> is either a set of algorithm steps or other definition of a function's behaviour provided in this specification.</step>
  <step>If <id>realm</id> is not present, set <id>realm</id> to the current Realm Record .</step>
  <step>Assert : <id>realm</id> is a Realm Record .</step>
  <step>If <id>prototype</id> is not present, set <id>prototype</id> to <id>realm</id> .[[Intrinsics]].[[ %FunctionPrototype% ]].</step>
  <step>Let <id>func</id> be a new built-in function object that when called performs the action described by <id>steps</id> . The new function object has internal slots whose names are the elements of <id>internalSlotsList</id> . The initial value of each of those internal slots is <value>undefined</value> .</step>
  <step>Set <id>func</id> .[[Realm]] to <id>realm</id> .</step>
  <step>Set <id>func</id> .[[Prototype]] to <id>prototype</id> .</step>
  <step>Set <id>func</id> .[[Extensible]] to <value>true</value> .</step>
  <step>Set <id>func</id> .[[ScriptOrModule]] to <value>null</value> .</step>
  <step>Return <id>func</id> .</step>
</step-list>
<step-list>
  <step>Let <id>target</id> be <id>F</id> .[[BoundTargetFunction]].</step>
  <step>Let <id>boundThis</id> be <id>F</id> .[[BoundThis]].</step>
  <step>Let <id>boundArgs</id> be <id>F</id> .[[BoundArguments]].</step>
  <step>Let <id>args</id> be a new list containing the same values as the list <id>boundArgs</id> in the same order followed by the same values as the list <id>argumentsList</id> in the same order.</step>
  <step>Return ? Call ( <id>target</id> , <id>boundThis</id> , <id>args</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>target</id> be <id>F</id> .[[BoundTargetFunction]].</step>
  <step>Assert : IsConstructor ( <id>target</id> ) is <value>true</value> .</step>
  <step>Let <id>boundArgs</id> be <id>F</id> .[[BoundArguments]].</step>
  <step>Let <id>args</id> be a new list containing the same values as the list <id>boundArgs</id> in the same order followed by the same values as the list <id>argumentsList</id> in the same order.</step>
  <step>If SameValue ( <id>F</id> , <id>newTarget</id> ) is <value>true</value> , set <id>newTarget</id> to <id>target</id> .</step>
  <step>Return ? Construct ( <id>target</id> , <id>args</id> , <id>newTarget</id> ).</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>targetFunction</id> ) is Object.</step>
  <step>Let <id>proto</id> be ? <id>targetFunction</id> .[[GetPrototypeOf]]().</step>
  <step>Let <id>obj</id> be a newly created object.</step>
  <step>Set <id>obj</id> 's essential internal methods to the default ordinary object definitions specified in 9.1 .</step>
  <step>Set <id>obj</id> .[[Call]] as described in 9.4.1.1 .</step>
  <step>If IsConstructor ( <id>targetFunction</id> ) is <value>true</value> , then   <step-list>
    <step>Set <id>obj</id> .[[Construct]] as described in 9.4.1.2 .</step>
  </step-list></step>
  <step>Set <id>obj</id> .[[Prototype]] to <id>proto</id> .</step>
  <step>Set <id>obj</id> .[[Extensible]] to <value>true</value> .</step>
  <step>Set <id>obj</id> .[[BoundTargetFunction]] to <id>targetFunction</id> .</step>
  <step>Set <id>obj</id> .[[BoundThis]] to <id>boundThis</id> .</step>
  <step>Set <id>obj</id> .[[BoundArguments]] to <id>boundArgs</id> .</step>
  <step>Return <id>obj</id> .</step>
</step-list>
<step-list>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>If <id>P</id> is <value>"length"</value> , then   <step-list>
    <step>Return ? ArraySetLength ( <id>A</id> , <id>Desc</id> ).</step>
  </step-list></step>
  <step>Else if <id>P</id> is an array index , then   <step-list>
    <step>Let <id>oldLenDesc</id> be OrdinaryGetOwnProperty ( <id>A</id> , <value>"length"</value> ).</step>
    <step>Assert : <id>oldLenDesc</id> will never be <value>undefined</value> or an accessor descriptor because Array objects are created with a length data property that cannot be deleted or reconfigured.</step>
    <step>Let <id>oldLen</id> be <id>oldLenDesc</id> .[[Value]].</step>
    <step>Let <id>index</id> be ! ToUint32 ( <id>P</id> ).</step>
    <step>If <id>index</id> ≥ <id>oldLen</id> and <id>oldLenDesc</id> .[[Writable]] is <value>false</value> , return <value>false</value> .</step>
    <step>Let <id>succeeded</id> be ! OrdinaryDefineOwnProperty ( <id>A</id> , <id>P</id> , <id>Desc</id> ).</step>
    <step>If <id>succeeded</id> is <value>false</value> , return <value>false</value> .</step>
    <step>If <id>index</id> ≥ <id>oldLen</id> , then     <step-list>
      <step>Set <id>oldLenDesc</id> .[[Value]] to <id>index</id> + 1.</step>
      <step>Let <id>succeeded</id> be OrdinaryDefineOwnProperty ( <id>A</id> , <value>"length"</value> , <id>oldLenDesc</id> ).</step>
      <step>Assert : <id>succeeded</id> is <value>true</value> .</step>
    </step-list></step>
    <step>Return <value>true</value> .</step>
  </step-list></step>
  <step>Return OrdinaryDefineOwnProperty ( <id>A</id> , <id>P</id> , <id>Desc</id> ).</step>
</step-list>
<step-list>
  <step>Assert : <id>length</id> is an integer Number ≥ 0.</step>
  <step>If <id>length</id> is <value>-0</value> , set <id>length</id> to <value>+0</value> .</step>
  <step>If <id>length</id> >2 32 -1, throw a <value>RangeError</value> exception.</step>
  <step>If <id>proto</id> is not present, set <id>proto</id> to the intrinsic object %ArrayPrototype% .</step>
  <step>Let <id>A</id> be a newly created Array exotic object .</step>
  <step>Set <id>A</id> 's essential internal methods except for [[DefineOwnProperty]] to the default ordinary object definitions specified in 9.1 .</step>
  <step>Set <id>A</id> .[[DefineOwnProperty]] as specified in 9.4.2.1 .</step>
  <step>Set <id>A</id> .[[Prototype]] to <id>proto</id> .</step>
  <step>Set <id>A</id> .[[Extensible]] to <value>true</value> .</step>
  <step>Perform ! OrdinaryDefineOwnProperty ( <id>A</id> , <value>"length"</value> , PropertyDescriptor { [[Value]]: <id>length</id> , [[Writable]]: <value>true</value> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>false</value> }).</step>
  <step>Return <id>A</id> .</step>
</step-list>
<step-list>
  <step>Assert : <id>length</id> is an integer Number ≥ 0.</step>
  <step>If <id>length</id> is <value>-0</value> , set <id>length</id> to <value>+0</value> .</step>
  <step>Let <id>isArray</id> be ? IsArray ( <id>originalArray</id> ).</step>
  <step>If <id>isArray</id> is <value>false</value> , return ? ArrayCreate ( <id>length</id> ).</step>
  <step>Let <id>C</id> be ? Get ( <id>originalArray</id> , <value>"constructor"</value> ).</step>
  <step>If IsConstructor ( <id>C</id> ) is <value>true</value> , then   <step-list>
    <step>Let <id>thisRealm</id> be the current Realm Record .</step>
    <step>Let <id>realmC</id> be ? GetFunctionRealm ( <id>C</id> ).</step>
    <step>If <id>thisRealm</id> and <id>realmC</id> are not the same Realm Record , then     <step-list>
      <step>If SameValue ( <id>C</id> , <id>realmC</id> .[[Intrinsics]].[[ %Array% ]]) is <value>true</value> , set <id>C</id> to <value>undefined</value> .</step>
    </step-list></step>
  </step-list></step>
  <step>If Type ( <id>C</id> ) is Object, then   <step-list>
    <step>Set <id>C</id> to ? Get ( <id>C</id> , @@species).</step>
    <step>If <id>C</id> is <value>null</value> , set <id>C</id> to <value>undefined</value> .</step>
  </step-list></step>
  <step>If <id>C</id> is <value>undefined</value> , return ? ArrayCreate ( <id>length</id> ).</step>
  <step>If IsConstructor ( <id>C</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Return ? Construct ( <id>C</id> , « <id>length</id> »).</step>
</step-list>
<step-list>
  <step>If <id>Desc</id> .[[Value]] is absent, then   <step-list>
    <step>Return OrdinaryDefineOwnProperty ( <id>A</id> , <value>"length"</value> , <id>Desc</id> ).</step>
  </step-list></step>
  <step>Let <id>newLenDesc</id> be a copy of <id>Desc</id> .</step>
  <step>Let <id>newLen</id> be ? ToUint32 ( <id>Desc</id> .[[Value]]).</step>
  <step>Let <id>numberLen</id> be ? ToNumber ( <id>Desc</id> .[[Value]]).</step>
  <step>If <id>newLen</id> ≠ <id>numberLen</id> , throw a <value>RangeError</value> exception.</step>
  <step>Set <id>newLenDesc</id> .[[Value]] to <id>newLen</id> .</step>
  <step>Let <id>oldLenDesc</id> be OrdinaryGetOwnProperty ( <id>A</id> , <value>"length"</value> ).</step>
  <step>Assert : <id>oldLenDesc</id> will never be <value>undefined</value> or an accessor descriptor because Array objects are created with a length data property that cannot be deleted or reconfigured.</step>
  <step>Let <id>oldLen</id> be <id>oldLenDesc</id> .[[Value]].</step>
  <step>If <id>newLen</id> ≥ <id>oldLen</id> , then   <step-list>
    <step>Return OrdinaryDefineOwnProperty ( <id>A</id> , <value>"length"</value> , <id>newLenDesc</id> ).</step>
  </step-list></step>
  <step>If <id>oldLenDesc</id> .[[Writable]] is <value>false</value> , return <value>false</value> .</step>
  <step>If <id>newLenDesc</id> .[[Writable]] is absent or has the value <value>true</value> , let <id>newWritable</id> be <value>true</value> .</step>
  <step>Else,   <step-list>
    <step>Need to defer setting the [[Writable]] attribute to <value>false</value> in case any elements cannot be deleted.</step>
    <step>Let <id>newWritable</id> be <value>false</value> .</step>
    <step>Set <id>newLenDesc</id> .[[Writable]] to <value>true</value> .</step>
  </step-list></step>
  <step>Let <id>succeeded</id> be ! OrdinaryDefineOwnProperty ( <id>A</id> , <value>"length"</value> , <id>newLenDesc</id> ).</step>
  <step>If <id>succeeded</id> is <value>false</value> , return <value>false</value> .</step>
  <step>Repeat, while <id>newLen</id> < <id>oldLen</id> ,   <step-list>
    <step>Set <id>oldLen</id> to <id>oldLen</id> - 1.</step>
    <step>Let <id>deleteSucceeded</id> be ! <id>A</id> .[[Delete]](! ToString ( <id>oldLen</id> )).</step>
    <step>If <id>deleteSucceeded</id> is <value>false</value> , then     <step-list>
      <step>Set <id>newLenDesc</id> .[[Value]] to <id>oldLen</id> + 1.</step>
      <step>If <id>newWritable</id> is <value>false</value> , set <id>newLenDesc</id> .[[Writable]] to <value>false</value> .</step>
      <step>Perform ! OrdinaryDefineOwnProperty ( <id>A</id> , <value>"length"</value> , <id>newLenDesc</id> ).</step>
      <step>Return <value>false</value> .</step>
    </step-list></step>
  </step-list></step>
  <step>If <id>newWritable</id> is <value>false</value> , then   <step-list>
    <step>Return OrdinaryDefineOwnProperty ( <id>A</id> , <value>"length"</value> , PropertyDescriptor { [[Writable]]: <value>false</value> }). This call will always return <value>true</value> .</step>
  </step-list></step>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>Let <id>desc</id> be OrdinaryGetOwnProperty ( <id>S</id> , <id>P</id> ).</step>
  <step>If <id>desc</id> is not <value>undefined</value> , return <id>desc</id> .</step>
  <step>Return ! StringGetOwnProperty ( <id>S</id> , <id>P</id> ).</step>
</step-list>
<step-list>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>Let <id>stringDesc</id> be ! StringGetOwnProperty ( <id>S</id> , <id>P</id> ).</step>
  <step>If <id>stringDesc</id> is not <value>undefined</value> , then   <step-list>
    <step>Let <id>extensible</id> be <id>S</id> .[[Extensible]].</step>
    <step>Return ! IsCompatiblePropertyDescriptor ( <id>extensible</id> , <id>Desc</id> , <id>stringDesc</id> ).</step>
  </step-list></step>
  <step>Return ! OrdinaryDefineOwnProperty ( <id>S</id> , <id>P</id> , <id>Desc</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>keys</id> be a new empty List .</step>
  <step>Let <id>str</id> be the String value of <id>O</id> .[[StringData]].</step>
  <step>Let <id>len</id> be the length of <id>str</id> .</step>
  <step>For each integer <id>i</id> starting with 0 such that <id>i</id> < <id>len</id> , in ascending order, do   <step-list>
    <step>Add ! ToString ( <id>i</id> ) as the last element of <id>keys</id> .</step>
  </step-list></step>
  <step>For each own property key <id>P</id> of <id>O</id> such that <id>P</id> is an integer index and ToInteger ( <id>P</id> ) ≥ <id>len</id> , in ascending numeric index order, do   <step-list>
    <step>Add <id>P</id> as the last element of <id>keys</id> .</step>
  </step-list></step>
  <step>For each own property key <id>P</id> of <id>O</id> such that Type ( <id>P</id> ) is String and <id>P</id> is not an integer index , in ascending chronological order of property creation, do   <step-list>
    <step>Add <id>P</id> as the last element of <id>keys</id> .</step>
  </step-list></step>
  <step>For each own property key <id>P</id> of <id>O</id> such that Type ( <id>P</id> ) is Symbol, in ascending chronological order of property creation, do   <step-list>
    <step>Add <id>P</id> as the last element of <id>keys</id> .</step>
  </step-list></step>
  <step>Return <id>keys</id> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>value</id> ) is String.</step>
  <step>Let <id>S</id> be a newly created String exotic object .</step>
  <step>Set <id>S</id> .[[StringData]] to <id>value</id> .</step>
  <step>Set <id>S</id> 's essential internal methods to the default ordinary object definitions specified in 9.1 .</step>
  <step>Set <id>S</id> .[[GetOwnProperty]] as specified in 9.4.3.1 .</step>
  <step>Set <id>S</id> .[[DefineOwnProperty]] as specified in 9.4.3.2 .</step>
  <step>Set <id>S</id> .[[OwnPropertyKeys]] as specified in 9.4.3.3 .</step>
  <step>Set <id>S</id> .[[Prototype]] to <id>prototype</id> .</step>
  <step>Set <id>S</id> .[[Extensible]] to <value>true</value> .</step>
  <step>Let <id>length</id> be the number of code unit elements in <id>value</id> .</step>
  <step>Perform ! DefinePropertyOrThrow ( <id>S</id> , <value>"length"</value> , PropertyDescriptor { [[Value]]: <id>length</id> , [[Writable]]: <value>false</value> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>false</value> }).</step>
  <step>Return <id>S</id> .</step>
</step-list>
<step-list>
  <step>Assert : <id>S</id> is an Object that has a [[StringData]] internal slot.</step>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>If Type ( <id>P</id> ) is not String, return <value>undefined</value> .</step>
  <step>Let <id>index</id> be ! CanonicalNumericIndexString ( <id>P</id> ).</step>
  <step>If <id>index</id> is <value>undefined</value> , return <value>undefined</value> .</step>
  <step>If IsInteger ( <id>index</id> ) is <value>false</value> , return <value>undefined</value> .</step>
  <step>If <id>index</id> = <value>-0</value> , return <value>undefined</value> .</step>
  <step>Let <id>str</id> be the String value of <id>S</id> .[[StringData]].</step>
  <step>Let <id>len</id> be the length of <id>str</id> .</step>
  <step>If <id>index</id> < 0 or <id>len</id> ≤ <id>index</id> , return <value>undefined</value> .</step>
  <step>Let <id>resultStr</id> be the String value of length 1, containing one code unit from <id>str</id> , specifically the code unit at index <id>index</id> .</step>
  <step>Return a PropertyDescriptor { [[Value]]: <id>resultStr</id> , [[Writable]]: <value>false</value> , [[Enumerable]]: <value>true</value> , [[Configurable]]: <value>false</value> }.</step>
</step-list>
<step-list>
  <step>Let <id>args</id> be the arguments object.</step>
  <step>Let <id>desc</id> be OrdinaryGetOwnProperty ( <id>args</id> , <id>P</id> ).</step>
  <step>If <id>desc</id> is <value>undefined</value> , return <id>desc</id> .</step>
  <step>Let <id>map</id> be <id>args</id> .[[ParameterMap]].</step>
  <step>Let <id>isMapped</id> be ! HasOwnProperty ( <id>map</id> , <id>P</id> ).</step>
  <step>If <id>isMapped</id> is <value>true</value> , then   <step-list>
    <step>Set <id>desc</id> .[[Value]] to Get ( <id>map</id> , <id>P</id> ).</step>
  </step-list></step>
  <step>Return <id>desc</id> .</step>
</step-list>
<step-list>
  <step>Let <id>args</id> be the arguments object.</step>
  <step>Let <id>map</id> be <id>args</id> .[[ParameterMap]].</step>
  <step>Let <id>isMapped</id> be HasOwnProperty ( <id>map</id> , <id>P</id> ).</step>
  <step>Let <id>newArgDesc</id> be <id>Desc</id> .</step>
  <step>If <id>isMapped</id> is <value>true</value> and IsDataDescriptor ( <id>Desc</id> ) is <value>true</value> , then   <step-list>
    <step>If <id>Desc</id> .[[Value]] is not present and <id>Desc</id> .[[Writable]] is present and its value is <value>false</value> , then     <step-list>
      <step>Set <id>newArgDesc</id> to a copy of <id>Desc</id> .</step>
      <step>Set <id>newArgDesc</id> .[[Value]] to Get ( <id>map</id> , <id>P</id> ).</step>
    </step-list></step>
  </step-list></step>
  <step>Let <id>allowed</id> be ? OrdinaryDefineOwnProperty ( <id>args</id> , <id>P</id> , <id>newArgDesc</id> ).</step>
  <step>If <id>allowed</id> is <value>false</value> , return <value>false</value> .</step>
  <step>If <id>isMapped</id> is <value>true</value> , then   <step-list>
    <step>If IsAccessorDescriptor ( <id>Desc</id> ) is <value>true</value> , then     <step-list>
      <step>Call <id>map</id> .[[Delete]]( <id>P</id> ).</step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>If <id>Desc</id> .[[Value]] is present, then       <step-list>
        <step>Let <id>setStatus</id> be Set ( <id>map</id> , <id>P</id> , <id>Desc</id> .[[Value]], <value>false</value> ).</step>
        <step>Assert : <id>setStatus</id> is <value>true</value> because formal parameters mapped by argument objects are always writable.</step>
      </step-list></step>
      <step>If <id>Desc</id> .[[Writable]] is present and its value is <value>false</value> , then       <step-list>
        <step>Call <id>map</id> .[[Delete]]( <id>P</id> ).</step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Let <id>args</id> be the arguments object.</step>
  <step>Let <id>map</id> be <id>args</id> .[[ParameterMap]].</step>
  <step>Let <id>isMapped</id> be ! HasOwnProperty ( <id>map</id> , <id>P</id> ).</step>
  <step>If <id>isMapped</id> is <value>false</value> , then   <step-list>
    <step>Return ? OrdinaryGet ( <id>args</id> , <id>P</id> , <id>Receiver</id> ).</step>
  </step-list></step>
  <step>Else <id>map</id> contains a formal parameter mapping for <id>P</id> ,   <step-list>
    <step>Return Get ( <id>map</id> , <id>P</id> ).</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>args</id> be the arguments object.</step>
  <step>If SameValue ( <id>args</id> , <id>Receiver</id> ) is <value>false</value> , then   <step-list>
    <step>Let <id>isMapped</id> be <value>false</value> .</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>map</id> be <id>args</id> .[[ParameterMap]].</step>
    <step>Let <id>isMapped</id> be ! HasOwnProperty ( <id>map</id> , <id>P</id> ).</step>
  </step-list></step>
  <step>If <id>isMapped</id> is <value>true</value> , then   <step-list>
    <step>Let <id>setStatus</id> be Set ( <id>map</id> , <id>P</id> , <id>V</id> , <value>false</value> ).</step>
    <step>Assert : <id>setStatus</id> is <value>true</value> because formal parameters mapped by argument objects are always writable.</step>
  </step-list></step>
  <step>Return ? OrdinarySet ( <id>args</id> , <id>P</id> , <id>V</id> , <id>Receiver</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>args</id> be the arguments object.</step>
  <step>Let <id>map</id> be <id>args</id> .[[ParameterMap]].</step>
  <step>Let <id>isMapped</id> be ! HasOwnProperty ( <id>map</id> , <id>P</id> ).</step>
  <step>Let <id>result</id> be ? OrdinaryDelete ( <id>args</id> , <id>P</id> ).</step>
  <step>If <id>result</id> is <value>true</value> and <id>isMapped</id> is <value>true</value> , then   <step-list>
    <step>Call <id>map</id> .[[Delete]]( <id>P</id> ).</step>
  </step-list></step>
  <step>Return <id>result</id> .</step>
</step-list>
<step-list>
  <step>Let <id>len</id> be the number of elements in <id>argumentsList</id> .</step>
  <step>Let <id>obj</id> be ObjectCreate ( %ObjectPrototype% , « [[ParameterMap]] »).</step>
  <step>Set <id>obj</id> .[[ParameterMap]] to <value>undefined</value> .</step>
  <step>Perform DefinePropertyOrThrow ( <id>obj</id> , <value>"length"</value> , PropertyDescriptor { [[Value]]: <id>len</id> , [[Writable]]: <value>true</value> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>true</value> }).</step>
  <step>Let <id>index</id> be 0.</step>
  <step>Repeat, while <id>index</id> < <id>len</id> ,   <step-list>
    <step>Let <id>val</id> be <id>argumentsList</id> [ <id>index</id> ].</step>
    <step>Perform CreateDataProperty ( <id>obj</id> , ! ToString ( <id>index</id> ), <id>val</id> ).</step>
    <step>Let <id>index</id> be <id>index</id> + 1.</step>
  </step-list></step>
  <step>Perform ! DefinePropertyOrThrow ( <id>obj</id> , @@iterator, PropertyDescriptor { [[Value]]: %ArrayProto_values% , [[Writable]]: <value>true</value> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>true</value> }).</step>
  <step>Perform ! DefinePropertyOrThrow ( <id>obj</id> , <value>"callee"</value> , PropertyDescriptor { [[Get]]: %ThrowTypeError% , [[Set]]: %ThrowTypeError% , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>false</value> }).</step>
  <step>Return <id>obj</id> .</step>
</step-list>
<step-list>
  <step>Assert : <id>formals</id> does not contain a rest parameter, any binding patterns, or any initializers. It may contain duplicate identifiers.</step>
  <step>Let <id>len</id> be the number of elements in <id>argumentsList</id> .</step>
  <step>Let <id>obj</id> be a newly created arguments exotic object with a [[ParameterMap]] internal slot.</step>
  <step>Set <id>obj</id> .[[GetOwnProperty]] as specified in 9.4.4.1 .</step>
  <step>Set <id>obj</id> .[[DefineOwnProperty]] as specified in 9.4.4.2 .</step>
  <step>Set <id>obj</id> .[[Get]] as specified in 9.4.4.3 .</step>
  <step>Set <id>obj</id> .[[Set]] as specified in 9.4.4.4 .</step>
  <step>Set <id>obj</id> .[[Delete]] as specified in 9.4.4.5 .</step>
  <step>Set the remainder of <id>obj</id> 's essential internal methods to the default ordinary object definitions specified in 9.1 .</step>
  <step>Set <id>obj</id> .[[Prototype]] to %ObjectPrototype% .</step>
  <step>Set <id>obj</id> .[[Extensible]] to <value>true</value> .</step>
  <step>Let <id>map</id> be ObjectCreate ( <value>null</value> ).</step>
  <step>Set <id>obj</id> .[[ParameterMap]] to <id>map</id> .</step>
  <step>Let <id>parameterNames</id> be the BoundNames of <id>formals</id> .</step>
  <step>Let <id>numberOfParameters</id> be the number of elements in <id>parameterNames</id> .</step>
  <step>Let <id>index</id> be 0.</step>
  <step>Repeat, while <id>index</id> < <id>len</id> ,   <step-list>
    <step>Let <id>val</id> be <id>argumentsList</id> [ <id>index</id> ].</step>
    <step>Perform CreateDataProperty ( <id>obj</id> , ! ToString ( <id>index</id> ), <id>val</id> ).</step>
    <step>Let <id>index</id> be <id>index</id> + 1.</step>
  </step-list></step>
  <step>Perform DefinePropertyOrThrow ( <id>obj</id> , <value>"length"</value> , PropertyDescriptor { [[Value]]: <id>len</id> , [[Writable]]: <value>true</value> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>true</value> }).</step>
  <step>Let <id>mappedNames</id> be a new empty List .</step>
  <step>Let <id>index</id> be <id>numberOfParameters</id> - 1.</step>
  <step>Repeat, while <id>index</id> ≥ 0,   <step-list>
    <step>Let <id>name</id> be <id>parameterNames</id> [ <id>index</id> ].</step>
    <step>If <id>name</id> is not an element of <id>mappedNames</id> , then     <step-list>
      <step>Add <id>name</id> as an element of the list <id>mappedNames</id> .</step>
      <step>If <id>index</id> < <id>len</id> , then       <step-list>
        <step>Let <id>g</id> be MakeArgGetter ( <id>name</id> , <id>env</id> ).</step>
        <step>Let <id>p</id> be MakeArgSetter ( <id>name</id> , <id>env</id> ).</step>
        <step>Perform <id>map</id> .[[DefineOwnProperty]](! ToString ( <id>index</id> ), PropertyDescriptor { [[Set]]: <id>p</id> , [[Get]]: <id>g</id> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>true</value> }).</step>
      </step-list></step>
    </step-list></step>
    <step>Let <id>index</id> be <id>index</id> - 1.</step>
  </step-list></step>
  <step>Perform ! DefinePropertyOrThrow ( <id>obj</id> , @@iterator, PropertyDescriptor { [[Value]]: %ArrayProto_values% , [[Writable]]: <value>true</value> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>true</value> }).</step>
  <step>Perform ! DefinePropertyOrThrow ( <id>obj</id> , <value>"callee"</value> , PropertyDescriptor { [[Value]]: <id>func</id> , [[Writable]]: <value>true</value> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>true</value> }).</step>
  <step>Return <id>obj</id> .</step>
</step-list>
<step-list>
  <step>Let <id>steps</id> be the steps of an ArgGetter function as specified below.</step>
  <step>Let <id>getter</id> be CreateBuiltinFunction ( <id>steps</id> , « [[Name]], [[Env]] »).</step>
  <step>Set <id>getter</id> .[[Name]] to <id>name</id> .</step>
  <step>Set <id>getter</id> .[[Env]] to <id>env</id> .</step>
  <step>Return <id>getter</id> .</step>
</step-list>
<step-list>
  <step>Let <id>name</id> be <id>f</id> .[[Name]].</step>
  <step>Let <id>env</id> be <id>f</id> .[[Env]].</step>
  <step>Return <id>env</id> .GetBindingValue( <id>name</id> , <value>false</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>steps</id> be the steps of an ArgSetter function as specified below.</step>
  <step>Let <id>setter</id> be CreateBuiltinFunction ( <id>steps</id> , « [[Name]], [[Env]] »).</step>
  <step>Set <id>setter</id> .[[Name]] to <id>name</id> .</step>
  <step>Set <id>setter</id> .[[Env]] to <id>env</id> .</step>
  <step>Return <id>setter</id> .</step>
</step-list>
<step-list>
  <step>Let <id>name</id> be <id>f</id> .[[Name]].</step>
  <step>Let <id>env</id> be <id>f</id> .[[Env]].</step>
  <step>Return <id>env</id> .SetMutableBinding( <id>name</id> , <id>value</id> , <value>false</value> ).</step>
</step-list>
<step-list>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>Assert : <id>O</id> is an Object that has a [[ViewedArrayBuffer]] internal slot.</step>
  <step>If Type ( <id>P</id> ) is String, then   <step-list>
    <step>Let <id>numericIndex</id> be ! CanonicalNumericIndexString ( <id>P</id> ).</step>
    <step>If <id>numericIndex</id> is not <value>undefined</value> , then     <step-list>
      <step>Let <id>value</id> be ? IntegerIndexedElementGet ( <id>O</id> , <id>numericIndex</id> ).</step>
      <step>If <id>value</id> is <value>undefined</value> , return <value>undefined</value> .</step>
      <step>Return a PropertyDescriptor { [[Value]]: <id>value</id> , [[Writable]]: <value>true</value> , [[Enumerable]]: <value>true</value> , [[Configurable]]: <value>false</value> }.</step>
    </step-list></step>
  </step-list></step>
  <step>Return OrdinaryGetOwnProperty ( <id>O</id> , <id>P</id> ).</step>
</step-list>
<step-list>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>Assert : <id>O</id> is an Object that has a [[ViewedArrayBuffer]] internal slot.</step>
  <step>If Type ( <id>P</id> ) is String, then   <step-list>
    <step>Let <id>numericIndex</id> be ! CanonicalNumericIndexString ( <id>P</id> ).</step>
    <step>If <id>numericIndex</id> is not <value>undefined</value> , then     <step-list>
      <step>Let <id>buffer</id> be <id>O</id> .[[ViewedArrayBuffer]].</step>
      <step>If IsDetachedBuffer ( <id>buffer</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
      <step>If IsInteger ( <id>numericIndex</id> ) is <value>false</value> , return <value>false</value> .</step>
      <step>If <id>numericIndex</id> = <value>-0</value> , return <value>false</value> .</step>
      <step>If <id>numericIndex</id> < 0, return <value>false</value> .</step>
      <step>If <id>numericIndex</id> ≥ <id>O</id> .[[ArrayLength]], return <value>false</value> .</step>
      <step>Return <value>true</value> .</step>
    </step-list></step>
  </step-list></step>
  <step>Return ? OrdinaryHasProperty ( <id>O</id> , <id>P</id> ).</step>
</step-list>
<step-list>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>Assert : <id>O</id> is an Object that has a [[ViewedArrayBuffer]] internal slot.</step>
  <step>If Type ( <id>P</id> ) is String, then   <step-list>
    <step>Let <id>numericIndex</id> be ! CanonicalNumericIndexString ( <id>P</id> ).</step>
    <step>If <id>numericIndex</id> is not <value>undefined</value> , then     <step-list>
      <step>If IsInteger ( <id>numericIndex</id> ) is <value>false</value> , return <value>false</value> .</step>
      <step>If <id>numericIndex</id> = <value>-0</value> , return <value>false</value> .</step>
      <step>If <id>numericIndex</id> < 0, return <value>false</value> .</step>
      <step>Let <id>length</id> be <id>O</id> .[[ArrayLength]].</step>
      <step>If <id>numericIndex</id> ≥ <id>length</id> , return <value>false</value> .</step>
      <step>If IsAccessorDescriptor ( <id>Desc</id> ) is <value>true</value> , return <value>false</value> .</step>
      <step>If <id>Desc</id> has a [[Configurable]] field and if <id>Desc</id> .[[Configurable]] is <value>true</value> , return <value>false</value> .</step>
      <step>If <id>Desc</id> has an [[Enumerable]] field and if <id>Desc</id> .[[Enumerable]] is <value>false</value> , return <value>false</value> .</step>
      <step>If <id>Desc</id> has a [[Writable]] field and if <id>Desc</id> .[[Writable]] is <value>false</value> , return <value>false</value> .</step>
      <step>If <id>Desc</id> has a [[Value]] field, then       <step-list>
        <step>Let <id>value</id> be <id>Desc</id> .[[Value]].</step>
        <step>Return ? IntegerIndexedElementSet ( <id>O</id> , <id>numericIndex</id> , <id>value</id> ).</step>
      </step-list></step>
      <step>Return <value>true</value> .</step>
    </step-list></step>
  </step-list></step>
  <step>Return ! OrdinaryDefineOwnProperty ( <id>O</id> , <id>P</id> , <id>Desc</id> ).</step>
</step-list>
<step-list>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>If Type ( <id>P</id> ) is String, then   <step-list>
    <step>Let <id>numericIndex</id> be ! CanonicalNumericIndexString ( <id>P</id> ).</step>
    <step>If <id>numericIndex</id> is not <value>undefined</value> , then     <step-list>
      <step>Return ? IntegerIndexedElementGet ( <id>O</id> , <id>numericIndex</id> ).</step>
    </step-list></step>
  </step-list></step>
  <step>Return ? OrdinaryGet ( <id>O</id> , <id>P</id> , <id>Receiver</id> ).</step>
</step-list>
<step-list>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>If Type ( <id>P</id> ) is String, then   <step-list>
    <step>Let <id>numericIndex</id> be ! CanonicalNumericIndexString ( <id>P</id> ).</step>
    <step>If <id>numericIndex</id> is not <value>undefined</value> , then     <step-list>
      <step>Return ? IntegerIndexedElementSet ( <id>O</id> , <id>numericIndex</id> , <id>V</id> ).</step>
    </step-list></step>
  </step-list></step>
  <step>Return ? OrdinarySet ( <id>O</id> , <id>P</id> , <id>V</id> , <id>Receiver</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>keys</id> be a new empty List .</step>
  <step>Assert : <id>O</id> is an Object that has [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal slots.</step>
  <step>Let <id>len</id> be <id>O</id> .[[ArrayLength]].</step>
  <step>For each integer <id>i</id> starting with 0 such that <id>i</id> < <id>len</id> , in ascending order, do   <step-list>
    <step>Add ! ToString ( <id>i</id> ) as the last element of <id>keys</id> .</step>
  </step-list></step>
  <step>For each own property key <id>P</id> of <id>O</id> such that Type ( <id>P</id> ) is String and <id>P</id> is not an integer index , in ascending chronological order of property creation, do   <step-list>
    <step>Add <id>P</id> as the last element of <id>keys</id> .</step>
  </step-list></step>
  <step>For each own property key <id>P</id> of <id>O</id> such that Type ( <id>P</id> ) is Symbol, in ascending chronological order of property creation, do   <step-list>
    <step>Add <id>P</id> as the last element of <id>keys</id> .</step>
  </step-list></step>
  <step>Return <id>keys</id> .</step>
</step-list>
<step-list>
  <step>Assert : <id>internalSlotsList</id> contains the names [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]].</step>
  <step>Let <id>A</id> be a newly created object with an internal slot for each name in <id>internalSlotsList</id> .</step>
  <step>Set <id>A</id> 's essential internal methods to the default ordinary object definitions specified in 9.1 .</step>
  <step>Set <id>A</id> .[[GetOwnProperty]] as specified in 9.4.5.1 .</step>
  <step>Set <id>A</id> .[[HasProperty]] as specified in 9.4.5.2 .</step>
  <step>Set <id>A</id> .[[DefineOwnProperty]] as specified in 9.4.5.3 .</step>
  <step>Set <id>A</id> .[[Get]] as specified in 9.4.5.4 .</step>
  <step>Set <id>A</id> .[[Set]] as specified in 9.4.5.5 .</step>
  <step>Set <id>A</id> .[[OwnPropertyKeys]] as specified in 9.4.5.6 .</step>
  <step>Set <id>A</id> .[[Prototype]] to <id>prototype</id> .</step>
  <step>Set <id>A</id> .[[Extensible]] to <value>true</value> .</step>
  <step>Return <id>A</id> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>index</id> ) is Number.</step>
  <step>Assert : <id>O</id> is an Object that has [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal slots.</step>
  <step>Let <id>buffer</id> be <id>O</id> .[[ViewedArrayBuffer]].</step>
  <step>If IsDetachedBuffer ( <id>buffer</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  <step>If IsInteger ( <id>index</id> ) is <value>false</value> , return <value>undefined</value> .</step>
  <step>If <id>index</id> = <value>-0</value> , return <value>undefined</value> .</step>
  <step>Let <id>length</id> be <id>O</id> .[[ArrayLength]].</step>
  <step>If <id>index</id> < 0 or <id>index</id> ≥ <id>length</id> , return <value>undefined</value> .</step>
  <step>Let <id>offset</id> be <id>O</id> .[[ByteOffset]].</step>
  <step>Let <id>arrayTypeName</id> be the String value of <id>O</id> .[[TypedArrayName]].</step>
  <step>Let <id>elementSize</id> be the Number value of the Element Size value specified in Table 56 for <id>arrayTypeName</id> .</step>
  <step>Let <id>indexedPosition</id> be ( <id>index</id> × <id>elementSize</id> ) + <id>offset</id> .</step>
  <step>Let <id>elementType</id> be the String value of the Element Type value in Table 56 for <id>arrayTypeName</id> .</step>
  <step>Return GetValueFromBuffer ( <id>buffer</id> , <id>indexedPosition</id> , <id>elementType</id> , <value>true</value> , <value>"Unordered"</value> ).</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>index</id> ) is Number.</step>
  <step>Assert : <id>O</id> is an Object that has [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal slots.</step>
  <step>Let <id>numValue</id> be ? ToNumber ( <id>value</id> ).</step>
  <step>Let <id>buffer</id> be <id>O</id> .[[ViewedArrayBuffer]].</step>
  <step>If IsDetachedBuffer ( <id>buffer</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  <step>If IsInteger ( <id>index</id> ) is <value>false</value> , return <value>false</value> .</step>
  <step>If <id>index</id> = <value>-0</value> , return <value>false</value> .</step>
  <step>Let <id>length</id> be <id>O</id> .[[ArrayLength]].</step>
  <step>If <id>index</id> < 0 or <id>index</id> ≥ <id>length</id> , return <value>false</value> .</step>
  <step>Let <id>offset</id> be <id>O</id> .[[ByteOffset]].</step>
  <step>Let <id>arrayTypeName</id> be the String value of <id>O</id> .[[TypedArrayName]].</step>
  <step>Let <id>elementSize</id> be the Number value of the Element Size value specified in Table 56 for <id>arrayTypeName</id> .</step>
  <step>Let <id>indexedPosition</id> be ( <id>index</id> × <id>elementSize</id> ) + <id>offset</id> .</step>
  <step>Let <id>elementType</id> be the String value of the Element Type value in Table 56 for <id>arrayTypeName</id> .</step>
  <step>Perform SetValueInBuffer ( <id>buffer</id> , <id>indexedPosition</id> , <id>elementType</id> , <id>numValue</id> , <value>true</value> , <value>"Unordered"</value> ).</step>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return ? SetImmutablePrototype ( <id>O</id> , <id>V</id> ).</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>If Type ( <id>P</id> ) is Symbol, return OrdinaryGetOwnProperty ( <id>O</id> , <id>P</id> ).</step>
  <step>Let <id>exports</id> be <id>O</id> .[[Exports]].</step>
  <step>If <id>P</id> is not an element of <id>exports</id> , return <value>undefined</value> .</step>
  <step>Let <id>value</id> be ? <id>O</id> .[[Get]]( <id>P</id> , <id>O</id> ).</step>
  <step>Return PropertyDescriptor { [[Value]]: <id>value</id> , [[Writable]]: <value>true</value> , [[Enumerable]]: <value>true</value> , [[Configurable]]: <value>false</value> }.</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If Type ( <id>P</id> ) is Symbol, return OrdinaryHasProperty ( <id>O</id> , <id>P</id> ).</step>
  <step>Let <id>exports</id> be <id>O</id> .[[Exports]].</step>
  <step>If <id>P</id> is an element of <id>exports</id> , return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>If Type ( <id>P</id> ) is Symbol, then   <step-list>
    <step>Return ? OrdinaryGet ( <id>O</id> , <id>P</id> , <id>Receiver</id> ).</step>
  </step-list></step>
  <step>Let <id>exports</id> be <id>O</id> .[[Exports]].</step>
  <step>If <id>P</id> is not an element of <id>exports</id> , return <value>undefined</value> .</step>
  <step>Let <id>m</id> be <id>O</id> .[[Module]].</step>
  <step>Let <id>binding</id> be ! <id>m</id> .ResolveExport( <id>P</id> , « »).</step>
  <step>Assert : <id>binding</id> is a ResolvedBinding Record .</step>
  <step>Let <id>targetModule</id> be <id>binding</id> .[[Module]].</step>
  <step>Assert : <id>targetModule</id> is not <value>undefined</value> .</step>
  <step>Let <id>targetEnv</id> be <id>targetModule</id> .[[Environment]].</step>
  <step>If <id>targetEnv</id> is <value>undefined</value> , throw a <value>ReferenceError</value> exception.</step>
  <step>Let <id>targetEnvRec</id> be <id>targetEnv</id> 's EnvironmentRecord .</step>
  <step>Return ? <id>targetEnvRec</id> .GetBindingValue( <id>binding</id> .[[BindingName]], <value>true</value> ).</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>If Type ( <id>P</id> ) is Symbol, then   <step-list>
    <step>Return ? OrdinaryDelete ( <id>O</id> , <id>P</id> ).</step>
  </step-list></step>
  <step>Let <id>exports</id> be <id>O</id> .[[Exports]].</step>
  <step>If <id>P</id> is an element of <id>exports</id> , return <value>false</value> .</step>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Let <id>exports</id> be a copy of <id>O</id> .[[Exports]].</step>
  <step>Let <id>symbolKeys</id> be ! OrdinaryOwnPropertyKeys ( <id>O</id> ).</step>
  <step>Append all the entries of <id>symbolKeys</id> to the end of <id>exports</id> .</step>
  <step>Return <id>exports</id> .</step>
</step-list>
<step-list>
  <step>Assert : <id>module</id> is a Module Record .</step>
  <step>Assert : <id>module</id> .[[Namespace]] is <value>undefined</value> .</step>
  <step>Assert : <id>exports</id> is a List of String values.</step>
  <step>Let <id>M</id> be a newly created object.</step>
  <step>Set <id>M</id> 's essential internal methods to the definitions specified in 9.4.6 .</step>
  <step>Set <id>M</id> .[[Module]] to <id>module</id> .</step>
  <step>Let <id>sortedExports</id> be a new List containing the same values as the list <id>exports</id> where the values are ordered as if an Array of the same values had been sorted using <value>Array.prototype.sort</value> using <value>undefined</value> as <id>comparefn</id> .</step>
  <step>Set <id>M</id> .[[Exports]] to <id>sortedExports</id> .</step>
  <step>Create own properties of <id>M</id> corresponding to the definitions in 26.3 .</step>
  <step>Set <id>module</id> .[[Namespace]] to <id>M</id> .</step>
  <step>Return <id>M</id> .</step>
</step-list>
<step-list>
  <step>Return ? SetImmutablePrototype ( <id>O</id> , <id>V</id> ).</step>
</step-list>
<step-list>
  <step>Assert : Either Type ( <id>V</id> ) is Object or Type ( <id>V</id> ) is Null.</step>
  <step>Let <id>current</id> be ? <id>O</id> .[[GetPrototypeOf]]().</step>
  <step>If SameValue ( <id>V</id> , <id>current</id> ) is <value>true</value> , return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>handler</id> be <id>O</id> .[[ProxyHandler]].</step>
  <step>If <id>handler</id> is <value>null</value> , throw a <value>TypeError</value> exception.</step>
  <step>Assert : Type ( <id>handler</id> ) is Object.</step>
  <step>Let <id>target</id> be <id>O</id> .[[ProxyTarget]].</step>
  <step>Let <id>trap</id> be ? GetMethod ( <id>handler</id> , <value>"getPrototypeOf"</value> ).</step>
  <step>If <id>trap</id> is <value>undefined</value> , then   <step-list>
    <step>Return ? <id>target</id> .[[GetPrototypeOf]]().</step>
  </step-list></step>
  <step>Let <id>handlerProto</id> be ? Call ( <id>trap</id> , <id>handler</id> , « <id>target</id> »).</step>
  <step>If Type ( <id>handlerProto</id> ) is neither Object nor Null, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>extensibleTarget</id> be ? IsExtensible ( <id>target</id> ).</step>
  <step>If <id>extensibleTarget</id> is <value>true</value> , return <id>handlerProto</id> .</step>
  <step>Let <id>targetProto</id> be ? <id>target</id> .[[GetPrototypeOf]]().</step>
  <step>If SameValue ( <id>handlerProto</id> , <id>targetProto</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Return <id>handlerProto</id> .</step>
</step-list>
<step-list>
  <step>Assert : Either Type ( <id>V</id> ) is Object or Type ( <id>V</id> ) is Null.</step>
  <step>Let <id>handler</id> be <id>O</id> .[[ProxyHandler]].</step>
  <step>If <id>handler</id> is <value>null</value> , throw a <value>TypeError</value> exception.</step>
  <step>Assert : Type ( <id>handler</id> ) is Object.</step>
  <step>Let <id>target</id> be <id>O</id> .[[ProxyTarget]].</step>
  <step>Let <id>trap</id> be ? GetMethod ( <id>handler</id> , <value>"setPrototypeOf"</value> ).</step>
  <step>If <id>trap</id> is <value>undefined</value> , then   <step-list>
    <step>Return ? <id>target</id> .[[SetPrototypeOf]]( <id>V</id> ).</step>
  </step-list></step>
  <step>Let <id>booleanTrapResult</id> be ToBoolean (? Call ( <id>trap</id> , <id>handler</id> , « <id>target</id> , <id>V</id> »)).</step>
  <step>If <id>booleanTrapResult</id> is <value>false</value> , return <value>false</value> .</step>
  <step>Let <id>extensibleTarget</id> be ? IsExtensible ( <id>target</id> ).</step>
  <step>If <id>extensibleTarget</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Let <id>targetProto</id> be ? <id>target</id> .[[GetPrototypeOf]]().</step>
  <step>If SameValue ( <id>V</id> , <id>targetProto</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Let <id>handler</id> be <id>O</id> .[[ProxyHandler]].</step>
  <step>If <id>handler</id> is <value>null</value> , throw a <value>TypeError</value> exception.</step>
  <step>Assert : Type ( <id>handler</id> ) is Object.</step>
  <step>Let <id>target</id> be <id>O</id> .[[ProxyTarget]].</step>
  <step>Let <id>trap</id> be ? GetMethod ( <id>handler</id> , <value>"isExtensible"</value> ).</step>
  <step>If <id>trap</id> is <value>undefined</value> , then   <step-list>
    <step>Return ? <id>target</id> .[[IsExtensible]]().</step>
  </step-list></step>
  <step>Let <id>booleanTrapResult</id> be ToBoolean (? Call ( <id>trap</id> , <id>handler</id> , « <id>target</id> »)).</step>
  <step>Let <id>targetResult</id> be ? <id>target</id> .[[IsExtensible]]().</step>
  <step>If SameValue ( <id>booleanTrapResult</id> , <id>targetResult</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Return <id>booleanTrapResult</id> .</step>
</step-list>
<step-list>
  <step>Let <id>handler</id> be <id>O</id> .[[ProxyHandler]].</step>
  <step>If <id>handler</id> is <value>null</value> , throw a <value>TypeError</value> exception.</step>
  <step>Assert : Type ( <id>handler</id> ) is Object.</step>
  <step>Let <id>target</id> be <id>O</id> .[[ProxyTarget]].</step>
  <step>Let <id>trap</id> be ? GetMethod ( <id>handler</id> , <value>"preventExtensions"</value> ).</step>
  <step>If <id>trap</id> is <value>undefined</value> , then   <step-list>
    <step>Return ? <id>target</id> .[[PreventExtensions]]().</step>
  </step-list></step>
  <step>Let <id>booleanTrapResult</id> be ToBoolean (? Call ( <id>trap</id> , <id>handler</id> , « <id>target</id> »)).</step>
  <step>If <id>booleanTrapResult</id> is <value>true</value> , then   <step-list>
    <step>Let <id>targetIsExtensible</id> be ? <id>target</id> .[[IsExtensible]]().</step>
    <step>If <id>targetIsExtensible</id> is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  </step-list></step>
  <step>Return <id>booleanTrapResult</id> .</step>
</step-list>
<step-list>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>Let <id>handler</id> be <id>O</id> .[[ProxyHandler]].</step>
  <step>If <id>handler</id> is <value>null</value> , throw a <value>TypeError</value> exception.</step>
  <step>Assert : Type ( <id>handler</id> ) is Object.</step>
  <step>Let <id>target</id> be <id>O</id> .[[ProxyTarget]].</step>
  <step>Let <id>trap</id> be ? GetMethod ( <id>handler</id> , <value>"getOwnPropertyDescriptor"</value> ).</step>
  <step>If <id>trap</id> is <value>undefined</value> , then   <step-list>
    <step>Return ? <id>target</id> .[[GetOwnProperty]]( <id>P</id> ).</step>
  </step-list></step>
  <step>Let <id>trapResultObj</id> be ? Call ( <id>trap</id> , <id>handler</id> , « <id>target</id> , <id>P</id> »).</step>
  <step>If Type ( <id>trapResultObj</id> ) is neither Object nor Undefined, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>targetDesc</id> be ? <id>target</id> .[[GetOwnProperty]]( <id>P</id> ).</step>
  <step>If <id>trapResultObj</id> is <value>undefined</value> , then   <step-list>
    <step>If <id>targetDesc</id> is <value>undefined</value> , return <value>undefined</value> .</step>
    <step>If <id>targetDesc</id> .[[Configurable]] is <value>false</value> , throw a <value>TypeError</value> exception.</step>
    <step>Let <id>extensibleTarget</id> be ? IsExtensible ( <id>target</id> ).</step>
    <step>Assert : Type ( <id>extensibleTarget</id> ) is Boolean.</step>
    <step>If <id>extensibleTarget</id> is <value>false</value> , throw a <value>TypeError</value> exception.</step>
    <step>Return <value>undefined</value> .</step>
  </step-list></step>
  <step>Let <id>extensibleTarget</id> be ? IsExtensible ( <id>target</id> ).</step>
  <step>Let <id>resultDesc</id> be ? ToPropertyDescriptor ( <id>trapResultObj</id> ).</step>
  <step>Call CompletePropertyDescriptor ( <id>resultDesc</id> ).</step>
  <step>Let <id>valid</id> be IsCompatiblePropertyDescriptor ( <id>extensibleTarget</id> , <id>resultDesc</id> , <id>targetDesc</id> ).</step>
  <step>If <id>valid</id> is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>If <id>resultDesc</id> .[[Configurable]] is <value>false</value> , then   <step-list>
    <step>If <id>targetDesc</id> is <value>undefined</value> or <id>targetDesc</id> .[[Configurable]] is <value>true</value> , then     <step-list>
      <step>Throw a <value>TypeError</value> exception.</step>
    </step-list></step>
  </step-list></step>
  <step>Return <id>resultDesc</id> .</step>
</step-list>
<step-list>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>Let <id>handler</id> be <id>O</id> .[[ProxyHandler]].</step>
  <step>If <id>handler</id> is <value>null</value> , throw a <value>TypeError</value> exception.</step>
  <step>Assert : Type ( <id>handler</id> ) is Object.</step>
  <step>Let <id>target</id> be <id>O</id> .[[ProxyTarget]].</step>
  <step>Let <id>trap</id> be ? GetMethod ( <id>handler</id> , <value>"defineProperty"</value> ).</step>
  <step>If <id>trap</id> is <value>undefined</value> , then   <step-list>
    <step>Return ? <id>target</id> .[[DefineOwnProperty]]( <id>P</id> , <id>Desc</id> ).</step>
  </step-list></step>
  <step>Let <id>descObj</id> be FromPropertyDescriptor ( <id>Desc</id> ).</step>
  <step>Let <id>booleanTrapResult</id> be ToBoolean (? Call ( <id>trap</id> , <id>handler</id> , « <id>target</id> , <id>P</id> , <id>descObj</id> »)).</step>
  <step>If <id>booleanTrapResult</id> is <value>false</value> , return <value>false</value> .</step>
  <step>Let <id>targetDesc</id> be ? <id>target</id> .[[GetOwnProperty]]( <id>P</id> ).</step>
  <step>Let <id>extensibleTarget</id> be ? IsExtensible ( <id>target</id> ).</step>
  <step>If <id>Desc</id> has a [[Configurable]] field and if <id>Desc</id> .[[Configurable]] is <value>false</value> , then   <step-list>
    <step>Let <id>settingConfigFalse</id> be <value>true</value> .</step>
  </step-list></step>
  <step>Else, let <id>settingConfigFalse</id> be <value>false</value> .</step>
  <step>If <id>targetDesc</id> is <value>undefined</value> , then   <step-list>
    <step>If <id>extensibleTarget</id> is <value>false</value> , throw a <value>TypeError</value> exception.</step>
    <step>If <id>settingConfigFalse</id> is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  </step-list></step>
  <step>Else <id>targetDesc</id> is not <value>undefined</value> ,   <step-list>
    <step>If IsCompatiblePropertyDescriptor ( <id>extensibleTarget</id> , <id>Desc</id> , <id>targetDesc</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
    <step>If <id>settingConfigFalse</id> is <value>true</value> and <id>targetDesc</id> .[[Configurable]] is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  </step-list></step>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>Let <id>handler</id> be <id>O</id> .[[ProxyHandler]].</step>
  <step>If <id>handler</id> is <value>null</value> , throw a <value>TypeError</value> exception.</step>
  <step>Assert : Type ( <id>handler</id> ) is Object.</step>
  <step>Let <id>target</id> be <id>O</id> .[[ProxyTarget]].</step>
  <step>Let <id>trap</id> be ? GetMethod ( <id>handler</id> , <value>"has"</value> ).</step>
  <step>If <id>trap</id> is <value>undefined</value> , then   <step-list>
    <step>Return ? <id>target</id> .[[HasProperty]]( <id>P</id> ).</step>
  </step-list></step>
  <step>Let <id>booleanTrapResult</id> be ToBoolean (? Call ( <id>trap</id> , <id>handler</id> , « <id>target</id> , <id>P</id> »)).</step>
  <step>If <id>booleanTrapResult</id> is <value>false</value> , then   <step-list>
    <step>Let <id>targetDesc</id> be ? <id>target</id> .[[GetOwnProperty]]( <id>P</id> ).</step>
    <step>If <id>targetDesc</id> is not <value>undefined</value> , then     <step-list>
      <step>If <id>targetDesc</id> .[[Configurable]] is <value>false</value> , throw a <value>TypeError</value> exception.</step>
      <step>Let <id>extensibleTarget</id> be ? IsExtensible ( <id>target</id> ).</step>
      <step>If <id>extensibleTarget</id> is <value>false</value> , throw a <value>TypeError</value> exception.</step>
    </step-list></step>
  </step-list></step>
  <step>Return <id>booleanTrapResult</id> .</step>
</step-list>
<step-list>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>Let <id>handler</id> be <id>O</id> .[[ProxyHandler]].</step>
  <step>If <id>handler</id> is <value>null</value> , throw a <value>TypeError</value> exception.</step>
  <step>Assert : Type ( <id>handler</id> ) is Object.</step>
  <step>Let <id>target</id> be <id>O</id> .[[ProxyTarget]].</step>
  <step>Let <id>trap</id> be ? GetMethod ( <id>handler</id> , <value>"get"</value> ).</step>
  <step>If <id>trap</id> is <value>undefined</value> , then   <step-list>
    <step>Return ? <id>target</id> .[[Get]]( <id>P</id> , <id>Receiver</id> ).</step>
  </step-list></step>
  <step>Let <id>trapResult</id> be ? Call ( <id>trap</id> , <id>handler</id> , « <id>target</id> , <id>P</id> , <id>Receiver</id> »).</step>
  <step>Let <id>targetDesc</id> be ? <id>target</id> .[[GetOwnProperty]]( <id>P</id> ).</step>
  <step>If <id>targetDesc</id> is not <value>undefined</value> and <id>targetDesc</id> .[[Configurable]] is <value>false</value> , then   <step-list>
    <step>If IsDataDescriptor ( <id>targetDesc</id> ) is <value>true</value> and <id>targetDesc</id> .[[Writable]] is <value>false</value> , then     <step-list>
      <step>If SameValue ( <id>trapResult</id> , <id>targetDesc</id> .[[Value]]) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
    </step-list></step>
    <step>If IsAccessorDescriptor ( <id>targetDesc</id> ) is <value>true</value> and <id>targetDesc</id> .[[Get]] is <value>undefined</value> , then     <step-list>
      <step>If <id>trapResult</id> is not <value>undefined</value> , throw a <value>TypeError</value> exception.</step>
    </step-list></step>
  </step-list></step>
  <step>Return <id>trapResult</id> .</step>
</step-list>
<step-list>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>Let <id>handler</id> be <id>O</id> .[[ProxyHandler]].</step>
  <step>If <id>handler</id> is <value>null</value> , throw a <value>TypeError</value> exception.</step>
  <step>Assert : Type ( <id>handler</id> ) is Object.</step>
  <step>Let <id>target</id> be <id>O</id> .[[ProxyTarget]].</step>
  <step>Let <id>trap</id> be ? GetMethod ( <id>handler</id> , <value>"set"</value> ).</step>
  <step>If <id>trap</id> is <value>undefined</value> , then   <step-list>
    <step>Return ? <id>target</id> .[[Set]]( <id>P</id> , <id>V</id> , <id>Receiver</id> ).</step>
  </step-list></step>
  <step>Let <id>booleanTrapResult</id> be ToBoolean (? Call ( <id>trap</id> , <id>handler</id> , « <id>target</id> , <id>P</id> , <id>V</id> , <id>Receiver</id> »)).</step>
  <step>If <id>booleanTrapResult</id> is <value>false</value> , return <value>false</value> .</step>
  <step>Let <id>targetDesc</id> be ? <id>target</id> .[[GetOwnProperty]]( <id>P</id> ).</step>
  <step>If <id>targetDesc</id> is not <value>undefined</value> and <id>targetDesc</id> .[[Configurable]] is <value>false</value> , then   <step-list>
    <step>If IsDataDescriptor ( <id>targetDesc</id> ) is <value>true</value> and <id>targetDesc</id> .[[Writable]] is <value>false</value> , then     <step-list>
      <step>If SameValue ( <id>V</id> , <id>targetDesc</id> .[[Value]]) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
    </step-list></step>
    <step>If IsAccessorDescriptor ( <id>targetDesc</id> ) is <value>true</value> , then     <step-list>
      <step>If <id>targetDesc</id> .[[Set]] is <value>undefined</value> , throw a <value>TypeError</value> exception.</step>
    </step-list></step>
  </step-list></step>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Assert : IsPropertyKey ( <id>P</id> ) is <value>true</value> .</step>
  <step>Let <id>handler</id> be <id>O</id> .[[ProxyHandler]].</step>
  <step>If <id>handler</id> is <value>null</value> , throw a <value>TypeError</value> exception.</step>
  <step>Assert : Type ( <id>handler</id> ) is Object.</step>
  <step>Let <id>target</id> be <id>O</id> .[[ProxyTarget]].</step>
  <step>Let <id>trap</id> be ? GetMethod ( <id>handler</id> , <value>"deleteProperty"</value> ).</step>
  <step>If <id>trap</id> is <value>undefined</value> , then   <step-list>
    <step>Return ? <id>target</id> .[[Delete]]( <id>P</id> ).</step>
  </step-list></step>
  <step>Let <id>booleanTrapResult</id> be ToBoolean (? Call ( <id>trap</id> , <id>handler</id> , « <id>target</id> , <id>P</id> »)).</step>
  <step>If <id>booleanTrapResult</id> is <value>false</value> , return <value>false</value> .</step>
  <step>Let <id>targetDesc</id> be ? <id>target</id> .[[GetOwnProperty]]( <id>P</id> ).</step>
  <step>If <id>targetDesc</id> is <value>undefined</value> , return <value>true</value> .</step>
  <step>If <id>targetDesc</id> .[[Configurable]] is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Let <id>handler</id> be <id>O</id> .[[ProxyHandler]].</step>
  <step>If <id>handler</id> is <value>null</value> , throw a <value>TypeError</value> exception.</step>
  <step>Assert : Type ( <id>handler</id> ) is Object.</step>
  <step>Let <id>target</id> be <id>O</id> .[[ProxyTarget]].</step>
  <step>Let <id>trap</id> be ? GetMethod ( <id>handler</id> , <value>"ownKeys"</value> ).</step>
  <step>If <id>trap</id> is <value>undefined</value> , then   <step-list>
    <step>Return ? <id>target</id> .[[OwnPropertyKeys]]().</step>
  </step-list></step>
  <step>Let <id>trapResultArray</id> be ? Call ( <id>trap</id> , <id>handler</id> , « <id>target</id> »).</step>
  <step>Let <id>trapResult</id> be ? CreateListFromArrayLike ( <id>trapResultArray</id> , « String, Symbol »).</step>
  <step>If <id>trapResult</id> contains any duplicate entries, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>extensibleTarget</id> be ? IsExtensible ( <id>target</id> ).</step>
  <step>Let <id>targetKeys</id> be ? <id>target</id> .[[OwnPropertyKeys]]().</step>
  <step>Assert : <id>targetKeys</id> is a List containing only String and Symbol values.</step>
  <step>Assert : <id>targetKeys</id> contains no duplicate entries.</step>
  <step>Let <id>targetConfigurableKeys</id> be a new empty List .</step>
  <step>Let <id>targetNonconfigurableKeys</id> be a new empty List .</step>
  <step>For each element <id>key</id> of <id>targetKeys</id> , do   <step-list>
    <step>Let <id>desc</id> be ? <id>target</id> .[[GetOwnProperty]]( <id>key</id> ).</step>
    <step>If <id>desc</id> is not <value>undefined</value> and <id>desc</id> .[[Configurable]] is <value>false</value> , then     <step-list>
      <step>Append <id>key</id> as an element of <id>targetNonconfigurableKeys</id> .</step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>Append <id>key</id> as an element of <id>targetConfigurableKeys</id> .</step>
    </step-list></step>
  </step-list></step>
  <step>If <id>extensibleTarget</id> is <value>true</value> and <id>targetNonconfigurableKeys</id> is empty, then   <step-list>
    <step>Return <id>trapResult</id> .</step>
  </step-list></step>
  <step>Let <id>uncheckedResultKeys</id> be a new List which is a copy of <id>trapResult</id> .</step>
  <step>For each <id>key</id> that is an element of <id>targetNonconfigurableKeys</id> , do   <step-list>
    <step>If <id>key</id> is not an element of <id>uncheckedResultKeys</id> , throw a <value>TypeError</value> exception.</step>
    <step>Remove <id>key</id> from <id>uncheckedResultKeys</id> .</step>
  </step-list></step>
  <step>If <id>extensibleTarget</id> is <value>true</value> , return <id>trapResult</id> .</step>
  <step>For each <id>key</id> that is an element of <id>targetConfigurableKeys</id> , do   <step-list>
    <step>If <id>key</id> is not an element of <id>uncheckedResultKeys</id> , throw a <value>TypeError</value> exception.</step>
    <step>Remove <id>key</id> from <id>uncheckedResultKeys</id> .</step>
  </step-list></step>
  <step>If <id>uncheckedResultKeys</id> is not empty, throw a <value>TypeError</value> exception.</step>
  <step>Return <id>trapResult</id> .</step>
</step-list>
<step-list>
  <step>Let <id>handler</id> be <id>O</id> .[[ProxyHandler]].</step>
  <step>If <id>handler</id> is <value>null</value> , throw a <value>TypeError</value> exception.</step>
  <step>Assert : Type ( <id>handler</id> ) is Object.</step>
  <step>Let <id>target</id> be <id>O</id> .[[ProxyTarget]].</step>
  <step>Let <id>trap</id> be ? GetMethod ( <id>handler</id> , <value>"apply"</value> ).</step>
  <step>If <id>trap</id> is <value>undefined</value> , then   <step-list>
    <step>Return ? Call ( <id>target</id> , <id>thisArgument</id> , <id>argumentsList</id> ).</step>
  </step-list></step>
  <step>Let <id>argArray</id> be CreateArrayFromList ( <id>argumentsList</id> ).</step>
  <step>Return ? Call ( <id>trap</id> , <id>handler</id> , « <id>target</id> , <id>thisArgument</id> , <id>argArray</id> »).</step>
</step-list>
<step-list>
  <step>Let <id>handler</id> be <id>O</id> .[[ProxyHandler]].</step>
  <step>If <id>handler</id> is <value>null</value> , throw a <value>TypeError</value> exception.</step>
  <step>Assert : Type ( <id>handler</id> ) is Object.</step>
  <step>Let <id>target</id> be <id>O</id> .[[ProxyTarget]].</step>
  <step>Let <id>trap</id> be ? GetMethod ( <id>handler</id> , <value>"construct"</value> ).</step>
  <step>If <id>trap</id> is <value>undefined</value> , then   <step-list>
    <step>Assert : IsConstructor ( <id>target</id> ) is <value>true</value> .</step>
    <step>Return ? Construct ( <id>target</id> , <id>argumentsList</id> , <id>newTarget</id> ).</step>
  </step-list></step>
  <step>Let <id>argArray</id> be CreateArrayFromList ( <id>argumentsList</id> ).</step>
  <step>Let <id>newObj</id> be ? Call ( <id>trap</id> , <id>handler</id> , « <id>target</id> , <id>argArray</id> , <id>newTarget</id> »).</step>
  <step>If Type ( <id>newObj</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Return <id>newObj</id> .</step>
</step-list>
<step-list>
  <step>If Type ( <id>target</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>target</id> is a Proxy exotic object and <id>target</id> .[[ProxyHandler]] is <value>null</value> , throw a <value>TypeError</value> exception.</step>
  <step>If Type ( <id>handler</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>handler</id> is a Proxy exotic object and <id>handler</id> .[[ProxyHandler]] is <value>null</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>P</id> be a newly created object.</step>
  <step>Set <id>P</id> 's essential internal methods (except for [[Call]] and [[Construct]]) to the definitions specified in 9.5 .</step>
  <step>If IsCallable ( <id>target</id> ) is <value>true</value> , then   <step-list>
    <step>Set <id>P</id> .[[Call]] as specified in 9.5.12 .</step>
    <step>If IsConstructor ( <id>target</id> ) is <value>true</value> , then     <step-list>
      <step>Set <id>P</id> .[[Construct]] as specified in 9.5.13 .</step>
    </step-list></step>
  </step-list></step>
  <step>Set <id>P</id> .[[ProxyTarget]] to <id>target</id> .</step>
  <step>Set <id>P</id> .[[ProxyHandler]] to <id>handler</id> .</step>
  <step>Return <id>P</id> .</step>
</step-list>
<step-list>
  <step>Assert : 0 ≤ <id>cp</id> ≤ 0x10FFFF.</step>
  <step>If <id>cp</id> ≤ 0xFFFF, return <id>cp</id> .</step>
  <step>Let <id>cu1</id> be floor (( <id>cp</id> - 0x10000) / 0x400) + 0xD800.</step>
  <step>Let <id>cu2</id> be (( <id>cp</id> - 0x10000) modulo 0x400) + 0xDC00.</step>
  <step>Return the code unit sequence consisting of <id>cu1</id> followed by <id>cu2</id> .</step>
</step-list>
<step-list>
  <step>Assert : <id>lead</id> is a leading surrogate and <id>trail</id> is a trailing surrogate .</step>
  <step>Let <id>cp</id> be ( <id>lead</id> - 0xD800) × 0x400 + ( <id>trail</id> - 0xDC00) + 0x10000.</step>
  <step>Return the code point <id>cp</id> .</step>
</step-list>
<step-list>
  <step>Return the String value consisting of the sequence of code units corresponding to IdentifierName . In determining the sequence any occurrences of <value>\</value>  UnicodeEscapeSequence are first replaced with the code point represented by the UnicodeEscapeSequence and then the code points of the entire IdentifierName are converted to code units by UTF16Encoding each code point.</step>
</step-list>
<step-list>
  <step>Return the String value whose elements are the SV of this StringLiteral .</step>
</step-list>
<step-list>
  <step>Return the source text that was recognized as RegularExpressionBody .</step>
</step-list>
<step-list>
  <step>Return the source text that was recognized as RegularExpressionFlags .</step>
</step-list>
<step-list>
  <step>Return a new List containing the StringValue of Identifier .</step>
</step-list>
<step-list>
  <step>Return a new List containing <value>"yield"</value> .</step>
</step-list>
<step-list>
  <step>Return a new List containing <value>"await"</value> .</step>
</step-list>
<step-list>
  <step>If this IdentifierReference is contained in strict mode code and StringValue of Identifier is <value>"eval"</value> or <value>"arguments"</value> , return <value>false</value> .</step>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return <value>"yield"</value> .</step>
</step-list>
<step-list>
  <step>Return <value>"await"</value> .</step>
</step-list>
<step-list>
  <step>Return the StringValue of IdentifierName .</step>
</step-list>
<step-list>
  <step>Let <id>name</id> be StringValue of Identifier .</step>
  <step>Return ? InitializeBoundName ( <id>name</id> , <id>value</id> , <id>environment</id> ).</step>
</step-list>
<step-list>
  <step>Return ? InitializeBoundName ( <value>"yield"</value> , <id>value</id> , <id>environment</id> ).</step>
</step-list>
<step-list>
  <step>Return ? InitializeBoundName ( <value>"await"</value> , <id>value</id> , <id>environment</id> ).</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>name</id> ) is String.</step>
  <step>If <id>environment</id> is not <value>undefined</value> , then   <step-list>
    <step>Let <id>env</id> be the EnvironmentRecord component of <id>environment</id> .</step>
    <step>Perform <id>env</id> .InitializeBinding( <id>name</id> , <id>value</id> ).</step>
    <step>Return NormalCompletion ( <value>undefined</value> ).</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>lhs</id> be ResolveBinding ( <id>name</id> ).</step>
    <step>Return ? PutValue ( <id>lhs</id> , <id>value</id> ).</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Return ? ResolveBinding (StringValue of Identifier ).</step>
</step-list>
<step-list>
  <step>Return ? ResolveBinding ( <value>"yield"</value> ).</step>
</step-list>
<step-list>
  <step>Return ? ResolveBinding ( <value>"await"</value> ).</step>
</step-list>
<step-list>
  <step>Return the ParenthesizedExpression that is covered by CoverParenthesizedExpressionAndArrowParameterList .</step>
</step-list>
<step-list>
  <step>Let <id>expr</id> be CoveredParenthesizedExpression of CoverParenthesizedExpressionAndArrowParameterList .</step>
  <step>If IsFunctionDefinition of <id>expr</id> is <value>false</value> , return <value>false</value> .</step>
  <step>Return HasName of <id>expr</id> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>expr</id> be CoveredParenthesizedExpression of CoverParenthesizedExpressionAndArrowParameterList .</step>
  <step>Return IsFunctionDefinition of <id>expr</id> .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>expr</id> be CoveredParenthesizedExpression of CoverParenthesizedExpressionAndArrowParameterList .</step>
  <step>Return IsValidSimpleAssignmentTarget of <id>expr</id> .</step>
</step-list>
<step-list>
  <step>Return ? ResolveThisBinding ().</step>
</step-list>
<step-list>
  <step>Return <value>null</value> .</step>
</step-list>
<step-list>
  <step>If BooleanLiteral is the token <value>false</value> , return <value>false</value> .</step>
  <step>If BooleanLiteral is the token <value>true</value> , return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return the number whose value is MV of NumericLiteral as defined in 11.8.3 .</step>
</step-list>
<step-list>
  <step>Return the StringValue of StringLiteral as defined in 11.8.4.1 .</step>
</step-list>
<step-list>
  <step>Return the numeric value 1.</step>
</step-list>
<step-list>
  <step>Let <id>preceding</id> be the ElisionWidth of Elision .</step>
  <step>Return <id>preceding</id> +1.</step>
</step-list>
<step-list>
  <step>Let <id>padding</id> be the ElisionWidth of Elision ; if Elision is not present, use the numeric value zero.</step>
  <step>Let <id>initResult</id> be the result of evaluating AssignmentExpression .</step>
  <step>Let <id>initValue</id> be ? GetValue ( <id>initResult</id> ).</step>
  <step>Let <id>created</id> be CreateDataProperty ( <id>array</id> , ToString ( ToUint32 ( <id>nextIndex</id> + <id>padding</id> )), <id>initValue</id> ).</step>
  <step>Assert : <id>created</id> is <value>true</value> .</step>
  <step>Return <id>nextIndex</id> + <id>padding</id> +1.</step>
</step-list>
<step-list>
  <step>Let <id>padding</id> be the ElisionWidth of Elision ; if Elision is not present, use the numeric value zero.</step>
  <step>Return the result of performing ArrayAccumulation for SpreadElement with arguments <id>array</id> and <id>nextIndex</id> + <id>padding</id> .</step>
</step-list>
<step-list>
  <step>Let <id>postIndex</id> be the result of performing ArrayAccumulation for ElementList with arguments <id>array</id> and <id>nextIndex</id> .</step>
  <step>ReturnIfAbrupt ( <id>postIndex</id> ).</step>
  <step>Let <id>padding</id> be the ElisionWidth of Elision ; if Elision is not present, use the numeric value zero.</step>
  <step>Let <id>initResult</id> be the result of evaluating AssignmentExpression .</step>
  <step>Let <id>initValue</id> be ? GetValue ( <id>initResult</id> ).</step>
  <step>Let <id>created</id> be CreateDataProperty ( <id>array</id> , ToString ( ToUint32 ( <id>postIndex</id> + <id>padding</id> )), <id>initValue</id> ).</step>
  <step>Assert : <id>created</id> is <value>true</value> .</step>
  <step>Return <id>postIndex</id> + <id>padding</id> +1.</step>
</step-list>
<step-list>
  <step>Let <id>postIndex</id> be the result of performing ArrayAccumulation for ElementList with arguments <id>array</id> and <id>nextIndex</id> .</step>
  <step>ReturnIfAbrupt ( <id>postIndex</id> ).</step>
  <step>Let <id>padding</id> be the ElisionWidth of Elision ; if Elision is not present, use the numeric value zero.</step>
  <step>Return the result of performing ArrayAccumulation for SpreadElement with arguments <id>array</id> and <id>postIndex</id> + <id>padding</id> .</step>
</step-list>
<step-list>
  <step>Let <id>spreadRef</id> be the result of evaluating AssignmentExpression .</step>
  <step>Let <id>spreadObj</id> be ? GetValue ( <id>spreadRef</id> ).</step>
  <step>Let <id>iteratorRecord</id> be ? GetIterator ( <id>spreadObj</id> ).</step>
  <step>Repeat,   <step-list>
    <step>Let <id>next</id> be ? IteratorStep ( <id>iteratorRecord</id> ).</step>
    <step>If <id>next</id> is <value>false</value> , return <id>nextIndex</id> .</step>
    <step>Let <id>nextValue</id> be ? IteratorValue ( <id>next</id> ).</step>
    <step>Let <id>status</id> be CreateDataProperty ( <id>array</id> , ToString ( ToUint32 ( <id>nextIndex</id> )), <id>nextValue</id> ).</step>
    <step>Assert : <id>status</id> is <value>true</value> .</step>
    <step>Let <id>nextIndex</id> be <id>nextIndex</id> + 1.</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>array</id> be ! ArrayCreate (0).</step>
  <step>Let <id>pad</id> be the ElisionWidth of Elision ; if Elision is not present, use the numeric value zero.</step>
  <step>Perform Set ( <id>array</id> , <value>"length"</value> , ToUint32 ( <id>pad</id> ), <value>false</value> ).</step>
  <step>NOTE: The above Set cannot fail because of the nature of the object returned by ArrayCreate .</step>
  <step>Return <id>array</id> .</step>
</step-list>
<step-list>
  <step>Let <id>array</id> be ! ArrayCreate (0).</step>
  <step>Let <id>len</id> be the result of performing ArrayAccumulation for ElementList with arguments <id>array</id> and 0.</step>
  <step>ReturnIfAbrupt ( <id>len</id> ).</step>
  <step>Perform Set ( <id>array</id> , <value>"length"</value> , ToUint32 ( <id>len</id> ), <value>false</value> ).</step>
  <step>NOTE: The above Set cannot fail because of the nature of the object returned by ArrayCreate .</step>
  <step>Return <id>array</id> .</step>
</step-list>
<step-list>
  <step>Let <id>array</id> be ! ArrayCreate (0).</step>
  <step>Let <id>len</id> be the result of performing ArrayAccumulation for ElementList with arguments <id>array</id> and 0.</step>
  <step>ReturnIfAbrupt ( <id>len</id> ).</step>
  <step>Let <id>padding</id> be the ElisionWidth of Elision ; if Elision is not present, use the numeric value zero.</step>
  <step>Perform Set ( <id>array</id> , <value>"length"</value> , ToUint32 ( <id>padding</id> + <id>len</id> ), <value>false</value> ).</step>
  <step>NOTE: The above Set cannot fail because of the nature of the object returned by ArrayCreate .</step>
  <step>Return <id>array</id> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return the result of ComputedPropertyName Contains <id>symbol</id> .</step>
</step-list>
<step-list>
  <step>If <id>symbol</id> is MethodDefinition , return <value>true</value> .</step>
  <step>Return the result of ComputedPropertyContains for MethodDefinition with argument <id>symbol</id> .</step>
</step-list>
<step-list>
  <step>If <id>symbol</id> is a ReservedWord , return <value>false</value> .</step>
  <step>If <id>symbol</id> is an Identifier and StringValue of <id>symbol</id> is the same value as the StringValue of IdentifierName , return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return StringValue of IdentifierReference .</step>
</step-list>
<step-list>
  <step>Return <value>empty</value> .</step>
</step-list>
<step-list>
  <step>Return PropName of PropertyName .</step>
</step-list>
<step-list>
  <step>Return StringValue of IdentifierName .</step>
</step-list>
<step-list>
  <step>Return the String value whose code units are the SV of the StringLiteral .</step>
</step-list>
<step-list>
  <step>Let <id>nbr</id> be the result of forming the value of the NumericLiteral .</step>
  <step>Return ! ToString ( <id>nbr</id> ).</step>
</step-list>
<step-list>
  <step>Return <value>empty</value> .</step>
</step-list>
<step-list>
  <step>If PropName of PropertyDefinition is <value>empty</value> , return a new empty List .</step>
  <step>Return a new List containing PropName of PropertyDefinition .</step>
</step-list>
<step-list>
  <step>Let <id>list</id> be PropertyNameList of PropertyDefinitionList .</step>
  <step>If PropName of PropertyDefinition is <value>empty</value> , return <id>list</id> .</step>
  <step>Append PropName of PropertyDefinition to the end of <id>list</id> .</step>
  <step>Return <id>list</id> .</step>
</step-list>
<step-list>
  <step>Return ObjectCreate ( %ObjectPrototype% ).</step>
</step-list>
<step-list>
  <step>Let <id>obj</id> be ObjectCreate ( %ObjectPrototype% ).</step>
  <step>Perform ? PropertyDefinitionEvaluation of PropertyDefinitionList with arguments <id>obj</id> and <value>true</value> .</step>
  <step>Return <id>obj</id> .</step>
</step-list>
<step-list>
  <step>Return StringValue of IdentifierName .</step>
</step-list>
<step-list>
  <step>Return the String value whose code units are the SV of the StringLiteral .</step>
</step-list>
<step-list>
  <step>Let <id>nbr</id> be the result of forming the value of the NumericLiteral .</step>
  <step>Return ! ToString ( <id>nbr</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>exprValue</id> be the result of evaluating AssignmentExpression .</step>
  <step>Let <id>propName</id> be ? GetValue ( <id>exprValue</id> ).</step>
  <step>Return ? ToPropertyKey ( <id>propName</id> ).</step>
</step-list>
<step-list>
  <step>Perform ? PropertyDefinitionEvaluation of PropertyDefinitionList with arguments <id>object</id> and <id>enumerable</id> .</step>
  <step>Return the result of performing PropertyDefinitionEvaluation of PropertyDefinition with arguments <id>object</id> and <id>enumerable</id> .</step>
</step-list>
<step-list>
  <step>Let <id>exprValue</id> be the result of evaluating AssignmentExpression .</step>
  <step>Let <id>fromValue</id> be ? GetValue ( <id>exprValue</id> ).</step>
  <step>Let <id>excludedNames</id> be a new empty List .</step>
  <step>Return ? CopyDataProperties ( <id>object</id> , <id>fromValue</id> , <id>excludedNames</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>propName</id> be StringValue of IdentifierReference .</step>
  <step>Let <id>exprValue</id> be the result of evaluating IdentifierReference .</step>
  <step>Let <id>propValue</id> be ? GetValue ( <id>exprValue</id> ).</step>
  <step>Assert : <id>enumerable</id> is <value>true</value> .</step>
  <step>Return CreateDataPropertyOrThrow ( <id>object</id> , <id>propName</id> , <id>propValue</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>propKey</id> be the result of evaluating PropertyName .</step>
  <step>ReturnIfAbrupt ( <id>propKey</id> ).</step>
  <step>Let <id>exprValueRef</id> be the result of evaluating AssignmentExpression .</step>
  <step>Let <id>propValue</id> be ? GetValue ( <id>exprValueRef</id> ).</step>
  <step>If IsAnonymousFunctionDefinition ( AssignmentExpression ) is <value>true</value> , then   <step-list>
    <step>Let <id>hasNameProperty</id> be ? HasOwnProperty ( <id>propValue</id> , <value>"name"</value> ).</step>
    <step>If <id>hasNameProperty</id> is <value>false</value> , perform SetFunctionName ( <id>propValue</id> , <id>propKey</id> ).</step>
  </step-list></step>
  <step>Assert : <id>enumerable</id> is <value>true</value> .</step>
  <step>Return CreateDataPropertyOrThrow ( <id>object</id> , <id>propKey</id> , <id>propValue</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>pattern</id> be the String value consisting of the UTF16Encoding of each code point of BodyText of RegularExpressionLiteral .</step>
  <step>Let <id>flags</id> be the String value consisting of the UTF16Encoding of each code point of FlagText of RegularExpressionLiteral .</step>
  <step>Return RegExpCreate ( <id>pattern</id> , <id>flags</id> ).</step>
</step-list>
<step-list>
  <step>If <id>raw</id> is <value>false</value> , then   <step-list>
    <step>Let <id>string</id> be the TV of NoSubstitutionTemplate .</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>string</id> be the TRV of NoSubstitutionTemplate .</step>
  </step-list></step>
  <step>Return a List containing the single element, <id>string</id> .</step>
</step-list>
<step-list>
  <step>If <id>raw</id> is <value>false</value> , then   <step-list>
    <step>Let <id>head</id> be the TV of TemplateHead .</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>head</id> be the TRV of TemplateHead .</step>
  </step-list></step>
  <step>Let <id>tail</id> be TemplateStrings of TemplateSpans with argument <id>raw</id> .</step>
  <step>Return a List containing <id>head</id> followed by the elements, in order, of <id>tail</id> .</step>
</step-list>
<step-list>
  <step>If <id>raw</id> is <value>false</value> , then   <step-list>
    <step>Let <id>tail</id> be the TV of TemplateTail .</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>tail</id> be the TRV of TemplateTail .</step>
  </step-list></step>
  <step>Return a List containing the single element, <id>tail</id> .</step>
</step-list>
<step-list>
  <step>Let <id>middle</id> be TemplateStrings of TemplateMiddleList with argument <id>raw</id> .</step>
  <step>If <id>raw</id> is <value>false</value> , then   <step-list>
    <step>Let <id>tail</id> be the TV of TemplateTail .</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>tail</id> be the TRV of TemplateTail .</step>
  </step-list></step>
  <step>Return a List containing the elements, in order, of <id>middle</id> followed by <id>tail</id> .</step>
</step-list>
<step-list>
  <step>If <id>raw</id> is <value>false</value> , then   <step-list>
    <step>Let <id>string</id> be the TV of TemplateMiddle .</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>string</id> be the TRV of TemplateMiddle .</step>
  </step-list></step>
  <step>Return a List containing the single element, <id>string</id> .</step>
</step-list>
<step-list>
  <step>Let <id>front</id> be TemplateStrings of TemplateMiddleList with argument <id>raw</id> .</step>
  <step>If <id>raw</id> is <value>false</value> , then   <step-list>
    <step>Let <id>last</id> be the TV of TemplateMiddle .</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>last</id> be the TRV of TemplateMiddle .</step>
  </step-list></step>
  <step>Append <id>last</id> as the last element of the List  <id>front</id> .</step>
  <step>Return <id>front</id> .</step>
</step-list>
<step-list>
  <step>Let <id>templateLiteral</id> be this TemplateLiteral .</step>
  <step>Let <id>siteObj</id> be GetTemplateObject ( <id>templateLiteral</id> ).</step>
  <step>Return a List containing the one element which is <id>siteObj</id> .</step>
</step-list>
<step-list>
  <step>Let <id>templateLiteral</id> be this TemplateLiteral .</step>
  <step>Let <id>siteObj</id> be GetTemplateObject ( <id>templateLiteral</id> ).</step>
  <step>Let <id>firstSubRef</id> be the result of evaluating Expression .</step>
  <step>Let <id>firstSub</id> be ? GetValue ( <id>firstSubRef</id> ).</step>
  <step>Let <id>restSub</id> be SubstitutionEvaluation of TemplateSpans .</step>
  <step>ReturnIfAbrupt ( <id>restSub</id> ).</step>
  <step>Assert : <id>restSub</id> is a List .</step>
  <step>Return a List whose first element is <id>siteObj</id> , whose second elements is <id>firstSub</id> , and whose subsequent elements are the elements of <id>restSub</id> , in order. <id>restSub</id> may contain no elements.</step>
</step-list>
<step-list>
  <step>Let <id>rawStrings</id> be TemplateStrings of <id>templateLiteral</id> with argument <value>true</value> .</step>
  <step>Let <id>realm</id> be the current Realm Record .</step>
  <step>Let <id>templateRegistry</id> be <id>realm</id> .[[TemplateMap]].</step>
  <step>For each element <id>e</id> of <id>templateRegistry</id> , do   <step-list>
    <step>If <id>e</id> .[[Site]] is the same Parse Node as <id>templateLiteral</id> , then     <step-list>
      <step>Return <id>e</id> .[[Array]].</step>
    </step-list></step>
  </step-list></step>
  <step>Let <id>cookedStrings</id> be TemplateStrings of <id>templateLiteral</id> with argument <value>false</value> .</step>
  <step>Let <id>count</id> be the number of elements in the List  <id>cookedStrings</id> .</step>
  <step>Assert : <id>count</id> ≤ 2 32 -1.</step>
  <step>Let <id>template</id> be ! ArrayCreate ( <id>count</id> ).</step>
  <step>Let <id>rawObj</id> be ! ArrayCreate ( <id>count</id> ).</step>
  <step>Let <id>index</id> be 0.</step>
  <step>Repeat, while <id>index</id> < <id>count</id>   <step-list>
    <step>Let <id>prop</id> be ! ToString ( <id>index</id> ).</step>
    <step>Let <id>cookedValue</id> be the String value <id>cookedStrings</id> [ <id>index</id> ].</step>
    <step>Call <id>template</id> .[[DefineOwnProperty]]( <id>prop</id> , PropertyDescriptor { [[Value]]: <id>cookedValue</id> , [[Writable]]: <value>false</value> , [[Enumerable]]: <value>true</value> , [[Configurable]]: <value>false</value> }).</step>
    <step>Let <id>rawValue</id> be the String value <id>rawStrings</id> [ <id>index</id> ].</step>
    <step>Call <id>rawObj</id> .[[DefineOwnProperty]]( <id>prop</id> , PropertyDescriptor { [[Value]]: <id>rawValue</id> , [[Writable]]: <value>false</value> , [[Enumerable]]: <value>true</value> , [[Configurable]]: <value>false</value> }).</step>
    <step>Let <id>index</id> be <id>index</id> +1.</step>
  </step-list></step>
  <step>Perform SetIntegrityLevel ( <id>rawObj</id> , <value>"frozen"</value> ).</step>
  <step>Call <id>template</id> .[[DefineOwnProperty]]( <value>"raw"</value> , PropertyDescriptor { [[Value]]: <id>rawObj</id> , [[Writable]]: <value>false</value> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>false</value> }).</step>
  <step>Perform SetIntegrityLevel ( <id>template</id> , <value>"frozen"</value> ).</step>
  <step>Append the Record { [[Site]]: <id>templateLiteral</id> , [[Array]]: <id>template</id> } to <id>templateRegistry</id> .</step>
  <step>Return <id>template</id> .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return the result of SubstitutionEvaluation of TemplateMiddleList .</step>
</step-list>
<step-list>
  <step>Let <id>subRef</id> be the result of evaluating Expression .</step>
  <step>Let <id>sub</id> be ? GetValue ( <id>subRef</id> ).</step>
  <step>Return a List containing only <id>sub</id> .</step>
</step-list>
<step-list>
  <step>Let <id>preceding</id> be the result of SubstitutionEvaluation of TemplateMiddleList .</step>
  <step>ReturnIfAbrupt ( <id>preceding</id> ).</step>
  <step>Let <id>nextRef</id> be the result of evaluating Expression .</step>
  <step>Let <id>next</id> be ? GetValue ( <id>nextRef</id> ).</step>
  <step>Append <id>next</id> as the last element of the List  <id>preceding</id> .</step>
  <step>Return <id>preceding</id> .</step>
</step-list>
<step-list>
  <step>Return the String value whose code units are the elements of the TV of NoSubstitutionTemplate as defined in 11.8.6 .</step>
</step-list>
<step-list>
  <step>Let <id>head</id> be the TV of TemplateHead as defined in 11.8.6 .</step>
  <step>Let <id>sub</id> be the result of evaluating Expression .</step>
  <step>ReturnIfAbrupt ( <id>sub</id> ).</step>
  <step>Let <id>middle</id> be ? ToString ( <id>sub</id> ).</step>
  <step>Let <id>tail</id> be the result of evaluating TemplateSpans .</step>
  <step>ReturnIfAbrupt ( <id>tail</id> ).</step>
  <step>Return the string-concatenation of <id>head</id> , <id>middle</id> , and <id>tail</id> .</step>
</step-list>
<step-list>
  <step>Let <id>tail</id> be the TV of TemplateTail as defined in 11.8.6 .</step>
  <step>Return the String value consisting of the code units of <id>tail</id> .</step>
</step-list>
<step-list>
  <step>Let <id>head</id> be the result of evaluating TemplateMiddleList .</step>
  <step>ReturnIfAbrupt ( <id>head</id> ).</step>
  <step>Let <id>tail</id> be the TV of TemplateTail as defined in 11.8.6 .</step>
  <step>Return the string-concatenation of <id>head</id> and <id>tail</id> .</step>
</step-list>
<step-list>
  <step>Let <id>head</id> be the TV of TemplateMiddle as defined in 11.8.6 .</step>
  <step>Let <id>sub</id> be the result of evaluating Expression .</step>
  <step>ReturnIfAbrupt ( <id>sub</id> ).</step>
  <step>Let <id>middle</id> be ? ToString ( <id>sub</id> ).</step>
  <step>Return the sequence of code units consisting of the code units of <id>head</id> followed by the elements of <id>middle</id> .</step>
</step-list>
<step-list>
  <step>Let <id>rest</id> be the result of evaluating TemplateMiddleList .</step>
  <step>ReturnIfAbrupt ( <id>rest</id> ).</step>
  <step>Let <id>middle</id> be the TV of TemplateMiddle as defined in 11.8.6 .</step>
  <step>Let <id>sub</id> be the result of evaluating Expression .</step>
  <step>ReturnIfAbrupt ( <id>sub</id> ).</step>
  <step>Let <id>last</id> be ? ToString ( <id>sub</id> ).</step>
  <step>Return the sequence of code units consisting of the elements of <id>rest</id> followed by the code units of <id>middle</id> followed by the elements of <id>last</id> .</step>
</step-list>
<step-list>
  <step>Return IsFunctionDefinition of Expression .</step>
</step-list>
<step-list>
  <step>Return IsValidSimpleAssignmentTarget of Expression .</step>
</step-list>
<step-list>
  <step>Let <id>expr</id> be CoveredParenthesizedExpression of CoverParenthesizedExpressionAndArrowParameterList .</step>
  <step>Return the result of evaluating <id>expr</id> .</step>
</step-list>
<step-list>
  <step>Return the result of evaluating Expression . This may be of type Reference .</step>
</step-list>
<step-list>
  <step>Return the CallMemberExpression that is covered by CoverCallExpressionAndAsyncArrowHead .</step>
</step-list>
<step-list>
  <step>If MemberExpression Contains <id>symbol</id> is <value>true</value> , return <value>true</value> .</step>
  <step>If <id>symbol</id> is a ReservedWord , return <value>false</value> .</step>
  <step>If <id>symbol</id> is an Identifier and StringValue of <id>symbol</id> is the same value as the StringValue of IdentifierName , return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If <id>symbol</id> is the ReservedWord  <value>super</value> , return <value>true</value> .</step>
  <step>If <id>symbol</id> is a ReservedWord , return <value>false</value> .</step>
  <step>If <id>symbol</id> is an Identifier and StringValue of <id>symbol</id> is the same value as the StringValue of IdentifierName , return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If CallExpression Contains <id>symbol</id> is <value>true</value> , return <value>true</value> .</step>
  <step>If <id>symbol</id> is a ReservedWord , return <value>false</value> .</step>
  <step>If <id>symbol</id> is an Identifier and StringValue of <id>symbol</id> is the same value as the StringValue of IdentifierName , return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If PrimaryExpression is either an ObjectLiteral or an ArrayLiteral , return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>baseReference</id> be the result of evaluating MemberExpression .</step>
  <step>Let <id>baseValue</id> be ? GetValue ( <id>baseReference</id> ).</step>
  <step>Let <id>propertyNameReference</id> be the result of evaluating Expression .</step>
  <step>Let <id>propertyNameValue</id> be ? GetValue ( <id>propertyNameReference</id> ).</step>
  <step>Let <id>bv</id> be ? RequireObjectCoercible ( <id>baseValue</id> ).</step>
  <step>Let <id>propertyKey</id> be ? ToPropertyKey ( <id>propertyNameValue</id> ).</step>
  <step>If the code matched by this MemberExpression is strict mode code , let <id>strict</id> be <value>true</value> , else let <id>strict</id> be <value>false</value> .</step>
  <step>Return a value of type Reference whose base value component is <id>bv</id> , whose referenced name component is <id>propertyKey</id> , and whose strict reference flag is <id>strict</id> .</step>
</step-list>
<step-list>
  <step>Let <id>baseReference</id> be the result of evaluating MemberExpression .</step>
  <step>Let <id>baseValue</id> be ? GetValue ( <id>baseReference</id> ).</step>
  <step>Let <id>bv</id> be ? RequireObjectCoercible ( <id>baseValue</id> ).</step>
  <step>Let <id>propertyNameString</id> be StringValue of IdentifierName .</step>
  <step>If the code matched by this MemberExpression is strict mode code , let <id>strict</id> be <value>true</value> , else let <id>strict</id> be <value>false</value> .</step>
  <step>Return a value of type Reference whose base value component is <id>bv</id> , whose referenced name component is <id>propertyNameString</id> , and whose strict reference flag is <id>strict</id> .</step>
</step-list>
<step-list>
  <step>Return ? EvaluateNew ( NewExpression , <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Return ? EvaluateNew ( MemberExpression , Arguments ).</step>
</step-list>
<step-list>
  <step>Assert : <id>constructExpr</id> is either a NewExpression or a MemberExpression .</step>
  <step>Assert : <id>arguments</id> is either <value>empty</value> or an Arguments .</step>
  <step>Let <id>ref</id> be the result of evaluating <id>constructExpr</id> .</step>
  <step>Let <id>constructor</id> be ? GetValue ( <id>ref</id> ).</step>
  <step>If <id>arguments</id> is <value>empty</value> , let <id>argList</id> be a new empty List .</step>
  <step>Else,   <step-list>
    <step>Let <id>argList</id> be ArgumentListEvaluation of <id>arguments</id> .</step>
    <step>ReturnIfAbrupt ( <id>argList</id> ).</step>
  </step-list></step>
  <step>If IsConstructor ( <id>constructor</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Return ? Construct ( <id>constructor</id> , <id>argList</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>expr</id> be CoveredCallExpression of CoverCallExpressionAndAsyncArrowHead .</step>
  <step>Let <id>memberExpr</id> be the MemberExpression of <id>expr</id> .</step>
  <step>Let <id>arguments</id> be the Arguments of <id>expr</id> .</step>
  <step>Let <id>ref</id> be the result of evaluating <id>memberExpr</id> .</step>
  <step>Let <id>func</id> be ? GetValue ( <id>ref</id> ).</step>
  <step>If Type ( <id>ref</id> ) is Reference and IsPropertyReference ( <id>ref</id> ) is <value>false</value> and GetReferencedName ( <id>ref</id> ) is <value>"eval"</value> , then   <step-list>
    <step>If SameValue ( <id>func</id> , %eval% ) is <value>true</value> , then     <step-list>
      <step>Let <id>argList</id> be ? ArgumentListEvaluation of <id>arguments</id> .</step>
      <step>If <id>argList</id> has no elements, return <value>undefined</value> .</step>
      <step>Let <id>evalText</id> be the first element of <id>argList</id> .</step>
      <step>If the source code matching this CallExpression is strict mode code , let <id>strictCaller</id> be <value>true</value> . Otherwise let <id>strictCaller</id> be <value>false</value> .</step>
      <step>Let <id>evalRealm</id> be the current Realm Record .</step>
      <step>Perform ? HostEnsureCanCompileStrings ( <id>evalRealm</id> , <id>evalRealm</id> ).</step>
      <step>Return ? PerformEval ( <id>evalText</id> , <id>evalRealm</id> , <id>strictCaller</id> , <value>true</value> ).</step>
    </step-list></step>
  </step-list></step>
  <step>Let <id>thisCall</id> be this CallExpression .</step>
  <step>Let <id>tailCall</id> be IsInTailPosition ( <id>thisCall</id> ).</step>
  <step>Return ? EvaluateCall ( <id>func</id> , <id>ref</id> , <id>arguments</id> , <id>tailCall</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>ref</id> be the result of evaluating CallExpression .</step>
  <step>Let <id>func</id> be ? GetValue ( <id>ref</id> ).</step>
  <step>Let <id>thisCall</id> be this CallExpression .</step>
  <step>Let <id>tailCall</id> be IsInTailPosition ( <id>thisCall</id> ).</step>
  <step>Return ? EvaluateCall ( <id>func</id> , <id>ref</id> , Arguments , <id>tailCall</id> ).</step>
</step-list>
<step-list>
  <step>If Type ( <id>ref</id> ) is Reference , then   <step-list>
    <step>If IsPropertyReference ( <id>ref</id> ) is <value>true</value> , then     <step-list>
      <step>Let <id>thisValue</id> be GetThisValue ( <id>ref</id> ).</step>
    </step-list></step>
    <step>Else the base of <id>ref</id> is an Environment Record ,     <step-list>
      <step>Let <id>refEnv</id> be GetBase ( <id>ref</id> ).</step>
      <step>Let <id>thisValue</id> be <id>refEnv</id> .WithBaseObject().</step>
    </step-list></step>
  </step-list></step>
  <step>Else Type ( <id>ref</id> ) is not Reference ,   <step-list>
    <step>Let <id>thisValue</id> be <value>undefined</value> .</step>
  </step-list></step>
  <step>Let <id>argList</id> be ArgumentListEvaluation of <id>arguments</id> .</step>
  <step>ReturnIfAbrupt ( <id>argList</id> ).</step>
  <step>If Type ( <id>func</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If IsCallable ( <id>func</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>If <id>tailPosition</id> is <value>true</value> , perform PrepareForTailCall ().</step>
  <step>Let <id>result</id> be Call ( <id>func</id> , <id>thisValue</id> , <id>argList</id> ).</step>
  <step>Assert : If <id>tailPosition</id> is <value>true</value> , the above call will not return here, but instead evaluation will continue as if the following return has already occurred.</step>
  <step>Assert : If <id>result</id> is not an abrupt completion , then Type ( <id>result</id> ) is an ECMAScript language type .</step>
  <step>Return <id>result</id> .</step>
</step-list>
<step-list>
  <step>Let <id>propertyNameReference</id> be the result of evaluating Expression .</step>
  <step>Let <id>propertyNameValue</id> be ? GetValue ( <id>propertyNameReference</id> ).</step>
  <step>Let <id>propertyKey</id> be ? ToPropertyKey ( <id>propertyNameValue</id> ).</step>
  <step>If the code matched by this SuperProperty is strict mode code , let <id>strict</id> be <value>true</value> , else let <id>strict</id> be <value>false</value> .</step>
  <step>Return ? MakeSuperPropertyReference ( <id>propertyKey</id> , <id>strict</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>propertyKey</id> be StringValue of IdentifierName .</step>
  <step>If the code matched by this SuperProperty is strict mode code , let <id>strict</id> be <value>true</value> , else let <id>strict</id> be <value>false</value> .</step>
  <step>Return ? MakeSuperPropertyReference ( <id>propertyKey</id> , <id>strict</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>newTarget</id> be GetNewTarget ().</step>
  <step>Assert : Type ( <id>newTarget</id> ) is Object.</step>
  <step>Let <id>func</id> be ? GetSuperConstructor ().</step>
  <step>Let <id>argList</id> be ArgumentListEvaluation of Arguments .</step>
  <step>ReturnIfAbrupt ( <id>argList</id> ).</step>
  <step>Let <id>result</id> be ? Construct ( <id>func</id> , <id>argList</id> , <id>newTarget</id> ).</step>
  <step>Let <id>thisER</id> be GetThisEnvironment ().</step>
  <step>Return ? <id>thisER</id> .BindThisValue( <id>result</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be GetThisEnvironment ().</step>
  <step>Assert : <id>envRec</id> is a function Environment Record .</step>
  <step>Let <id>activeFunction</id> be <id>envRec</id> .[[FunctionObject]].</step>
  <step>Assert : <id>activeFunction</id> is an ECMAScript function object .</step>
  <step>Let <id>superConstructor</id> be ! <id>activeFunction</id> .[[GetPrototypeOf]]().</step>
  <step>If IsConstructor ( <id>superConstructor</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Return <id>superConstructor</id> .</step>
</step-list>
<step-list>
  <step>Let <id>env</id> be GetThisEnvironment ().</step>
  <step>Assert : <id>env</id> .HasSuperBinding() is <value>true</value> .</step>
  <step>Let <id>actualThis</id> be ? <id>env</id> .GetThisBinding().</step>
  <step>Let <id>baseValue</id> be ? <id>env</id> .GetSuperBase().</step>
  <step>Let <id>bv</id> be ? RequireObjectCoercible ( <id>baseValue</id> ).</step>
  <step>Return a value of type Reference that is a Super Reference whose base value component is <id>bv</id> , whose referenced name component is <id>propertyKey</id> , whose thisValue component is <id>actualThis</id> , and whose strict reference flag is <id>strict</id> .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Let <id>ref</id> be the result of evaluating AssignmentExpression .</step>
  <step>Let <id>arg</id> be ? GetValue ( <id>ref</id> ).</step>
  <step>Return a List whose sole item is <id>arg</id> .</step>
</step-list>
<step-list>
  <step>Let <id>list</id> be a new empty List .</step>
  <step>Let <id>spreadRef</id> be the result of evaluating AssignmentExpression .</step>
  <step>Let <id>spreadObj</id> be ? GetValue ( <id>spreadRef</id> ).</step>
  <step>Let <id>iteratorRecord</id> be ? GetIterator ( <id>spreadObj</id> ).</step>
  <step>Repeat,   <step-list>
    <step>Let <id>next</id> be ? IteratorStep ( <id>iteratorRecord</id> ).</step>
    <step>If <id>next</id> is <value>false</value> , return <id>list</id> .</step>
    <step>Let <id>nextArg</id> be ? IteratorValue ( <id>next</id> ).</step>
    <step>Append <id>nextArg</id> as the last element of <id>list</id> .</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>precedingArgs</id> be ArgumentListEvaluation of ArgumentList .</step>
  <step>ReturnIfAbrupt ( <id>precedingArgs</id> ).</step>
  <step>Let <id>ref</id> be the result of evaluating AssignmentExpression .</step>
  <step>Let <id>arg</id> be ? GetValue ( <id>ref</id> ).</step>
  <step>Append <id>arg</id> to the end of <id>precedingArgs</id> .</step>
  <step>Return <id>precedingArgs</id> .</step>
</step-list>
<step-list>
  <step>Let <id>precedingArgs</id> be ArgumentListEvaluation of ArgumentList .</step>
  <step>ReturnIfAbrupt ( <id>precedingArgs</id> ).</step>
  <step>Let <id>spreadRef</id> be the result of evaluating AssignmentExpression .</step>
  <step>Let <id>iteratorRecord</id> be ? GetIterator (? GetValue ( <id>spreadRef</id> )).</step>
  <step>Repeat,   <step-list>
    <step>Let <id>next</id> be ? IteratorStep ( <id>iteratorRecord</id> ).</step>
    <step>If <id>next</id> is <value>false</value> , return <id>precedingArgs</id> .</step>
    <step>Let <id>nextArg</id> be ? IteratorValue ( <id>next</id> ).</step>
    <step>Append <id>nextArg</id> as the last element of <id>precedingArgs</id> .</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>tagRef</id> be the result of evaluating MemberExpression .</step>
  <step>Let <id>tagFunc</id> be ? GetValue ( <id>tagRef</id> ).</step>
  <step>Let <id>thisCall</id> be this MemberExpression .</step>
  <step>Let <id>tailCall</id> be IsInTailPosition ( <id>thisCall</id> ).</step>
  <step>Return ? EvaluateCall ( <id>tagFunc</id> , <id>tagRef</id> , TemplateLiteral , <id>tailCall</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>tagRef</id> be the result of evaluating CallExpression .</step>
  <step>Let <id>tagFunc</id> be ? GetValue ( <id>tagRef</id> ).</step>
  <step>Let <id>thisCall</id> be this CallExpression .</step>
  <step>Let <id>tailCall</id> be IsInTailPosition ( <id>thisCall</id> ).</step>
  <step>Return ? EvaluateCall ( <id>tagFunc</id> , <id>tagRef</id> , TemplateLiteral , <id>tailCall</id> ).</step>
</step-list>
<step-list>
  <step>Return GetNewTarget ().</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>lhs</id> be the result of evaluating LeftHandSideExpression .</step>
  <step>Let <id>oldValue</id> be ? ToNumber (? GetValue ( <id>lhs</id> )).</step>
  <step>Let <id>newValue</id> be the result of adding the value 1 to <id>oldValue</id> , using the same rules as for the <value>+</value> operator (see 12.8.5 ).</step>
  <step>Perform ? PutValue ( <id>lhs</id> , <id>newValue</id> ).</step>
  <step>Return <id>oldValue</id> .</step>
</step-list>
<step-list>
  <step>Let <id>lhs</id> be the result of evaluating LeftHandSideExpression .</step>
  <step>Let <id>oldValue</id> be ? ToNumber (? GetValue ( <id>lhs</id> )).</step>
  <step>Let <id>newValue</id> be the result of subtracting the value 1 from <id>oldValue</id> , using the same rules as for the <value>-</value> operator (see 12.8.5 ).</step>
  <step>Perform ? PutValue ( <id>lhs</id> , <id>newValue</id> ).</step>
  <step>Return <id>oldValue</id> .</step>
</step-list>
<step-list>
  <step>Let <id>expr</id> be the result of evaluating UnaryExpression .</step>
  <step>Let <id>oldValue</id> be ? ToNumber (? GetValue ( <id>expr</id> )).</step>
  <step>Let <id>newValue</id> be the result of adding the value 1 to <id>oldValue</id> , using the same rules as for the <value>+</value> operator (see 12.8.5 ).</step>
  <step>Perform ? PutValue ( <id>expr</id> , <id>newValue</id> ).</step>
  <step>Return <id>newValue</id> .</step>
</step-list>
<step-list>
  <step>Let <id>expr</id> be the result of evaluating UnaryExpression .</step>
  <step>Let <id>oldValue</id> be ? ToNumber (? GetValue ( <id>expr</id> )).</step>
  <step>Let <id>newValue</id> be the result of subtracting the value 1 from <id>oldValue</id> , using the same rules as for the <value>-</value> operator (see 12.8.5 ).</step>
  <step>Perform ? PutValue ( <id>expr</id> , <id>newValue</id> ).</step>
  <step>Return <id>newValue</id> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>ref</id> be the result of evaluating UnaryExpression .</step>
  <step>ReturnIfAbrupt ( <id>ref</id> ).</step>
  <step>If Type ( <id>ref</id> ) is not Reference , return <value>true</value> .</step>
  <step>If IsUnresolvableReference ( <id>ref</id> ) is <value>true</value> , then   <step-list>
    <step>Assert : IsStrictReference ( <id>ref</id> ) is <value>false</value> .</step>
    <step>Return <value>true</value> .</step>
  </step-list></step>
  <step>If IsPropertyReference ( <id>ref</id> ) is <value>true</value> , then   <step-list>
    <step>If IsSuperReference ( <id>ref</id> ) is <value>true</value> , throw a <value>ReferenceError</value> exception.</step>
    <step>Let <id>baseObj</id> be ! ToObject ( GetBase ( <id>ref</id> )).</step>
    <step>Let <id>deleteStatus</id> be ? <id>baseObj</id> .[[Delete]]( GetReferencedName ( <id>ref</id> )).</step>
    <step>If <id>deleteStatus</id> is <value>false</value> and IsStrictReference ( <id>ref</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
    <step>Return <id>deleteStatus</id> .</step>
  </step-list></step>
  <step>Else <id>ref</id> is a Reference to an Environment Record binding,   <step-list>
    <step>Let <id>bindings</id> be GetBase ( <id>ref</id> ).</step>
    <step>Return ? <id>bindings</id> .DeleteBinding( GetReferencedName ( <id>ref</id> )).</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>expr</id> be the result of evaluating UnaryExpression .</step>
  <step>Perform ? GetValue ( <id>expr</id> ).</step>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Let <id>val</id> be the result of evaluating UnaryExpression .</step>
  <step>If Type ( <id>val</id> ) is Reference , then   <step-list>
    <step>If IsUnresolvableReference ( <id>val</id> ) is <value>true</value> , return <value>"undefined"</value> .</step>
  </step-list></step>
  <step>Set <id>val</id> to ? GetValue ( <id>val</id> ).</step>
  <step>Return a String according to Table 35 .</step>
</step-list>
<step-list>
  <step>Let <id>expr</id> be the result of evaluating UnaryExpression .</step>
  <step>Return ? ToNumber (? GetValue ( <id>expr</id> )).</step>
</step-list>
<step-list>
  <step>Let <id>expr</id> be the result of evaluating UnaryExpression .</step>
  <step>Let <id>oldValue</id> be ? ToNumber (? GetValue ( <id>expr</id> )).</step>
  <step>If <id>oldValue</id> is <value>NaN</value> , return <value>NaN</value> .</step>
  <step>Return the result of negating <id>oldValue</id> ; that is, compute a Number with the same magnitude but opposite sign.</step>
</step-list>
<step-list>
  <step>Let <id>expr</id> be the result of evaluating UnaryExpression .</step>
  <step>Let <id>oldValue</id> be ? ToInt32 (? GetValue ( <id>expr</id> )).</step>
  <step>Return the result of applying bitwise complement to <id>oldValue</id> . The result is a signed 32-bit integer.</step>
</step-list>
<step-list>
  <step>Let <id>expr</id> be the result of evaluating UnaryExpression .</step>
  <step>Let <id>oldValue</id> be ToBoolean (? GetValue ( <id>expr</id> )).</step>
  <step>If <id>oldValue</id> is <value>true</value> , return <value>false</value> .</step>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>left</id> be the result of evaluating UpdateExpression .</step>
  <step>Let <id>leftValue</id> be ? GetValue ( <id>left</id> ).</step>
  <step>Let <id>right</id> be the result of evaluating ExponentiationExpression .</step>
  <step>Let <id>rightValue</id> be ? GetValue ( <id>right</id> ).</step>
  <step>Let <id>base</id> be ? ToNumber ( <id>leftValue</id> ).</step>
  <step>Let <id>exponent</id> be ? ToNumber ( <id>rightValue</id> ).</step>
  <step>Return the result of Applying the ** operator with <id>base</id> and <id>exponent</id> as specified in 12.6.4 .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>left</id> be the result of evaluating MultiplicativeExpression .</step>
  <step>Let <id>leftValue</id> be ? GetValue ( <id>left</id> ).</step>
  <step>Let <id>right</id> be the result of evaluating ExponentiationExpression .</step>
  <step>Let <id>rightValue</id> be ? GetValue ( <id>right</id> ).</step>
  <step>Let <id>lnum</id> be ? ToNumber ( <id>leftValue</id> ).</step>
  <step>Let <id>rnum</id> be ? ToNumber ( <id>rightValue</id> ).</step>
  <step>Return the result of applying the MultiplicativeOperator ( <value>*</value> , <value>/</value> , or <value>%</value> ) to <id>lnum</id> and <id>rnum</id> as specified in 12.7.3.1 , 12.7.3.2 , or 12.7.3.3 .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>lref</id> be the result of evaluating AdditiveExpression .</step>
  <step>Let <id>lval</id> be ? GetValue ( <id>lref</id> ).</step>
  <step>Let <id>rref</id> be the result of evaluating MultiplicativeExpression .</step>
  <step>Let <id>rval</id> be ? GetValue ( <id>rref</id> ).</step>
  <step>Let <id>lprim</id> be ? ToPrimitive ( <id>lval</id> ).</step>
  <step>Let <id>rprim</id> be ? ToPrimitive ( <id>rval</id> ).</step>
  <step>If Type ( <id>lprim</id> ) is String or Type ( <id>rprim</id> ) is String, then   <step-list>
    <step>Let <id>lstr</id> be ? ToString ( <id>lprim</id> ).</step>
    <step>Let <id>rstr</id> be ? ToString ( <id>rprim</id> ).</step>
    <step>Return the string-concatenation of <id>lstr</id> and <id>rstr</id> .</step>
  </step-list></step>
  <step>Let <id>lnum</id> be ? ToNumber ( <id>lprim</id> ).</step>
  <step>Let <id>rnum</id> be ? ToNumber ( <id>rprim</id> ).</step>
  <step>Return the result of applying the addition operation to <id>lnum</id> and <id>rnum</id> . See the Note below 12.8.5 .</step>
</step-list>
<step-list>
  <step>Let <id>lref</id> be the result of evaluating AdditiveExpression .</step>
  <step>Let <id>lval</id> be ? GetValue ( <id>lref</id> ).</step>
  <step>Let <id>rref</id> be the result of evaluating MultiplicativeExpression .</step>
  <step>Let <id>rval</id> be ? GetValue ( <id>rref</id> ).</step>
  <step>Let <id>lnum</id> be ? ToNumber ( <id>lval</id> ).</step>
  <step>Let <id>rnum</id> be ? ToNumber ( <id>rval</id> ).</step>
  <step>Return the result of applying the subtraction operation to <id>lnum</id> and <id>rnum</id> . See the note below 12.8.5 .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>lref</id> be the result of evaluating ShiftExpression .</step>
  <step>Let <id>lval</id> be ? GetValue ( <id>lref</id> ).</step>
  <step>Let <id>rref</id> be the result of evaluating AdditiveExpression .</step>
  <step>Let <id>rval</id> be ? GetValue ( <id>rref</id> ).</step>
  <step>Let <id>lnum</id> be ? ToInt32 ( <id>lval</id> ).</step>
  <step>Let <id>rnum</id> be ? ToUint32 ( <id>rval</id> ).</step>
  <step>Let <id>shiftCount</id> be the result of masking out all but the least significant 5 bits of <id>rnum</id> , that is, compute <id>rnum</id> & 0x1F.</step>
  <step>Return the result of left shifting <id>lnum</id> by <id>shiftCount</id> bits. The result is a signed 32-bit integer.</step>
</step-list>
<step-list>
  <step>Let <id>lref</id> be the result of evaluating ShiftExpression .</step>
  <step>Let <id>lval</id> be ? GetValue ( <id>lref</id> ).</step>
  <step>Let <id>rref</id> be the result of evaluating AdditiveExpression .</step>
  <step>Let <id>rval</id> be ? GetValue ( <id>rref</id> ).</step>
  <step>Let <id>lnum</id> be ? ToInt32 ( <id>lval</id> ).</step>
  <step>Let <id>rnum</id> be ? ToUint32 ( <id>rval</id> ).</step>
  <step>Let <id>shiftCount</id> be the result of masking out all but the least significant 5 bits of <id>rnum</id> , that is, compute <id>rnum</id> & 0x1F.</step>
  <step>Return the result of performing a sign-extending right shift of <id>lnum</id> by <id>shiftCount</id> bits. The most significant bit is propagated. The result is a signed 32-bit integer.</step>
</step-list>
<step-list>
  <step>Let <id>lref</id> be the result of evaluating ShiftExpression .</step>
  <step>Let <id>lval</id> be ? GetValue ( <id>lref</id> ).</step>
  <step>Let <id>rref</id> be the result of evaluating AdditiveExpression .</step>
  <step>Let <id>rval</id> be ? GetValue ( <id>rref</id> ).</step>
  <step>Let <id>lnum</id> be ? ToUint32 ( <id>lval</id> ).</step>
  <step>Let <id>rnum</id> be ? ToUint32 ( <id>rval</id> ).</step>
  <step>Let <id>shiftCount</id> be the result of masking out all but the least significant 5 bits of <id>rnum</id> , that is, compute <id>rnum</id> & 0x1F.</step>
  <step>Return the result of performing a zero-filling right shift of <id>lnum</id> by <id>shiftCount</id> bits. Vacated bits are filled with zero. The result is an unsigned 32-bit integer.</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>lref</id> be the result of evaluating RelationalExpression .</step>
  <step>Let <id>lval</id> be ? GetValue ( <id>lref</id> ).</step>
  <step>Let <id>rref</id> be the result of evaluating ShiftExpression .</step>
  <step>Let <id>rval</id> be ? GetValue ( <id>rref</id> ).</step>
  <step>Let <id>r</id> be the result of performing Abstract Relational Comparison  <id>lval</id> < <id>rval</id> .</step>
  <step>ReturnIfAbrupt ( <id>r</id> ).</step>
  <step>If <id>r</id> is <value>undefined</value> , return <value>false</value> . Otherwise, return <id>r</id> .</step>
</step-list>
<step-list>
  <step>Let <id>lref</id> be the result of evaluating RelationalExpression .</step>
  <step>Let <id>lval</id> be ? GetValue ( <id>lref</id> ).</step>
  <step>Let <id>rref</id> be the result of evaluating ShiftExpression .</step>
  <step>Let <id>rval</id> be ? GetValue ( <id>rref</id> ).</step>
  <step>Let <id>r</id> be the result of performing Abstract Relational Comparison  <id>rval</id> < <id>lval</id> with <id>LeftFirst</id> equal to <value>false</value> .</step>
  <step>ReturnIfAbrupt ( <id>r</id> ).</step>
  <step>If <id>r</id> is <value>undefined</value> , return <value>false</value> . Otherwise, return <id>r</id> .</step>
</step-list>
<step-list>
  <step>Let <id>lref</id> be the result of evaluating RelationalExpression .</step>
  <step>Let <id>lval</id> be ? GetValue ( <id>lref</id> ).</step>
  <step>Let <id>rref</id> be the result of evaluating ShiftExpression .</step>
  <step>Let <id>rval</id> be ? GetValue ( <id>rref</id> ).</step>
  <step>Let <id>r</id> be the result of performing Abstract Relational Comparison  <id>rval</id> < <id>lval</id> with <id>LeftFirst</id> equal to <value>false</value> .</step>
  <step>ReturnIfAbrupt ( <id>r</id> ).</step>
  <step>If <id>r</id> is <value>true</value> or <value>undefined</value> , return <value>false</value> . Otherwise, return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Let <id>lref</id> be the result of evaluating RelationalExpression .</step>
  <step>Let <id>lval</id> be ? GetValue ( <id>lref</id> ).</step>
  <step>Let <id>rref</id> be the result of evaluating ShiftExpression .</step>
  <step>Let <id>rval</id> be ? GetValue ( <id>rref</id> ).</step>
  <step>Let <id>r</id> be the result of performing Abstract Relational Comparison  <id>lval</id> < <id>rval</id> .</step>
  <step>ReturnIfAbrupt ( <id>r</id> ).</step>
  <step>If <id>r</id> is <value>true</value> or <value>undefined</value> , return <value>false</value> . Otherwise, return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Let <id>lref</id> be the result of evaluating RelationalExpression .</step>
  <step>Let <id>lval</id> be ? GetValue ( <id>lref</id> ).</step>
  <step>Let <id>rref</id> be the result of evaluating ShiftExpression .</step>
  <step>Let <id>rval</id> be ? GetValue ( <id>rref</id> ).</step>
  <step>Return ? InstanceofOperator ( <id>lval</id> , <id>rval</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>lref</id> be the result of evaluating RelationalExpression .</step>
  <step>Let <id>lval</id> be ? GetValue ( <id>lref</id> ).</step>
  <step>Let <id>rref</id> be the result of evaluating ShiftExpression .</step>
  <step>Let <id>rval</id> be ? GetValue ( <id>rref</id> ).</step>
  <step>If Type ( <id>rval</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Return ? HasProperty ( <id>rval</id> , ToPropertyKey ( <id>lval</id> )).</step>
</step-list>
<step-list>
  <step>If Type ( <id>target</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>instOfHandler</id> be ? GetMethod ( <id>target</id> , @@hasInstance).</step>
  <step>If <id>instOfHandler</id> is not <value>undefined</value> , then   <step-list>
    <step>Return ToBoolean (? Call ( <id>instOfHandler</id> , <id>target</id> , « <id>V</id> »)).</step>
  </step-list></step>
  <step>If IsCallable ( <id>target</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Return ? OrdinaryHasInstance ( <id>target</id> , <id>V</id> ).</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>lref</id> be the result of evaluating EqualityExpression .</step>
  <step>Let <id>lval</id> be ? GetValue ( <id>lref</id> ).</step>
  <step>Let <id>rref</id> be the result of evaluating RelationalExpression .</step>
  <step>Let <id>rval</id> be ? GetValue ( <id>rref</id> ).</step>
  <step>Return the result of performing Abstract Equality Comparison  <id>rval</id> == <id>lval</id> .</step>
</step-list>
<step-list>
  <step>Let <id>lref</id> be the result of evaluating EqualityExpression .</step>
  <step>Let <id>lval</id> be ? GetValue ( <id>lref</id> ).</step>
  <step>Let <id>rref</id> be the result of evaluating RelationalExpression .</step>
  <step>Let <id>rval</id> be ? GetValue ( <id>rref</id> ).</step>
  <step>Let <id>r</id> be the result of performing Abstract Equality Comparison  <id>rval</id> == <id>lval</id> .</step>
  <step>If <id>r</id> is <value>true</value> , return <value>false</value> . Otherwise, return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Let <id>lref</id> be the result of evaluating EqualityExpression .</step>
  <step>Let <id>lval</id> be ? GetValue ( <id>lref</id> ).</step>
  <step>Let <id>rref</id> be the result of evaluating RelationalExpression .</step>
  <step>Let <id>rval</id> be ? GetValue ( <id>rref</id> ).</step>
  <step>Return the result of performing Strict Equality Comparison  <id>rval</id> === <id>lval</id> .</step>
</step-list>
<step-list>
  <step>Let <id>lref</id> be the result of evaluating EqualityExpression .</step>
  <step>Let <id>lval</id> be ? GetValue ( <id>lref</id> ).</step>
  <step>Let <id>rref</id> be the result of evaluating RelationalExpression .</step>
  <step>Let <id>rval</id> be ? GetValue ( <id>rref</id> ).</step>
  <step>Let <id>r</id> be the result of performing Strict Equality Comparison  <id>rval</id> === <id>lval</id> .</step>
  <step>If <id>r</id> is <value>true</value> , return <value>false</value> . Otherwise, return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>lref</id> be the result of evaluating <id>A</id> .</step>
  <step>Let <id>lval</id> be ? GetValue ( <id>lref</id> ).</step>
  <step>Let <id>rref</id> be the result of evaluating <id>B</id> .</step>
  <step>Let <id>rval</id> be ? GetValue ( <id>rref</id> ).</step>
  <step>Let <id>lnum</id> be ? ToInt32 ( <id>lval</id> ).</step>
  <step>Let <id>rnum</id> be ? ToInt32 ( <id>rval</id> ).</step>
  <step>Return the result of applying the bitwise operator @ to <id>lnum</id> and <id>rnum</id> . The result is a signed 32-bit integer.</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>lref</id> be the result of evaluating LogicalANDExpression .</step>
  <step>Let <id>lval</id> be ? GetValue ( <id>lref</id> ).</step>
  <step>Let <id>lbool</id> be ToBoolean ( <id>lval</id> ).</step>
  <step>If <id>lbool</id> is <value>false</value> , return <id>lval</id> .</step>
  <step>Let <id>rref</id> be the result of evaluating BitwiseORExpression .</step>
  <step>Return ? GetValue ( <id>rref</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>lref</id> be the result of evaluating LogicalORExpression .</step>
  <step>Let <id>lval</id> be ? GetValue ( <id>lref</id> ).</step>
  <step>Let <id>lbool</id> be ToBoolean ( <id>lval</id> ).</step>
  <step>If <id>lbool</id> is <value>true</value> , return <id>lval</id> .</step>
  <step>Let <id>rref</id> be the result of evaluating LogicalANDExpression .</step>
  <step>Return ? GetValue ( <id>rref</id> ).</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>lref</id> be the result of evaluating LogicalORExpression .</step>
  <step>Let <id>lval</id> be ToBoolean (? GetValue ( <id>lref</id> )).</step>
  <step>If <id>lval</id> is <value>true</value> , then   <step-list>
    <step>Let <id>trueRef</id> be the result of evaluating the first AssignmentExpression .</step>
    <step>Return ? GetValue ( <id>trueRef</id> ).</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>falseRef</id> be the result of evaluating the second AssignmentExpression .</step>
    <step>Return ? GetValue ( <id>falseRef</id> ).</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If LeftHandSideExpression is neither an ObjectLiteral nor an ArrayLiteral , then   <step-list>
    <step>Let <id>lref</id> be the result of evaluating LeftHandSideExpression .</step>
    <step>ReturnIfAbrupt ( <id>lref</id> ).</step>
    <step>Let <id>rref</id> be the result of evaluating AssignmentExpression .</step>
    <step>Let <id>rval</id> be ? GetValue ( <id>rref</id> ).</step>
    <step>If IsAnonymousFunctionDefinition ( AssignmentExpression ) and IsIdentifierRef of LeftHandSideExpression are both <value>true</value> , then     <step-list>
      <step>Let <id>hasNameProperty</id> be ? HasOwnProperty ( <id>rval</id> , <value>"name"</value> ).</step>
      <step>If <id>hasNameProperty</id> is <value>false</value> , perform SetFunctionName ( <id>rval</id> , GetReferencedName ( <id>lref</id> )).</step>
    </step-list></step>
    <step>Perform ? PutValue ( <id>lref</id> , <id>rval</id> ).</step>
    <step>Return <id>rval</id> .</step>
  </step-list></step>
  <step>Let <id>assignmentPattern</id> be the AssignmentPattern that is covered by LeftHandSideExpression .</step>
  <step>Let <id>rref</id> be the result of evaluating AssignmentExpression .</step>
  <step>Let <id>rval</id> be ? GetValue ( <id>rref</id> ).</step>
  <step>Perform ? DestructuringAssignmentEvaluation of <id>assignmentPattern</id> using <id>rval</id> as the argument.</step>
  <step>Return <id>rval</id> .</step>
</step-list>
<step-list>
  <step>Let <id>lref</id> be the result of evaluating LeftHandSideExpression .</step>
  <step>Let <id>lval</id> be ? GetValue ( <id>lref</id> ).</step>
  <step>Let <id>rref</id> be the result of evaluating AssignmentExpression .</step>
  <step>Let <id>rval</id> be ? GetValue ( <id>rref</id> ).</step>
  <step>Let <id>op</id> be the <value>@</value> where AssignmentOperator is <value>@=</value> .</step>
  <step>Let <id>r</id> be the result of applying <id>op</id> to <id>lval</id> and <id>rval</id> as if evaluating the expression <id>lval</id>  <id>op</id>  <id>rval</id> .</step>
  <step>Perform ? PutValue ( <id>lref</id> , <id>r</id> ).</step>
  <step>Return <id>r</id> .</step>
</step-list>
<step-list>
  <step>Perform ? RequireObjectCoercible ( <id>value</id> ).</step>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Perform ? RequireObjectCoercible ( <id>value</id> ).</step>
  <step>Perform ? PropertyDestructuringAssignmentEvaluation for AssignmentPropertyList using <id>value</id> as the argument.</step>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>iteratorRecord</id> be ? GetIterator ( <id>value</id> ).</step>
  <step>Return ? IteratorClose ( <id>iteratorRecord</id> , NormalCompletion ( <value>empty</value> )).</step>
</step-list>
<step-list>
  <step>Let <id>iteratorRecord</id> be ? GetIterator ( <id>value</id> ).</step>
  <step>Let <id>result</id> be the result of performing IteratorDestructuringAssignmentEvaluation of Elision with <id>iteratorRecord</id> as the argument.</step>
  <step>If <id>iteratorRecord</id> .[[Done]] is <value>false</value> , return ? IteratorClose ( <id>iteratorRecord</id> , <id>result</id> ).</step>
  <step>Return <id>result</id> .</step>
</step-list>
<step-list>
  <step>Let <id>iteratorRecord</id> be ? GetIterator ( <id>value</id> ).</step>
  <step>If Elision is present, then   <step-list>
    <step>Let <id>status</id> be the result of performing IteratorDestructuringAssignmentEvaluation of Elision with <id>iteratorRecord</id> as the argument.</step>
    <step>If <id>status</id> is an abrupt completion , then     <step-list>
      <step>Assert : <id>iteratorRecord</id> .[[Done]] is <value>true</value> .</step>
      <step>Return Completion ( <id>status</id> ).</step>
    </step-list></step>
  </step-list></step>
  <step>Let <id>result</id> be the result of performing IteratorDestructuringAssignmentEvaluation of AssignmentRestElement with <id>iteratorRecord</id> as the argument.</step>
  <step>If <id>iteratorRecord</id> .[[Done]] is <value>false</value> , return ? IteratorClose ( <id>iteratorRecord</id> , <id>result</id> ).</step>
  <step>Return <id>result</id> .</step>
</step-list>
<step-list>
  <step>Let <id>iteratorRecord</id> be ? GetIterator ( <id>value</id> ).</step>
  <step>Let <id>result</id> be the result of performing IteratorDestructuringAssignmentEvaluation of AssignmentElementList using <id>iteratorRecord</id> as the argument.</step>
  <step>If <id>iteratorRecord</id> .[[Done]] is <value>false</value> , return ? IteratorClose ( <id>iteratorRecord</id> , <id>result</id> ).</step>
  <step>Return <id>result</id> .</step>
</step-list>
<step-list>
  <step>Let <id>iteratorRecord</id> be ? GetIterator ( <id>value</id> ).</step>
  <step>Let <id>status</id> be the result of performing IteratorDestructuringAssignmentEvaluation of AssignmentElementList using <id>iteratorRecord</id> as the argument.</step>
  <step>If <id>status</id> is an abrupt completion , then   <step-list>
    <step>If <id>iteratorRecord</id> .[[Done]] is <value>false</value> , return ? IteratorClose ( <id>iteratorRecord</id> , <id>status</id> ).</step>
    <step>Return Completion ( <id>status</id> ).</step>
  </step-list></step>
  <step>If Elision is present, then   <step-list>
    <step>Set <id>status</id> to the result of performing IteratorDestructuringAssignmentEvaluation of Elision with <id>iteratorRecord</id> as the argument.</step>
    <step>If <id>status</id> is an abrupt completion , then     <step-list>
      <step>Assert : <id>iteratorRecord</id> .[[Done]] is <value>true</value> .</step>
      <step>Return Completion ( <id>status</id> ).</step>
    </step-list></step>
  </step-list></step>
  <step>If AssignmentRestElement is present, then   <step-list>
    <step>Set <id>status</id> to the result of performing IteratorDestructuringAssignmentEvaluation of AssignmentRestElement with <id>iteratorRecord</id> as the argument.</step>
  </step-list></step>
  <step>If <id>iteratorRecord</id> .[[Done]] is <value>false</value> , return ? IteratorClose ( <id>iteratorRecord</id> , <id>status</id> ).</step>
  <step>Return Completion ( <id>status</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>excludedNames</id> be a new empty List .</step>
  <step>Return the result of performing RestDestructuringAssignmentEvaluation of AssignmentRestProperty with <id>value</id> and <id>excludedNames</id> as the arguments.</step>
</step-list>
<step-list>
  <step>Let <id>excludedNames</id> be the result of performing ? PropertyDestructuringAssignmentEvaluation for AssignmentPropertyList using <id>value</id> as the argument.</step>
  <step>Return the result of performing RestDestructuringAssignmentEvaluation of AssignmentRestProperty with <id>value</id> and <id>excludedNames</id> as the arguments.</step>
</step-list>
<step-list>
  <step>Let <id>propertyNames</id> be the result of performing ? PropertyDestructuringAssignmentEvaluation for AssignmentPropertyList using <id>value</id> as the argument.</step>
  <step>Let <id>nextNames</id> be the result of performing ? PropertyDestructuringAssignmentEvaluation for AssignmentProperty using <id>value</id> as the argument.</step>
  <step>Append each item in <id>nextNames</id> to the end of <id>propertyNames</id> .</step>
  <step>Return <id>propertyNames</id> .</step>
</step-list>
<step-list>
  <step>Let <id>P</id> be StringValue of IdentifierReference .</step>
  <step>Let <id>lref</id> be ? ResolveBinding ( <id>P</id> ).</step>
  <step>Let <id>v</id> be ? GetV ( <id>value</id> , <id>P</id> ).</step>
  <step>If Initializeropt is present and <id>v</id> is <value>undefined</value> , then   <step-list>
    <step>Let <id>defaultValue</id> be the result of evaluating Initializer .</step>
    <step>Set <id>v</id> to ? GetValue ( <id>defaultValue</id> ).</step>
    <step>If IsAnonymousFunctionDefinition ( Initializer ) is <value>true</value> , then     <step-list>
      <step>Let <id>hasNameProperty</id> be ? HasOwnProperty ( <id>v</id> , <value>"name"</value> ).</step>
      <step>If <id>hasNameProperty</id> is <value>false</value> , perform SetFunctionName ( <id>v</id> , <id>P</id> ).</step>
    </step-list></step>
  </step-list></step>
  <step>Perform ? PutValue ( <id>lref</id> , <id>v</id> ).</step>
  <step>Return a new List containing <id>P</id> .</step>
</step-list>
<step-list>
  <step>Let <id>name</id> be the result of evaluating PropertyName .</step>
  <step>ReturnIfAbrupt ( <id>name</id> ).</step>
  <step>Perform ? KeyedDestructuringAssignmentEvaluation of AssignmentElement with <id>value</id> and <id>name</id> as the arguments.</step>
  <step>Return a new List containing <id>name</id> .</step>
</step-list>
<step-list>
  <step>Let <id>lref</id> be the result of evaluating DestructuringAssignmentTarget .</step>
  <step>ReturnIfAbrupt ( <id>lref</id> ).</step>
  <step>Let <id>restObj</id> be ObjectCreate ( %ObjectPrototype% ).</step>
  <step>Perform ? CopyDataProperties ( <id>restObj</id> , <id>value</id> , <id>excludedNames</id> ).</step>
  <step>Return PutValue ( <id>lref</id> , <id>restObj</id> ).</step>
</step-list>
<step-list>
  <step>Return the result of performing IteratorDestructuringAssignmentEvaluation of AssignmentElisionElement using <id>iteratorRecord</id> as the argument.</step>
</step-list>
<step-list>
  <step>Perform ? IteratorDestructuringAssignmentEvaluation of AssignmentElementList using <id>iteratorRecord</id> as the argument.</step>
  <step>Return the result of performing IteratorDestructuringAssignmentEvaluation of AssignmentElisionElement using <id>iteratorRecord</id> as the argument.</step>
</step-list>
<step-list>
  <step>Return the result of performing IteratorDestructuringAssignmentEvaluation of AssignmentElement with <id>iteratorRecord</id> as the argument.</step>
</step-list>
<step-list>
  <step>Perform ? IteratorDestructuringAssignmentEvaluation of Elision with <id>iteratorRecord</id> as the argument.</step>
  <step>Return the result of performing IteratorDestructuringAssignmentEvaluation of AssignmentElement with <id>iteratorRecord</id> as the argument.</step>
</step-list>
<step-list>
  <step>If <id>iteratorRecord</id> .[[Done]] is <value>false</value> , then   <step-list>
    <step>Let <id>next</id> be IteratorStep ( <id>iteratorRecord</id> ).</step>
    <step>If <id>next</id> is an abrupt completion , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
    <step>ReturnIfAbrupt ( <id>next</id> ).</step>
    <step>If <id>next</id> is <value>false</value> , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
  </step-list></step>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Perform ? IteratorDestructuringAssignmentEvaluation of Elision with <id>iteratorRecord</id> as the argument.</step>
  <step>If <id>iteratorRecord</id> .[[Done]] is <value>false</value> , then   <step-list>
    <step>Let <id>next</id> be IteratorStep ( <id>iteratorRecord</id> ).</step>
    <step>If <id>next</id> is an abrupt completion , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
    <step>ReturnIfAbrupt ( <id>next</id> ).</step>
    <step>If <id>next</id> is <value>false</value> , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
  </step-list></step>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral , then   <step-list>
    <step>Let <id>lref</id> be the result of evaluating DestructuringAssignmentTarget .</step>
    <step>ReturnIfAbrupt ( <id>lref</id> ).</step>
  </step-list></step>
  <step>If <id>iteratorRecord</id> .[[Done]] is <value>false</value> , then   <step-list>
    <step>Let <id>next</id> be IteratorStep ( <id>iteratorRecord</id> ).</step>
    <step>If <id>next</id> is an abrupt completion , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
    <step>ReturnIfAbrupt ( <id>next</id> ).</step>
    <step>If <id>next</id> is <value>false</value> , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
    <step>Else,     <step-list>
      <step>Let <id>value</id> be IteratorValue ( <id>next</id> ).</step>
      <step>If <id>value</id> is an abrupt completion , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
      <step>ReturnIfAbrupt ( <id>value</id> ).</step>
    </step-list></step>
  </step-list></step>
  <step>If <id>iteratorRecord</id> .[[Done]] is <value>true</value> , let <id>value</id> be <value>undefined</value> .</step>
  <step>If Initializer is present and <id>value</id> is <value>undefined</value> , then   <step-list>
    <step>Let <id>defaultValue</id> be the result of evaluating Initializer .</step>
    <step>Let <id>v</id> be ? GetValue ( <id>defaultValue</id> ).</step>
  </step-list></step>
  <step>Else, let <id>v</id> be <id>value</id> .</step>
  <step>If DestructuringAssignmentTarget is an ObjectLiteral or an ArrayLiteral , then   <step-list>
    <step>Let <id>nestedAssignmentPattern</id> be the AssignmentPattern that is covered by DestructuringAssignmentTarget .</step>
    <step>Return the result of performing DestructuringAssignmentEvaluation of <id>nestedAssignmentPattern</id> with <id>v</id> as the argument.</step>
  </step-list></step>
  <step>If Initializer is present and <id>value</id> is <value>undefined</value> and IsAnonymousFunctionDefinition ( Initializer ) and IsIdentifierRef of DestructuringAssignmentTarget are both <value>true</value> , then   <step-list>
    <step>Let <id>hasNameProperty</id> be ? HasOwnProperty ( <id>v</id> , <value>"name"</value> ).</step>
    <step>If <id>hasNameProperty</id> is <value>false</value> , perform SetFunctionName ( <id>v</id> , GetReferencedName ( <id>lref</id> )).</step>
  </step-list></step>
  <step>Return ? PutValue ( <id>lref</id> , <id>v</id> ).</step>
</step-list>
<step-list>
  <step>If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral , then   <step-list>
    <step>Let <id>lref</id> be the result of evaluating DestructuringAssignmentTarget .</step>
    <step>ReturnIfAbrupt ( <id>lref</id> ).</step>
  </step-list></step>
  <step>Let <id>A</id> be ! ArrayCreate (0).</step>
  <step>Let <id>n</id> be 0.</step>
  <step>Repeat, while <id>iteratorRecord</id> .[[Done]] is <value>false</value> ,   <step-list>
    <step>Let <id>next</id> be IteratorStep ( <id>iteratorRecord</id> ).</step>
    <step>If <id>next</id> is an abrupt completion , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
    <step>ReturnIfAbrupt ( <id>next</id> ).</step>
    <step>If <id>next</id> is <value>false</value> , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
    <step>Else,     <step-list>
      <step>Let <id>nextValue</id> be IteratorValue ( <id>next</id> ).</step>
      <step>If <id>nextValue</id> is an abrupt completion , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
      <step>ReturnIfAbrupt ( <id>nextValue</id> ).</step>
      <step>Let <id>status</id> be CreateDataProperty ( <id>A</id> , ! ToString ( <id>n</id> ), <id>nextValue</id> ).</step>
      <step>Assert : <id>status</id> is <value>true</value> .</step>
      <step>Increment <id>n</id> by 1.</step>
    </step-list></step>
  </step-list></step>
  <step>If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral , then   <step-list>
    <step>Return ? PutValue ( <id>lref</id> , <id>A</id> ).</step>
  </step-list></step>
  <step>Let <id>nestedAssignmentPattern</id> be the AssignmentPattern that is covered by DestructuringAssignmentTarget .</step>
  <step>Return the result of performing DestructuringAssignmentEvaluation of <id>nestedAssignmentPattern</id> with <id>A</id> as the argument.</step>
</step-list>
<step-list>
  <step>If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral , then   <step-list>
    <step>Let <id>lref</id> be the result of evaluating DestructuringAssignmentTarget .</step>
    <step>ReturnIfAbrupt ( <id>lref</id> ).</step>
  </step-list></step>
  <step>Let <id>v</id> be ? GetV ( <id>value</id> , <id>propertyName</id> ).</step>
  <step>If Initializer is present and <id>v</id> is <value>undefined</value> , then   <step-list>
    <step>Let <id>defaultValue</id> be the result of evaluating Initializer .</step>
    <step>Let <id>rhsValue</id> be ? GetValue ( <id>defaultValue</id> ).</step>
  </step-list></step>
  <step>Else, let <id>rhsValue</id> be <id>v</id> .</step>
  <step>If DestructuringAssignmentTarget is an ObjectLiteral or an ArrayLiteral , then   <step-list>
    <step>Let <id>assignmentPattern</id> be the AssignmentPattern that is covered by DestructuringAssignmentTarget .</step>
    <step>Return the result of performing DestructuringAssignmentEvaluation of <id>assignmentPattern</id> with <id>rhsValue</id> as the argument.</step>
  </step-list></step>
  <step>If Initializer is present and <id>v</id> is <value>undefined</value> and IsAnonymousFunctionDefinition ( Initializer ) and IsIdentifierRef of DestructuringAssignmentTarget are both <value>true</value> , then   <step-list>
    <step>Let <id>hasNameProperty</id> be ? HasOwnProperty ( <id>rhsValue</id> , <value>"name"</value> ).</step>
    <step>If <id>hasNameProperty</id> is <value>false</value> , perform SetFunctionName ( <id>rhsValue</id> , GetReferencedName ( <id>lref</id> )).</step>
  </step-list></step>
  <step>Return ? PutValue ( <id>lref</id> , <id>rhsValue</id> ).</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>lref</id> be the result of evaluating Expression .</step>
  <step>Perform ? GetValue ( <id>lref</id> ).</step>
  <step>Let <id>rref</id> be the result of evaluating AssignmentExpression .</step>
  <step>Return ? GetValue ( <id>rref</id> ).</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>newIterationSet</id> be a copy of <id>iterationSet</id> with all the elements of <id>labelSet</id> appended.</step>
  <step>Return ContainsUndefinedContinueTarget of IterationStatement with arguments <id>newIterationSet</id> and « ».</step>
</step-list>
<step-list>
  <step>Return FunctionDeclaration .</step>
</step-list>
<step-list>
  <step>Return GeneratorDeclaration .</step>
</step-list>
<step-list>
  <step>Return AsyncFunctionDeclaration .</step>
</step-list>
<step-list>
  <step>Return AsyncGeneratorDeclaration .</step>
</step-list>
<step-list>
  <step>Return ClassDeclaration .</step>
</step-list>
<step-list>
  <step>Return LexicalDeclaration .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Let <id>stmtResult</id> be the result of performing LabelledEvaluation of IterationStatement with argument <id>labelSet</id> .</step>
  <step>If <id>stmtResult</id> .[[Type]] is <value>break</value> , then   <step-list>
    <step>If <id>stmtResult</id> .[[Target]] is <value>empty</value> , then     <step-list>
      <step>If <id>stmtResult</id> .[[Value]] is <value>empty</value> , set <id>stmtResult</id> to NormalCompletion ( <value>undefined</value> ).</step>
      <step>Else, set <id>stmtResult</id> to NormalCompletion ( <id>stmtResult</id> .[[Value]]).</step>
    </step-list></step>
  </step-list></step>
  <step>Return Completion ( <id>stmtResult</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>stmtResult</id> be the result of evaluating SwitchStatement .</step>
  <step>If <id>stmtResult</id> .[[Type]] is <value>break</value> , then   <step-list>
    <step>If <id>stmtResult</id> .[[Target]] is <value>empty</value> , then     <step-list>
      <step>If <id>stmtResult</id> .[[Value]] is <value>empty</value> , set <id>stmtResult</id> to NormalCompletion ( <value>undefined</value> ).</step>
      <step>Else, set <id>stmtResult</id> to NormalCompletion ( <id>stmtResult</id> .[[Value]]).</step>
    </step-list></step>
  </step-list></step>
  <step>Return Completion ( <id>stmtResult</id> ).</step>
</step-list>
<step-list>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Return the result of evaluating FunctionDeclaration .</step>
</step-list>
<step-list>
  <step>Let <id>newLabelSet</id> be a new empty List .</step>
  <step>Return the result of performing LabelledEvaluation of this BreakableStatement with argument <id>newLabelSet</id> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>hasDuplicates</id> be ContainsDuplicateLabels of StatementList with argument <id>labelSet</id> .</step>
  <step>If <id>hasDuplicates</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return ContainsDuplicateLabels of StatementListItem with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>hasUndefinedLabels</id> be ContainsUndefinedBreakTarget of StatementList with argument <id>labelSet</id> .</step>
  <step>If <id>hasUndefinedLabels</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return ContainsUndefinedBreakTarget of StatementListItem with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>hasUndefinedLabels</id> be ContainsUndefinedContinueTarget of StatementList with arguments <id>iterationSet</id> and « ».</step>
  <step>If <id>hasUndefinedLabels</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return ContainsUndefinedContinueTarget of StatementListItem with arguments <id>iterationSet</id> and « ».</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be LexicallyDeclaredNames of StatementList .</step>
  <step>Append to <id>names</id> the elements of the LexicallyDeclaredNames of StatementListItem .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>If Statement is Statement:LabelledStatement , return LexicallyDeclaredNames of LabelledStatement .</step>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return the BoundNames of Declaration .</step>
</step-list>
<step-list>
  <step>Let <id>declarations</id> be LexicallyScopedDeclarations of StatementList .</step>
  <step>Append to <id>declarations</id> the elements of the LexicallyScopedDeclarations of StatementListItem .</step>
  <step>Return <id>declarations</id> .</step>
</step-list>
<step-list>
  <step>If Statement is Statement:LabelledStatement , return LexicallyScopedDeclarations of LabelledStatement .</step>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return a new List containing DeclarationPart of Declaration .</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be TopLevelLexicallyDeclaredNames of StatementList .</step>
  <step>Append to <id>names</id> the elements of the TopLevelLexicallyDeclaredNames of StatementListItem .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>If Declaration is Declaration:HoistableDeclaration , then   <step-list>
    <step>Return « ».</step>
  </step-list></step>
  <step>Return the BoundNames of Declaration .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Let <id>declarations</id> be TopLevelLexicallyScopedDeclarations of StatementList .</step>
  <step>Append to <id>declarations</id> the elements of the TopLevelLexicallyScopedDeclarations of StatementListItem .</step>
  <step>Return <id>declarations</id> .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>If Declaration is Declaration:HoistableDeclaration , then   <step-list>
    <step>Return « ».</step>
  </step-list></step>
  <step>Return a new List containing Declaration .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be TopLevelVarDeclaredNames of StatementList .</step>
  <step>Append to <id>names</id> the elements of the TopLevelVarDeclaredNames of StatementListItem .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>If Declaration is Declaration:HoistableDeclaration , then   <step-list>
    <step>Return the BoundNames of HoistableDeclaration .</step>
  </step-list></step>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>If Statement is Statement:LabelledStatement , return TopLevelVarDeclaredNames of Statement .</step>
  <step>Return VarDeclaredNames of Statement .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Let <id>declarations</id> be TopLevelVarScopedDeclarations of StatementList .</step>
  <step>Append to <id>declarations</id> the elements of the TopLevelVarScopedDeclarations of StatementListItem .</step>
  <step>Return <id>declarations</id> .</step>
</step-list>
<step-list>
  <step>If Statement is Statement:LabelledStatement , return TopLevelVarScopedDeclarations of Statement .</step>
  <step>Return VarScopedDeclarations of Statement .</step>
</step-list>
<step-list>
  <step>If Declaration is Declaration:HoistableDeclaration , then   <step-list>
    <step>Let <id>declaration</id> be DeclarationPart of HoistableDeclaration .</step>
    <step>Return « <id>declaration</id> ».</step>
  </step-list></step>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be VarDeclaredNames of StatementList .</step>
  <step>Append to <id>names</id> the elements of the VarDeclaredNames of StatementListItem .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Let <id>declarations</id> be VarScopedDeclarations of StatementList .</step>
  <step>Append to <id>declarations</id> the elements of the VarScopedDeclarations of StatementListItem .</step>
  <step>Return <id>declarations</id> .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>oldEnv</id> be the running execution context 's LexicalEnvironment.</step>
  <step>Let <id>blockEnv</id> be NewDeclarativeEnvironment ( <id>oldEnv</id> ).</step>
  <step>Perform BlockDeclarationInstantiation ( StatementList , <id>blockEnv</id> ).</step>
  <step>Set the running execution context 's LexicalEnvironment to <id>blockEnv</id> .</step>
  <step>Let <id>blockValue</id> be the result of evaluating StatementList .</step>
  <step>Set the running execution context 's LexicalEnvironment to <id>oldEnv</id> .</step>
  <step>Return <id>blockValue</id> .</step>
</step-list>
<step-list>
  <step>Let <id>sl</id> be the result of evaluating StatementList .</step>
  <step>ReturnIfAbrupt ( <id>sl</id> ).</step>
  <step>Let <id>s</id> be the result of evaluating StatementListItem .</step>
  <step>Return Completion ( UpdateEmpty ( <id>s</id> , <id>sl</id> )).</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be <id>env</id> 's EnvironmentRecord .</step>
  <step>Assert : <id>envRec</id> is a declarative Environment Record .</step>
  <step>Let <id>declarations</id> be the LexicallyScopedDeclarations of <id>code</id> .</step>
  <step>For each element <id>d</id> in <id>declarations</id> , do   <step-list>
    <step>For each element <id>dn</id> of the BoundNames of <id>d</id> , do     <step-list>
      <step>If IsConstantDeclaration of <id>d</id> is <value>true</value> , then       <step-list>
        <step>Perform ! <id>envRec</id> .CreateImmutableBinding( <id>dn</id> , <value>true</value> ).</step>
      </step-list></step>
      <step>Else,       <step-list>
        <step>Perform ! <id>envRec</id> .CreateMutableBinding( <id>dn</id> , <value>false</value> ).</step>
      </step-list></step>
    </step-list></step>
    <step>If <id>d</id> is a FunctionDeclaration , a GeneratorDeclaration , an AsyncFunctionDeclaration , or an AsyncGeneratorDeclaration , then     <step-list>
      <step>Let <id>fn</id> be the sole element of the BoundNames of <id>d</id> .</step>
      <step>Let <id>fo</id> be the result of performing InstantiateFunctionObject for <id>d</id> with argument <id>env</id> .</step>
      <step>Perform <id>envRec</id> .InitializeBinding( <id>fn</id> , <id>fo</id> ).</step>
    </step-list></step>
  </step-list></step>
</step-list>
<step-list>
  <step>Return the BoundNames of BindingList .</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be the BoundNames of BindingList .</step>
  <step>Append to <id>names</id> the elements of the BoundNames of LexicalBinding .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>Return the BoundNames of BindingIdentifier .</step>
</step-list>
<step-list>
  <step>Return the BoundNames of BindingPattern .</step>
</step-list>
<step-list>
  <step>Return IsConstantDeclaration of LetOrConst .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Let <id>next</id> be the result of evaluating BindingList .</step>
  <step>ReturnIfAbrupt ( <id>next</id> ).</step>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>next</id> be the result of evaluating BindingList .</step>
  <step>ReturnIfAbrupt ( <id>next</id> ).</step>
  <step>Return the result of evaluating LexicalBinding .</step>
</step-list>
<step-list>
  <step>Let <id>lhs</id> be ResolveBinding (StringValue of BindingIdentifier ).</step>
  <step>Return InitializeReferencedBinding ( <id>lhs</id> , <value>undefined</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>bindingId</id> be StringValue of BindingIdentifier .</step>
  <step>Let <id>lhs</id> be ResolveBinding ( <id>bindingId</id> ).</step>
  <step>Let <id>rhs</id> be the result of evaluating Initializer .</step>
  <step>Let <id>value</id> be ? GetValue ( <id>rhs</id> ).</step>
  <step>If IsAnonymousFunctionDefinition ( Initializer ) is <value>true</value> , then   <step-list>
    <step>Let <id>hasNameProperty</id> be ? HasOwnProperty ( <id>value</id> , <value>"name"</value> ).</step>
    <step>If <id>hasNameProperty</id> is <value>false</value> , perform SetFunctionName ( <id>value</id> , <id>bindingId</id> ).</step>
  </step-list></step>
  <step>Return InitializeReferencedBinding ( <id>lhs</id> , <id>value</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>rhs</id> be the result of evaluating Initializer .</step>
  <step>Let <id>value</id> be ? GetValue ( <id>rhs</id> ).</step>
  <step>Let <id>env</id> be the running execution context 's LexicalEnvironment.</step>
  <step>Return the result of performing BindingInitialization for BindingPattern using <id>value</id> and <id>env</id> as the arguments.</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be BoundNames of VariableDeclarationList .</step>
  <step>Append to <id>names</id> the elements of BoundNames of VariableDeclaration .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>Return the BoundNames of BindingIdentifier .</step>
</step-list>
<step-list>
  <step>Return the BoundNames of BindingPattern .</step>
</step-list>
<step-list>
  <step>Return BoundNames of VariableDeclarationList .</step>
</step-list>
<step-list>
  <step>Return a new List containing VariableDeclaration .</step>
</step-list>
<step-list>
  <step>Let <id>declarations</id> be VarScopedDeclarations of VariableDeclarationList .</step>
  <step>Append VariableDeclaration to <id>declarations</id> .</step>
  <step>Return <id>declarations</id> .</step>
</step-list>
<step-list>
  <step>Let <id>next</id> be the result of evaluating VariableDeclarationList .</step>
  <step>ReturnIfAbrupt ( <id>next</id> ).</step>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>next</id> be the result of evaluating VariableDeclarationList .</step>
  <step>ReturnIfAbrupt ( <id>next</id> ).</step>
  <step>Return the result of evaluating VariableDeclaration .</step>
</step-list>
<step-list>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>bindingId</id> be StringValue of BindingIdentifier .</step>
  <step>Let <id>lhs</id> be ? ResolveBinding ( <id>bindingId</id> ).</step>
  <step>Let <id>rhs</id> be the result of evaluating Initializer .</step>
  <step>Let <id>value</id> be ? GetValue ( <id>rhs</id> ).</step>
  <step>If IsAnonymousFunctionDefinition ( Initializer ) is <value>true</value> , then   <step-list>
    <step>Let <id>hasNameProperty</id> be ? HasOwnProperty ( <id>value</id> , <value>"name"</value> ).</step>
    <step>If <id>hasNameProperty</id> is <value>false</value> , perform SetFunctionName ( <id>value</id> , <id>bindingId</id> ).</step>
  </step-list></step>
  <step>Return ? PutValue ( <id>lhs</id> , <id>value</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>rhs</id> be the result of evaluating Initializer .</step>
  <step>Let <id>rval</id> be ? GetValue ( <id>rhs</id> ).</step>
  <step>Return the result of performing BindingInitialization for BindingPattern passing <id>rval</id> and <value>undefined</value> as arguments.</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return the BoundNames of BindingRestElement .</step>
</step-list>
<step-list>
  <step>Return the BoundNames of BindingElementList .</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be BoundNames of BindingElementList .</step>
  <step>Append to <id>names</id> the elements of BoundNames of BindingRestElement .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be BoundNames of BindingPropertyList .</step>
  <step>Append to <id>names</id> the elements of BoundNames of BindingProperty .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be BoundNames of BindingElementList .</step>
  <step>Append to <id>names</id> the elements of BoundNames of BindingElisionElement .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>Return BoundNames of BindingElement .</step>
</step-list>
<step-list>
  <step>Return the BoundNames of BindingElement .</step>
</step-list>
<step-list>
  <step>Return the BoundNames of BindingIdentifier .</step>
</step-list>
<step-list>
  <step>Return the BoundNames of BindingPattern .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return ContainsExpression of BindingRestElement .</step>
</step-list>
<step-list>
  <step>Return ContainsExpression of BindingElementList .</step>
</step-list>
<step-list>
  <step>Let <id>has</id> be ContainsExpression of BindingElementList .</step>
  <step>If <id>has</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return ContainsExpression of BindingRestElement .</step>
</step-list>
<step-list>
  <step>Let <id>has</id> be ContainsExpression of BindingPropertyList .</step>
  <step>If <id>has</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return ContainsExpression of BindingProperty .</step>
</step-list>
<step-list>
  <step>Let <id>has</id> be ContainsExpression of BindingElementList .</step>
  <step>If <id>has</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return ContainsExpression of BindingElisionElement .</step>
</step-list>
<step-list>
  <step>Return ContainsExpression of BindingElement .</step>
</step-list>
<step-list>
  <step>Let <id>has</id> be IsComputedPropertyKey of PropertyName .</step>
  <step>If <id>has</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return ContainsExpression of BindingElement .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return ContainsExpression of BindingPattern .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Perform ? RequireObjectCoercible ( <id>value</id> ).</step>
  <step>Return the result of performing BindingInitialization for ObjectBindingPattern using <id>value</id> and <id>environment</id> as arguments.</step>
</step-list>
<step-list>
  <step>Let <id>iteratorRecord</id> be ? GetIterator ( <id>value</id> ).</step>
  <step>Let <id>result</id> be IteratorBindingInitialization for ArrayBindingPattern using <id>iteratorRecord</id> and <id>environment</id> as arguments.</step>
  <step>If <id>iteratorRecord</id> .[[Done]] is <value>false</value> , return ? IteratorClose ( <id>iteratorRecord</id> , <id>result</id> ).</step>
  <step>Return <id>result</id> .</step>
</step-list>
<step-list>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Perform ? PropertyBindingInitialization for BindingPropertyList using <id>value</id> and <id>environment</id> as the arguments.</step>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>excludedNames</id> be a new empty List .</step>
  <step>Return the result of performing RestBindingInitialization of BindingRestProperty with <id>value</id> , <id>environment</id> , and <id>excludedNames</id> as the arguments.</step>
</step-list>
<step-list>
  <step>Let <id>excludedNames</id> be the result of performing ? PropertyBindingInitialization of BindingPropertyList using <id>value</id> and <id>environment</id> as arguments.</step>
  <step>Return the result of performing RestBindingInitialization of BindingRestProperty with <id>value</id> , <id>environment</id> , and <id>excludedNames</id> as the arguments.</step>
</step-list>
<step-list>
  <step>Let <id>boundNames</id> be the result of performing ? PropertyBindingInitialization for BindingPropertyList using <id>value</id> and <id>environment</id> as arguments.</step>
  <step>Let <id>nextNames</id> be the result of performing ? PropertyBindingInitialization for BindingProperty using <id>value</id> and <id>environment</id> as arguments.</step>
  <step>Append each item in <id>nextNames</id> to the end of <id>boundNames</id> .</step>
  <step>Return <id>boundNames</id> .</step>
</step-list>
<step-list>
  <step>Let <id>name</id> be the string that is the only element of BoundNames of SingleNameBinding .</step>
  <step>Perform ? KeyedBindingInitialization for SingleNameBinding using <id>value</id> , <id>environment</id> , and <id>name</id> as the arguments.</step>
  <step>Return a new List containing <id>name</id> .</step>
</step-list>
<step-list>
  <step>Let <id>P</id> be the result of evaluating PropertyName .</step>
  <step>ReturnIfAbrupt ( <id>P</id> ).</step>
  <step>Perform ? KeyedBindingInitialization of BindingElement with <id>value</id> , <id>environment</id> , and <id>P</id> as the arguments.</step>
  <step>Return a new List containing <id>P</id> .</step>
</step-list>
<step-list>
  <step>Let <id>lhs</id> be ? ResolveBinding (StringValue of BindingIdentifier , <id>environment</id> ).</step>
  <step>Let <id>restObj</id> be ObjectCreate ( %ObjectPrototype% ).</step>
  <step>Perform ? CopyDataProperties ( <id>restObj</id> , <id>value</id> , <id>excludedNames</id> ).</step>
  <step>If <id>environment</id> is <value>undefined</value> , return PutValue ( <id>lhs</id> , <id>restObj</id> ).</step>
  <step>Return InitializeReferencedBinding ( <id>lhs</id> , <id>restObj</id> ).</step>
</step-list>
<step-list>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Return the result of performing IteratorDestructuringAssignmentEvaluation of Elision with <id>iteratorRecord</id> as the argument.</step>
</step-list>
<step-list>
  <step>If Elision is present, then   <step-list>
    <step>Perform ? IteratorDestructuringAssignmentEvaluation of Elision with <id>iteratorRecord</id> as the argument.</step>
  </step-list></step>
  <step>Return the result of performing IteratorBindingInitialization for BindingRestElement with <id>iteratorRecord</id> and <id>environment</id> as arguments.</step>
</step-list>
<step-list>
  <step>Return the result of performing IteratorBindingInitialization for BindingElementList with <id>iteratorRecord</id> and <id>environment</id> as arguments.</step>
</step-list>
<step-list>
  <step>Return the result of performing IteratorBindingInitialization for BindingElementList with <id>iteratorRecord</id> and <id>environment</id> as arguments.</step>
</step-list>
<step-list>
  <step>Perform ? IteratorBindingInitialization for BindingElementList with <id>iteratorRecord</id> and <id>environment</id> as arguments.</step>
  <step>Return the result of performing IteratorDestructuringAssignmentEvaluation of Elision with <id>iteratorRecord</id> as the argument.</step>
</step-list>
<step-list>
  <step>Perform ? IteratorBindingInitialization for BindingElementList with <id>iteratorRecord</id> and <id>environment</id> as arguments.</step>
  <step>If Elision is present, then   <step-list>
    <step>Perform ? IteratorDestructuringAssignmentEvaluation of Elision with <id>iteratorRecord</id> as the argument.</step>
  </step-list></step>
  <step>Return the result of performing IteratorBindingInitialization for BindingRestElement with <id>iteratorRecord</id> and <id>environment</id> as arguments.</step>
</step-list>
<step-list>
  <step>Return the result of performing IteratorBindingInitialization for BindingElisionElement with <id>iteratorRecord</id> and <id>environment</id> as arguments.</step>
</step-list>
<step-list>
  <step>Perform ? IteratorBindingInitialization for BindingElementList with <id>iteratorRecord</id> and <id>environment</id> as arguments.</step>
  <step>Return the result of performing IteratorBindingInitialization for BindingElisionElement using <id>iteratorRecord</id> and <id>environment</id> as arguments.</step>
</step-list>
<step-list>
  <step>Return the result of performing IteratorBindingInitialization of BindingElement with <id>iteratorRecord</id> and <id>environment</id> as the arguments.</step>
</step-list>
<step-list>
  <step>Perform ? IteratorDestructuringAssignmentEvaluation of Elision with <id>iteratorRecord</id> as the argument.</step>
  <step>Return the result of performing IteratorBindingInitialization of BindingElement with <id>iteratorRecord</id> and <id>environment</id> as the arguments.</step>
</step-list>
<step-list>
  <step>Return the result of performing IteratorBindingInitialization for SingleNameBinding with <id>iteratorRecord</id> and <id>environment</id> as the arguments.</step>
</step-list>
<step-list>
  <step>Let <id>bindingId</id> be StringValue of BindingIdentifier .</step>
  <step>Let <id>lhs</id> be ? ResolveBinding ( <id>bindingId</id> , <id>environment</id> ).</step>
  <step>If <id>iteratorRecord</id> .[[Done]] is <value>false</value> , then   <step-list>
    <step>Let <id>next</id> be IteratorStep ( <id>iteratorRecord</id> ).</step>
    <step>If <id>next</id> is an abrupt completion , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
    <step>ReturnIfAbrupt ( <id>next</id> ).</step>
    <step>If <id>next</id> is <value>false</value> , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
    <step>Else,     <step-list>
      <step>Let <id>v</id> be IteratorValue ( <id>next</id> ).</step>
      <step>If <id>v</id> is an abrupt completion , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
      <step>ReturnIfAbrupt ( <id>v</id> ).</step>
    </step-list></step>
  </step-list></step>
  <step>If <id>iteratorRecord</id> .[[Done]] is <value>true</value> , let <id>v</id> be <value>undefined</value> .</step>
  <step>If Initializer is present and <id>v</id> is <value>undefined</value> , then   <step-list>
    <step>Let <id>defaultValue</id> be the result of evaluating Initializer .</step>
    <step>Set <id>v</id> to ? GetValue ( <id>defaultValue</id> ).</step>
    <step>If IsAnonymousFunctionDefinition ( Initializer ) is <value>true</value> , then     <step-list>
      <step>Let <id>hasNameProperty</id> be ? HasOwnProperty ( <id>v</id> , <value>"name"</value> ).</step>
      <step>If <id>hasNameProperty</id> is <value>false</value> , perform SetFunctionName ( <id>v</id> , <id>bindingId</id> ).</step>
    </step-list></step>
  </step-list></step>
  <step>If <id>environment</id> is <value>undefined</value> , return ? PutValue ( <id>lhs</id> , <id>v</id> ).</step>
  <step>Return InitializeReferencedBinding ( <id>lhs</id> , <id>v</id> ).</step>
</step-list>
<step-list>
  <step>If <id>iteratorRecord</id> .[[Done]] is <value>false</value> , then   <step-list>
    <step>Let <id>next</id> be IteratorStep ( <id>iteratorRecord</id> ).</step>
    <step>If <id>next</id> is an abrupt completion , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
    <step>ReturnIfAbrupt ( <id>next</id> ).</step>
    <step>If <id>next</id> is <value>false</value> , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
    <step>Else,     <step-list>
      <step>Let <id>v</id> be IteratorValue ( <id>next</id> ).</step>
      <step>If <id>v</id> is an abrupt completion , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
      <step>ReturnIfAbrupt ( <id>v</id> ).</step>
    </step-list></step>
  </step-list></step>
  <step>If <id>iteratorRecord</id> .[[Done]] is <value>true</value> , let <id>v</id> be <value>undefined</value> .</step>
  <step>If Initializer is present and <id>v</id> is <value>undefined</value> , then   <step-list>
    <step>Let <id>defaultValue</id> be the result of evaluating Initializer .</step>
    <step>Set <id>v</id> to ? GetValue ( <id>defaultValue</id> ).</step>
  </step-list></step>
  <step>Return the result of performing BindingInitialization of BindingPattern with <id>v</id> and <id>environment</id> as the arguments.</step>
</step-list>
<step-list>
  <step>Let <id>lhs</id> be ? ResolveBinding (StringValue of BindingIdentifier , <id>environment</id> ).</step>
  <step>Let <id>A</id> be ! ArrayCreate (0).</step>
  <step>Let <id>n</id> be 0.</step>
  <step>Repeat,   <step-list>
    <step>If <id>iteratorRecord</id> .[[Done]] is <value>false</value> , then     <step-list>
      <step>Let <id>next</id> be IteratorStep ( <id>iteratorRecord</id> ).</step>
      <step>If <id>next</id> is an abrupt completion , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
      <step>ReturnIfAbrupt ( <id>next</id> ).</step>
      <step>If <id>next</id> is <value>false</value> , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
    </step-list></step>
    <step>If <id>iteratorRecord</id> .[[Done]] is <value>true</value> , then     <step-list>
      <step>If <id>environment</id> is <value>undefined</value> , return ? PutValue ( <id>lhs</id> , <id>A</id> ).</step>
      <step>Return InitializeReferencedBinding ( <id>lhs</id> , <id>A</id> ).</step>
    </step-list></step>
    <step>Let <id>nextValue</id> be IteratorValue ( <id>next</id> ).</step>
    <step>If <id>nextValue</id> is an abrupt completion , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
    <step>ReturnIfAbrupt ( <id>nextValue</id> ).</step>
    <step>Let <id>status</id> be CreateDataProperty ( <id>A</id> , ! ToString ( <id>n</id> ), <id>nextValue</id> ).</step>
    <step>Assert : <id>status</id> is <value>true</value> .</step>
    <step>Increment <id>n</id> by 1.</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>A</id> be ! ArrayCreate (0).</step>
  <step>Let <id>n</id> be 0.</step>
  <step>Repeat,   <step-list>
    <step>If <id>iteratorRecord</id> .[[Done]] is <value>false</value> , then     <step-list>
      <step>Let <id>next</id> be IteratorStep ( <id>iteratorRecord</id> ).</step>
      <step>If <id>next</id> is an abrupt completion , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
      <step>ReturnIfAbrupt ( <id>next</id> ).</step>
      <step>If <id>next</id> is <value>false</value> , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
    </step-list></step>
    <step>If <id>iteratorRecord</id> .[[Done]] is <value>true</value> , then     <step-list>
      <step>Return the result of performing BindingInitialization of BindingPattern with <id>A</id> and <id>environment</id> as the arguments.</step>
    </step-list></step>
    <step>Let <id>nextValue</id> be IteratorValue ( <id>next</id> ).</step>
    <step>If <id>nextValue</id> is an abrupt completion , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
    <step>ReturnIfAbrupt ( <id>nextValue</id> ).</step>
    <step>Let <id>status</id> be CreateDataProperty ( <id>A</id> , ! ToString ( <id>n</id> ), <id>nextValue</id> ).</step>
    <step>Assert : <id>status</id> is <value>true</value> .</step>
    <step>Increment <id>n</id> by 1.</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>v</id> be ? GetV ( <id>value</id> , <id>propertyName</id> ).</step>
  <step>If Initializer is present and <id>v</id> is <value>undefined</value> , then   <step-list>
    <step>Let <id>defaultValue</id> be the result of evaluating Initializer .</step>
    <step>Set <id>v</id> to ? GetValue ( <id>defaultValue</id> ).</step>
  </step-list></step>
  <step>Return the result of performing BindingInitialization for BindingPattern passing <id>v</id> and <id>environment</id> as arguments.</step>
</step-list>
<step-list>
  <step>Let <id>bindingId</id> be StringValue of BindingIdentifier .</step>
  <step>Let <id>lhs</id> be ? ResolveBinding ( <id>bindingId</id> , <id>environment</id> ).</step>
  <step>Let <id>v</id> be ? GetV ( <id>value</id> , <id>propertyName</id> ).</step>
  <step>If Initializer is present and <id>v</id> is <value>undefined</value> , then   <step-list>
    <step>Let <id>defaultValue</id> be the result of evaluating Initializer .</step>
    <step>Set <id>v</id> to ? GetValue ( <id>defaultValue</id> ).</step>
    <step>If IsAnonymousFunctionDefinition ( Initializer ) is <value>true</value> , then     <step-list>
      <step>Let <id>hasNameProperty</id> be ? HasOwnProperty ( <id>v</id> , <value>"name"</value> ).</step>
      <step>If <id>hasNameProperty</id> is <value>false</value> , perform SetFunctionName ( <id>v</id> , <id>bindingId</id> ).</step>
    </step-list></step>
  </step-list></step>
  <step>If <id>environment</id> is <value>undefined</value> , return ? PutValue ( <id>lhs</id> , <id>v</id> ).</step>
  <step>Return InitializeReferencedBinding ( <id>lhs</id> , <id>v</id> ).</step>
</step-list>
<step-list>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>exprRef</id> be the result of evaluating Expression .</step>
  <step>Return ? GetValue ( <id>exprRef</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>hasDuplicate</id> be ContainsDuplicateLabels of the first Statement with argument <id>labelSet</id> .</step>
  <step>If <id>hasDuplicate</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return ContainsDuplicateLabels of the second Statement with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Return ContainsDuplicateLabels of Statement with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Let <id>hasUndefinedLabels</id> be ContainsUndefinedBreakTarget of the first Statement with argument <id>labelSet</id> .</step>
  <step>If <id>hasUndefinedLabels</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return ContainsUndefinedBreakTarget of the second Statement with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Return ContainsUndefinedBreakTarget of Statement with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Let <id>hasUndefinedLabels</id> be ContainsUndefinedContinueTarget of the first Statement with arguments <id>iterationSet</id> and « ».</step>
  <step>If <id>hasUndefinedLabels</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return ContainsUndefinedContinueTarget of the second Statement with arguments <id>iterationSet</id> and « ».</step>
</step-list>
<step-list>
  <step>Return ContainsUndefinedContinueTarget of Statement with arguments <id>iterationSet</id> and « ».</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be VarDeclaredNames of the first Statement .</step>
  <step>Append to <id>names</id> the elements of the VarDeclaredNames of the second Statement .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>Return the VarDeclaredNames of Statement .</step>
</step-list>
<step-list>
  <step>Let <id>declarations</id> be VarScopedDeclarations of the first Statement .</step>
  <step>Append to <id>declarations</id> the elements of the VarScopedDeclarations of the second Statement .</step>
  <step>Return <id>declarations</id> .</step>
</step-list>
<step-list>
  <step>Return the VarScopedDeclarations of Statement .</step>
</step-list>
<step-list>
  <step>Let <id>exprRef</id> be the result of evaluating Expression .</step>
  <step>Let <id>exprValue</id> be ToBoolean (? GetValue ( <id>exprRef</id> )).</step>
  <step>If <id>exprValue</id> is <value>true</value> , then   <step-list>
    <step>Let <id>stmtCompletion</id> be the result of evaluating the first Statement .</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>stmtCompletion</id> be the result of evaluating the second Statement .</step>
  </step-list></step>
  <step>Return Completion ( UpdateEmpty ( <id>stmtCompletion</id> , <value>undefined</value> )).</step>
</step-list>
<step-list>
  <step>Let <id>exprRef</id> be the result of evaluating Expression .</step>
  <step>Let <id>exprValue</id> be ToBoolean (? GetValue ( <id>exprRef</id> )).</step>
  <step>If <id>exprValue</id> is <value>false</value> , then   <step-list>
    <step>Return NormalCompletion ( <value>undefined</value> ).</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>stmtCompletion</id> be the result of evaluating Statement .</step>
    <step>Return Completion ( UpdateEmpty ( <id>stmtCompletion</id> , <value>undefined</value> )).</step>
  </step-list></step>
</step-list>
<step-list>
  <step>If <id>completion</id> .[[Type]] is <value>normal</value> , return <value>true</value> .</step>
  <step>If <id>completion</id> .[[Type]] is not <value>continue</value> , return <value>false</value> .</step>
  <step>If <id>completion</id> .[[Target]] is <value>empty</value> , return <value>true</value> .</step>
  <step>If <id>completion</id> .[[Target]] is an element of <id>labelSet</id> , return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return ContainsDuplicateLabels of Statement with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Return ContainsUndefinedBreakTarget of Statement with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Return ContainsUndefinedContinueTarget of Statement with arguments <id>iterationSet</id> and « ».</step>
</step-list>
<step-list>
  <step>Return the VarDeclaredNames of Statement .</step>
</step-list>
<step-list>
  <step>Return the VarScopedDeclarations of Statement .</step>
</step-list>
<step-list>
  <step>Let <id>V</id> be <value>undefined</value> .</step>
  <step>Repeat,   <step-list>
    <step>Let <id>stmtResult</id> be the result of evaluating Statement .</step>
    <step>If LoopContinues ( <id>stmtResult</id> , <id>labelSet</id> ) is <value>false</value> , return Completion ( UpdateEmpty ( <id>stmtResult</id> , <id>V</id> )).</step>
    <step>If <id>stmtResult</id> .[[Value]] is not <value>empty</value> , set <id>V</id> to <id>stmtResult</id> .[[Value]].</step>
    <step>Let <id>exprRef</id> be the result of evaluating Expression .</step>
    <step>Let <id>exprValue</id> be ? GetValue ( <id>exprRef</id> ).</step>
    <step>If ToBoolean ( <id>exprValue</id> ) is <value>false</value> , return NormalCompletion ( <id>V</id> ).</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Return ContainsDuplicateLabels of Statement with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Return ContainsUndefinedBreakTarget of Statement with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Return ContainsUndefinedContinueTarget of Statement with arguments <id>iterationSet</id> and « ».</step>
</step-list>
<step-list>
  <step>Return the VarDeclaredNames of Statement .</step>
</step-list>
<step-list>
  <step>Return the VarScopedDeclarations of Statement .</step>
</step-list>
<step-list>
  <step>Let <id>V</id> be <value>undefined</value> .</step>
  <step>Repeat,   <step-list>
    <step>Let <id>exprRef</id> be the result of evaluating Expression .</step>
    <step>Let <id>exprValue</id> be ? GetValue ( <id>exprRef</id> ).</step>
    <step>If ToBoolean ( <id>exprValue</id> ) is <value>false</value> , return NormalCompletion ( <id>V</id> ).</step>
    <step>Let <id>stmtResult</id> be the result of evaluating Statement .</step>
    <step>If LoopContinues ( <id>stmtResult</id> , <id>labelSet</id> ) is <value>false</value> , return Completion ( UpdateEmpty ( <id>stmtResult</id> , <id>V</id> )).</step>
    <step>If <id>stmtResult</id> .[[Value]] is not <value>empty</value> , set <id>V</id> to <id>stmtResult</id> .[[Value]].</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Return ContainsDuplicateLabels of Statement with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Return ContainsUndefinedBreakTarget of Statement with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Return ContainsUndefinedContinueTarget of Statement with arguments <id>iterationSet</id> and « ».</step>
</step-list>
<step-list>
  <step>Return the VarDeclaredNames of Statement .</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be BoundNames of VariableDeclarationList .</step>
  <step>Append to <id>names</id> the elements of the VarDeclaredNames of Statement .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>Return the VarDeclaredNames of Statement .</step>
</step-list>
<step-list>
  <step>Return the VarScopedDeclarations of Statement .</step>
</step-list>
<step-list>
  <step>Let <id>declarations</id> be VarScopedDeclarations of VariableDeclarationList .</step>
  <step>Append to <id>declarations</id> the elements of the VarScopedDeclarations of Statement .</step>
  <step>Return <id>declarations</id> .</step>
</step-list>
<step-list>
  <step>Return the VarScopedDeclarations of Statement .</step>
</step-list>
<step-list>
  <step>If the first Expression is present, then   <step-list>
    <step>Let <id>exprRef</id> be the result of evaluating the first Expression .</step>
    <step>Perform ? GetValue ( <id>exprRef</id> ).</step>
  </step-list></step>
  <step>Return ? ForBodyEvaluation (the second Expression , the third Expression , Statement , « », <id>labelSet</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>varDcl</id> be the result of evaluating VariableDeclarationList .</step>
  <step>ReturnIfAbrupt ( <id>varDcl</id> ).</step>
  <step>Return ? ForBodyEvaluation (the first Expression , the second Expression , Statement , « », <id>labelSet</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>oldEnv</id> be the running execution context 's LexicalEnvironment.</step>
  <step>Let <id>loopEnv</id> be NewDeclarativeEnvironment ( <id>oldEnv</id> ).</step>
  <step>Let <id>loopEnvRec</id> be <id>loopEnv</id> 's EnvironmentRecord .</step>
  <step>Let <id>isConst</id> be the result of performing IsConstantDeclaration of LexicalDeclaration .</step>
  <step>Let <id>boundNames</id> be the BoundNames of LexicalDeclaration .</step>
  <step>For each element <id>dn</id> of <id>boundNames</id> , do   <step-list>
    <step>If <id>isConst</id> is <value>true</value> , then     <step-list>
      <step>Perform ! <id>loopEnvRec</id> .CreateImmutableBinding( <id>dn</id> , <value>true</value> ).</step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>Perform ! <id>loopEnvRec</id> .CreateMutableBinding( <id>dn</id> , <value>false</value> ).</step>
    </step-list></step>
  </step-list></step>
  <step>Set the running execution context 's LexicalEnvironment to <id>loopEnv</id> .</step>
  <step>Let <id>forDcl</id> be the result of evaluating LexicalDeclaration .</step>
  <step>If <id>forDcl</id> is an abrupt completion , then   <step-list>
    <step>Set the running execution context 's LexicalEnvironment to <id>oldEnv</id> .</step>
    <step>Return Completion ( <id>forDcl</id> ).</step>
  </step-list></step>
  <step>If <id>isConst</id> is <value>false</value> , let <id>perIterationLets</id> be <id>boundNames</id> ; otherwise let <id>perIterationLets</id> be « ».</step>
  <step>Let <id>bodyResult</id> be ForBodyEvaluation (the first Expression , the second Expression , Statement , <id>perIterationLets</id> , <id>labelSet</id> ).</step>
  <step>Set the running execution context 's LexicalEnvironment to <id>oldEnv</id> .</step>
  <step>Return Completion ( <id>bodyResult</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>V</id> be <value>undefined</value> .</step>
  <step>Perform ? CreatePerIterationEnvironment ( <id>perIterationBindings</id> ).</step>
  <step>Repeat,   <step-list>
    <step>If <id>test</id> is not <value>[empty]</value> , then     <step-list>
      <step>Let <id>testRef</id> be the result of evaluating <id>test</id> .</step>
      <step>Let <id>testValue</id> be ? GetValue ( <id>testRef</id> ).</step>
      <step>If ToBoolean ( <id>testValue</id> ) is <value>false</value> , return NormalCompletion ( <id>V</id> ).</step>
    </step-list></step>
    <step>Let <id>result</id> be the result of evaluating <id>stmt</id> .</step>
    <step>If LoopContinues ( <id>result</id> , <id>labelSet</id> ) is <value>false</value> , return Completion ( UpdateEmpty ( <id>result</id> , <id>V</id> )).</step>
    <step>If <id>result</id> .[[Value]] is not <value>empty</value> , set <id>V</id> to <id>result</id> .[[Value]].</step>
    <step>Perform ? CreatePerIterationEnvironment ( <id>perIterationBindings</id> ).</step>
    <step>If <id>increment</id> is not <value>[empty]</value> , then     <step-list>
      <step>Let <id>incRef</id> be the result of evaluating <id>increment</id> .</step>
      <step>Perform ? GetValue ( <id>incRef</id> ).</step>
    </step-list></step>
  </step-list></step>
</step-list>
<step-list>
  <step>If <id>perIterationBindings</id> has any elements, then   <step-list>
    <step>Let <id>lastIterationEnv</id> be the running execution context 's LexicalEnvironment.</step>
    <step>Let <id>lastIterationEnvRec</id> be <id>lastIterationEnv</id> 's EnvironmentRecord .</step>
    <step>Let <id>outer</id> be <id>lastIterationEnv</id> 's outer environment reference.</step>
    <step>Assert : <id>outer</id> is not <value>null</value> .</step>
    <step>Let <id>thisIterationEnv</id> be NewDeclarativeEnvironment ( <id>outer</id> ).</step>
    <step>Let <id>thisIterationEnvRec</id> be <id>thisIterationEnv</id> 's EnvironmentRecord .</step>
    <step>For each element <id>bn</id> of <id>perIterationBindings</id> , do     <step-list>
      <step>Perform ! <id>thisIterationEnvRec</id> .CreateMutableBinding( <id>bn</id> , <value>false</value> ).</step>
      <step>Let <id>lastValue</id> be ? <id>lastIterationEnvRec</id> .GetBindingValue( <id>bn</id> , <value>true</value> ).</step>
      <step>Perform <id>thisIterationEnvRec</id> .InitializeBinding( <id>bn</id> , <id>lastValue</id> ).</step>
    </step-list></step>
    <step>Set the running execution context 's LexicalEnvironment to <id>thisIterationEnv</id> .</step>
  </step-list></step>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Return the BoundNames of ForBinding .</step>
</step-list>
<step-list>
  <step>Return ContainsDuplicateLabels of Statement with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Return ContainsUndefinedBreakTarget of Statement with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Return ContainsUndefinedContinueTarget of Statement with arguments <id>iterationSet</id> and « ».</step>
</step-list>
<step-list>
  <step>Return IsDestructuring of ForBinding .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return the VarDeclaredNames of Statement .</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be the BoundNames of ForBinding .</step>
  <step>Append to <id>names</id> the elements of the VarDeclaredNames of Statement .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>Return the VarDeclaredNames of Statement .</step>
</step-list>
<step-list>
  <step>Return the VarDeclaredNames of Statement .</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be the BoundNames of ForBinding .</step>
  <step>Append to <id>names</id> the elements of the VarDeclaredNames of Statement .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>Return the VarDeclaredNames of Statement .</step>
</step-list>
<step-list>
  <step>Return the VarScopedDeclarations of Statement .</step>
</step-list>
<step-list>
  <step>Let <id>declarations</id> be a List containing ForBinding .</step>
  <step>Append to <id>declarations</id> the elements of the VarScopedDeclarations of Statement .</step>
  <step>Return <id>declarations</id> .</step>
</step-list>
<step-list>
  <step>Return the VarScopedDeclarations of Statement .</step>
</step-list>
<step-list>
  <step>Return the VarScopedDeclarations of Statement .</step>
</step-list>
<step-list>
  <step>Let <id>declarations</id> be a List containing ForBinding .</step>
  <step>Append to <id>declarations</id> the elements of the VarScopedDeclarations of Statement .</step>
  <step>Return <id>declarations</id> .</step>
</step-list>
<step-list>
  <step>Return the VarScopedDeclarations of Statement .</step>
</step-list>
<step-list>
  <step>Return the result of performing BindingInitialization for ForBinding passing <id>value</id> and <id>environment</id> as the arguments.</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be <id>environment</id> 's EnvironmentRecord .</step>
  <step>Assert : <id>envRec</id> is a declarative Environment Record .</step>
  <step>For each element <id>name</id> of the BoundNames of ForBinding , do   <step-list>
    <step>If IsConstantDeclaration of LetOrConst is <value>true</value> , then     <step-list>
      <step>Perform ! <id>envRec</id> .CreateImmutableBinding( <id>name</id> , <value>true</value> ).</step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>Perform ! <id>envRec</id> .CreateMutableBinding( <id>name</id> , <value>false</value> ).</step>
    </step-list></step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>keyResult</id> be ? ForIn/OfHeadEvaluation (« », Expression , <value>enumerate</value> ).</step>
  <step>Return ? ForIn/OfBodyEvaluation ( LeftHandSideExpression , Statement , <id>keyResult</id> , <value>enumerate</value> , <value>assignment</value> , <id>labelSet</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>keyResult</id> be ? ForIn/OfHeadEvaluation (« », Expression , <value>enumerate</value> ).</step>
  <step>Return ? ForIn/OfBodyEvaluation ( ForBinding , Statement , <id>keyResult</id> , <value>enumerate</value> , <value>varBinding</value> , <id>labelSet</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>keyResult</id> be the result of performing ? ForIn/OfHeadEvaluation (BoundNames of ForDeclaration , Expression , <value>enumerate</value> ).</step>
  <step>Return ? ForIn/OfBodyEvaluation ( ForDeclaration , Statement , <id>keyResult</id> , <value>enumerate</value> , <value>lexicalBinding</value> , <id>labelSet</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>keyResult</id> be the result of performing ? ForIn/OfHeadEvaluation (« », AssignmentExpression , <value>iterate</value> ).</step>
  <step>Return ? ForIn/OfBodyEvaluation ( LeftHandSideExpression , Statement , <id>keyResult</id> , <value>iterate</value> , <value>assignment</value> , <id>labelSet</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>keyResult</id> be the result of performing ? ForIn/OfHeadEvaluation (« », AssignmentExpression , <value>iterate</value> ).</step>
  <step>Return ? ForIn/OfBodyEvaluation ( ForBinding , Statement , <id>keyResult</id> , <value>iterate</value> , <value>varBinding</value> , <id>labelSet</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>keyResult</id> be the result of performing ? ForIn/OfHeadEvaluation (BoundNames of ForDeclaration , AssignmentExpression , <value>iterate</value> ).</step>
  <step>Return ? ForIn/OfBodyEvaluation ( ForDeclaration , Statement , <id>keyResult</id> , <value>iterate</value> , <value>lexicalBinding</value> , <id>labelSet</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>keyResult</id> be the result of performing ? ForIn/OfHeadEvaluation (« », AssignmentExpression , <value>async-iterate</value> ).</step>
  <step>Return ? ForIn/OfBodyEvaluation ( LeftHandSideExpression , Statement , <id>keyResult</id> , <value>iterate</value> , <value>assignment</value> , <id>labelSet</id> , <value>async</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>keyResult</id> be the result of performing ? ForIn/OfHeadEvaluation (« », AssignmentExpression , <value>async-iterate</value> ).</step>
  <step>Return ? ForIn/OfBodyEvaluation ( ForBinding , Statement , <id>keyResult</id> , <value>iterate</value> , <value>varBinding</value> , <id>labelSet</id> , <value>async</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>keyResult</id> be the result of performing ? ForIn/OfHeadEvaluation (BoundNames of ForDeclaration , AssignmentExpression , <value>async-iterate</value> ).</step>
  <step>Return ? ForIn/OfBodyEvaluation ( ForDeclaration , Statement , <id>keyResult</id> , <value>iterate</value> , <value>lexicalBinding</value> , <id>labelSet</id> , <value>async</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>oldEnv</id> be the running execution context 's LexicalEnvironment.</step>
  <step>If <id>TDZnames</id> is not an empty List , then   <step-list>
    <step>Assert : <id>TDZnames</id> has no duplicate entries.</step>
    <step>Let <id>TDZ</id> be NewDeclarativeEnvironment ( <id>oldEnv</id> ).</step>
    <step>Let <id>TDZEnvRec</id> be <id>TDZ</id> 's EnvironmentRecord .</step>
    <step>For each string <id>name</id> in <id>TDZnames</id> , do     <step-list>
      <step>Perform ! <id>TDZEnvRec</id> .CreateMutableBinding( <id>name</id> , <value>false</value> ).</step>
    </step-list></step>
    <step>Set the running execution context 's LexicalEnvironment to <id>TDZ</id> .</step>
  </step-list></step>
  <step>Let <id>exprRef</id> be the result of evaluating <id>expr</id> .</step>
  <step>Set the running execution context 's LexicalEnvironment to <id>oldEnv</id> .</step>
  <step>Let <id>exprValue</id> be ? GetValue ( <id>exprRef</id> ).</step>
  <step>If <id>iterationKind</id> is <value>enumerate</value> , then   <step-list>
    <step>If <id>exprValue</id> is <value>undefined</value> or <value>null</value> , then     <step-list>
      <step>Return Completion { [[Type]]: <value>break</value> , [[Value]]: <value>empty</value> , [[Target]]: <value>empty</value> }.</step>
    </step-list></step>
    <step>Let <id>obj</id> be ! ToObject ( <id>exprValue</id> ).</step>
    <step>Return ? EnumerateObjectProperties ( <id>obj</id> ).</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Assert : <id>iterationKind</id> is <value>iterate</value> .</step>
    <step>If <id>iterationKind</id> is <value>async-iterate</value> , let <id>iteratorHint</id> be <value>async</value> .</step>
    <step>Else, let <id>iteratorHint</id> be <value>sync</value> .</step>
    <step>Return ? GetIterator ( <id>exprValue</id> , <id>iteratorHint</id> ).</step>
  </step-list></step>
</step-list>
<step-list>
  <step>If <id>iteratorKind</id> is not present, set <id>iteratorKind</id> to <value>sync</value> .</step>
  <step>Let <id>oldEnv</id> be the running execution context 's LexicalEnvironment.</step>
  <step>Let <id>V</id> be <value>undefined</value> .</step>
  <step>Let <id>destructuring</id> be IsDestructuring of <id>lhs</id> .</step>
  <step>If <id>destructuring</id> is <value>true</value> and if <id>lhsKind</id> is <value>assignment</value> , then   <step-list>
    <step>Assert : <id>lhs</id> is a LeftHandSideExpression .</step>
    <step>Let <id>assignmentPattern</id> be the AssignmentPattern that is covered by <id>lhs</id> .</step>
  </step-list></step>
  <step>Repeat,   <step-list>
    <step>Let <id>nextResult</id> be ? Call ( <id>iteratorRecord</id> .[[NextMethod]], <id>iteratorRecord</id> .[[Iterator]], « »).</step>
    <step>If <id>iteratorKind</id> is <value>async</value> , then set <id>nextResult</id> to ? Await ( <id>nextResult</id> ).</step>
    <step>If Type ( <id>nextResult</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
    <step>Let <id>nextValue</id> be ? IteratorValue ( <id>nextResult</id> ).</step>
    <step>If <id>lhsKind</id> is either <value>assignment</value> or <value>varBinding</value> , then     <step-list>
      <step>If <id>destructuring</id> is <value>false</value> , then       <step-list>
        <step>Let <id>lhsRef</id> be the result of evaluating <id>lhs</id> . (It may be evaluated repeatedly.)</step>
      </step-list></step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>Assert : <id>lhsKind</id> is <value>lexicalBinding</value> .</step>
      <step>Assert : <id>lhs</id> is a ForDeclaration .</step>
      <step>Let <id>iterationEnv</id> be NewDeclarativeEnvironment ( <id>oldEnv</id> ).</step>
      <step>Perform BindingInstantiation for <id>lhs</id> passing <id>iterationEnv</id> as the argument.</step>
      <step>Set the running execution context 's LexicalEnvironment to <id>iterationEnv</id> .</step>
      <step>If <id>destructuring</id> is <value>false</value> , then       <step-list>
        <step>Assert : <id>lhs</id> binds a single name.</step>
        <step>Let <id>lhsName</id> be the sole element of BoundNames of <id>lhs</id> .</step>
        <step>Let <id>lhsRef</id> be ! ResolveBinding ( <id>lhsName</id> ).</step>
      </step-list></step>
    </step-list></step>
    <step>If <id>destructuring</id> is <value>false</value> , then     <step-list>
      <step>If <id>lhsRef</id> is an abrupt completion , then       <step-list>
        <step>Let <id>status</id> be <id>lhsRef</id> .</step>
      </step-list></step>
      <step>Else if <id>lhsKind</id> is <value>lexicalBinding</value> , then       <step-list>
        <step>Let <id>status</id> be InitializeReferencedBinding ( <id>lhsRef</id> , <id>nextValue</id> ).</step>
      </step-list></step>
      <step>Else,       <step-list>
        <step>Let <id>status</id> be PutValue ( <id>lhsRef</id> , <id>nextValue</id> ).</step>
      </step-list></step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>If <id>lhsKind</id> is <value>assignment</value> , then       <step-list>
        <step>Let <id>status</id> be the result of performing DestructuringAssignmentEvaluation of <id>assignmentPattern</id> using <id>nextValue</id> as the argument.</step>
      </step-list></step>
      <step>Else if <id>lhsKind</id> is <value>varBinding</value> , then       <step-list>
        <step>Assert : <id>lhs</id> is a ForBinding .</step>
        <step>Let <id>status</id> be the result of performing BindingInitialization for <id>lhs</id> passing <id>nextValue</id> and <value>undefined</value> as the arguments.</step>
      </step-list></step>
      <step>Else,       <step-list>
        <step>Assert : <id>lhsKind</id> is <value>lexicalBinding</value> .</step>
        <step>Assert : <id>lhs</id> is a ForDeclaration .</step>
        <step>Let <id>status</id> be the result of performing BindingInitialization for <id>lhs</id> passing <id>nextValue</id> and <id>iterationEnv</id> as arguments.</step>
      </step-list></step>
    </step-list></step>
    <step>If <id>status</id> is an abrupt completion , then     <step-list>
      <step>Set the running execution context 's LexicalEnvironment to <id>oldEnv</id> .</step>
      <step>If <id>iteratorKind</id> is <value>async</value> , return ? AsyncIteratorClose ( <id>iteratorRecord</id> , <id>status</id> ).</step>
      <step>If <id>iterationKind</id> is <value>enumerate</value> , then       <step-list>
        <step>Return <id>status</id> .</step>
      </step-list></step>
      <step>Else,       <step-list>
        <step>Assert : <id>iterationKind</id> is <value>iterate</value> .</step>
        <step>Return ? IteratorClose ( <id>iteratorRecord</id> , <id>status</id> ).</step>
      </step-list></step>
    </step-list></step>
    <step>Let <id>result</id> be the result of evaluating <id>stmt</id> .</step>
    <step>Set the running execution context 's LexicalEnvironment to <id>oldEnv</id> .</step>
    <step>If LoopContinues ( <id>result</id> , <id>labelSet</id> ) is <value>false</value> , then     <step-list>
      <step>If <id>iterationKind</id> is <value>enumerate</value> , then       <step-list>
        <step>Return Completion ( UpdateEmpty ( <id>result</id> , <id>V</id> )).</step>
      </step-list></step>
      <step>Else,       <step-list>
        <step>Assert : <id>iterationKind</id> is <value>iterate</value> .</step>
        <step>Set <id>status</id> to UpdateEmpty ( <id>result</id> , <id>V</id> ).</step>
        <step>If <id>iteratorKind</id> is <value>async</value> , return ? AsyncIteratorClose ( <id>iteratorRecord</id> , <id>status</id> ).</step>
        <step>Return ? IteratorClose ( <id>iteratorRecord</id> , <id>status</id> ).</step>
      </step-list></step>
    </step-list></step>
    <step>If <id>result</id> .[[Value]] is not <value>empty</value> , set <id>V</id> to <id>result</id> .[[Value]].</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>bindingId</id> be StringValue of BindingIdentifier .</step>
  <step>Return ? ResolveBinding ( <id>bindingId</id> ).</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>O</id> ) is Object.</step>
  <step>Return an Iterator object ( 25.1.1.2 ) whose <value>next</value> method iterates over all the String-valued keys of enumerable properties of <id>O</id> .
 The iterator object is never directly accessible to ECMAScript code. 
The mechanics and order of enumerating the properties is not specified 
but must conform to the rules specified below.</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If the StringValue of LabelIdentifier is not an element of <id>iterationSet</id> , return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return Completion { [[Type]]: <value>continue</value> , [[Value]]: <value>empty</value> , [[Target]]: <value>empty</value> }.</step>
</step-list>
<step-list>
  <step>Let <id>label</id> be the StringValue of LabelIdentifier .</step>
  <step>Return Completion { [[Type]]: <value>continue</value> , [[Value]]: <value>empty</value> , [[Target]]: <id>label</id> }.</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If the StringValue of LabelIdentifier is not an element of <id>labelSet</id> , return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return Completion { [[Type]]: <value>break</value> , [[Value]]: <value>empty</value> , [[Target]]: <value>empty</value> }.</step>
</step-list>
<step-list>
  <step>Let <id>label</id> be the StringValue of LabelIdentifier .</step>
  <step>Return Completion { [[Type]]: <value>break</value> , [[Value]]: <value>empty</value> , [[Target]]: <id>label</id> }.</step>
</step-list>
<step-list>
  <step>Return Completion { [[Type]]: <value>return</value> , [[Value]]: <value>undefined</value> , [[Target]]: <value>empty</value> }.</step>
</step-list>
<step-list>
  <step>Let <id>exprRef</id> be the result of evaluating Expression .</step>
  <step>Let <id>exprValue</id> be ? GetValue ( <id>exprRef</id> ).</step>
  <step>If ! GetGeneratorKind () is <value>async</value> , set <id>exprValue</id> to ? Await ( <id>exprValue</id> ).</step>
  <step>Return Completion { [[Type]]: <value>return</value> , [[Value]]: <id>exprValue</id> , [[Target]]: <value>empty</value> }.</step>
</step-list>
<step-list>
  <step>Return ContainsDuplicateLabels of Statement with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Return ContainsUndefinedBreakTarget of Statement with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Return ContainsUndefinedContinueTarget of Statement with arguments <id>iterationSet</id> and « ».</step>
</step-list>
<step-list>
  <step>Return the VarDeclaredNames of Statement .</step>
</step-list>
<step-list>
  <step>Return the VarScopedDeclarations of Statement .</step>
</step-list>
<step-list>
  <step>Let <id>val</id> be the result of evaluating Expression .</step>
  <step>Let <id>obj</id> be ? ToObject (? GetValue ( <id>val</id> )).</step>
  <step>Let <id>oldEnv</id> be the running execution context 's LexicalEnvironment.</step>
  <step>Let <id>newEnv</id> be NewObjectEnvironment ( <id>obj</id> , <id>oldEnv</id> ).</step>
  <step>Set the <id>withEnvironment</id> flag of <id>newEnv</id> 's EnvironmentRecord to <value>true</value> .</step>
  <step>Set the running execution context 's LexicalEnvironment to <id>newEnv</id> .</step>
  <step>Let <id>C</id> be the result of evaluating Statement .</step>
  <step>Set the running execution context 's LexicalEnvironment to <id>oldEnv</id> .</step>
  <step>Return Completion ( UpdateEmpty ( <id>C</id> , <value>undefined</value> )).</step>
</step-list>
<step-list>
  <step>Return ContainsDuplicateLabels of CaseBlock with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If the first CaseClauses is present, then   <step-list>
    <step>Let <id>hasDuplicates</id> be ContainsDuplicateLabels of the first CaseClauses with argument <id>labelSet</id> .</step>
    <step>If <id>hasDuplicates</id> is <value>true</value> , return <value>true</value> .</step>
  </step-list></step>
  <step>Let <id>hasDuplicates</id> be ContainsDuplicateLabels of DefaultClause with argument <id>labelSet</id> .</step>
  <step>If <id>hasDuplicates</id> is <value>true</value> , return <value>true</value> .</step>
  <step>If the second CaseClauses is not present, return <value>false</value> .</step>
  <step>Return ContainsDuplicateLabels of the second CaseClauses with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Let <id>hasDuplicates</id> be ContainsDuplicateLabels of CaseClauses with argument <id>labelSet</id> .</step>
  <step>If <id>hasDuplicates</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return ContainsDuplicateLabels of CaseClause with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>If the StatementList is present, return ContainsDuplicateLabels of StatementList with argument <id>labelSet</id> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If the StatementList is present, return ContainsDuplicateLabels of StatementList with argument <id>labelSet</id> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return ContainsUndefinedBreakTarget of CaseBlock with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If the first CaseClauses is present, then   <step-list>
    <step>Let <id>hasUndefinedLabels</id> be ContainsUndefinedBreakTarget of the first CaseClauses with argument <id>labelSet</id> .</step>
    <step>If <id>hasUndefinedLabels</id> is <value>true</value> , return <value>true</value> .</step>
  </step-list></step>
  <step>Let <id>hasUndefinedLabels</id> be ContainsUndefinedBreakTarget of DefaultClause with argument <id>labelSet</id> .</step>
  <step>If <id>hasUndefinedLabels</id> is <value>true</value> , return <value>true</value> .</step>
  <step>If the second CaseClauses is not present, return <value>false</value> .</step>
  <step>Return ContainsUndefinedBreakTarget of the second CaseClauses with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Let <id>hasUndefinedLabels</id> be ContainsUndefinedBreakTarget of CaseClauses with argument <id>labelSet</id> .</step>
  <step>If <id>hasUndefinedLabels</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return ContainsUndefinedBreakTarget of CaseClause with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>If the StatementList is present, return ContainsUndefinedBreakTarget of StatementList with argument <id>labelSet</id> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If the StatementList is present, return ContainsUndefinedBreakTarget of StatementList with argument <id>labelSet</id> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return ContainsUndefinedContinueTarget of CaseBlock with arguments <id>iterationSet</id> and « ».</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If the first CaseClauses is present, then   <step-list>
    <step>Let <id>hasUndefinedLabels</id> be ContainsUndefinedContinueTarget of the first CaseClauses with arguments <id>iterationSet</id> and « ».</step>
    <step>If <id>hasUndefinedLabels</id> is <value>true</value> , return <value>true</value> .</step>
  </step-list></step>
  <step>Let <id>hasUndefinedLabels</id> be ContainsUndefinedContinueTarget of DefaultClause with arguments <id>iterationSet</id> and « ».</step>
  <step>If <id>hasUndefinedLabels</id> is <value>true</value> , return <value>true</value> .</step>
  <step>If the second CaseClauses is not present, return <value>false</value> .</step>
  <step>Return ContainsUndefinedContinueTarget of the second CaseClauses with arguments <id>iterationSet</id> and « ».</step>
</step-list>
<step-list>
  <step>Let <id>hasUndefinedLabels</id> be ContainsUndefinedContinueTarget of CaseClauses with arguments <id>iterationSet</id> and « ».</step>
  <step>If <id>hasUndefinedLabels</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return ContainsUndefinedContinueTarget of CaseClause with arguments <id>iterationSet</id> and « ».</step>
</step-list>
<step-list>
  <step>If the StatementList is present, return ContainsUndefinedContinueTarget of StatementList with arguments <id>iterationSet</id> and « ».</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If the StatementList is present, return ContainsUndefinedContinueTarget of StatementList with arguments <id>iterationSet</id> and « ».</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>If the first CaseClauses is present, let <id>names</id> be the LexicallyDeclaredNames of the first CaseClauses .</step>
  <step>Else, let <id>names</id> be a new empty List .</step>
  <step>Append to <id>names</id> the elements of the LexicallyDeclaredNames of the DefaultClause .</step>
  <step>If the second CaseClauses is not present, return <id>names</id> .</step>
  <step>Return the result of appending to <id>names</id> the elements of the LexicallyDeclaredNames of the second CaseClauses .</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be LexicallyDeclaredNames of CaseClauses .</step>
  <step>Append to <id>names</id> the elements of the LexicallyDeclaredNames of CaseClause .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>If the StatementList is present, return the LexicallyDeclaredNames of StatementList .</step>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>If the StatementList is present, return the LexicallyDeclaredNames of StatementList .</step>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>If the first CaseClauses is present, let <id>declarations</id> be the LexicallyScopedDeclarations of the first CaseClauses .</step>
  <step>Else, let <id>declarations</id> be a new empty List .</step>
  <step>Append to <id>declarations</id> the elements of the LexicallyScopedDeclarations of the DefaultClause .</step>
  <step>If the second CaseClauses is not present, return <id>declarations</id> .</step>
  <step>Return the result of appending to <id>declarations</id> the elements of the LexicallyScopedDeclarations of the second CaseClauses .</step>
</step-list>
<step-list>
  <step>Let <id>declarations</id> be LexicallyScopedDeclarations of CaseClauses .</step>
  <step>Append to <id>declarations</id> the elements of the LexicallyScopedDeclarations of CaseClause .</step>
  <step>Return <id>declarations</id> .</step>
</step-list>
<step-list>
  <step>If the StatementList is present, return the LexicallyScopedDeclarations of StatementList .</step>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>If the StatementList is present, return the LexicallyScopedDeclarations of StatementList .</step>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return the VarDeclaredNames of CaseBlock .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>If the first CaseClauses is present, let <id>names</id> be the VarDeclaredNames of the first CaseClauses .</step>
  <step>Else, let <id>names</id> be a new empty List .</step>
  <step>Append to <id>names</id> the elements of the VarDeclaredNames of the DefaultClause .</step>
  <step>If the second CaseClauses is not present, return <id>names</id> .</step>
  <step>Return the result of appending to <id>names</id> the elements of the VarDeclaredNames of the second CaseClauses .</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be VarDeclaredNames of CaseClauses .</step>
  <step>Append to <id>names</id> the elements of the VarDeclaredNames of CaseClause .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>If the StatementList is present, return the VarDeclaredNames of StatementList .</step>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>If the StatementList is present, return the VarDeclaredNames of StatementList .</step>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return the VarScopedDeclarations of CaseBlock .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>If the first CaseClauses is present, let <id>declarations</id> be the VarScopedDeclarations of the first CaseClauses .</step>
  <step>Else, let <id>declarations</id> be a new empty List .</step>
  <step>Append to <id>declarations</id> the elements of the VarScopedDeclarations of the DefaultClause .</step>
  <step>If the second CaseClauses is not present, return <id>declarations</id> .</step>
  <step>Return the result of appending to <id>declarations</id> the elements of the VarScopedDeclarations of the second CaseClauses .</step>
</step-list>
<step-list>
  <step>Let <id>declarations</id> be VarScopedDeclarations of CaseClauses .</step>
  <step>Append to <id>declarations</id> the elements of the VarScopedDeclarations of CaseClause .</step>
  <step>Return <id>declarations</id> .</step>
</step-list>
<step-list>
  <step>If the StatementList is present, return the VarScopedDeclarations of StatementList .</step>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>If the StatementList is present, return the VarScopedDeclarations of StatementList .</step>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return NormalCompletion ( <value>undefined</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>V</id> be <value>undefined</value> .</step>
  <step>Let <id>A</id> be the List of CaseClause items in CaseClauses , in source text order.</step>
  <step>Let <id>found</id> be <value>false</value> .</step>
  <step>For each CaseClause  <id>C</id> in <id>A</id> , do   <step-list>
    <step>If <id>found</id> is <value>false</value> , then     <step-list>
      <step>Set <id>found</id> to ? CaseClauseIsSelected ( <id>C</id> , <id>input</id> ).</step>
    </step-list></step>
    <step>If <id>found</id> is <value>true</value> , then     <step-list>
      <step>Let <id>R</id> be the result of evaluating <id>C</id> .</step>
      <step>If <id>R</id> .[[Value]] is not <value>empty</value> , set <id>V</id> to <id>R</id> .[[Value]].</step>
      <step>If <id>R</id> is an abrupt completion , return Completion ( UpdateEmpty ( <id>R</id> , <id>V</id> )).</step>
    </step-list></step>
  </step-list></step>
  <step>Return NormalCompletion ( <id>V</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>V</id> be <value>undefined</value> .</step>
  <step>If the first CaseClauses is present, then   <step-list>
    <step>Let <id>A</id> be the List of CaseClause items in the first CaseClauses , in source text order.</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>A</id> be « ».</step>
  </step-list></step>
  <step>Let <id>found</id> be <value>false</value> .</step>
  <step>For each CaseClause  <id>C</id> in <id>A</id> , do   <step-list>
    <step>If <id>found</id> is <value>false</value> , then     <step-list>
      <step>Set <id>found</id> to ? CaseClauseIsSelected ( <id>C</id> , <id>input</id> ).</step>
    </step-list></step>
    <step>If <id>found</id> is <value>true</value> , then     <step-list>
      <step>Let <id>R</id> be the result of evaluating <id>C</id> .</step>
      <step>If <id>R</id> .[[Value]] is not <value>empty</value> , set <id>V</id> to <id>R</id> .[[Value]].</step>
      <step>If <id>R</id> is an abrupt completion , return Completion ( UpdateEmpty ( <id>R</id> , <id>V</id> )).</step>
    </step-list></step>
  </step-list></step>
  <step>Let <id>foundInB</id> be <value>false</value> .</step>
  <step>If the second CaseClauses is present, then   <step-list>
    <step>Let <id>B</id> be the List of CaseClause items in the second CaseClauses , in source text order.</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>B</id> be « ».</step>
  </step-list></step>
  <step>If <id>found</id> is <value>false</value> , then   <step-list>
    <step>For each CaseClause  <id>C</id> in <id>B</id> , do     <step-list>
      <step>If <id>foundInB</id> is <value>false</value> , then       <step-list>
        <step>Set <id>foundInB</id> to ? CaseClauseIsSelected ( <id>C</id> , <id>input</id> ).</step>
      </step-list></step>
      <step>If <id>foundInB</id> is <value>true</value> , then       <step-list>
        <step>Let <id>R</id> be the result of evaluating CaseClause  <id>C</id> .</step>
        <step>If <id>R</id> .[[Value]] is not <value>empty</value> , set <id>V</id> to <id>R</id> .[[Value]].</step>
        <step>If <id>R</id> is an abrupt completion , return Completion ( UpdateEmpty ( <id>R</id> , <id>V</id> )).</step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
  <step>If <id>foundInB</id> is <value>true</value> , return NormalCompletion ( <id>V</id> ).</step>
  <step>Let <id>R</id> be the result of evaluating DefaultClause .</step>
  <step>If <id>R</id> .[[Value]] is not <value>empty</value> , set <id>V</id> to <id>R</id> .[[Value]].</step>
  <step>If <id>R</id> is an abrupt completion , return Completion ( UpdateEmpty ( <id>R</id> , <id>V</id> )).</step>
  <step>For each CaseClause  <id>C</id> in <id>B</id> (NOTE: this is another complete iteration of the second CaseClauses ), do   <step-list>
    <step>Let <id>R</id> be the result of evaluating CaseClause  <id>C</id> .</step>
    <step>If <id>R</id> .[[Value]] is not <value>empty</value> , set <id>V</id> to <id>R</id> .[[Value]].</step>
    <step>If <id>R</id> is an abrupt completion , return Completion ( UpdateEmpty ( <id>R</id> , <id>V</id> )).</step>
  </step-list></step>
  <step>Return NormalCompletion ( <id>V</id> ).</step>
</step-list>
<step-list>
  <step>Assert : <id>C</id> is an instance of the production CaseClause:caseExpression:StatementList .</step>
  <step>Let <id>exprRef</id> be the result of evaluating the Expression of <id>C</id> .</step>
  <step>Let <id>clauseSelector</id> be ? GetValue ( <id>exprRef</id> ).</step>
  <step>Return the result of performing Strict Equality Comparison  <id>input</id> === <id>clauseSelector</id> .</step>
</step-list>
<step-list>
  <step>Let <id>exprRef</id> be the result of evaluating Expression .</step>
  <step>Let <id>switchValue</id> be ? GetValue ( <id>exprRef</id> ).</step>
  <step>Let <id>oldEnv</id> be the running execution context 's LexicalEnvironment.</step>
  <step>Let <id>blockEnv</id> be NewDeclarativeEnvironment ( <id>oldEnv</id> ).</step>
  <step>Perform BlockDeclarationInstantiation ( CaseBlock , <id>blockEnv</id> ).</step>
  <step>Set the running execution context 's LexicalEnvironment to <id>blockEnv</id> .</step>
  <step>Let <id>R</id> be the result of performing CaseBlockEvaluation of CaseBlock with argument <id>switchValue</id> .</step>
  <step>Set the running execution context 's LexicalEnvironment to <id>oldEnv</id> .</step>
  <step>Return <id>R</id> .</step>
</step-list>
<step-list>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Return the result of evaluating StatementList .</step>
</step-list>
<step-list>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Return the result of evaluating StatementList .</step>
</step-list>
<step-list>
  <step>Let <id>label</id> be the StringValue of LabelIdentifier .</step>
  <step>If <id>label</id> is an element of <id>labelSet</id> , return <value>true</value> .</step>
  <step>Let <id>newLabelSet</id> be a copy of <id>labelSet</id> with <id>label</id> appended.</step>
  <step>Return ContainsDuplicateLabels of LabelledItem with argument <id>newLabelSet</id> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>label</id> be the StringValue of LabelIdentifier .</step>
  <step>Let <id>newLabelSet</id> be a copy of <id>labelSet</id> with <id>label</id> appended.</step>
  <step>Return ContainsUndefinedBreakTarget of LabelledItem with argument <id>newLabelSet</id> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>label</id> be the StringValue of LabelIdentifier .</step>
  <step>Let <id>newLabelSet</id> be a copy of <id>labelSet</id> with <id>label</id> appended.</step>
  <step>Return ContainsUndefinedContinueTarget of LabelledItem with arguments <id>iterationSet</id> and <id>newLabelSet</id> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If <id>stmt</id> is not a LabelledStatement , return <value>false</value> .</step>
  <step>Let <id>item</id> be the LabelledItem of <id>stmt</id> .</step>
  <step>If <id>item</id> is LabelledItem:FunctionDeclaration , return <value>true</value> .</step>
  <step>Let <id>subStmt</id> be the Statement of <id>item</id> .</step>
  <step>Return IsLabelledFunction ( <id>subStmt</id> ).</step>
</step-list>
<step-list>
  <step>Return the LexicallyDeclaredNames of LabelledItem .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return BoundNames of FunctionDeclaration .</step>
</step-list>
<step-list>
  <step>Return the LexicallyScopedDeclarations of LabelledItem .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return a new List containing FunctionDeclaration .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return the TopLevelVarDeclaredNames of LabelledItem .</step>
</step-list>
<step-list>
  <step>If Statement is Statement:LabelledStatement , return TopLevelVarDeclaredNames of Statement .</step>
  <step>Return VarDeclaredNames of Statement .</step>
</step-list>
<step-list>
  <step>Return BoundNames of FunctionDeclaration .</step>
</step-list>
<step-list>
  <step>Return the TopLevelVarScopedDeclarations of LabelledItem .</step>
</step-list>
<step-list>
  <step>If Statement is Statement:LabelledStatement , return TopLevelVarScopedDeclarations of Statement .</step>
  <step>Return VarScopedDeclarations of Statement .</step>
</step-list>
<step-list>
  <step>Return a new List containing FunctionDeclaration .</step>
</step-list>
<step-list>
  <step>Return the VarDeclaredNames of LabelledItem .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return the VarScopedDeclarations of LabelledItem .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Let <id>label</id> be the StringValue of LabelIdentifier .</step>
  <step>Append <id>label</id> as an element of <id>labelSet</id> .</step>
  <step>Let <id>stmtResult</id> be LabelledEvaluation of LabelledItem with argument <id>labelSet</id> .</step>
  <step>If <id>stmtResult</id> .[[Type]] is <value>break</value> and SameValue ( <id>stmtResult</id> .[[Target]], <id>label</id> ) is <value>true</value> , then   <step-list>
    <step>Set <id>stmtResult</id> to NormalCompletion ( <id>stmtResult</id> .[[Value]]).</step>
  </step-list></step>
  <step>Return Completion ( <id>stmtResult</id> ).</step>
</step-list>
<step-list>
  <step>If Statement is either a LabelledStatement or a BreakableStatement , then   <step-list>
    <step>Return LabelledEvaluation of Statement with argument <id>labelSet</id> .</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Return the result of evaluating Statement .</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Return the result of evaluating FunctionDeclaration .</step>
</step-list>
<step-list>
  <step>Let <id>newLabelSet</id> be a new empty List .</step>
  <step>Return LabelledEvaluation of this LabelledStatement with argument <id>newLabelSet</id> .</step>
</step-list>
<step-list>
  <step>Let <id>exprRef</id> be the result of evaluating Expression .</step>
  <step>Let <id>exprValue</id> be ? GetValue ( <id>exprRef</id> ).</step>
  <step>Return ThrowCompletion ( <id>exprValue</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>hasDuplicates</id> be ContainsDuplicateLabels of Block with argument <id>labelSet</id> .</step>
  <step>If <id>hasDuplicates</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return ContainsDuplicateLabels of Catch with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Let <id>hasDuplicates</id> be ContainsDuplicateLabels of Block with argument <id>labelSet</id> .</step>
  <step>If <id>hasDuplicates</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return ContainsDuplicateLabels of Finally with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Let <id>hasDuplicates</id> be ContainsDuplicateLabels of Block with argument <id>labelSet</id> .</step>
  <step>If <id>hasDuplicates</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Let <id>hasDuplicates</id> be ContainsDuplicateLabels of Catch with argument <id>labelSet</id> .</step>
  <step>If <id>hasDuplicates</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return ContainsDuplicateLabels of Finally with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Return ContainsDuplicateLabels of Block with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Let <id>hasUndefinedLabels</id> be ContainsUndefinedBreakTarget of Block with argument <id>labelSet</id> .</step>
  <step>If <id>hasUndefinedLabels</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return ContainsUndefinedBreakTarget of Catch with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Let <id>hasUndefinedLabels</id> be ContainsUndefinedBreakTarget of Block with argument <id>labelSet</id> .</step>
  <step>If <id>hasUndefinedLabels</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return ContainsUndefinedBreakTarget of Finally with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Let <id>hasUndefinedLabels</id> be ContainsUndefinedBreakTarget of Block with argument <id>labelSet</id> .</step>
  <step>If <id>hasUndefinedLabels</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Let <id>hasUndefinedLabels</id> be ContainsUndefinedBreakTarget of Catch with argument <id>labelSet</id> .</step>
  <step>If <id>hasUndefinedLabels</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return ContainsUndefinedBreakTarget of Finally with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Return ContainsUndefinedBreakTarget of Block with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Let <id>hasUndefinedLabels</id> be ContainsUndefinedContinueTarget of Block with arguments <id>iterationSet</id> and « ».</step>
  <step>If <id>hasUndefinedLabels</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return ContainsUndefinedContinueTarget of Catch with arguments <id>iterationSet</id> and « ».</step>
</step-list>
<step-list>
  <step>Let <id>hasUndefinedLabels</id> be ContainsUndefinedContinueTarget of Block with arguments <id>iterationSet</id> and « ».</step>
  <step>If <id>hasUndefinedLabels</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return ContainsUndefinedContinueTarget of Finally with arguments <id>iterationSet</id> and « ».</step>
</step-list>
<step-list>
  <step>Let <id>hasUndefinedLabels</id> be ContainsUndefinedContinueTarget of Block with arguments <id>iterationSet</id> and « ».</step>
  <step>If <id>hasUndefinedLabels</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Let <id>hasUndefinedLabels</id> be ContainsUndefinedContinueTarget of Catch with arguments <id>iterationSet</id> and « ».</step>
  <step>If <id>hasUndefinedLabels</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return ContainsUndefinedContinueTarget of Finally with arguments <id>iterationSet</id> and « ».</step>
</step-list>
<step-list>
  <step>Return ContainsUndefinedContinueTarget of Block with arguments <id>iterationSet</id> and « ».</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be VarDeclaredNames of Block .</step>
  <step>Append to <id>names</id> the elements of the VarDeclaredNames of Catch .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be VarDeclaredNames of Block .</step>
  <step>Append to <id>names</id> the elements of the VarDeclaredNames of Finally .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be VarDeclaredNames of Block .</step>
  <step>Append to <id>names</id> the elements of the VarDeclaredNames of Catch .</step>
  <step>Append to <id>names</id> the elements of the VarDeclaredNames of Finally .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>Return the VarDeclaredNames of Block .</step>
</step-list>
<step-list>
  <step>Let <id>declarations</id> be VarScopedDeclarations of Block .</step>
  <step>Append to <id>declarations</id> the elements of the VarScopedDeclarations of Catch .</step>
  <step>Return <id>declarations</id> .</step>
</step-list>
<step-list>
  <step>Let <id>declarations</id> be VarScopedDeclarations of Block .</step>
  <step>Append to <id>declarations</id> the elements of the VarScopedDeclarations of Finally .</step>
  <step>Return <id>declarations</id> .</step>
</step-list>
<step-list>
  <step>Let <id>declarations</id> be VarScopedDeclarations of Block .</step>
  <step>Append to <id>declarations</id> the elements of the VarScopedDeclarations of Catch .</step>
  <step>Append to <id>declarations</id> the elements of the VarScopedDeclarations of Finally .</step>
  <step>Return <id>declarations</id> .</step>
</step-list>
<step-list>
  <step>Return the VarScopedDeclarations of Block .</step>
</step-list>
<step-list>
  <step>Let <id>oldEnv</id> be the running execution context 's LexicalEnvironment.</step>
  <step>Let <id>catchEnv</id> be NewDeclarativeEnvironment ( <id>oldEnv</id> ).</step>
  <step>Let <id>catchEnvRec</id> be <id>catchEnv</id> 's EnvironmentRecord .</step>
  <step>For each element <id>argName</id> of the BoundNames of CatchParameter , do   <step-list>
    <step>Perform ! <id>catchEnvRec</id> .CreateMutableBinding( <id>argName</id> , <value>false</value> ).</step>
  </step-list></step>
  <step>Set the running execution context 's LexicalEnvironment to <id>catchEnv</id> .</step>
  <step>Let <id>status</id> be the result of performing BindingInitialization for CatchParameter passing <id>thrownValue</id> and <id>catchEnv</id> as arguments.</step>
  <step>If <id>status</id> is an abrupt completion , then   <step-list>
    <step>Set the running execution context 's LexicalEnvironment to <id>oldEnv</id> .</step>
    <step>Return Completion ( <id>status</id> ).</step>
  </step-list></step>
  <step>Let <id>B</id> be the result of evaluating Block .</step>
  <step>Set the running execution context 's LexicalEnvironment to <id>oldEnv</id> .</step>
  <step>Return Completion ( <id>B</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>B</id> be the result of evaluating Block .</step>
  <step>If <id>B</id> .[[Type]] is <value>throw</value> , let <id>C</id> be CatchClauseEvaluation of Catch with argument <id>B</id> .[[Value]].</step>
  <step>Else, let <id>C</id> be <id>B</id> .</step>
  <step>Return Completion ( UpdateEmpty ( <id>C</id> , <value>undefined</value> )).</step>
</step-list>
<step-list>
  <step>Let <id>B</id> be the result of evaluating Block .</step>
  <step>Let <id>F</id> be the result of evaluating Finally .</step>
  <step>If <id>F</id> .[[Type]] is <value>normal</value> , set <id>F</id> to <id>B</id> .</step>
  <step>Return Completion ( UpdateEmpty ( <id>F</id> , <value>undefined</value> )).</step>
</step-list>
<step-list>
  <step>Let <id>B</id> be the result of evaluating Block .</step>
  <step>If <id>B</id> .[[Type]] is <value>throw</value> , let <id>C</id> be CatchClauseEvaluation of Catch with argument <id>B</id> .[[Value]].</step>
  <step>Else, let <id>C</id> be <id>B</id> .</step>
  <step>Let <id>F</id> be the result of evaluating Finally .</step>
  <step>If <id>F</id> .[[Type]] is <value>normal</value> , set <id>F</id> to <id>C</id> .</step>
  <step>Return Completion ( UpdateEmpty ( <id>F</id> , <value>undefined</value> )).</step>
</step-list>
<step-list>
  <step>If an implementation-defined debugging facility is available and enabled, then   <step-list>
    <step>Perform an implementation-defined debugging action.</step>
    <step>Let <id>result</id> be an implementation-defined Completion value.</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>result</id> be NormalCompletion ( <value>empty</value> ).</step>
  </step-list></step>
  <step>Return <id>result</id> .</step>
</step-list>
<step-list>
  <step>Return the BoundNames of BindingIdentifier .</step>
</step-list>
<step-list>
  <step>Return « <value>"*default*"</value> ».</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be BoundNames of FormalParameterList .</step>
  <step>Append to <id>names</id> the BoundNames of FunctionRestParameter .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be BoundNames of FormalParameterList .</step>
  <step>Append to <id>names</id> the BoundNames of FormalParameter .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If ContainsExpression of FormalParameterList is <value>true</value> , return <value>true</value> .</step>
  <step>Return ContainsExpression of FunctionRestParameter .</step>
</step-list>
<step-list>
  <step>If ContainsExpression of FormalParameterList is <value>true</value> , return <value>true</value> .</step>
  <step>Return ContainsExpression of FormalParameter .</step>
</step-list>
<step-list>
  <step>If the Directive Prologue of FunctionStatementList contains a Use Strict Directive , return <value>true</value> ; otherwise, return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return 0.</step>
</step-list>
<step-list>
  <step>Return ExpectedArgumentCount of FormalParameterList .</step>
</step-list>
<step-list>
  <step>Let <id>count</id> be ExpectedArgumentCount of FormalParameterList .</step>
  <step>If HasInitializer of FormalParameterList is <value>true</value> or HasInitializer of FormalParameter is <value>true</value> , return <id>count</id> .</step>
  <step>Return <id>count</id> + 1.</step>
</step-list>
<step-list>
  <step>If HasInitializer of FormalParameterList is <value>true</value> , return <value>true</value> .</step>
  <step>Return HasInitializer of FormalParameter .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>If IsFunctionDefinition of <id>expr</id> is <value>false</value> , return <value>false</value> .</step>
  <step>Let <id>hasName</id> be the result of HasName of <id>expr</id> .</step>
  <step>If <id>hasName</id> is <value>true</value> , return <value>false</value> .</step>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If IsSimpleParameterList of FormalParameterList is <value>false</value> , return <value>false</value> .</step>
  <step>Return IsSimpleParameterList of FormalParameter .</step>
</step-list>
<step-list>
  <step>Return IsSimpleParameterList of BindingElement .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return TopLevelLexicallyDeclaredNames of StatementList .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return the TopLevelLexicallyScopedDeclarations of StatementList .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return TopLevelVarDeclaredNames of StatementList .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return the TopLevelVarScopedDeclarations of StatementList .</step>
</step-list>
<step-list>
  <step>Perform ? FunctionDeclarationInstantiation ( <id>functionObject</id> , <id>argumentsList</id> ).</step>
  <step>Return the result of evaluating FunctionStatementList .</step>
</step-list>
<step-list>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Perform ? IteratorBindingInitialization for FormalParameterList using <id>iteratorRecord</id> and <id>environment</id> as the arguments.</step>
  <step>Return the result of performing IteratorBindingInitialization for FunctionRestParameter using <id>iteratorRecord</id> and <id>environment</id> as the arguments.</step>
</step-list>
<step-list>
  <step>Perform ? IteratorBindingInitialization for FormalParameterList using <id>iteratorRecord</id> and <id>environment</id> as the arguments.</step>
  <step>Return the result of performing IteratorBindingInitialization for FormalParameter using <id>iteratorRecord</id> and <id>environment</id> as the arguments.</step>
</step-list>
<step-list>
  <step>If ContainsExpression of BindingElement is <value>false</value> , return the result of performing IteratorBindingInitialization for BindingElement using <id>iteratorRecord</id> and <id>environment</id> as the arguments.</step>
  <step>Let <id>currentContext</id> be the running execution context .</step>
  <step>Let <id>originalEnv</id> be the VariableEnvironment of <id>currentContext</id> .</step>
  <step>Assert : The VariableEnvironment and LexicalEnvironment of <id>currentContext</id> are the same.</step>
  <step>Assert : <id>environment</id> and <id>originalEnv</id> are the same.</step>
  <step>Let <id>paramVarEnv</id> be NewDeclarativeEnvironment ( <id>originalEnv</id> ).</step>
  <step>Set the VariableEnvironment of <id>currentContext</id> to <id>paramVarEnv</id> .</step>
  <step>Set the LexicalEnvironment of <id>currentContext</id> to <id>paramVarEnv</id> .</step>
  <step>Let <id>result</id> be the result of performing IteratorBindingInitialization for BindingElement using <id>iteratorRecord</id> and <id>environment</id> as the arguments.</step>
  <step>Set the VariableEnvironment of <id>currentContext</id> to <id>originalEnv</id> .</step>
  <step>Set the LexicalEnvironment of <id>currentContext</id> to <id>originalEnv</id> .</step>
  <step>Return <id>result</id> .</step>
</step-list>
<step-list>
  <step>If ContainsExpression of BindingRestElement is <value>false</value> , return the result of performing IteratorBindingInitialization for BindingRestElement using <id>iteratorRecord</id> and <id>environment</id> as the arguments.</step>
  <step>Let <id>currentContext</id> be the running execution context .</step>
  <step>Let <id>originalEnv</id> be the VariableEnvironment of <id>currentContext</id> .</step>
  <step>Assert : The VariableEnvironment and LexicalEnvironment of <id>currentContext</id> are the same.</step>
  <step>Assert : <id>environment</id> and <id>originalEnv</id> are the same.</step>
  <step>Let <id>paramVarEnv</id> be NewDeclarativeEnvironment ( <id>originalEnv</id> ).</step>
  <step>Set the VariableEnvironment of <id>currentContext</id> to <id>paramVarEnv</id> .</step>
  <step>Set the LexicalEnvironment of <id>currentContext</id> to <id>paramVarEnv</id> .</step>
  <step>Let <id>result</id> be the result of performing IteratorBindingInitialization for BindingRestElement using <id>iteratorRecord</id> and <id>environment</id> as the arguments.</step>
  <step>Set the VariableEnvironment of <id>currentContext</id> to <id>originalEnv</id> .</step>
  <step>Set the LexicalEnvironment of <id>currentContext</id> to <id>originalEnv</id> .</step>
  <step>Return <id>result</id> .</step>
</step-list>
<step-list>
  <step>If the function code for FunctionDeclaration is strict mode code , let <id>strict</id> be <value>true</value> . Otherwise let <id>strict</id> be <value>false</value> .</step>
  <step>Let <id>name</id> be StringValue of BindingIdentifier .</step>
  <step>Let <id>F</id> be FunctionCreate ( <value>Normal</value> , FormalParameters , FunctionBody , <id>scope</id> , <id>strict</id> ).</step>
  <step>Perform MakeConstructor ( <id>F</id> ).</step>
  <step>Perform SetFunctionName ( <id>F</id> , <id>name</id> ).</step>
  <step>Return <id>F</id> .</step>
</step-list>
<step-list>
  <step>Let <id>F</id> be FunctionCreate ( <value>Normal</value> , FormalParameters , FunctionBody , <id>scope</id> , <value>true</value> ).</step>
  <step>Perform MakeConstructor ( <id>F</id> ).</step>
  <step>Perform SetFunctionName ( <id>F</id> , <value>"default"</value> ).</step>
  <step>Return <id>F</id> .</step>
</step-list>
<step-list>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>If the function code for FunctionExpression is strict mode code , let <id>strict</id> be <value>true</value> . Otherwise let <id>strict</id> be <value>false</value> .</step>
  <step>Let <id>scope</id> be the LexicalEnvironment of the running execution context .</step>
  <step>Let <id>closure</id> be FunctionCreate ( <value>Normal</value> , FormalParameters , FunctionBody , <id>scope</id> , <id>strict</id> ).</step>
  <step>Perform MakeConstructor ( <id>closure</id> ).</step>
  <step>Return <id>closure</id> .</step>
</step-list>
<step-list>
  <step>If the function code for FunctionExpression is strict mode code , let <id>strict</id> be <value>true</value> . Otherwise let <id>strict</id> be <value>false</value> .</step>
  <step>Let <id>scope</id> be the running execution context 's LexicalEnvironment.</step>
  <step>Let <id>funcEnv</id> be NewDeclarativeEnvironment ( <id>scope</id> ).</step>
  <step>Let <id>envRec</id> be <id>funcEnv</id> 's EnvironmentRecord .</step>
  <step>Let <id>name</id> be StringValue of BindingIdentifier .</step>
  <step>Perform <id>envRec</id> .CreateImmutableBinding( <id>name</id> , <value>false</value> ).</step>
  <step>Let <id>closure</id> be FunctionCreate ( <value>Normal</value> , FormalParameters , FunctionBody , <id>funcEnv</id> , <id>strict</id> ).</step>
  <step>Perform MakeConstructor ( <id>closure</id> ).</step>
  <step>Perform SetFunctionName ( <id>closure</id> , <id>name</id> ).</step>
  <step>Perform <id>envRec</id> .InitializeBinding( <id>name</id> , <id>closure</id> ).</step>
  <step>Return <id>closure</id> .</step>
</step-list>
<step-list>
  <step>Return NormalCompletion ( <value>undefined</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>formals</id> be CoveredFormalsList of CoverParenthesizedExpressionAndArrowParameterList .</step>
  <step>Return the BoundNames of <id>formals</id> .</step>
</step-list>
<step-list>
  <step>If <id>symbol</id> is not one of NewTarget , SuperProperty , SuperCall , <value>super</value> or <value>this</value> , return <value>false</value> .</step>
  <step>If ArrowParameters Contains <id>symbol</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return ConciseBody Contains <id>symbol</id> .</step>
</step-list>
<step-list>
  <step>Let <id>formals</id> be CoveredFormalsList of CoverParenthesizedExpressionAndArrowParameterList .</step>
  <step>Return <id>formals</id> Contains <id>symbol</id> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return 1.</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Let <id>formals</id> be CoveredFormalsList of CoverParenthesizedExpressionAndArrowParameterList .</step>
  <step>Return IsSimpleParameterList of <id>formals</id> .</step>
</step-list>
<step-list>
  <step>Return this ArrowParameters .</step>
</step-list>
<step-list>
  <step>Return the ArrowFormalParameters that is covered by CoverParenthesizedExpressionAndArrowParameterList .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Assert : <id>iteratorRecord</id> .[[Done]] is <value>false</value> .</step>
  <step>Let <id>next</id> be IteratorStep ( <id>iteratorRecord</id> ).</step>
  <step>If <id>next</id> is an abrupt completion , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
  <step>ReturnIfAbrupt ( <id>next</id> ).</step>
  <step>If <id>next</id> is <value>false</value> , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
  <step>Else,   <step-list>
    <step>Let <id>v</id> be IteratorValue ( <id>next</id> ).</step>
    <step>If <id>v</id> is an abrupt completion , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
    <step>ReturnIfAbrupt ( <id>v</id> ).</step>
  </step-list></step>
  <step>If <id>iteratorRecord</id> .[[Done]] is <value>true</value> , let <id>v</id> be <value>undefined</value> .</step>
  <step>Return the result of performing BindingInitialization for BindingIdentifier using <id>v</id> and <id>environment</id> as the arguments.</step>
</step-list>
<step-list>
  <step>Perform ? FunctionDeclarationInstantiation ( <id>functionObject</id> , <id>argumentsList</id> ).</step>
  <step>Let <id>exprRef</id> be the result of evaluating AssignmentExpression .</step>
  <step>Let <id>exprValue</id> be ? GetValue ( <id>exprRef</id> ).</step>
  <step>Return Completion { [[Type]]: <value>return</value> , [[Value]]: <id>exprValue</id> , [[Target]]: <value>empty</value> }.</step>
</step-list>
<step-list>
  <step>If the function code for this ArrowFunction is strict mode code , let <id>strict</id> be <value>true</value> . Otherwise let <id>strict</id> be <value>false</value> .</step>
  <step>Let <id>scope</id> be the LexicalEnvironment of the running execution context .</step>
  <step>Let <id>parameters</id> be CoveredFormalsList of ArrowParameters .</step>
  <step>Let <id>closure</id> be FunctionCreate ( <value>Arrow</value> , <id>parameters</id> , ConciseBody , <id>scope</id> , <id>strict</id> ).</step>
  <step>Return <id>closure</id> .</step>
</step-list>
<step-list>
  <step>Return the result of ComputedPropertyContains for PropertyName with argument <id>symbol</id> .</step>
</step-list>
<step-list>
  <step>If HasInitializer of FormalParameter is <value>true</value> , return 0.</step>
  <step>Return 1.</step>
</step-list>
<step-list>
  <step>If UniqueFormalParameters Contains SuperCall is <value>true</value> , return <value>true</value> .</step>
  <step>Return FunctionBody Contains SuperCall .</step>
</step-list>
<step-list>
  <step>Return FunctionBody Contains SuperCall .</step>
</step-list>
<step-list>
  <step>If PropertySetParameterList Contains SuperCall is <value>true</value> , return <value>true</value> .</step>
  <step>Return FunctionBody Contains SuperCall .</step>
</step-list>
<step-list>
  <step>Return PropName of PropertyName .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Let <id>propKey</id> be the result of evaluating PropertyName .</step>
  <step>ReturnIfAbrupt ( <id>propKey</id> ).</step>
  <step>If the function code for this MethodDefinition is strict mode code , let <id>strict</id> be <value>true</value> . Otherwise let <id>strict</id> be <value>false</value> .</step>
  <step>Let <id>scope</id> be the running execution context 's LexicalEnvironment.</step>
  <step>If <id>functionPrototype</id> is present as a parameter, then   <step-list>
    <step>Let <id>kind</id> be <value>Normal</value> .</step>
    <step>Let <id>prototype</id> be <id>functionPrototype</id> .</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>kind</id> be <value>Method</value> .</step>
    <step>Let <id>prototype</id> be the intrinsic object %FunctionPrototype% .</step>
  </step-list></step>
  <step>Let <id>closure</id> be FunctionCreate ( <id>kind</id> , UniqueFormalParameters , FunctionBody , <id>scope</id> , <id>strict</id> , <id>prototype</id> ).</step>
  <step>Perform MakeMethod ( <id>closure</id> , <id>object</id> ).</step>
  <step>Return the Record { [[Key]]: <id>propKey</id> , [[Closure]]: <id>closure</id> }.</step>
</step-list>
<step-list>
  <step>Let <id>methodDef</id> be DefineMethod of MethodDefinition with argument <id>object</id> .</step>
  <step>ReturnIfAbrupt ( <id>methodDef</id> ).</step>
  <step>Perform SetFunctionName ( <id>methodDef</id> .[[Closure]], <id>methodDef</id> .[[Key]]).</step>
  <step>Let <id>desc</id> be the PropertyDescriptor { [[Value]]: <id>methodDef</id> .[[Closure]], [[Writable]]: <value>true</value> , [[Enumerable]]: <id>enumerable</id> , [[Configurable]]: <value>true</value> }.</step>
  <step>Return ? DefinePropertyOrThrow ( <id>object</id> , <id>methodDef</id> .[[Key]], <id>desc</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>propKey</id> be the result of evaluating PropertyName .</step>
  <step>ReturnIfAbrupt ( <id>propKey</id> ).</step>
  <step>If the function code for this MethodDefinition is strict mode code , let <id>strict</id> be <value>true</value> . Otherwise let <id>strict</id> be <value>false</value> .</step>
  <step>Let <id>scope</id> be the running execution context 's LexicalEnvironment.</step>
  <step>Let <id>formalParameterList</id> be an instance of the production FormalParameters:[empty] .</step>
  <step>Let <id>closure</id> be FunctionCreate ( <value>Method</value> , <id>formalParameterList</id> , FunctionBody , <id>scope</id> , <id>strict</id> ).</step>
  <step>Perform MakeMethod ( <id>closure</id> , <id>object</id> ).</step>
  <step>Perform SetFunctionName ( <id>closure</id> , <id>propKey</id> , <value>"get"</value> ).</step>
  <step>Let <id>desc</id> be the PropertyDescriptor { [[Get]]: <id>closure</id> , [[Enumerable]]: <id>enumerable</id> , [[Configurable]]: <value>true</value> }.</step>
  <step>Return ? DefinePropertyOrThrow ( <id>object</id> , <id>propKey</id> , <id>desc</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>propKey</id> be the result of evaluating PropertyName .</step>
  <step>ReturnIfAbrupt ( <id>propKey</id> ).</step>
  <step>If the function code for this MethodDefinition is strict mode code , let <id>strict</id> be <value>true</value> . Otherwise let <id>strict</id> be <value>false</value> .</step>
  <step>Let <id>scope</id> be the running execution context 's LexicalEnvironment.</step>
  <step>Let <id>closure</id> be FunctionCreate ( <value>Method</value> , PropertySetParameterList , FunctionBody , <id>scope</id> , <id>strict</id> ).</step>
  <step>Perform MakeMethod ( <id>closure</id> , <id>object</id> ).</step>
  <step>Perform SetFunctionName ( <id>closure</id> , <id>propKey</id> , <value>"set"</value> ).</step>
  <step>Let <id>desc</id> be the PropertyDescriptor { [[Set]]: <id>closure</id> , [[Enumerable]]: <id>enumerable</id> , [[Configurable]]: <value>true</value> }.</step>
  <step>Return ? DefinePropertyOrThrow ( <id>object</id> , <id>propKey</id> , <id>desc</id> ).</step>
</step-list>
<step-list>
  <step>Return the BoundNames of BindingIdentifier .</step>
</step-list>
<step-list>
  <step>Return « <value>"*default*"</value> ».</step>
</step-list>
<step-list>
  <step>Return the result of ComputedPropertyContains for PropertyName with argument <id>symbol</id> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If UniqueFormalParameters Contains SuperCall is <value>true</value> , return <value>true</value> .</step>
  <step>Return GeneratorBody Contains SuperCall .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return PropName of PropertyName .</step>
</step-list>
<step-list>
  <step>Perform ? FunctionDeclarationInstantiation ( <id>functionObject</id> , <id>argumentsList</id> ).</step>
  <step>Let <id>G</id> be ? OrdinaryCreateFromConstructor ( <id>functionObject</id> , <value>"%GeneratorPrototype%"</value> , « [[GeneratorState]], [[GeneratorContext]] »).</step>
  <step>Perform GeneratorStart ( <id>G</id> , FunctionBody ).</step>
  <step>Return Completion { [[Type]]: <value>return</value> , [[Value]]: <id>G</id> , [[Target]]: <value>empty</value> }.</step>
</step-list>
<step-list>
  <step>If the function code for GeneratorDeclaration is strict mode code , let <id>strict</id> be <value>true</value> . Otherwise let <id>strict</id> be <value>false</value> .</step>
  <step>Let <id>name</id> be StringValue of BindingIdentifier .</step>
  <step>Let <id>F</id> be GeneratorFunctionCreate ( <value>Normal</value> , FormalParameters , GeneratorBody , <id>scope</id> , <id>strict</id> ).</step>
  <step>Let <id>prototype</id> be ObjectCreate ( %GeneratorPrototype% ).</step>
  <step>Perform DefinePropertyOrThrow ( <id>F</id> , <value>"prototype"</value> , PropertyDescriptor { [[Value]]: <id>prototype</id> , [[Writable]]: <value>true</value> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>false</value> }).</step>
  <step>Perform SetFunctionName ( <id>F</id> , <id>name</id> ).</step>
  <step>Return <id>F</id> .</step>
</step-list>
<step-list>
  <step>Let <id>F</id> be GeneratorFunctionCreate ( <value>Normal</value> , FormalParameters , GeneratorBody , <id>scope</id> , <value>true</value> ).</step>
  <step>Let <id>prototype</id> be ObjectCreate ( %GeneratorPrototype% ).</step>
  <step>Perform DefinePropertyOrThrow ( <id>F</id> , <value>"prototype"</value> , PropertyDescriptor { [[Value]]: <id>prototype</id> , [[Writable]]: <value>true</value> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>false</value> }).</step>
  <step>Perform SetFunctionName ( <id>F</id> , <value>"default"</value> ).</step>
  <step>Return <id>F</id> .</step>
</step-list>
<step-list>
  <step>Let <id>propKey</id> be the result of evaluating PropertyName .</step>
  <step>ReturnIfAbrupt ( <id>propKey</id> ).</step>
  <step>If the function code for this GeneratorMethod is strict mode code , let <id>strict</id> be <value>true</value> . Otherwise let <id>strict</id> be <value>false</value> .</step>
  <step>Let <id>scope</id> be the running execution context 's LexicalEnvironment.</step>
  <step>Let <id>closure</id> be GeneratorFunctionCreate ( <value>Method</value> , UniqueFormalParameters , GeneratorBody , <id>scope</id> , <id>strict</id> ).</step>
  <step>Perform MakeMethod ( <id>closure</id> , <id>object</id> ).</step>
  <step>Let <id>prototype</id> be ObjectCreate ( %GeneratorPrototype% ).</step>
  <step>Perform DefinePropertyOrThrow ( <id>closure</id> , <value>"prototype"</value> , PropertyDescriptor { [[Value]]: <id>prototype</id> , [[Writable]]: <value>true</value> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>false</value> }).</step>
  <step>Perform SetFunctionName ( <id>closure</id> , <id>propKey</id> ).</step>
  <step>Let <id>desc</id> be the PropertyDescriptor { [[Value]]: <id>closure</id> , [[Writable]]: <value>true</value> , [[Enumerable]]: <id>enumerable</id> , [[Configurable]]: <value>true</value> }.</step>
  <step>Return ? DefinePropertyOrThrow ( <id>object</id> , <id>propKey</id> , <id>desc</id> ).</step>
</step-list>
<step-list>
  <step>If the function code for this GeneratorExpression is strict mode code , let <id>strict</id> be <value>true</value> . Otherwise let <id>strict</id> be <value>false</value> .</step>
  <step>Let <id>scope</id> be the LexicalEnvironment of the running execution context .</step>
  <step>Let <id>closure</id> be GeneratorFunctionCreate ( <value>Normal</value> , FormalParameters , GeneratorBody , <id>scope</id> , <id>strict</id> ).</step>
  <step>Let <id>prototype</id> be ObjectCreate ( %GeneratorPrototype% ).</step>
  <step>Perform DefinePropertyOrThrow ( <id>closure</id> , <value>"prototype"</value> , PropertyDescriptor { [[Value]]: <id>prototype</id> , [[Writable]]: <value>true</value> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>false</value> }).</step>
  <step>Return <id>closure</id> .</step>
</step-list>
<step-list>
  <step>If the function code for this GeneratorExpression is strict mode code , let <id>strict</id> be <value>true</value> . Otherwise let <id>strict</id> be <value>false</value> .</step>
  <step>Let <id>scope</id> be the running execution context 's LexicalEnvironment.</step>
  <step>Let <id>funcEnv</id> be NewDeclarativeEnvironment ( <id>scope</id> ).</step>
  <step>Let <id>envRec</id> be <id>funcEnv</id> 's EnvironmentRecord .</step>
  <step>Let <id>name</id> be StringValue of BindingIdentifier .</step>
  <step>Perform <id>envRec</id> .CreateImmutableBinding( <id>name</id> , <value>false</value> ).</step>
  <step>Let <id>closure</id> be GeneratorFunctionCreate ( <value>Normal</value> , FormalParameters , GeneratorBody , <id>funcEnv</id> , <id>strict</id> ).</step>
  <step>Let <id>prototype</id> be ObjectCreate ( %GeneratorPrototype% ).</step>
  <step>Perform DefinePropertyOrThrow ( <id>closure</id> , <value>"prototype"</value> , PropertyDescriptor { [[Value]]: <id>prototype</id> , [[Writable]]: <value>true</value> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>false</value> }).</step>
  <step>Perform SetFunctionName ( <id>closure</id> , <id>name</id> ).</step>
  <step>Perform <id>envRec</id> .InitializeBinding( <id>name</id> , <id>closure</id> ).</step>
  <step>Return <id>closure</id> .</step>
</step-list>
<step-list>
  <step>Let <id>generatorKind</id> be ! GetGeneratorKind ().</step>
  <step>If <id>generatorKind</id> is <value>async</value> , then return ? AsyncGeneratorYield ( <value>undefined</value> ).</step>
  <step>Otherwise, return ? GeneratorYield ( CreateIterResultObject ( <value>undefined</value> , <value>false</value> )).</step>
</step-list>
<step-list>
  <step>Let <id>generatorKind</id> be ! GetGeneratorKind ().</step>
  <step>Let <id>exprRef</id> be the result of evaluating AssignmentExpression .</step>
  <step>Let <id>value</id> be ? GetValue ( <id>exprRef</id> ).</step>
  <step>If <id>generatorKind</id> is <value>async</value> , then return ? AsyncGeneratorYield ( <id>value</id> ).</step>
  <step>Otherwise, return ? GeneratorYield ( CreateIterResultObject ( <id>value</id> , <value>false</value> )).</step>
</step-list>
<step-list>
  <step>Let <id>generatorKind</id> be ! GetGeneratorKind ().</step>
  <step>Let <id>exprRef</id> be the result of evaluating AssignmentExpression .</step>
  <step>Let <id>value</id> be ? GetValue ( <id>exprRef</id> ).</step>
  <step>Let <id>iteratorRecord</id> be ? GetIterator ( <id>value</id> , <id>generatorKind</id> ).</step>
  <step>Let <id>iterator</id> be <id>iteratorRecord</id> .[[Iterator]].</step>
  <step>Let <id>received</id> be NormalCompletion ( <value>undefined</value> ).</step>
  <step>Repeat,   <step-list>
    <step>If <id>received</id> .[[Type]] is <value>normal</value> , then     <step-list>
      <step>Let <id>innerResult</id> be ? Call ( <id>iteratorRecord</id> .[[NextMethod]], <id>iteratorRecord</id> .[[Iterator]], « <id>received</id> .[[Value]] »).</step>
      <step>If <id>generatorKind</id> is <value>async</value> , then set <id>innerResult</id> to ? Await ( <id>innerResult</id> ).</step>
      <step>If Type ( <id>innerResult</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
      <step>Let <id>done</id> be ? IteratorComplete ( <id>innerResult</id> ).</step>
      <step>If <id>done</id> is <value>true</value> , then       <step-list>
        <step>Return ? IteratorValue ( <id>innerResult</id> ).</step>
      </step-list></step>
      <step>If <id>generatorKind</id> is <value>async</value> , then set <id>received</id> to AsyncGeneratorYield (? IteratorValue ( <id>innerResult</id> )).</step>
      <step>Else, set <id>received</id> to GeneratorYield ( <id>innerResult</id> ).</step>
    </step-list></step>
    <step>Else if <id>received</id> .[[Type]] is <value>throw</value> , then     <step-list>
      <step>Let <id>throw</id> be ? GetMethod ( <id>iterator</id> , <value>"throw"</value> ).</step>
      <step>If <id>throw</id> is not <value>undefined</value> , then       <step-list>
        <step>Let <id>innerResult</id> be ? Call ( <id>throw</id> , <id>iterator</id> , « <id>received</id> .[[Value]] »).</step>
        <step>If <id>generatorKind</id> is <value>async</value> , then set <id>innerResult</id> to ? Await ( <id>innerResult</id> ).</step>
        <step>NOTE: Exceptions from the inner iterator <value>throw</value> method are propagated. Normal completions from an inner <value>throw</value> method are processed similarly to an inner <value>next</value> .</step>
        <step>If Type ( <id>innerResult</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
        <step>Let <id>done</id> be ? IteratorComplete ( <id>innerResult</id> ).</step>
        <step>If <id>done</id> is <value>true</value> , then         <step-list>
          <step>Return ? IteratorValue ( <id>innerResult</id> ).</step>
        </step-list></step>
        <step>If <id>generatorKind</id> is <value>async</value> , then set <id>received</id> to AsyncGeneratorYield (? IteratorValue ( <id>innerResult</id> )).</step>
        <step>Else, set <id>received</id> to GeneratorYield ( <id>innerResult</id> ).</step>
      </step-list></step>
      <step>Else,       <step-list>
        <step>NOTE: If <id>iterator</id> does not have a <value>throw</value> method, this throw is going to terminate the <value>yield*</value> loop. But first we need to give <id>iterator</id> a chance to clean up.</step>
        <step>Let <id>closeCompletion</id> be Completion { [[Type]]: <value>normal</value> , [[Value]]: <value>empty</value> , [[Target]]: <value>empty</value> }.</step>
        <step>If <id>generatorKind</id> is <value>async</value> , perform ? AsyncIteratorClose ( <id>iteratorRecord</id> , <id>closeCompletion</id> ).</step>
        <step>Else, perform ? IteratorClose ( <id>iteratorRecord</id> , <id>closeCompletion</id> ).</step>
        <step>NOTE: The next step throws a <value>TypeError</value> to indicate that there was a <value>yield*</value> protocol violation: <id>iterator</id> does not have a <value>throw</value> method.</step>
        <step>Throw a <value>TypeError</value> exception.</step>
      </step-list></step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>Assert : <id>received</id> .[[Type]] is <value>return</value> .</step>
      <step>Let <id>return</id> be ? GetMethod ( <id>iterator</id> , <value>"return"</value> ).</step>
      <step>If <id>return</id> is <value>undefined</value> , then       <step-list>
        <step>If <id>generatorKind</id> is <value>async</value> , then set <id>received</id> .[[Value]] to ? Await ( <id>received</id> .[[Value]]).</step>
        <step>Return Completion ( <id>received</id> ).</step>
      </step-list></step>
      <step>Let <id>innerReturnResult</id> be ? Call ( <id>return</id> , <id>iterator</id> , « <id>received</id> .[[Value]] »).</step>
      <step>If <id>generatorKind</id> is <value>async</value> , then set <id>innerReturnResult</id> to ? Await ( <id>innerReturnResult</id> ).</step>
      <step>If Type ( <id>innerReturnResult</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
      <step>Let <id>done</id> be ? IteratorComplete ( <id>innerReturnResult</id> ).</step>
      <step>If <id>done</id> is <value>true</value> , then       <step-list>
        <step>Let <id>value</id> be ? IteratorValue ( <id>innerReturnResult</id> ).</step>
        <step>Return Completion { [[Type]]: <value>return</value> , [[Value]]: <id>value</id> , [[Target]]: <value>empty</value> }.</step>
      </step-list></step>
      <step>If <id>generatorKind</id> is <value>async</value> , then set <id>received</id> to AsyncGeneratorYield (? IteratorValue ( <id>innerReturnResult</id> )).</step>
      <step>Else, set <id>received</id> to GeneratorYield ( <id>innerReturnResult</id> ).</step>
    </step-list></step>
  </step-list></step>
</step-list>
<step-list>
  <step>Return the BoundNames of BindingIdentifier .</step>
</step-list>
<step-list>
  <step>Return « <value>"*default*"</value> ».</step>
</step-list>
<step-list>
  <step>Return the result of ComputedPropertyContains for PropertyName with argument <id>symbol</id> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If UniqueFormalParameters Contains SuperCall is <value>true</value> , return <value>true</value> .</step>
  <step>Return AsyncGeneratorBody Contains SuperCall .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return PropName of PropertyName .</step>
</step-list>
<step-list>
  <step>Perform ? FunctionDeclarationInstantiation ( <id>functionObject</id> , <id>argumentsList</id> ).</step>
  <step>Let <id>generator</id> be ? OrdinaryCreateFromConstructor ( <id>functionObject</id> , <value>"%AsyncGeneratorPrototype%"</value> , « [[AsyncGeneratorState]], [[AsyncGeneratorContext]], [[AsyncGeneratorQueue]] »).</step>
  <step>Perform ! AsyncGeneratorStart ( <id>generator</id> , FunctionBody ).</step>
  <step>Return Completion { [[Type]]: <value>return</value> , [[Value]]: <id>generator</id> , [[Target]]: <value>empty</value> }.</step>
</step-list>
<step-list>
  <step>If the function code for AsyncGeneratorDeclaration is strict mode code , let <id>strict</id> be <value>true</value> . Otherwise let <id>strict</id> be <value>false</value> .</step>
  <step>Let <id>name</id> be StringValue of BindingIdentifier .</step>
  <step>Let <id>F</id> be ! AsyncGeneratorFunctionCreate ( <value>Normal</value> , FormalParameters , AsyncGeneratorBody , <id>scope</id> , <id>strict</id> ).</step>
  <step>Let <id>prototype</id> be ! ObjectCreate ( %AsyncGeneratorPrototype% ).</step>
  <step>Perform ! DefinePropertyOrThrow ( <id>F</id> , <value>"prototype"</value> , PropertyDescriptor { [[Value]]: <id>prototype</id> , [[Writable]]: <value>true</value> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>false</value> }).</step>
  <step>Perform ! SetFunctionName ( <id>F</id> , <id>name</id> ).</step>
  <step>Return <id>F</id> .</step>
</step-list>
<step-list>
  <step>If the function code for AsyncGeneratorDeclaration is strict mode code , let <id>strict</id> be <value>true</value> . Otherwise let <id>strict</id> be <value>false</value> .</step>
  <step>Let <id>F</id> be AsyncGeneratorFunctionCreate ( <value>Normal</value> , FormalParameters , AsyncGeneratorBody , <id>scope</id> , <id>strict</id> ).</step>
  <step>Let <id>prototype</id> be ObjectCreate ( %AsyncGeneratorPrototype% ).</step>
  <step>Perform DefinePropertyOrThrow ( <id>F</id> , <value>"prototype"</value> , PropertyDescriptor { [[Value]]: <id>prototype</id> , [[Writable]]: <value>true</value> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>false</value> }).</step>
  <step>Perform SetFunctionName ( <id>F</id> , <value>"default"</value> ).</step>
  <step>Return <id>F</id> .</step>
</step-list>
<step-list>
  <step>Let <id>propKey</id> be the result of evaluating PropertyName .</step>
  <step>ReturnIfAbrupt ( <id>propKey</id> ).</step>
  <step>If the function code for this AsyncGeneratorMethod is strict mode code , let <id>strict</id> be <value>true</value> . Otherwise let <id>strict</id> be <value>false</value> .</step>
  <step>Let <id>scope</id> be the running execution context 's LexicalEnvironment.</step>
  <step>Let <id>closure</id> be ! AsyncGeneratorFunctionCreate ( <value>Method</value> , UniqueFormalParameters , AsyncGeneratorBody , <id>scope</id> , <id>strict</id> ).</step>
  <step>Perform ! MakeMethod ( <id>closure</id> , <id>object</id> ).</step>
  <step>Let <id>prototype</id> be ! ObjectCreate ( %AsyncGeneratorPrototype% ).</step>
  <step>Perform ! DefinePropertyOrThrow ( <id>closure</id> , <value>"prototype"</value> , PropertyDescriptor { [[Value]]: <id>prototype</id> , [[Writable]]: <value>true</value> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>false</value> }).</step>
  <step>Perform ! SetFunctionName ( <id>closure</id> , <id>propKey</id> ).</step>
  <step>Let <id>desc</id> be PropertyDescriptor { [[Value]]: <id>closure</id> , [[Writable]]: <value>true</value> , [[Enumerable]]: <id>enumerable</id> , [[Configurable]]: <value>true</value> }.</step>
  <step>Return ? DefinePropertyOrThrow ( <id>object</id> , <id>propKey</id> , <id>desc</id> ).</step>
</step-list>
<step-list>
  <step>If the function code for this AsyncGeneratorExpression is strict mode code , let <id>strict</id> be <value>true</value> . Otherwise let <id>strict</id> be <value>false</value> .</step>
  <step>Let <id>scope</id> be the LexicalEnvironment of the running execution context .</step>
  <step>Let <id>closure</id> be ! AsyncGeneratorFunctionCreate ( <value>Normal</value> , FormalParameters , AsyncGeneratorBody , <id>scope</id> , <id>strict</id> ).</step>
  <step>Let <id>prototype</id> be ! ObjectCreate ( %AsyncGeneratorPrototype% ).</step>
  <step>Perform ! DefinePropertyOrThrow ( <id>closure</id> , <value>"prototype"</value> , PropertyDescriptor { [[Value]]: <id>prototype</id> , [[Writable]]: <value>true</value> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>false</value> }).</step>
  <step>Return <id>closure</id> .</step>
</step-list>
<step-list>
  <step>If the function code for this AsyncGeneratorExpression is strict mode code , let <id>strict</id> be <value>true</value> . Otherwise let <id>strict</id> be <value>false</value> .</step>
  <step>Let <id>scope</id> be the running execution context 's LexicalEnvironment.</step>
  <step>Let <id>funcEnv</id> be ! NewDeclarativeEnvironment ( <id>scope</id> ).</step>
  <step>Let <id>envRec</id> be <id>funcEnv</id> 's EnvironmentRecord .</step>
  <step>Let <id>name</id> be StringValue of BindingIdentifier .</step>
  <step>Perform ! <id>envRec</id> .CreateImmutableBinding( <id>name</id> ).</step>
  <step>Let <id>closure</id> be ! AsyncGeneratorFunctionCreate ( <value>Normal</value> , FormalParameters , AsyncGeneratorBody , <id>funcEnv</id> , <id>strict</id> ).</step>
  <step>Let <id>prototype</id> be ! ObjectCreate ( %AsyncGeneratorPrototype% ).</step>
  <step>Perform ! DefinePropertyOrThrow ( <id>closure</id> , <value>"prototype"</value> , PropertyDescriptor { [[Value]]: <id>prototype</id> , [[Writable]]: <value>true</value> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>false</value> }).</step>
  <step>Perform ! SetFunctionName ( <id>closure</id> , <id>name</id> ).</step>
  <step>Perform ! <id>envRec</id> .InitializeBinding( <id>name</id> , <id>closure</id> ).</step>
  <step>Return <id>closure</id> .</step>
</step-list>
<step-list>
  <step>Let <id>constructor</id> be ConstructorMethod of ClassBody .</step>
  <step>If <id>constructor</id> is <value>empty</value> , return <value>false</value> .</step>
  <step>Return HasDirectSuper of <id>constructor</id> .</step>
</step-list>
<step-list>
  <step>Return the BoundNames of BindingIdentifier .</step>
</step-list>
<step-list>
  <step>Return « <value>"*default*"</value> ».</step>
</step-list>
<step-list>
  <step>If ClassElement is ClassElement:; , return <value>empty</value> .</step>
  <step>If IsStatic of ClassElement is <value>true</value> , return <value>empty</value> .</step>
  <step>If PropName of ClassElement is not <value>"constructor"</value> , return <value>empty</value> .</step>
  <step>Return ClassElement .</step>
</step-list>
<step-list>
  <step>Let <id>head</id> be ConstructorMethod of ClassElementList .</step>
  <step>If <id>head</id> is not <value>empty</value> , return <id>head</id> .</step>
  <step>If ClassElement is ClassElement:; , return <value>empty</value> .</step>
  <step>If IsStatic of ClassElement is <value>true</value> , return <value>empty</value> .</step>
  <step>If PropName of ClassElement is not <value>"constructor"</value> , return <value>empty</value> .</step>
  <step>Return ClassElement .</step>
</step-list>
<step-list>
  <step>If <id>symbol</id> is ClassBody , return <value>true</value> .</step>
  <step>If <id>symbol</id> is ClassHeritage , then   <step-list>
    <step>If ClassHeritage is present, return <value>true</value> ; otherwise return <value>false</value> .</step>
  </step-list></step>
  <step>Let <id>inHeritage</id> be ClassHeritage Contains <id>symbol</id> .</step>
  <step>If <id>inHeritage</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return the result of ComputedPropertyContains for ClassBody with argument <id>symbol</id> .</step>
</step-list>
<step-list>
  <step>Let <id>inList</id> be the result of ComputedPropertyContains for ClassElementList with argument <id>symbol</id> .</step>
  <step>If <id>inList</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return the result of ComputedPropertyContains for ClassElement with argument <id>symbol</id> .</step>
</step-list>
<step-list>
  <step>Return the result of ComputedPropertyContains for MethodDefinition with argument <id>symbol</id> .</step>
</step-list>
<step-list>
  <step>Return the result of ComputedPropertyContains for MethodDefinition with argument <id>symbol</id> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If ClassElement is ClassElement:; , return a new empty List .</step>
  <step>If IsStatic of ClassElement is <value>false</value> and PropName of ClassElement is <value>"constructor"</value> , return a new empty List .</step>
  <step>Return a List containing ClassElement .</step>
</step-list>
<step-list>
  <step>Let <id>list</id> be NonConstructorMethodDefinitions of ClassElementList .</step>
  <step>If ClassElement is ClassElement:; , return <id>list</id> .</step>
  <step>If IsStatic of ClassElement is <value>false</value> and PropName of ClassElement is <value>"constructor"</value> , return <id>list</id> .</step>
  <step>Append ClassElement to the end of <id>list</id> .</step>
  <step>Return <id>list</id> .</step>
</step-list>
<step-list>
  <step>If PropName of ClassElement is <value>empty</value> , return a new empty List .</step>
  <step>If IsStatic of ClassElement is <value>true</value> , return a new empty List .</step>
  <step>Return a List containing PropName of ClassElement .</step>
</step-list>
<step-list>
  <step>Let <id>list</id> be PrototypePropertyNameList of ClassElementList .</step>
  <step>If PropName of ClassElement is <value>empty</value> , return <id>list</id> .</step>
  <step>If IsStatic of ClassElement is <value>true</value> , return <id>list</id> .</step>
  <step>Append PropName of ClassElement to the end of <id>list</id> .</step>
  <step>Return <id>list</id> .</step>
</step-list>
<step-list>
  <step>Return <value>empty</value> .</step>
</step-list>
<step-list>
  <step>Let <id>lex</id> be the LexicalEnvironment of the running execution context .</step>
  <step>Let <id>classScope</id> be NewDeclarativeEnvironment ( <id>lex</id> ).</step>
  <step>Let <id>classScopeEnvRec</id> be <id>classScope</id> 's EnvironmentRecord .</step>
  <step>If <id>className</id> is not <value>undefined</value> , then   <step-list>
    <step>Perform <id>classScopeEnvRec</id> .CreateImmutableBinding( <id>className</id> , <value>true</value> ).</step>
  </step-list></step>
  <step>If ClassHeritageopt is not present, then   <step-list>
    <step>Let <id>protoParent</id> be the intrinsic object %ObjectPrototype% .</step>
    <step>Let <id>constructorParent</id> be the intrinsic object %FunctionPrototype% .</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Set the running execution context 's LexicalEnvironment to <id>classScope</id> .</step>
    <step>Let <id>superclass</id> be the result of evaluating ClassHeritage .</step>
    <step>Set the running execution context 's LexicalEnvironment to <id>lex</id> .</step>
    <step>ReturnIfAbrupt ( <id>superclass</id> ).</step>
    <step>If <id>superclass</id> is <value>null</value> , then     <step-list>
      <step>Let <id>protoParent</id> be <value>null</value> .</step>
      <step>Let <id>constructorParent</id> be the intrinsic object %FunctionPrototype% .</step>
    </step-list></step>
    <step>Else if IsConstructor ( <id>superclass</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
    <step>Else,     <step-list>
      <step>Let <id>protoParent</id> be ? Get ( <id>superclass</id> , <value>"prototype"</value> ).</step>
      <step>If Type ( <id>protoParent</id> ) is neither Object nor Null, throw a <value>TypeError</value> exception.</step>
      <step>Let <id>constructorParent</id> be <id>superclass</id> .</step>
    </step-list></step>
  </step-list></step>
  <step>Let <id>proto</id> be ObjectCreate ( <id>protoParent</id> ).</step>
  <step>If ClassBodyopt is not present, let <id>constructor</id> be <value>empty</value> .</step>
  <step>Else, let <id>constructor</id> be ConstructorMethod of ClassBody .</step>
  <step>If <id>constructor</id> is <value>empty</value> , then   <step-list>
    <step>If ClassHeritageopt is present, then     <step-list>
      <step>Set <id>constructor</id> to the result of parsing the source text constructor(... args){ super (...args);} using the syntactic grammar with the goal symbol  MethodDefinition[~Yield, ~Await] .</step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>Set <id>constructor</id> to the result of parsing the source text constructor(){ } using the syntactic grammar with the goal symbol  MethodDefinition[~Yield, ~Await] .</step>
    </step-list></step>
  </step-list></step>
  <step>Set the running execution context 's LexicalEnvironment to <id>classScope</id> .</step>
  <step>Let <id>constructorInfo</id> be the result of performing DefineMethod for <id>constructor</id> with arguments <id>proto</id> and <id>constructorParent</id> as the optional <id>functionPrototype</id> argument.</step>
  <step>Assert : <id>constructorInfo</id> is not an abrupt completion .</step>
  <step>Let <id>F</id> be <id>constructorInfo</id> .[[Closure]].</step>
  <step>If ClassHeritageopt is present, set <id>F</id> .[[ConstructorKind]] to <value>"derived"</value> .</step>
  <step>Perform MakeConstructor ( <id>F</id> , <value>false</value> , <id>proto</id> ).</step>
  <step>Perform MakeClassConstructor ( <id>F</id> ).</step>
  <step>Perform CreateMethodProperty ( <id>proto</id> , <value>"constructor"</value> , <id>F</id> ).</step>
  <step>If ClassBodyopt is not present, let <id>methods</id> be a new empty List .</step>
  <step>Else, let <id>methods</id> be NonConstructorMethodDefinitions of ClassBody .</step>
  <step>For each ClassElement  <id>m</id> in order from <id>methods</id> , do   <step-list>
    <step>If IsStatic of <id>m</id> is <value>false</value> , then     <step-list>
      <step>Let <id>status</id> be the result of performing PropertyDefinitionEvaluation for <id>m</id> with arguments <id>proto</id> and <value>false</value> .</step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>Let <id>status</id> be the result of performing PropertyDefinitionEvaluation for <id>m</id> with arguments <id>F</id> and <value>false</value> .</step>
    </step-list></step>
    <step>If <id>status</id> is an abrupt completion , then     <step-list>
      <step>Set the running execution context 's LexicalEnvironment to <id>lex</id> .</step>
      <step>Return Completion ( <id>status</id> ).</step>
    </step-list></step>
  </step-list></step>
  <step>Set the running execution context 's LexicalEnvironment to <id>lex</id> .</step>
  <step>If <id>className</id> is not <value>undefined</value> , then   <step-list>
    <step>Perform <id>classScopeEnvRec</id> .InitializeBinding( <id>className</id> , <id>F</id> ).</step>
  </step-list></step>
  <step>Return <id>F</id> .</step>
</step-list>
<step-list>
  <step>Let <id>className</id> be StringValue of BindingIdentifier .</step>
  <step>Let <id>value</id> be the result of ClassDefinitionEvaluation of ClassTail with argument <id>className</id> .</step>
  <step>ReturnIfAbrupt ( <id>value</id> ).</step>
  <step>Let <id>hasNameProperty</id> be ? HasOwnProperty ( <id>value</id> , <value>"name"</value> ).</step>
  <step>If <id>hasNameProperty</id> is <value>false</value> , perform SetFunctionName ( <id>value</id> , <id>className</id> ).</step>
  <step>Let <id>env</id> be the running execution context 's LexicalEnvironment.</step>
  <step>Perform ? InitializeBoundName ( <id>className</id> , <id>value</id> , <id>env</id> ).</step>
  <step>Return <id>value</id> .</step>
</step-list>
<step-list>
  <step>Return the result of ClassDefinitionEvaluation of ClassTail with argument <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Perform ? BindingClassDeclarationEvaluation of this ClassDeclaration .</step>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>If BindingIdentifieropt is not present, let <id>className</id> be <value>undefined</value> .</step>
  <step>Else, let <id>className</id> be StringValue of BindingIdentifier .</step>
  <step>Let <id>value</id> be the result of ClassDefinitionEvaluation of ClassTail with argument <id>className</id> .</step>
  <step>ReturnIfAbrupt ( <id>value</id> ).</step>
  <step>If <id>className</id> is not <value>undefined</value> , then   <step-list>
    <step>Let <id>hasNameProperty</id> be ? HasOwnProperty ( <id>value</id> , <value>"name"</value> ).</step>
    <step>If <id>hasNameProperty</id> is <value>false</value> , then     <step-list>
      <step>Perform SetFunctionName ( <id>value</id> , <id>className</id> ).</step>
    </step-list></step>
  </step-list></step>
  <step>Return NormalCompletion ( <id>value</id> ).</step>
</step-list>
<step-list>
  <step>Return the BoundNames of BindingIdentifier .</step>
</step-list>
<step-list>
  <step>Return « <value>"*default*"</value> ».</step>
</step-list>
<step-list>
  <step>Return the result of ComputedPropertyContains for PropertyName with argument <id>symbol</id> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If UniqueFormalParameters Contains SuperCall is <value>true</value> , return <value>true</value> .</step>
  <step>Return AsyncFunctionBody Contains SuperCall .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return PropName of PropertyName .</step>
</step-list>
<step-list>
  <step>If the function code for AsyncFunctionDeclaration is strict mode code , let <id>strict</id> be <value>true</value> . Otherwise, let <id>strict</id> be <value>false</value> .</step>
  <step>Let <id>name</id> be StringValue of BindingIdentifier .</step>
  <step>Let <id>F</id> be ! AsyncFunctionCreate ( <value>Normal</value> , FormalParameters , AsyncFunctionBody , <id>scope</id> , <id>strict</id> ).</step>
  <step>Perform ! SetFunctionName ( <id>F</id> , <id>name</id> ).</step>
  <step>Return <id>F</id> .</step>
</step-list>
<step-list>
  <step>If the function code for AsyncFunctionDeclaration is strict mode code , let <id>strict</id> be <value>true</value> . Otherwise, let <id>strict</id> be <value>false</value> .</step>
  <step>Let <id>F</id> be ! AsyncFunctionCreate ( <value>Normal</value> , FormalParameters , AsyncFunctionBody , <id>scope</id> , <id>strict</id> ).</step>
  <step>Perform ! SetFunctionName ( <id>F</id> , <value>"default"</value> ).</step>
  <step>Return <id>F</id> .</step>
</step-list>
<step-list>
  <step>Let <id>promiseCapability</id> be ! NewPromiseCapability ( %Promise% ).</step>
  <step>Let <id>declResult</id> be FunctionDeclarationInstantiation ( <id>functionObject</id> , <id>argumentsList</id> ).</step>
  <step>If <id>declResult</id> is not an abrupt completion , then   <step-list>
    <step>Perform ! AsyncFunctionStart ( <id>promiseCapability</id> , FunctionBody ).</step>
  </step-list></step>
  <step>Else <id>declResult</id> is an abrupt completion ,   <step-list>
    <step>Perform ! Call ( <id>promiseCapability</id> .[[Reject]], <value>undefined</value> , « <id>declResult</id> .[[Value]] »).</step>
  </step-list></step>
  <step>Return Completion { [[Type]]: <value>return</value> , [[Value]]: <id>promiseCapability</id> .[[Promise]], [[Target]]: <value>empty</value> }.</step>
</step-list>
<step-list>
  <step>Let <id>propKey</id> be the result of evaluating PropertyName .</step>
  <step>ReturnIfAbrupt ( <id>propKey</id> ).</step>
  <step>If the function code for this AsyncMethod is strict mode code , let <id>strict</id> be <value>true</value> . Otherwise let <id>strict</id> be <value>false</value> .</step>
  <step>Let <id>scope</id> be the LexicalEnvironment of the running execution context .</step>
  <step>Let <id>closure</id> be ! AsyncFunctionCreate ( <value>Method</value> , UniqueFormalParameters , AsyncFunctionBody , <id>scope</id> , <id>strict</id> ).</step>
  <step>Perform ! MakeMethod ( <id>closure</id> , <id>object</id> ).</step>
  <step>Perform ! SetFunctionName ( <id>closure</id> , <id>propKey</id> ).</step>
  <step>Let <id>desc</id> be the PropertyDescriptor { [[Value]]: <id>closure</id> , [[Writable]]: <value>true</value> , [[Enumerable]]: <id>enumerable</id> , [[Configurable]]: <value>true</value> }.</step>
  <step>Return ? DefinePropertyOrThrow ( <id>object</id> , <id>propKey</id> , <id>desc</id> ).</step>
</step-list>
<step-list>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>If the function code for AsyncFunctionExpression is strict mode code , let <id>strict</id> be <value>true</value> . Otherwise let <id>strict</id> be <value>false</value> .</step>
  <step>Let <id>scope</id> be the LexicalEnvironment of the running execution context .</step>
  <step>Let <id>closure</id> be ! AsyncFunctionCreate ( <value>Normal</value> , FormalParameters , AsyncFunctionBody , <id>scope</id> , <id>strict</id> ).</step>
  <step>Return <id>closure</id> .</step>
</step-list>
<step-list>
  <step>If the function code for AsyncFunctionExpression is strict mode code , let <id>strict</id> be <value>true</value> . Otherwise let <id>strict</id> be <value>false</value> .</step>
  <step>Let <id>scope</id> be the LexicalEnvironment of the running execution context .</step>
  <step>Let <id>funcEnv</id> be ! NewDeclarativeEnvironment ( <id>scope</id> ).</step>
  <step>Let <id>envRec</id> be <id>funcEnv</id> 's EnvironmentRecord .</step>
  <step>Let <id>name</id> be StringValue of BindingIdentifier .</step>
  <step>Perform ! <id>envRec</id> .CreateImmutableBinding( <id>name</id> ).</step>
  <step>Let <id>closure</id> be ! AsyncFunctionCreate ( <value>Normal</value> , FormalParameters , AsyncFunctionBody , <id>funcEnv</id> , <id>strict</id> ).</step>
  <step>Perform ! SetFunctionName ( <id>closure</id> , <id>name</id> ).</step>
  <step>Perform ! <id>envRec</id> .InitializeBinding( <id>name</id> , <id>closure</id> ).</step>
  <step>Return <id>closure</id> .</step>
</step-list>
<step-list>
  <step>Let <id>exprRef</id> be the result of evaluating UnaryExpression .</step>
  <step>Let <id>value</id> be ? GetValue ( <id>exprRef</id> ).</step>
  <step>Return ? Await ( <id>value</id> ).</step>
</step-list>
<step-list>
  <step>Return the AsyncArrowHead that is covered by CoverCallExpressionAndAsyncArrowHead .</step>
</step-list>
<step-list>
  <step>Let <id>head</id> be CoveredAsyncArrowHead of CoverCallExpressionAndAsyncArrowHead .</step>
  <step>Return the BoundNames of <id>head</id> .</step>
</step-list>
<step-list>
  <step>If <id>symbol</id> is not one of NewTarget , SuperProperty , SuperCall , <value>super</value> , or <value>this</value> , return <value>false</value> .</step>
  <step>Return AsyncConciseBody Contains <id>symbol</id> .</step>
</step-list>
<step-list>
  <step>If <id>symbol</id> is not one of NewTarget , SuperProperty , SuperCall , <value>super</value> , or <value>this</value> , return <value>false</value> .</step>
  <step>Let <id>head</id> be CoveredAsyncArrowHead of CoverCallExpressionAndAsyncArrowHead .</step>
  <step>If <id>head</id> Contains <id>symbol</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return AsyncConciseBody Contains <id>symbol</id> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return 1.</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Let <id>head</id> be CoveredAsyncArrowHead of CoverCallExpressionAndAsyncArrowHead .</step>
  <step>Return IsSimpleParameterList of <id>head</id> .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Assert : <id>iteratorRecord</id> .[[Done]] is <value>false</value> .</step>
  <step>Let <id>next</id> be ? IteratorStep ( <id>iteratorRecord</id> ).</step>
  <step>If <id>next</id> is an abrupt completion , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
  <step>ReturnIfAbrupt ( <id>next</id> ).</step>
  <step>If <id>next</id> is <value>false</value> , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
  <step>Else,   <step-list>
    <step>Let <id>v</id> be ? IteratorValue ( <id>next</id> ).</step>
    <step>If <id>v</id> is an abrupt completion , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
    <step>ReturnIfAbrupt ( <id>v</id> ).</step>
  </step-list></step>
  <step>If <id>iteratorRecord</id> .[[Done]] is <value>true</value> , let <id>v</id> be <value>undefined</value> .</step>
  <step>Return the result of performing BindingInitialization for BindingIdentifier using <id>v</id> and <id>environment</id> as the arguments.</step>
</step-list>
<step-list>
  <step>Let <id>promiseCapability</id> be ! NewPromiseCapability ( %Promise% ).</step>
  <step>Let <id>declResult</id> be FunctionDeclarationInstantiation ( <id>functionObject</id> , <id>argumentsList</id> ).</step>
  <step>If <id>declResult</id> is not an abrupt completion , then   <step-list>
    <step>Perform ! AsyncFunctionStart ( <id>promiseCapability</id> , AssignmentExpression ).</step>
  </step-list></step>
  <step>Else <id>declResult</id> is an abrupt completion ,   <step-list>
    <step>Perform ! Call ( <id>promiseCapability</id> .[[Reject]], <value>undefined</value> , « <id>declResult</id> .[[Value]] »).</step>
  </step-list></step>
  <step>Return Completion { [[Type]]: <value>return</value> , [[Value]]: <id>promiseCapability</id> .[[Promise]], [[Target]]: <value>empty</value> }.</step>
</step-list>
<step-list>
  <step>Return the result of EvaluateBody of AsyncFunctionBody passing <id>functionObject</id> and <id>argumentsList</id> as the arguments.</step>
</step-list>
<step-list>
  <step>If the function code for this AsyncArrowFunction is strict mode code , let <id>strict</id> be <value>true</value> . Otherwise, let <id>strict</id> be <value>false</value> .</step>
  <step>Let <id>scope</id> be the LexicalEnvironment of the running execution context .</step>
  <step>Let <id>parameters</id> be AsyncArrowBindingIdentifier .</step>
  <step>Let <id>closure</id> be ! AsyncFunctionCreate ( <value>Arrow</value> , <id>parameters</id> , AsyncConciseBody , <id>scope</id> , <id>strict</id> ).</step>
  <step>Return <id>closure</id> .</step>
</step-list>
<step-list>
  <step>If the function code for this AsyncArrowFunction is strict mode code , let <id>strict</id> be <value>true</value> . Otherwise, let <id>strict</id> be <value>false</value> .</step>
  <step>Let <id>scope</id> be the LexicalEnvironment of the running execution context .</step>
  <step>Let <id>head</id> be CoveredAsyncArrowHead of CoverCallExpressionAndAsyncArrowHead .</step>
  <step>Let <id>parameters</id> be the ArrowFormalParameters of <id>head</id> .</step>
  <step>Let <id>closure</id> be ! AsyncFunctionCreate ( <value>Arrow</value> , <id>parameters</id> , AsyncConciseBody , <id>scope</id> , <id>strict</id> ).</step>
  <step>Return <id>closure</id> .</step>
</step-list>
<step-list>
  <step>Assert : <id>call</id> is a Parse Node .</step>
  <step>If the source code matching <id>call</id> is non-strict code , return <value>false</value> .</step>
  <step>If <id>call</id> is not contained within a FunctionBody , ConciseBody , or AsyncConciseBody , return <value>false</value> .</step>
  <step>Let <id>body</id> be the FunctionBody , ConciseBody , or AsyncConciseBody that most closely contains <id>call</id> .</step>
  <step>If <id>body</id> is the FunctionBody of a GeneratorBody , return <value>false</value> .</step>
  <step>If <id>body</id> is the FunctionBody of an AsyncFunctionBody , return <value>false</value> .</step>
  <step>If <id>body</id> is the FunctionBody of an AsyncGeneratorBody , return <value>false</value> .</step>
  <step>If <id>body</id> is an AsyncConciseBody , return <value>false</value> .</step>
  <step>Return the result of HasCallInTailPosition of <id>body</id> with argument <id>call</id> .</step>
</step-list>
<step-list>
  <step>Return HasCallInTailPosition of AssignmentExpression with argument <id>call</id> .</step>
</step-list>
<step-list>
  <step>Let <id>has</id> be HasCallInTailPosition of StatementList with argument <id>call</id> .</step>
  <step>If <id>has</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return HasCallInTailPosition of StatementListItem with argument <id>call</id> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>has</id> be HasCallInTailPosition of the first Statement with argument <id>call</id> .</step>
  <step>If <id>has</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return HasCallInTailPosition of the second Statement with argument <id>call</id> .</step>
</step-list>
<step-list>
  <step>Return HasCallInTailPosition of Statement with argument <id>call</id> .</step>
</step-list>
<step-list>
  <step>Return HasCallInTailPosition of LabelledItem with argument <id>call</id> .</step>
</step-list>
<step-list>
  <step>Return HasCallInTailPosition of Expression with argument <id>call</id> .</step>
</step-list>
<step-list>
  <step>Return HasCallInTailPosition of CaseBlock with argument <id>call</id> .</step>
</step-list>
<step-list>
  <step>Let <id>has</id> be <value>false</value> .</step>
  <step>If the first CaseClauses is present, let <id>has</id> be HasCallInTailPosition of the first CaseClauses with argument <id>call</id> .</step>
  <step>If <id>has</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Let <id>has</id> be HasCallInTailPosition of the DefaultClause with argument <id>call</id> .</step>
  <step>If <id>has</id> is <value>true</value> , return <value>true</value> .</step>
  <step>If the second CaseClauses is present, let <id>has</id> be HasCallInTailPosition of the second CaseClauses with argument <id>call</id> .</step>
  <step>Return <id>has</id> .</step>
</step-list>
<step-list>
  <step>Let <id>has</id> be HasCallInTailPosition of CaseClauses with argument <id>call</id> .</step>
  <step>If <id>has</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return HasCallInTailPosition of CaseClause with argument <id>call</id> .</step>
</step-list>
<step-list>
  <step>If StatementList is present, return HasCallInTailPosition of StatementList with argument <id>call</id> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return HasCallInTailPosition of Catch with argument <id>call</id> .</step>
</step-list>
<step-list>
  <step>Return HasCallInTailPosition of Finally with argument <id>call</id> .</step>
</step-list>
<step-list>
  <step>Return HasCallInTailPosition of Block with argument <id>call</id> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return HasCallInTailPosition of AssignmentExpression with argument <id>call</id> .</step>
</step-list>
<step-list>
  <step>Let <id>has</id> be HasCallInTailPosition of the first AssignmentExpression with argument <id>call</id> .</step>
  <step>If <id>has</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return HasCallInTailPosition of the second AssignmentExpression with argument <id>call</id> .</step>
</step-list>
<step-list>
  <step>Return HasCallInTailPosition of BitwiseORExpression with argument <id>call</id> .</step>
</step-list>
<step-list>
  <step>Return HasCallInTailPosition of LogicalANDExpression with argument <id>call</id> .</step>
</step-list>
<step-list>
  <step>If this CallExpression is <id>call</id> , return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If this MemberExpression is <id>call</id> , return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>expr</id> be CoveredParenthesizedExpression of CoverParenthesizedExpressionAndArrowParameterList .</step>
  <step>Return HasCallInTailPosition of <id>expr</id> with argument <id>call</id> .</step>
</step-list>
<step-list>
  <step>Return HasCallInTailPosition of Expression with argument <id>call</id> .</step>
</step-list>
<step-list>
  <step>Let <id>leafContext</id> be the running execution context .</step>
  <step>Suspend  <id>leafContext</id> .</step>
  <step>Pop <id>leafContext</id> from the execution context stack . The execution context now on the top of the stack becomes the running execution context .</step>
  <step>Assert : <id>leafContext</id> has no further use. It will never be activated as the running execution context .</step>
</step-list>
<step-list>
  <step>If the Directive Prologue of StatementList contains a Use Strict Directive , return <value>true</value> ; otherwise, return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return TopLevelLexicallyDeclaredNames of StatementList .</step>
</step-list>
<step-list>
  <step>Return TopLevelLexicallyScopedDeclarations of StatementList .</step>
</step-list>
<step-list>
  <step>Return TopLevelVarDeclaredNames of StatementList .</step>
</step-list>
<step-list>
  <step>Return TopLevelVarScopedDeclarations of StatementList .</step>
</step-list>
<step-list>
  <step>Return NormalCompletion ( <value>undefined</value> ).</step>
</step-list>
<step-list>
  <step>Assert : <id>sourceText</id> is an ECMAScript source text (see clause 10 ).</step>
  <step>Parse <id>sourceText</id> using Script as the goal symbol and analyse the parse result for any Early Error conditions. If the parse was successful and no early errors were found, let <id>body</id> be the resulting parse tree. Otherwise, let <id>body</id> be a List of one or more <value>SyntaxError</value> or <value>ReferenceError</value> objects representing the parsing errors and/or early errors. Parsing and early error detection may be interweaved in an implementation-dependent manner. If more than one parsing error or early error is present, the number and ordering of error objects in the list is implementation-dependent, but at least one must be present.</step>
  <step>If <id>body</id> is a List of errors, return <id>body</id> .</step>
  <step>Return Script Record { [[Realm]]: <id>realm</id> , [[Environment]]: <value>undefined</value> , [[ECMAScriptCode]]: <id>body</id> , [[HostDefined]]: <id>hostDefined</id> }.</step>
</step-list>
<step-list>
  <step>Let <id>globalEnv</id> be <id>scriptRecord</id> .[[Realm]].[[GlobalEnv]].</step>
  <step>Let <id>scriptCxt</id> be a new ECMAScript code execution context .</step>
  <step>Set the Function of <id>scriptCxt</id> to <value>null</value> .</step>
  <step>Set the Realm of <id>scriptCxt</id> to <id>scriptRecord</id> .[[Realm]].</step>
  <step>Set the ScriptOrModule of <id>scriptCxt</id> to <id>scriptRecord</id> .</step>
  <step>Set the VariableEnvironment of <id>scriptCxt</id> to <id>globalEnv</id> .</step>
  <step>Set the LexicalEnvironment of <id>scriptCxt</id> to <id>globalEnv</id> .</step>
  <step>Suspend the currently running execution context .</step>
  <step>Push <id>scriptCxt</id> on to the execution context stack ; <id>scriptCxt</id> is now the running execution context .</step>
  <step>Let <id>scriptBody</id> be <id>scriptRecord</id> .[[ECMAScriptCode]].</step>
  <step>Let <id>result</id> be GlobalDeclarationInstantiation ( <id>scriptBody</id> , <id>globalEnv</id> ).</step>
  <step>If <id>result</id> .[[Type]] is <value>normal</value> , then   <step-list>
    <step>Set <id>result</id> to the result of evaluating <id>scriptBody</id> .</step>
  </step-list></step>
  <step>If <id>result</id> .[[Type]] is <value>normal</value> and <id>result</id> .[[Value]] is <value>empty</value> , then   <step-list>
    <step>Set <id>result</id> to NormalCompletion ( <value>undefined</value> ).</step>
  </step-list></step>
  <step>Suspend  <id>scriptCxt</id> and remove it from the execution context stack .</step>
  <step>Assert : The execution context stack is not empty.</step>
  <step>Resume the context that is now on the top of the execution context stack as the running execution context .</step>
  <step>Return Completion ( <id>result</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>envRec</id> be <id>env</id> 's EnvironmentRecord .</step>
  <step>Assert : <id>envRec</id> is a global Environment Record .</step>
  <step>Let <id>lexNames</id> be the LexicallyDeclaredNames of <id>script</id> .</step>
  <step>Let <id>varNames</id> be the VarDeclaredNames of <id>script</id> .</step>
  <step>For each <id>name</id> in <id>lexNames</id> , do   <step-list>
    <step>If <id>envRec</id> .HasVarDeclaration( <id>name</id> ) is <value>true</value> , throw a <value>SyntaxError</value> exception.</step>
    <step>If <id>envRec</id> .HasLexicalDeclaration( <id>name</id> ) is <value>true</value> , throw a <value>SyntaxError</value> exception.</step>
    <step>Let <id>hasRestrictedGlobal</id> be ? <id>envRec</id> .HasRestrictedGlobalProperty( <id>name</id> ).</step>
    <step>If <id>hasRestrictedGlobal</id> is <value>true</value> , throw a <value>SyntaxError</value> exception.</step>
  </step-list></step>
  <step>For each <id>name</id> in <id>varNames</id> , do   <step-list>
    <step>If <id>envRec</id> .HasLexicalDeclaration( <id>name</id> ) is <value>true</value> , throw a <value>SyntaxError</value> exception.</step>
  </step-list></step>
  <step>Let <id>varDeclarations</id> be the VarScopedDeclarations of <id>script</id> .</step>
  <step>Let <id>functionsToInitialize</id> be a new empty List .</step>
  <step>Let <id>declaredFunctionNames</id> be a new empty List .</step>
  <step>For each <id>d</id> in <id>varDeclarations</id> , in reverse list order, do   <step-list>
    <step>If <id>d</id> is neither a VariableDeclaration nor a ForBinding nor a BindingIdentifier , then     <step-list>
      <step>Assert : <id>d</id> is either a FunctionDeclaration , a GeneratorDeclaration , an AsyncFunctionDeclaration , or an AsyncGeneratorDeclaration .</step>
      <step>NOTE: If there are multiple function declarations for the same name, the last declaration is used.</step>
      <step>Let <id>fn</id> be the sole element of the BoundNames of <id>d</id> .</step>
      <step>If <id>fn</id> is not an element of <id>declaredFunctionNames</id> , then       <step-list>
        <step>Let <id>fnDefinable</id> be ? <id>envRec</id> .CanDeclareGlobalFunction( <id>fn</id> ).</step>
        <step>If <id>fnDefinable</id> is <value>false</value> , throw a <value>TypeError</value> exception.</step>
        <step>Append <id>fn</id> to <id>declaredFunctionNames</id> .</step>
        <step>Insert <id>d</id> as the first element of <id>functionsToInitialize</id> .</step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
  <step>Let <id>declaredVarNames</id> be a new empty List .</step>
  <step>For each <id>d</id> in <id>varDeclarations</id> , do   <step-list>
    <step>If <id>d</id> is a VariableDeclaration , a ForBinding , or a BindingIdentifier , then     <step-list>
      <step>For each String <id>vn</id> in the BoundNames of <id>d</id> , do       <step-list>
        <step>If <id>vn</id> is not an element of <id>declaredFunctionNames</id> , then         <step-list>
          <step>Let <id>vnDefinable</id> be ? <id>envRec</id> .CanDeclareGlobalVar( <id>vn</id> ).</step>
          <step>If <id>vnDefinable</id> is <value>false</value> , throw a <value>TypeError</value> exception.</step>
          <step>If <id>vn</id> is not an element of <id>declaredVarNames</id> , then           <step-list>
            <step>Append <id>vn</id> to <id>declaredVarNames</id> .</step>
          </step-list></step>
        </step-list></step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
  <step>NOTE: No abnormal terminations occur after this algorithm step if the global object is an ordinary object. However, if the global object is a Proxy exotic object it may exhibit behaviours that cause abnormal terminations in some of the following steps.</step>
  <step>NOTE: Annex B.3.3.2 adds additional steps at this point.</step>
  <step>Let <id>lexDeclarations</id> be the LexicallyScopedDeclarations of <id>script</id> .</step>
  <step>For each element <id>d</id> in <id>lexDeclarations</id> , do   <step-list>
    <step>NOTE: Lexically declared names are only instantiated here but not initialized.</step>
    <step>For each element <id>dn</id> of the BoundNames of <id>d</id> , do     <step-list>
      <step>If IsConstantDeclaration of <id>d</id> is <value>true</value> , then       <step-list>
        <step>Perform ? <id>envRec</id> .CreateImmutableBinding( <id>dn</id> , <value>true</value> ).</step>
      </step-list></step>
      <step>Else,       <step-list>
        <step>Perform ? <id>envRec</id> .CreateMutableBinding( <id>dn</id> , <value>false</value> ).</step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
  <step>For each Parse Node  <id>f</id> in <id>functionsToInitialize</id> , do   <step-list>
    <step>Let <id>fn</id> be the sole element of the BoundNames of <id>f</id> .</step>
    <step>Let <id>fo</id> be the result of performing InstantiateFunctionObject for <id>f</id> with argument <id>env</id> .</step>
    <step>Perform ? <id>envRec</id> .CreateGlobalFunctionBinding( <id>fn</id> , <id>fo</id> , <value>false</value> ).</step>
  </step-list></step>
  <step>For each String <id>vn</id> in <id>declaredVarNames</id> , in list order, do   <step-list>
    <step>Perform ? <id>envRec</id> .CreateGlobalVarBinding( <id>vn</id> , <value>false</value> ).</step>
  </step-list></step>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Assert : <id>sourceText</id> is an ECMAScript source text (see clause 10 ).</step>
  <step>Let <id>realm</id> be the current Realm Record .</step>
  <step>Let <id>s</id> be ParseScript ( <id>sourceText</id> , <id>realm</id> , <id>hostDefined</id> ).</step>
  <step>If <id>s</id> is a List of errors, then   <step-list>
    <step>Perform HostReportErrors ( <id>s</id> ).</step>
    <step>Return NormalCompletion ( <value>undefined</value> ).</step>
  </step-list></step>
  <step>Return ? ScriptEvaluation ( <id>s</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>hasDuplicates</id> be ContainsDuplicateLabels of ModuleItemList with argument <id>labelSet</id> .</step>
  <step>If <id>hasDuplicates</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return ContainsDuplicateLabels of ModuleItem with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>hasUndefinedLabels</id> be ContainsUndefinedBreakTarget of ModuleItemList with argument <id>labelSet</id> .</step>
  <step>If <id>hasUndefinedLabels</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return ContainsUndefinedBreakTarget of ModuleItem with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>hasUndefinedLabels</id> be ContainsUndefinedContinueTarget of ModuleItemList with arguments <id>iterationSet</id> and « ».</step>
  <step>If <id>hasUndefinedLabels</id> is <value>true</value> , return <value>true</value> .</step>
  <step>Return ContainsUndefinedContinueTarget of ModuleItem with arguments <id>iterationSet</id> and « ».</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be ExportedBindings of ModuleItemList .</step>
  <step>Append to <id>names</id> the elements of the ExportedBindings of ModuleItem .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be ExportedNames of ModuleItemList .</step>
  <step>Append to <id>names</id> the elements of the ExportedNames of ModuleItem .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>Return the ExportedNames of ExportDeclaration .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Let <id>entries</id> be ExportEntries of ModuleItemList .</step>
  <step>Append to <id>entries</id> the elements of the ExportEntries of ModuleItem .</step>
  <step>Return <id>entries</id> .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Let <id>entries</id> be ImportEntries of ModuleItemList .</step>
  <step>Append to <id>entries</id> the elements of the ImportEntries of ModuleItem .</step>
  <step>Return <id>entries</id> .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Let <id>localNames</id> be a new empty List .</step>
  <step>For each ImportEntry Record  <id>i</id> in <id>importEntries</id> , do   <step-list>
    <step>Append <id>i</id> .[[LocalName]] to <id>localNames</id> .</step>
  </step-list></step>
  <step>Return <id>localNames</id> .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return ModuleRequests of ModuleItem .</step>
</step-list>
<step-list>
  <step>Let <id>moduleNames</id> be ModuleRequests of ModuleItemList .</step>
  <step>Let <id>additionalNames</id> be ModuleRequests of ModuleItem .</step>
  <step>Append to <id>moduleNames</id> each element of <id>additionalNames</id> that is not already an element of <id>moduleNames</id> .</step>
  <step>Return <id>moduleNames</id> .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be LexicallyDeclaredNames of ModuleItemList .</step>
  <step>Append to <id>names</id> the elements of the LexicallyDeclaredNames of ModuleItem .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>Return the BoundNames of ImportDeclaration .</step>
</step-list>
<step-list>
  <step>If ExportDeclaration is <value>export</value>  VariableStatement , return a new empty List .</step>
  <step>Return the BoundNames of ExportDeclaration .</step>
</step-list>
<step-list>
  <step>Return LexicallyDeclaredNames of StatementListItem .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Let <id>declarations</id> be LexicallyScopedDeclarations of ModuleItemList .</step>
  <step>Append to <id>declarations</id> the elements of the LexicallyScopedDeclarations of ModuleItem .</step>
  <step>Return <id>declarations</id> .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be VarDeclaredNames of ModuleItemList .</step>
  <step>Append to <id>names</id> the elements of the VarDeclaredNames of ModuleItem .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>If ExportDeclaration is <value>export</value>  VariableStatement , return BoundNames of ExportDeclaration .</step>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Let <id>declarations</id> be VarScopedDeclarations of ModuleItemList .</step>
  <step>Append to <id>declarations</id> the elements of the VarScopedDeclarations of ModuleItem .</step>
  <step>Return <id>declarations</id> .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>If ExportDeclaration is <value>export</value>  VariableStatement , return VarScopedDeclarations of VariableStatement .</step>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Assert : <id>sourceText</id> is an ECMAScript source text (see clause 10 ).</step>
  <step>Parse <id>sourceText</id> using Module as the goal symbol and analyse the parse result for any Early Error conditions. If the parse was successful and no early errors were found, let <id>body</id> be the resulting parse tree. Otherwise, let <id>body</id> be a List of one or more <value>SyntaxError</value> or <value>ReferenceError</value> objects representing the parsing errors and/or early errors. Parsing and early error detection may be interweaved in an implementation-dependent manner. If more than one parsing error or early error is present, the number and ordering of error objects in the list is implementation-dependent, but at least one must be present.</step>
  <step>If <id>body</id> is a List of errors, return <id>body</id> .</step>
  <step>Let <id>requestedModules</id> be the ModuleRequests of <id>body</id> .</step>
  <step>Let <id>importEntries</id> be ImportEntries of <id>body</id> .</step>
  <step>Let <id>importedBoundNames</id> be ImportedLocalNames ( <id>importEntries</id> ).</step>
  <step>Let <id>indirectExportEntries</id> be a new empty List .</step>
  <step>Let <id>localExportEntries</id> be a new empty List .</step>
  <step>Let <id>starExportEntries</id> be a new empty List .</step>
  <step>Let <id>exportEntries</id> be ExportEntries of <id>body</id> .</step>
  <step>For each ExportEntry Record  <id>ee</id> in <id>exportEntries</id> , do   <step-list>
    <step>If <id>ee</id> .[[ModuleRequest]] is <value>null</value> , then     <step-list>
      <step>If <id>ee</id> .[[LocalName]] is not an element of <id>importedBoundNames</id> , then       <step-list>
        <step>Append <id>ee</id> to <id>localExportEntries</id> .</step>
      </step-list></step>
      <step>Else,       <step-list>
        <step>Let <id>ie</id> be the element of <id>importEntries</id> whose [[LocalName]] is the same as <id>ee</id> .[[LocalName]].</step>
        <step>If <id>ie</id> .[[ImportName]] is <value>"*"</value> , then         <step-list>
          <step>Assert : This is a re-export of an imported module namespace object.</step>
          <step>Append <id>ee</id> to <id>localExportEntries</id> .</step>
        </step-list></step>
        <step>Else this is a re-export of a single name,         <step-list>
          <step>Append the ExportEntry Record { [[ModuleRequest]]: <id>ie</id> .[[ModuleRequest]], [[ImportName]]: <id>ie</id> .[[ImportName]], [[LocalName]]: <value>null</value> , [[ExportName]]: <id>ee</id> .[[ExportName]] } to <id>indirectExportEntries</id> .</step>
        </step-list></step>
      </step-list></step>
    </step-list></step>
    <step>Else if <id>ee</id> .[[ImportName]] is <value>"*"</value> , then     <step-list>
      <step>Append <id>ee</id> to <id>starExportEntries</id> .</step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>Append <id>ee</id> to <id>indirectExportEntries</id> .</step>
    </step-list></step>
  </step-list></step>
  <step>Return Source Text Module Record { [[Realm]]: <id>realm</id> , [[Environment]]: <value>undefined</value> , [[Namespace]]: <value>undefined</value> , [[Status]]: <value>"uninstantiated"</value> , [[EvaluationError]]: <value>undefined</value> , [[HostDefined]]: <id>hostDefined</id> , [[ECMAScriptCode]]: <id>body</id> , [[RequestedModules]]: <id>requestedModules</id> , [[ImportEntries]]: <id>importEntries</id> , [[LocalExportEntries]]: <id>localExportEntries</id> , [[IndirectExportEntries]]: <id>indirectExportEntries</id> , [[StarExportEntries]]: <id>starExportEntries</id> , [[DFSIndex]]: <value>undefined</value> , [[DFSAncestorIndex]]: <value>undefined</value> }.</step>
</step-list>
<step-list>
  <step>Let <id>module</id> be this Source Text Module Record .</step>
  <step>If <id>exportStarSet</id> contains <id>module</id> , then   <step-list>
    <step>Assert : We've reached the starting point of an <value>import *</value> circularity.</step>
    <step>Return a new empty List .</step>
  </step-list></step>
  <step>Append <id>module</id> to <id>exportStarSet</id> .</step>
  <step>Let <id>exportedNames</id> be a new empty List .</step>
  <step>For each ExportEntry Record  <id>e</id> in <id>module</id> .[[LocalExportEntries]], do   <step-list>
    <step>Assert : <id>module</id> provides the direct binding for this export.</step>
    <step>Append <id>e</id> .[[ExportName]] to <id>exportedNames</id> .</step>
  </step-list></step>
  <step>For each ExportEntry Record  <id>e</id> in <id>module</id> .[[IndirectExportEntries]], do   <step-list>
    <step>Assert : <id>module</id> imports a specific binding for this export.</step>
    <step>Append <id>e</id> .[[ExportName]] to <id>exportedNames</id> .</step>
  </step-list></step>
  <step>For each ExportEntry Record  <id>e</id> in <id>module</id> .[[StarExportEntries]], do   <step-list>
    <step>Let <id>requestedModule</id> be ? HostResolveImportedModule ( <id>module</id> , <id>e</id> .[[ModuleRequest]]).</step>
    <step>Let <id>starNames</id> be ? <id>requestedModule</id> .GetExportedNames( <id>exportStarSet</id> ).</step>
    <step>For each element <id>n</id> of <id>starNames</id> , do     <step-list>
      <step>If SameValue ( <id>n</id> , <value>"default"</value> ) is <value>false</value> , then       <step-list>
        <step>If <id>n</id> is not an element of <id>exportedNames</id> , then         <step-list>
          <step>Append <id>n</id> to <id>exportedNames</id> .</step>
        </step-list></step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
  <step>Return <id>exportedNames</id> .</step>
</step-list>
<step-list>
  <step>Let <id>module</id> be this Source Text Module Record .</step>
  <step>For each Record { [[Module]], [[ExportName]] } <id>r</id> in <id>resolveSet</id> , do   <step-list>
    <step>If <id>module</id> and <id>r</id> .[[Module]] are the same Module Record and SameValue ( <id>exportName</id> , <id>r</id> .[[ExportName]]) is <value>true</value> , then     <step-list>
      <step>Assert : This is a circular import request.</step>
      <step>Return <value>null</value> .</step>
    </step-list></step>
  </step-list></step>
  <step>Append the Record { [[Module]]: <id>module</id> , [[ExportName]]: <id>exportName</id> } to <id>resolveSet</id> .</step>
  <step>For each ExportEntry Record  <id>e</id> in <id>module</id> .[[LocalExportEntries]], do   <step-list>
    <step>If SameValue ( <id>exportName</id> , <id>e</id> .[[ExportName]]) is <value>true</value> , then     <step-list>
      <step>Assert : <id>module</id> provides the direct binding for this export.</step>
      <step>Return ResolvedBinding Record { [[Module]]: <id>module</id> , [[BindingName]]: <id>e</id> .[[LocalName]] }.</step>
    </step-list></step>
  </step-list></step>
  <step>For each ExportEntry Record  <id>e</id> in <id>module</id> .[[IndirectExportEntries]], do   <step-list>
    <step>If SameValue ( <id>exportName</id> , <id>e</id> .[[ExportName]]) is <value>true</value> , then     <step-list>
      <step>Assert : <id>module</id> imports a specific binding for this export.</step>
      <step>Let <id>importedModule</id> be ? HostResolveImportedModule ( <id>module</id> , <id>e</id> .[[ModuleRequest]]).</step>
      <step>Return <id>importedModule</id> .ResolveExport( <id>e</id> .[[ImportName]], <id>resolveSet</id> ).</step>
    </step-list></step>
  </step-list></step>
  <step>If SameValue ( <id>exportName</id> , <value>"default"</value> ) is <value>true</value> , then   <step-list>
    <step>Assert : A <value>default</value> export was not explicitly defined by this module.</step>
    <step>Return <value>null</value> .</step>
    <step>NOTE: A <value>default</value> export cannot be provided by an <value>export *</value> .</step>
  </step-list></step>
  <step>Let <id>starResolution</id> be <value>null</value> .</step>
  <step>For each ExportEntry Record  <id>e</id> in <id>module</id> .[[StarExportEntries]], do   <step-list>
    <step>Let <id>importedModule</id> be ? HostResolveImportedModule ( <id>module</id> , <id>e</id> .[[ModuleRequest]]).</step>
    <step>Let <id>resolution</id> be ? <id>importedModule</id> .ResolveExport( <id>exportName</id> , <id>resolveSet</id> ).</step>
    <step>If <id>resolution</id> is <value>"ambiguous"</value> , return <value>"ambiguous"</value> .</step>
    <step>If <id>resolution</id> is not <value>null</value> , then     <step-list>
      <step>Assert : <id>resolution</id> is a ResolvedBinding Record .</step>
      <step>If <id>starResolution</id> is <value>null</value> , set <id>starResolution</id> to <id>resolution</id> .</step>
      <step>Else,       <step-list>
        <step>Assert : There is more than one <value>*</value> import that includes the requested name.</step>
        <step>If <id>resolution</id> .[[Module]] and <id>starResolution</id> .[[Module]] are not the same Module Record or SameValue ( <id>resolution</id> .[[BindingName]], <id>starResolution</id> .[[BindingName]]) is <value>false</value> , return <value>"ambiguous"</value> .</step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
  <step>Return <id>starResolution</id> .</step>
</step-list>
<step-list>
  <step>Let <id>module</id> be this Source Text Module Record .</step>
  <step>Assert : <id>module</id> .[[Status]] is not <value>"instantiating"</value> or <value>"evaluating"</value> .</step>
  <step>Let <id>stack</id> be a new empty List .</step>
  <step>Let <id>result</id> be InnerModuleInstantiation ( <id>module</id> , <id>stack</id> , 0).</step>
  <step>If <id>result</id> is an abrupt completion , then   <step-list>
    <step>For each module <id>m</id> in <id>stack</id> , do     <step-list>
      <step>Assert : <id>m</id> .[[Status]] is <value>"instantiating"</value> .</step>
      <step>Set <id>m</id> .[[Status]] to <value>"uninstantiated"</value> .</step>
      <step>Set <id>m</id> .[[Environment]] to <value>undefined</value> .</step>
      <step>Set <id>m</id> .[[DFSIndex]] to <value>undefined</value> .</step>
      <step>Set <id>m</id> .[[DFSAncestorIndex]] to <value>undefined</value> .</step>
    </step-list></step>
    <step>Assert : <id>module</id> .[[Status]] is <value>"uninstantiated"</value> .</step>
    <step>Return <id>result</id> .</step>
  </step-list></step>
  <step>Assert : <id>module</id> .[[Status]] is <value>"instantiated"</value> or <value>"evaluated"</value> .</step>
  <step>Assert : <id>stack</id> is empty.</step>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>If <id>module</id> is not a Source Text Module Record , then   <step-list>
    <step>Perform ? <id>module</id> .Instantiate().</step>
    <step>Return <id>index</id> .</step>
  </step-list></step>
  <step>If <id>module</id> .[[Status]] is <value>"instantiating"</value> , <value>"instantiated"</value> , or <value>"evaluated"</value> , then   <step-list>
    <step>Return <id>index</id> .</step>
  </step-list></step>
  <step>Assert : <id>module</id> .[[Status]] is <value>"uninstantiated"</value> .</step>
  <step>Set <id>module</id> .[[Status]] to <value>"instantiating"</value> .</step>
  <step>Set <id>module</id> .[[DFSIndex]] to <id>index</id> .</step>
  <step>Set <id>module</id> .[[DFSAncestorIndex]] to <id>index</id> .</step>
  <step>Set <id>index</id> to <id>index</id> + 1.</step>
  <step>Append <id>module</id> to <id>stack</id> .</step>
  <step>For each String <id>required</id> that is an element of <id>module</id> .[[RequestedModules]], do   <step-list>
    <step>Let <id>requiredModule</id> be ? HostResolveImportedModule ( <id>module</id> , <id>required</id> ).</step>
    <step>Set <id>index</id> to ? InnerModuleInstantiation ( <id>requiredModule</id> , <id>stack</id> , <id>index</id> ).</step>
    <step>Assert : <id>requiredModule</id> .[[Status]] is either <value>"instantiating"</value> , <value>"instantiated"</value> , or <value>"evaluated"</value> .</step>
    <step>Assert : <id>requiredModule</id> .[[Status]] is <value>"instantiating"</value> if and only if <id>requiredModule</id> is in <id>stack</id> .</step>
    <step>If <id>requiredModule</id> .[[Status]] is <value>"instantiating"</value> , then     <step-list>
      <step>Assert : <id>requiredModule</id> is a Source Text Module Record .</step>
      <step>Set <id>module</id> .[[DFSAncestorIndex]] to min ( <id>module</id> .[[DFSAncestorIndex]], <id>requiredModule</id> .[[DFSAncestorIndex]]).</step>
    </step-list></step>
  </step-list></step>
  <step>Perform ? ModuleDeclarationEnvironmentSetup ( <id>module</id> ).</step>
  <step>Assert : <id>module</id> occurs exactly once in <id>stack</id> .</step>
  <step>Assert : <id>module</id> .[[DFSAncestorIndex]] is less than or equal to <id>module</id> .[[DFSIndex]].</step>
  <step>If <id>module</id> .[[DFSAncestorIndex]] equals <id>module</id> .[[DFSIndex]], then   <step-list>
    <step>Let <id>done</id> be <value>false</value> .</step>
    <step>Repeat, while <id>done</id> is <value>false</value> ,     <step-list>
      <step>Let <id>requiredModule</id> be the last element in <id>stack</id> .</step>
      <step>Remove the last element of <id>stack</id> .</step>
      <step>Set <id>requiredModule</id> .[[Status]] to <value>"instantiated"</value> .</step>
      <step>If <id>requiredModule</id> and <id>module</id> are the same Module Record , set <id>done</id> to <value>true</value> .</step>
    </step-list></step>
  </step-list></step>
  <step>Return <id>index</id> .</step>
</step-list>
<step-list>
  <step>For each ExportEntry Record  <id>e</id> in <id>module</id> .[[IndirectExportEntries]], do   <step-list>
    <step>Let <id>resolution</id> be ? <id>module</id> .ResolveExport( <id>e</id> .[[ExportName]], « »).</step>
    <step>If <id>resolution</id> is <value>null</value> or <value>"ambiguous"</value> , throw a <value>SyntaxError</value> exception.</step>
    <step>Assert : <id>resolution</id> is a ResolvedBinding Record .</step>
  </step-list></step>
  <step>Assert : All named exports from <id>module</id> are resolvable.</step>
  <step>Let <id>realm</id> be <id>module</id> .[[Realm]].</step>
  <step>Assert : <id>realm</id> is not <value>undefined</value> .</step>
  <step>Let <id>env</id> be NewModuleEnvironment ( <id>realm</id> .[[GlobalEnv]]).</step>
  <step>Set <id>module</id> .[[Environment]] to <id>env</id> .</step>
  <step>Let <id>envRec</id> be <id>env</id> 's EnvironmentRecord .</step>
  <step>For each ImportEntry Record  <id>in</id> in <id>module</id> .[[ImportEntries]], do   <step-list>
    <step>Let <id>importedModule</id> be ! HostResolveImportedModule ( <id>module</id> , <id>in</id> .[[ModuleRequest]]).</step>
    <step>NOTE: The above call cannot fail because imported module requests are a subset of <id>module</id> .[[RequestedModules]], and these have been resolved earlier in this algorithm.</step>
    <step>If <id>in</id> .[[ImportName]] is <value>"*"</value> , then     <step-list>
      <step>Let <id>namespace</id> be ? GetModuleNamespace ( <id>importedModule</id> ).</step>
      <step>Perform ! <id>envRec</id> .CreateImmutableBinding( <id>in</id> .[[LocalName]], <value>true</value> ).</step>
      <step>Call <id>envRec</id> .InitializeBinding( <id>in</id> .[[LocalName]], <id>namespace</id> ).</step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>Let <id>resolution</id> be ? <id>importedModule</id> .ResolveExport( <id>in</id> .[[ImportName]], « »).</step>
      <step>If <id>resolution</id> is <value>null</value> or <value>"ambiguous"</value> , throw a <value>SyntaxError</value> exception.</step>
      <step>Call <id>envRec</id> .CreateImportBinding( <id>in</id> .[[LocalName]], <id>resolution</id> .[[Module]], <id>resolution</id> .[[BindingName]]).</step>
    </step-list></step>
  </step-list></step>
  <step>Let <id>code</id> be <id>module</id> .[[ECMAScriptCode]].</step>
  <step>Let <id>varDeclarations</id> be the VarScopedDeclarations of <id>code</id> .</step>
  <step>Let <id>declaredVarNames</id> be a new empty List .</step>
  <step>For each element <id>d</id> in <id>varDeclarations</id> , do   <step-list>
    <step>For each element <id>dn</id> of the BoundNames of <id>d</id> , do     <step-list>
      <step>If <id>dn</id> is not an element of <id>declaredVarNames</id> , then       <step-list>
        <step>Perform ! <id>envRec</id> .CreateMutableBinding( <id>dn</id> , <value>false</value> ).</step>
        <step>Call <id>envRec</id> .InitializeBinding( <id>dn</id> , <value>undefined</value> ).</step>
        <step>Append <id>dn</id> to <id>declaredVarNames</id> .</step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
  <step>Let <id>lexDeclarations</id> be the LexicallyScopedDeclarations of <id>code</id> .</step>
  <step>For each element <id>d</id> in <id>lexDeclarations</id> , do   <step-list>
    <step>For each element <id>dn</id> of the BoundNames of <id>d</id> , do     <step-list>
      <step>If IsConstantDeclaration of <id>d</id> is <value>true</value> , then       <step-list>
        <step>Perform ! <id>envRec</id> .CreateImmutableBinding( <id>dn</id> , <value>true</value> ).</step>
      </step-list></step>
      <step>Else,       <step-list>
        <step>Perform ! <id>envRec</id> .CreateMutableBinding( <id>dn</id> , <value>false</value> ).</step>
      </step-list></step>
      <step>If <id>d</id> is a FunctionDeclaration , a GeneratorDeclaration , an AsyncFunctionDeclaration , or an AsyncGeneratorDeclaration , then       <step-list>
        <step>Let <id>fo</id> be the result of performing InstantiateFunctionObject for <id>d</id> with argument <id>env</id> .</step>
        <step>Call <id>envRec</id> .InitializeBinding( <id>dn</id> , <id>fo</id> ).</step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>module</id> be this Source Text Module Record .</step>
  <step>Assert : <id>module</id> .[[Status]] is <value>"instantiated"</value> or <value>"evaluated"</value> .</step>
  <step>Let <id>stack</id> be a new empty List .</step>
  <step>Let <id>result</id> be InnerModuleEvaluation ( <id>module</id> , <id>stack</id> , 0).</step>
  <step>If <id>result</id> is an abrupt completion , then   <step-list>
    <step>For each module <id>m</id> in <id>stack</id> , do     <step-list>
      <step>Assert : <id>m</id> .[[Status]] is <value>"evaluating"</value> .</step>
      <step>Set <id>m</id> .[[Status]] to <value>"evaluated"</value> .</step>
      <step>Set <id>m</id> .[[EvaluationError]] to <id>result</id> .</step>
    </step-list></step>
    <step>Assert : <id>module</id> .[[Status]] is <value>"evaluated"</value> and <id>module</id> .[[EvaluationError]] is <id>result</id> .</step>
    <step>Return <id>result</id> .</step>
  </step-list></step>
  <step>Assert : <id>module</id> .[[Status]] is <value>"evaluated"</value> and <id>module</id> .[[EvaluationError]] is <value>undefined</value> .</step>
  <step>Assert : <id>stack</id> is empty.</step>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>If <id>module</id> is not a Source Text Module Record , then   <step-list>
    <step>Perform ? <id>module</id> .Evaluate().</step>
    <step>Return <id>index</id> .</step>
  </step-list></step>
  <step>If <id>module</id> .[[Status]] is <value>"evaluated"</value> , then   <step-list>
    <step>If <id>module</id> .[[EvaluationError]] is <value>undefined</value> , return <id>index</id> .</step>
    <step>Otherwise return <id>module</id> .[[EvaluationError]].</step>
  </step-list></step>
  <step>If <id>module</id> .[[Status]] is <value>"evaluating"</value> , return <id>index</id> .</step>
  <step>Assert : <id>module</id> .[[Status]] is <value>"instantiated"</value> .</step>
  <step>Set <id>module</id> .[[Status]] to <value>"evaluating"</value> .</step>
  <step>Set <id>module</id> .[[DFSIndex]] to <id>index</id> .</step>
  <step>Set <id>module</id> .[[DFSAncestorIndex]] to <id>index</id> .</step>
  <step>Set <id>index</id> to <id>index</id> + 1.</step>
  <step>Append <id>module</id> to <id>stack</id> .</step>
  <step>For each String <id>required</id> that is an element of <id>module</id> .[[RequestedModules]], do   <step-list>
    <step>Let <id>requiredModule</id> be ! HostResolveImportedModule ( <id>module</id> , <id>required</id> ).</step>
    <step>NOTE:
 Instantiate must be completed successfully prior to invoking this 
method, so every requested module is guaranteed to resolve successfully.</step>
    <step>Set <id>index</id> to ? InnerModuleEvaluation ( <id>requiredModule</id> , <id>stack</id> , <id>index</id> ).</step>
    <step>Assert : <id>requiredModule</id> .[[Status]] is either <value>"evaluating"</value> or <value>"evaluated"</value> .</step>
    <step>Assert : <id>requiredModule</id> .[[Status]] is <value>"evaluating"</value> if and only if <id>requiredModule</id> is in <id>stack</id> .</step>
    <step>If <id>requiredModule</id> .[[Status]] is <value>"evaluating"</value> , then     <step-list>
      <step>Assert : <id>requiredModule</id> is a Source Text Module Record .</step>
      <step>Set <id>module</id> .[[DFSAncestorIndex]] to min ( <id>module</id> .[[DFSAncestorIndex]], <id>requiredModule</id> .[[DFSAncestorIndex]]).</step>
    </step-list></step>
  </step-list></step>
  <step>Perform ? ModuleExecution ( <id>module</id> ).</step>
  <step>Assert : <id>module</id> occurs exactly once in <id>stack</id> .</step>
  <step>Assert : <id>module</id> .[[DFSAncestorIndex]] is less than or equal to <id>module</id> .[[DFSIndex]].</step>
  <step>If <id>module</id> .[[DFSAncestorIndex]] equals <id>module</id> .[[DFSIndex]], then   <step-list>
    <step>Let <id>done</id> be <value>false</value> .</step>
    <step>Repeat, while <id>done</id> is <value>false</value> ,     <step-list>
      <step>Let <id>requiredModule</id> be the last element in <id>stack</id> .</step>
      <step>Remove the last element of <id>stack</id> .</step>
      <step>Set <id>requiredModule</id> .[[Status]] to <value>"evaluated"</value> .</step>
      <step>If <id>requiredModule</id> and <id>module</id> are the same Module Record , set <id>done</id> to <value>true</value> .</step>
    </step-list></step>
  </step-list></step>
  <step>Return <id>index</id> .</step>
</step-list>
<step-list>
  <step>Let <id>moduleCxt</id> be a new ECMAScript code execution context .</step>
  <step>Set the Function of <id>moduleCxt</id> to <value>null</value> .</step>
  <step>Assert : <id>module</id> .[[Realm]] is not <value>undefined</value> .</step>
  <step>Set the Realm of <id>moduleCxt</id> to <id>module</id> .[[Realm]].</step>
  <step>Set the ScriptOrModule of <id>moduleCxt</id> to <id>module</id> .</step>
  <step>Assert : <id>module</id> has been linked and declarations in its module environment have been instantiated.</step>
  <step>Set the VariableEnvironment of <id>moduleCxt</id> to <id>module</id> .[[Environment]].</step>
  <step>Set the LexicalEnvironment of <id>moduleCxt</id> to <id>module</id> .[[Environment]].</step>
  <step>Suspend the currently running execution context .</step>
  <step>Push <id>moduleCxt</id> on to the execution context stack ; <id>moduleCxt</id> is now the running execution context .</step>
  <step>Let <id>result</id> be the result of evaluating <id>module</id> .[[ECMAScriptCode]].</step>
  <step>Suspend  <id>moduleCxt</id> and remove it from the execution context stack .</step>
  <step>Resume the context that is now on the top of the execution context stack as the running execution context .</step>
  <step>Return Completion ( <id>result</id> ).</step>
</step-list>
<step-list>
  <step>Assert : <id>module</id> is an instance of a concrete subclass of Module Record .</step>
  <step>Assert : <id>module</id> .[[Status]] is not <value>"uninstantiated"</value> .</step>
  <step>Assert : If <id>module</id> .[[Status]] is <value>"evaluated"</value> , <id>module</id> .[[EvaluationError]] is <value>undefined</value> .</step>
  <step>Let <id>namespace</id> be <id>module</id> .[[Namespace]].</step>
  <step>If <id>namespace</id> is <value>undefined</value> , then   <step-list>
    <step>Let <id>exportedNames</id> be ? <id>module</id> .GetExportedNames(« »).</step>
    <step>Let <id>unambiguousNames</id> be a new empty List .</step>
    <step>For each <id>name</id> that is an element of <id>exportedNames</id> , do     <step-list>
      <step>Let <id>resolution</id> be ? <id>module</id> .ResolveExport( <id>name</id> , « »).</step>
      <step>If <id>resolution</id> is a ResolvedBinding Record , append <id>name</id> to <id>unambiguousNames</id> .</step>
    </step-list></step>
    <step>Set <id>namespace</id> to ModuleNamespaceCreate ( <id>module</id> , <id>unambiguousNames</id> ).</step>
  </step-list></step>
  <step>Return <id>namespace</id> .</step>
</step-list>
<step-list>
  <step>Assert : <id>sourceText</id> is an ECMAScript source text (see clause 10 ).</step>
  <step>Let <id>realm</id> be the current Realm Record .</step>
  <step>Let <id>m</id> be ParseModule ( <id>sourceText</id> , <id>realm</id> , <id>hostDefined</id> ).</step>
  <step>If <id>m</id> is a List of errors, then   <step-list>
    <step>Perform HostReportErrors ( <id>m</id> ).</step>
    <step>Return NormalCompletion ( <value>undefined</value> ).</step>
  </step-list></step>
  <step>Perform ? <id>m</id> .Instantiate().</step>
  <step>Assert : All dependencies of <id>m</id> have been transitively resolved and <id>m</id> is ready for evaluation.</step>
  <step>Return ? <id>m</id> .Evaluate().</step>
</step-list>
<step-list>
  <step>Return NormalCompletion ( <value>undefined</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>result</id> be the result of evaluating ModuleItemList .</step>
  <step>If <id>result</id> .[[Type]] is <value>normal</value> and <id>result</id> .[[Value]] is <value>empty</value> , then   <step-list>
    <step>Return NormalCompletion ( <value>undefined</value> ).</step>
  </step-list></step>
  <step>Return Completion ( <id>result</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>sl</id> be the result of evaluating ModuleItemList .</step>
  <step>ReturnIfAbrupt ( <id>sl</id> ).</step>
  <step>Let <id>s</id> be the result of evaluating ModuleItem .</step>
  <step>Return Completion ( UpdateEmpty ( <id>s</id> , <id>sl</id> .[[Value]])).</step>
</step-list>
<step-list>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Return the BoundNames of ImportClause .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be the BoundNames of ImportedDefaultBinding .</step>
  <step>Append to <id>names</id> the elements of the BoundNames of NameSpaceImport .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be the BoundNames of ImportedDefaultBinding .</step>
  <step>Append to <id>names</id> the elements of the BoundNames of NamedImports .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be the BoundNames of ImportsList .</step>
  <step>Append to <id>names</id> the elements of the BoundNames of ImportSpecifier .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>Return the BoundNames of ImportedBinding .</step>
</step-list>
<step-list>
  <step>Let <id>module</id> be the sole element of ModuleRequests of FromClause .</step>
  <step>Return ImportEntriesForModule of ImportClause with argument <id>module</id> .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Let <id>entries</id> be ImportEntriesForModule of ImportedDefaultBinding with argument <id>module</id> .</step>
  <step>Append to <id>entries</id> the elements of the ImportEntriesForModule of NameSpaceImport with argument <id>module</id> .</step>
  <step>Return <id>entries</id> .</step>
</step-list>
<step-list>
  <step>Let <id>entries</id> be ImportEntriesForModule of ImportedDefaultBinding with argument <id>module</id> .</step>
  <step>Append to <id>entries</id> the elements of the ImportEntriesForModule of NamedImports with argument <id>module</id> .</step>
  <step>Return <id>entries</id> .</step>
</step-list>
<step-list>
  <step>Let <id>localName</id> be the sole element of BoundNames of ImportedBinding .</step>
  <step>Let <id>defaultEntry</id> be the ImportEntry Record { [[ModuleRequest]]: <id>module</id> , [[ImportName]]: <value>"default"</value> , [[LocalName]]: <id>localName</id> }.</step>
  <step>Return a new List containing <id>defaultEntry</id> .</step>
</step-list>
<step-list>
  <step>Let <id>localName</id> be the StringValue of ImportedBinding .</step>
  <step>Let <id>entry</id> be the ImportEntry Record { [[ModuleRequest]]: <id>module</id> , [[ImportName]]: <value>"*"</value> , [[LocalName]]: <id>localName</id> }.</step>
  <step>Return a new List containing <id>entry</id> .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Let <id>specs</id> be the ImportEntriesForModule of ImportsList with argument <id>module</id> .</step>
  <step>Append to <id>specs</id> the elements of the ImportEntriesForModule of ImportSpecifier with argument <id>module</id> .</step>
  <step>Return <id>specs</id> .</step>
</step-list>
<step-list>
  <step>Let <id>localName</id> be the sole element of BoundNames of ImportedBinding .</step>
  <step>Let <id>entry</id> be the ImportEntry Record { [[ModuleRequest]]: <id>module</id> , [[ImportName]]: <id>localName</id> , [[LocalName]]: <id>localName</id> }.</step>
  <step>Return a new List containing <id>entry</id> .</step>
</step-list>
<step-list>
  <step>Let <id>importName</id> be the StringValue of IdentifierName .</step>
  <step>Let <id>localName</id> be the StringValue of ImportedBinding .</step>
  <step>Let <id>entry</id> be the ImportEntry Record { [[ModuleRequest]]: <id>module</id> , [[ImportName]]: <id>importName</id> , [[LocalName]]: <id>localName</id> }.</step>
  <step>Return a new List containing <id>entry</id> .</step>
</step-list>
<step-list>
  <step>Return ModuleRequests of FromClause .</step>
</step-list>
<step-list>
  <step>Return a List containing the StringValue of StringLiteral .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return the BoundNames of VariableStatement .</step>
</step-list>
<step-list>
  <step>Return the BoundNames of Declaration .</step>
</step-list>
<step-list>
  <step>Let <id>declarationNames</id> be the BoundNames of HoistableDeclaration .</step>
  <step>If <id>declarationNames</id> does not include the element <value>"*default*"</value> , append <value>"*default*"</value> to <id>declarationNames</id> .</step>
  <step>Return <id>declarationNames</id> .</step>
</step-list>
<step-list>
  <step>Let <id>declarationNames</id> be the BoundNames of ClassDeclaration .</step>
  <step>If <id>declarationNames</id> does not include the element <value>"*default*"</value> , append <value>"*default*"</value> to <id>declarationNames</id> .</step>
  <step>Return <id>declarationNames</id> .</step>
</step-list>
<step-list>
  <step>Return « <value>"*default*"</value> ».</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return the ExportedBindings of ExportClause .</step>
</step-list>
<step-list>
  <step>Return the BoundNames of VariableStatement .</step>
</step-list>
<step-list>
  <step>Return the BoundNames of Declaration .</step>
</step-list>
<step-list>
  <step>Return the BoundNames of this ExportDeclaration .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be the ExportedBindings of ExportsList .</step>
  <step>Append to <id>names</id> the elements of the ExportedBindings of ExportSpecifier .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>Return a List containing the StringValue of IdentifierName .</step>
</step-list>
<step-list>
  <step>Return a List containing the StringValue of the first IdentifierName .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return the ExportedNames of ExportClause .</step>
</step-list>
<step-list>
  <step>Return the BoundNames of VariableStatement .</step>
</step-list>
<step-list>
  <step>Return the BoundNames of Declaration .</step>
</step-list>
<step-list>
  <step>Return « <value>"default"</value> ».</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be the ExportedNames of ExportsList .</step>
  <step>Append to <id>names</id> the elements of the ExportedNames of ExportSpecifier .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>Return a List containing the StringValue of IdentifierName .</step>
</step-list>
<step-list>
  <step>Return a List containing the StringValue of the second IdentifierName .</step>
</step-list>
<step-list>
  <step>Let <id>module</id> be the sole element of ModuleRequests of FromClause .</step>
  <step>Let <id>entry</id> be the ExportEntry Record { [[ModuleRequest]]: <id>module</id> , [[ImportName]]: <value>"*"</value> , [[LocalName]]: <value>null</value> , [[ExportName]]: <value>null</value> }.</step>
  <step>Return a new List containing <id>entry</id> .</step>
</step-list>
<step-list>
  <step>Let <id>module</id> be the sole element of ModuleRequests of FromClause .</step>
  <step>Return ExportEntriesForModule of ExportClause with argument <id>module</id> .</step>
</step-list>
<step-list>
  <step>Return ExportEntriesForModule of ExportClause with argument <value>null</value> .</step>
</step-list>
<step-list>
  <step>Let <id>entries</id> be a new empty List .</step>
  <step>Let <id>names</id> be the BoundNames of VariableStatement .</step>
  <step>For each <id>name</id> in <id>names</id> , do   <step-list>
    <step>Append the ExportEntry Record { [[ModuleRequest]]: <value>null</value> , [[ImportName]]: <value>null</value> , [[LocalName]]: <id>name</id> , [[ExportName]]: <id>name</id> } to <id>entries</id> .</step>
  </step-list></step>
  <step>Return <id>entries</id> .</step>
</step-list>
<step-list>
  <step>Let <id>entries</id> be a new empty List .</step>
  <step>Let <id>names</id> be the BoundNames of Declaration .</step>
  <step>For each <id>name</id> in <id>names</id> , do   <step-list>
    <step>Append the ExportEntry Record { [[ModuleRequest]]: <value>null</value> , [[ImportName]]: <value>null</value> , [[LocalName]]: <id>name</id> , [[ExportName]]: <id>name</id> } to <id>entries</id> .</step>
  </step-list></step>
  <step>Return <id>entries</id> .</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be BoundNames of HoistableDeclaration .</step>
  <step>Let <id>localName</id> be the sole element of <id>names</id> .</step>
  <step>Return a new List containing the ExportEntry Record { [[ModuleRequest]]: <value>null</value> , [[ImportName]]: <value>null</value> , [[LocalName]]: <id>localName</id> , [[ExportName]]: <value>"default"</value> }.</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be BoundNames of ClassDeclaration .</step>
  <step>Let <id>localName</id> be the sole element of <id>names</id> .</step>
  <step>Return a new List containing the ExportEntry Record { [[ModuleRequest]]: <value>null</value> , [[ImportName]]: <value>null</value> , [[LocalName]]: <id>localName</id> , [[ExportName]]: <value>"default"</value> }.</step>
</step-list>
<step-list>
  <step>Let <id>entry</id> be the ExportEntry Record { [[ModuleRequest]]: <value>null</value> , [[ImportName]]: <value>null</value> , [[LocalName]]: <value>"*default*"</value> , [[ExportName]]: <value>"default"</value> }.</step>
  <step>Return a new List containing <id>entry</id> .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Let <id>specs</id> be the ExportEntriesForModule of ExportsList with argument <id>module</id> .</step>
  <step>Append to <id>specs</id> the elements of the ExportEntriesForModule of ExportSpecifier with argument <id>module</id> .</step>
  <step>Return <id>specs</id> .</step>
</step-list>
<step-list>
  <step>Let <id>sourceName</id> be the StringValue of IdentifierName .</step>
  <step>If <id>module</id> is <value>null</value> , then   <step-list>
    <step>Let <id>localName</id> be <id>sourceName</id> .</step>
    <step>Let <id>importName</id> be <value>null</value> .</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>localName</id> be <value>null</value> .</step>
    <step>Let <id>importName</id> be <id>sourceName</id> .</step>
  </step-list></step>
  <step>Return a new List containing the ExportEntry Record { [[ModuleRequest]]: <id>module</id> , [[ImportName]]: <id>importName</id> , [[LocalName]]: <id>localName</id> , [[ExportName]]: <id>sourceName</id> }.</step>
</step-list>
<step-list>
  <step>Let <id>sourceName</id> be the StringValue of the first IdentifierName .</step>
  <step>Let <id>exportName</id> be the StringValue of the second IdentifierName .</step>
  <step>If <id>module</id> is <value>null</value> , then   <step-list>
    <step>Let <id>localName</id> be <id>sourceName</id> .</step>
    <step>Let <id>importName</id> be <value>null</value> .</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>localName</id> be <value>null</value> .</step>
    <step>Let <id>importName</id> be <id>sourceName</id> .</step>
  </step-list></step>
  <step>Return a new List containing the ExportEntry Record { [[ModuleRequest]]: <id>module</id> , [[ImportName]]: <id>importName</id> , [[LocalName]]: <id>localName</id> , [[ExportName]]: <id>exportName</id> }.</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return a new List containing DeclarationPart of Declaration .</step>
</step-list>
<step-list>
  <step>Return a new List containing DeclarationPart of HoistableDeclaration .</step>
</step-list>
<step-list>
  <step>Return a new List containing ClassDeclaration .</step>
</step-list>
<step-list>
  <step>Return a new List containing this ExportDeclaration .</step>
</step-list>
<step-list>
  <step>Return the ModuleRequests of FromClause .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Return a new empty List .</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be the ReferencedBindings of ExportsList .</step>
  <step>Append to <id>names</id> the elements of the ReferencedBindings of ExportSpecifier .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>Return a List containing the IdentifierName .</step>
</step-list>
<step-list>
  <step>Return a List containing the first IdentifierName .</step>
</step-list>
<step-list>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Return the result of evaluating VariableStatement .</step>
</step-list>
<step-list>
  <step>Return the result of evaluating Declaration .</step>
</step-list>
<step-list>
  <step>Return the result of evaluating HoistableDeclaration .</step>
</step-list>
<step-list>
  <step>Let <id>value</id> be the result of BindingClassDeclarationEvaluation of ClassDeclaration .</step>
  <step>ReturnIfAbrupt ( <id>value</id> ).</step>
  <step>Let <id>className</id> be the sole element of BoundNames of ClassDeclaration .</step>
  <step>If <id>className</id> is <value>"*default*"</value> , then   <step-list>
    <step>Let <id>hasNameProperty</id> be ? HasOwnProperty ( <id>value</id> , <value>"name"</value> ).</step>
    <step>If <id>hasNameProperty</id> is <value>false</value> , perform SetFunctionName ( <id>value</id> , <value>"default"</value> ).</step>
    <step>Let <id>env</id> be the running execution context 's LexicalEnvironment.</step>
    <step>Perform ? InitializeBoundName ( <value>"*default*"</value> , <id>value</id> , <id>env</id> ).</step>
  </step-list></step>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>rhs</id> be the result of evaluating AssignmentExpression .</step>
  <step>Let <id>value</id> be ? GetValue ( <id>rhs</id> ).</step>
  <step>If IsAnonymousFunctionDefinition ( AssignmentExpression ) is <value>true</value> , then   <step-list>
    <step>Let <id>hasNameProperty</id> be ? HasOwnProperty ( <id>value</id> , <value>"name"</value> ).</step>
    <step>If <id>hasNameProperty</id> is <value>false</value> , perform SetFunctionName ( <id>value</id> , <value>"default"</value> ).</step>
  </step-list></step>
  <step>Let <id>env</id> be the running execution context 's LexicalEnvironment.</step>
  <step>Perform ? InitializeBoundName ( <value>"*default*"</value> , <id>value</id> , <id>env</id> ).</step>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Assert : The execution context stack has at least two elements.</step>
  <step>Let <id>callerContext</id> be the second to top element of the execution context stack .</step>
  <step>Let <id>callerRealm</id> be <id>callerContext</id> 's Realm .</step>
  <step>Let <id>calleeRealm</id> be the current Realm Record .</step>
  <step>Perform ? HostEnsureCanCompileStrings ( <id>callerRealm</id> , <id>calleeRealm</id> ).</step>
  <step>Return ? PerformEval ( <id>x</id> , <id>calleeRealm</id> , <value>false</value> , <value>false</value> ).</step>
</step-list>
<step-list>
  <step>Assert : If <id>direct</id> is <value>false</value> , then <id>strictCaller</id> is also <value>false</value> .</step>
  <step>If Type ( <id>x</id> ) is not String, return <id>x</id> .</step>
  <step>Let <id>thisEnvRec</id> be ! GetThisEnvironment ().</step>
  <step>If <id>thisEnvRec</id> is a function Environment Record , then   <step-list>
    <step>Let <id>F</id> be <id>thisEnvRec</id> .[[FunctionObject]].</step>
    <step>Let <id>inFunction</id> be <value>true</value> .</step>
    <step>Let <id>inMethod</id> be <id>thisEnvRec</id> .HasSuperBinding().</step>
    <step>If <id>F</id> .[[ConstructorKind]] is <value>"derived"</value> , let <id>inDerivedConstructor</id> be <value>true</value> ; otherwise, let <id>inDerivedConstructor</id> be <value>false</value> .</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>inFunction</id> be <value>false</value> .</step>
    <step>Let <id>inMethod</id> be <value>false</value> .</step>
    <step>Let <id>inDerivedConstructor</id> be <value>false</value> .</step>
  </step-list></step>
  <step>Let <id>script</id> be the ECMAScript code that is the result of parsing <id>x</id> , interpreted as UTF-16 encoded Unicode text as described in 6.1.4 , for the goal symbol  Script . If <id>inFunction</id> is <value>false</value> , additional early error rules from 18.2.1.1.1 are applied. If <id>inMethod</id> is <value>false</value> , additional early error rules from 18.2.1.1.2 are applied. If <id>inDerivedConstructor</id> is <value>false</value> , additional early error rules from 18.2.1.1.3 are applied. If the parse fails, throw a <value>SyntaxError</value> exception. If any early errors are detected, throw a <value>SyntaxError</value> or a <value>ReferenceError</value> exception, depending on the type of the error (but see also clause 16 ). Parsing and early error detection may be interweaved in an implementation-dependent manner.</step>
  <step>If <id>script</id> Contains ScriptBody is <value>false</value> , return <value>undefined</value> .</step>
  <step>Let <id>body</id> be the ScriptBody of <id>script</id> .</step>
  <step>If <id>strictCaller</id> is <value>true</value> , let <id>strictEval</id> be <value>true</value> .</step>
  <step>Else, let <id>strictEval</id> be IsStrict of <id>script</id> .</step>
  <step>Let <id>ctx</id> be the running execution context .</step>
  <step>NOTE: If <id>direct</id> is <value>true</value> , <id>ctx</id> will be the execution context that performed the direct eval . If <id>direct</id> is <value>false</value> , <id>ctx</id> will be the execution context for the invocation of the <value>eval</value> function.</step>
  <step>If <id>direct</id> is <value>true</value> , then   <step-list>
    <step>Let <id>lexEnv</id> be NewDeclarativeEnvironment ( <id>ctx</id> 's LexicalEnvironment).</step>
    <step>Let <id>varEnv</id> be <id>ctx</id> 's VariableEnvironment.</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>lexEnv</id> be NewDeclarativeEnvironment ( <id>evalRealm</id> .[[GlobalEnv]]).</step>
    <step>Let <id>varEnv</id> be <id>evalRealm</id> .[[GlobalEnv]].</step>
  </step-list></step>
  <step>If <id>strictEval</id> is <value>true</value> , set <id>varEnv</id> to <id>lexEnv</id> .</step>
  <step>If <id>ctx</id> is not already suspended, suspend <id>ctx</id> .</step>
  <step>Let <id>evalCxt</id> be a new ECMAScript code execution context .</step>
  <step>Set the <id>evalCxt</id> 's Function to <value>null</value> .</step>
  <step>Set the <id>evalCxt</id> 's Realm to <id>evalRealm</id> .</step>
  <step>Set the <id>evalCxt</id> 's ScriptOrModule to <id>ctx</id> 's ScriptOrModule.</step>
  <step>Set the <id>evalCxt</id> 's VariableEnvironment to <id>varEnv</id> .</step>
  <step>Set the <id>evalCxt</id> 's LexicalEnvironment to <id>lexEnv</id> .</step>
  <step>Push <id>evalCxt</id> on to the execution context stack ; <id>evalCxt</id> is now the running execution context .</step>
  <step>Let <id>result</id> be EvalDeclarationInstantiation ( <id>body</id> , <id>varEnv</id> , <id>lexEnv</id> , <id>strictEval</id> ).</step>
  <step>If <id>result</id> .[[Type]] is <value>normal</value> , then   <step-list>
    <step>Set <id>result</id> to the result of evaluating <id>body</id> .</step>
  </step-list></step>
  <step>If <id>result</id> .[[Type]] is <value>normal</value> and <id>result</id> .[[Value]] is <value>empty</value> , then   <step-list>
    <step>Set <id>result</id> to NormalCompletion ( <value>undefined</value> ).</step>
  </step-list></step>
  <step>Suspend  <id>evalCxt</id> and remove it from the execution context stack .</step>
  <step>Resume the context that is now on the top of the execution context stack as the running execution context .</step>
  <step>Return Completion ( <id>result</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>varNames</id> be the VarDeclaredNames of <id>body</id> .</step>
  <step>Let <id>varDeclarations</id> be the VarScopedDeclarations of <id>body</id> .</step>
  <step>Let <id>lexEnvRec</id> be <id>lexEnv</id> 's EnvironmentRecord .</step>
  <step>Let <id>varEnvRec</id> be <id>varEnv</id> 's EnvironmentRecord .</step>
  <step>If <id>strict</id> is <value>false</value> , then   <step-list>
    <step>If <id>varEnvRec</id> is a global Environment Record , then     <step-list>
      <step>For each <id>name</id> in <id>varNames</id> , do       <step-list>
        <step>If <id>varEnvRec</id> .HasLexicalDeclaration( <id>name</id> ) is <value>true</value> , throw a <value>SyntaxError</value> exception.</step>
        <step>NOTE: <value>eval</value> will not create a global var declaration that would be shadowed by a global lexical declaration.</step>
      </step-list></step>
    </step-list></step>
    <step>Let <id>thisLex</id> be <id>lexEnv</id> .</step>
    <step>Assert : The following loop will terminate.</step>
    <step>Repeat, while <id>thisLex</id> is not the same as <id>varEnv</id> ,     <step-list>
      <step>Let <id>thisEnvRec</id> be <id>thisLex</id> 's EnvironmentRecord .</step>
      <step>If <id>thisEnvRec</id> is not an object Environment Record , then       <step-list>
        <step>NOTE:
 The environment of with statements cannot contain any lexical 
declaration so it doesn't need to be checked for var/let hoisting 
conflicts.</step>
        <step>For each <id>name</id> in <id>varNames</id> , do         <step-list>
          <step>If <id>thisEnvRec</id> .HasBinding( <id>name</id> ) is <value>true</value> , then           <step-list>
            <step>Throw a <value>SyntaxError</value> exception.</step>
            <step>NOTE: Annex B.3.5 defines alternate semantics for the above step.</step>
          </step-list></step>
          <step>NOTE: A direct eval will not hoist var declaration over a like-named lexical declaration.</step>
        </step-list></step>
      </step-list></step>
      <step>Set <id>thisLex</id> to <id>thisLex</id> 's outer environment reference.</step>
    </step-list></step>
  </step-list></step>
  <step>Let <id>functionsToInitialize</id> be a new empty List .</step>
  <step>Let <id>declaredFunctionNames</id> be a new empty List .</step>
  <step>For each <id>d</id> in <id>varDeclarations</id> , in reverse list order, do   <step-list>
    <step>If <id>d</id> is neither a VariableDeclaration nor a ForBinding nor a BindingIdentifier , then     <step-list>
      <step>Assert : <id>d</id> is either a FunctionDeclaration , a GeneratorDeclaration , an AsyncFunctionDeclaration , or an AsyncGeneratorDeclaration .</step>
      <step>NOTE: If there are multiple function declarations for the same name, the last declaration is used.</step>
      <step>Let <id>fn</id> be the sole element of the BoundNames of <id>d</id> .</step>
      <step>If <id>fn</id> is not an element of <id>declaredFunctionNames</id> , then       <step-list>
        <step>If <id>varEnvRec</id> is a global Environment Record , then         <step-list>
          <step>Let <id>fnDefinable</id> be ? <id>varEnvRec</id> .CanDeclareGlobalFunction( <id>fn</id> ).</step>
          <step>If <id>fnDefinable</id> is <value>false</value> , throw a <value>TypeError</value> exception.</step>
        </step-list></step>
        <step>Append <id>fn</id> to <id>declaredFunctionNames</id> .</step>
        <step>Insert <id>d</id> as the first element of <id>functionsToInitialize</id> .</step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
  <step>NOTE: Annex B.3.3.3 adds additional steps at this point.</step>
  <step>Let <id>declaredVarNames</id> be a new empty List .</step>
  <step>For each <id>d</id> in <id>varDeclarations</id> , do   <step-list>
    <step>If <id>d</id> is a VariableDeclaration , a ForBinding , or a BindingIdentifier , then     <step-list>
      <step>For each String <id>vn</id> in the BoundNames of <id>d</id> , do       <step-list>
        <step>If <id>vn</id> is not an element of <id>declaredFunctionNames</id> , then         <step-list>
          <step>If <id>varEnvRec</id> is a global Environment Record , then           <step-list>
            <step>Let <id>vnDefinable</id> be ? <id>varEnvRec</id> .CanDeclareGlobalVar( <id>vn</id> ).</step>
            <step>If <id>vnDefinable</id> is <value>false</value> , throw a <value>TypeError</value> exception.</step>
          </step-list></step>
          <step>If <id>vn</id> is not an element of <id>declaredVarNames</id> , then           <step-list>
            <step>Append <id>vn</id> to <id>declaredVarNames</id> .</step>
          </step-list></step>
        </step-list></step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
  <step>NOTE: No abnormal terminations occur after this algorithm step unless <id>varEnvRec</id> is a global Environment Record and the global object is a Proxy exotic object .</step>
  <step>Let <id>lexDeclarations</id> be the LexicallyScopedDeclarations of <id>body</id> .</step>
  <step>For each element <id>d</id> in <id>lexDeclarations</id> , do   <step-list>
    <step>NOTE: Lexically declared names are only instantiated here but not initialized.</step>
    <step>For each element <id>dn</id> of the BoundNames of <id>d</id> , do     <step-list>
      <step>If IsConstantDeclaration of <id>d</id> is <value>true</value> , then       <step-list>
        <step>Perform ? <id>lexEnvRec</id> .CreateImmutableBinding( <id>dn</id> , <value>true</value> ).</step>
      </step-list></step>
      <step>Else,       <step-list>
        <step>Perform ? <id>lexEnvRec</id> .CreateMutableBinding( <id>dn</id> , <value>false</value> ).</step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
  <step>For each Parse Node  <id>f</id> in <id>functionsToInitialize</id> , do   <step-list>
    <step>Let <id>fn</id> be the sole element of the BoundNames of <id>f</id> .</step>
    <step>Let <id>fo</id> be the result of performing InstantiateFunctionObject for <id>f</id> with argument <id>lexEnv</id> .</step>
    <step>If <id>varEnvRec</id> is a global Environment Record , then     <step-list>
      <step>Perform ? <id>varEnvRec</id> .CreateGlobalFunctionBinding( <id>fn</id> , <id>fo</id> , <value>true</value> ).</step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>Let <id>bindingExists</id> be <id>varEnvRec</id> .HasBinding( <id>fn</id> ).</step>
      <step>If <id>bindingExists</id> is <value>false</value> , then       <step-list>
        <step>Let <id>status</id> be ! <id>varEnvRec</id> .CreateMutableBinding( <id>fn</id> , <value>true</value> ).</step>
        <step>Assert : <id>status</id> is not an abrupt completion because of validation preceding step 12.</step>
        <step>Perform ! <id>varEnvRec</id> .InitializeBinding( <id>fn</id> , <id>fo</id> ).</step>
      </step-list></step>
      <step>Else,       <step-list>
        <step>Perform ! <id>varEnvRec</id> .SetMutableBinding( <id>fn</id> , <id>fo</id> , <value>false</value> ).</step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
  <step>For each String <id>vn</id> in <id>declaredVarNames</id> , in list order, do   <step-list>
    <step>If <id>varEnvRec</id> is a global Environment Record , then     <step-list>
      <step>Perform ? <id>varEnvRec</id> .CreateGlobalVarBinding( <id>vn</id> , <value>true</value> ).</step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>Let <id>bindingExists</id> be <id>varEnvRec</id> .HasBinding( <id>vn</id> ).</step>
      <step>If <id>bindingExists</id> is <value>false</value> , then       <step-list>
        <step>Let <id>status</id> be ! <id>varEnvRec</id> .CreateMutableBinding( <id>vn</id> , <value>true</value> ).</step>
        <step>Assert : <id>status</id> is not an abrupt completion because of validation preceding step 12.</step>
        <step>Perform ! <id>varEnvRec</id> .InitializeBinding( <id>vn</id> , <value>undefined</value> ).</step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
  <step>Return NormalCompletion ( <value>empty</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>num</id> be ? ToNumber ( <id>number</id> ).</step>
  <step>If <id>num</id> is <value>NaN</value> , <value>+∞</value> , or <value>-∞</value> , return <value>false</value> .</step>
  <step>Otherwise, return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Let <id>num</id> be ? ToNumber ( <id>number</id> ).</step>
  <step>If <id>num</id> is <value>NaN</value> , return <value>true</value> .</step>
  <step>Otherwise, return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>inputString</id> be ? ToString ( <id>string</id> ).</step>
  <step>Let <id>trimmedString</id> be a substring of <id>inputString</id> consisting of the leftmost code unit that is not a StrWhiteSpaceChar and all code units to the right of that code unit. (In other words, remove leading white space.) If <id>inputString</id> does not contain any such code units, let <id>trimmedString</id> be the empty string.</step>
  <step>If neither <id>trimmedString</id> nor any prefix of <id>trimmedString</id> satisfies the syntax of a StrDecimalLiteral (see 7.1.3.1 ), return <value>NaN</value> .</step>
  <step>Let <id>numberString</id> be the longest prefix of <id>trimmedString</id> , which might be <id>trimmedString</id> itself, that satisfies the syntax of a StrDecimalLiteral .</step>
  <step>Let <id>mathFloat</id> be MV of <id>numberString</id> .</step>
  <step>If <id>mathFloat</id> =0, then   <step-list>
    <step>If the first code unit of <id>trimmedString</id> is the code unit 0x002D (HYPHEN-MINUS), return <value>-0</value> .</step>
    <step>Return <value>+0</value> .</step>
  </step-list></step>
  <step>Return the Number value for <id>mathFloat</id> .</step>
</step-list>
<step-list>
  <step>Let <id>inputString</id> be ? ToString ( <id>string</id> ).</step>
  <step>Let <id>S</id> be a newly created substring of <id>inputString</id> consisting of the first code unit that is not a StrWhiteSpaceChar and all code units following that code unit. (In other words, remove leading white space.) If <id>inputString</id> does not contain any such code unit, let <id>S</id> be the empty string.</step>
  <step>Let <id>sign</id> be 1.</step>
  <step>If <id>S</id> is not empty and the first code unit of <id>S</id> is the code unit 0x002D (HYPHEN-MINUS), let <id>sign</id> be -1.</step>
  <step>If <id>S</id> is not empty and the first code unit of <id>S</id> is the code unit 0x002B (PLUS SIGN) or the code unit 0x002D (HYPHEN-MINUS), remove the first code unit from <id>S</id> .</step>
  <step>Let <id>R</id> be ? ToInt32 ( <id>radix</id> ).</step>
  <step>Let <id>stripPrefix</id> be <value>true</value> .</step>
  <step>If <id>R</id> ≠ 0, then   <step-list>
    <step>If <id>R</id> < 2 or <id>R</id> > 36, return <value>NaN</value> .</step>
    <step>If <id>R</id> ≠ 16, let <id>stripPrefix</id> be <value>false</value> .</step>
  </step-list></step>
  <step>Else <id>R</id> = 0,   <step-list>
    <step>Let <id>R</id> be 10.</step>
  </step-list></step>
  <step>If <id>stripPrefix</id> is <value>true</value> , then   <step-list>
    <step>If the length of <id>S</id> is at least 2 and the first two code units of <id>S</id> are either <value>"0x"</value> or <value>"0X"</value> , remove the first two code units from <id>S</id> and let <id>R</id> be 16.</step>
  </step-list></step>
  <step>If <id>S</id> contains a code unit that is not a radix- <id>R</id> digit, let <id>Z</id> be the substring of <id>S</id> consisting of all code units before the first such code unit; otherwise, let <id>Z</id> be <id>S</id> .</step>
  <step>If <id>Z</id> is empty, return <value>NaN</value> .</step>
  <step>Let <id>mathInt</id> be the mathematical integer value that is represented by <id>Z</id> in radix- <id>R</id> notation, using the letters A - Z and a - z for digits with values 10 through 35. (However, if <id>R</id> is 10 and <id>Z</id> contains more than 20 significant digits, every significant digit after
 the 20th may be replaced by a 0 digit, at the option of the 
implementation; and if <id>R</id> is not 2, 4, 8, 10, 16, or 32, then <id>mathInt</id> may be an implementation-dependent approximation to the mathematical integer value that is represented by <id>Z</id> in radix- <id>R</id> notation.)</step>
  <step>If <id>mathInt</id> = 0, then   <step-list>
    <step>If <id>sign</id> = -1, return <value>-0</value> .</step>
    <step>Return <value>+0</value> .</step>
  </step-list></step>
  <step>Let <id>number</id> be the Number value for <id>mathInt</id> .</step>
  <step>Return <id>sign</id> × <id>number</id> .</step>
</step-list>
<step-list>
  <step>Let <id>strLen</id> be the number of code units in <id>string</id> .</step>
  <step>Let <id>R</id> be the empty String.</step>
  <step>Let <id>k</id> be 0.</step>
  <step>Repeat,   <step-list>
    <step>If <id>k</id> equals <id>strLen</id> , return <id>R</id> .</step>
    <step>Let <id>C</id> be the code unit at index <id>k</id> within <id>string</id> .</step>
    <step>If <id>C</id> is in <id>unescapedSet</id> , then     <step-list>
      <step>Let <id>S</id> be the String value containing only the code unit <id>C</id> .</step>
      <step>Set <id>R</id> to the string-concatenation of the previous value of <id>R</id> and <id>S</id> .</step>
    </step-list></step>
    <step>Else <id>C</id> is not in <id>unescapedSet</id> ,     <step-list>
      <step>If <id>C</id> is a trailing surrogate , throw a <value>URIError</value> exception.</step>
      <step>If <id>C</id> is not a leading surrogate , then       <step-list>
        <step>Let <id>V</id> be the code point with the same numeric value as code unit <id>C</id> .</step>
      </step-list></step>
      <step>Else,       <step-list>
        <step>Increase <id>k</id> by 1.</step>
        <step>If <id>k</id> equals <id>strLen</id> , throw a <value>URIError</value> exception.</step>
        <step>Let <id>kChar</id> be the code unit at index <id>k</id> within <id>string</id> .</step>
        <step>If <id>kChar</id> is not a trailing surrogate , throw a <value>URIError</value> exception.</step>
        <step>Let <id>V</id> be UTF16Decode ( <id>C</id> , <id>kChar</id> ).</step>
      </step-list></step>
      <step>Let <id>Octets</id> be the List of octets resulting by applying the UTF-8 transformation to <id>V</id> .</step>
      <step>For each element <id>octet</id> of <id>Octets</id> in List order, do       <step-list>
        <step>Let <id>S</id> be the string-concatenation of: "%"
the String representation of octet, formatted as a two-digit uppercase hexadecimal number, padded to the left with a zero if necessary</step>
        <step>Set <id>R</id> to the string-concatenation of the previous value of <id>R</id> and <id>S</id> .</step>
      </step-list></step>
    </step-list></step>
    <step>Increase <id>k</id> by 1.</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>strLen</id> be the number of code units in <id>string</id> .</step>
  <step>Let <id>R</id> be the empty String.</step>
  <step>Let <id>k</id> be 0.</step>
  <step>Repeat,   <step-list>
    <step>If <id>k</id> equals <id>strLen</id> , return <id>R</id> .</step>
    <step>Let <id>C</id> be the code unit at index <id>k</id> within <id>string</id> .</step>
    <step>If <id>C</id> is not the code unit 0x0025 (PERCENT SIGN), then     <step-list>
      <step>Let <id>S</id> be the String value containing only the code unit <id>C</id> .</step>
    </step-list></step>
    <step>Else <id>C</id> is the code unit 0x0025 (PERCENT SIGN),     <step-list>
      <step>Let <id>start</id> be <id>k</id> .</step>
      <step>If <id>k</id> + 2 is greater than or equal to <id>strLen</id> , throw a <value>URIError</value> exception.</step>
      <step>If the code units at index ( <id>k</id> + 1) and ( <id>k</id> + 2) within <id>string</id> do not represent hexadecimal digits, throw a <value>URIError</value> exception.</step>
      <step>Let <id>B</id> be the 8-bit value represented by the two hexadecimal digits at index ( <id>k</id> + 1) and ( <id>k</id> + 2).</step>
      <step>Increment <id>k</id> by 2.</step>
      <step>If the most significant bit in <id>B</id> is 0, then       <step-list>
        <step>Let <id>C</id> be the code unit whose value is <id>B</id> .</step>
        <step>If <id>C</id> is not in <id>reservedSet</id> , then         <step-list>
          <step>Let <id>S</id> be the String value containing only the code unit <id>C</id> .</step>
        </step-list></step>
        <step>Else <id>C</id> is in <id>reservedSet</id> ,         <step-list>
          <step>Let <id>S</id> be the substring of <id>string</id> from index <id>start</id> to index <id>k</id> inclusive.</step>
        </step-list></step>
      </step-list></step>
      <step>Else the most significant bit in <id>B</id> is 1,       <step-list>
        <step>Let <id>n</id> be the smallest nonnegative integer such that ( <id>B</id> << <id>n</id> ) & 0x80 is equal to 0.</step>
        <step>If <id>n</id> equals 1 or <id>n</id> is greater than 4, throw a <value>URIError</value> exception.</step>
        <step>Let <id>Octets</id> be a List of 8-bit integers of size <id>n</id> .</step>
        <step>Set <id>Octets</id> [0] to <id>B</id> .</step>
        <step>If <id>k</id> + (3 × ( <id>n</id> - 1)) is greater than or equal to <id>strLen</id> , throw a <value>URIError</value> exception.</step>
        <step>Let <id>j</id> be 1.</step>
        <step>Repeat, while <id>j</id> < <id>n</id>         <step-list>
          <step>Increment <id>k</id> by 1.</step>
          <step>If the code unit at index <id>k</id> within <id>string</id> is not the code unit 0x0025 (PERCENT SIGN), throw a <value>URIError</value> exception.</step>
          <step>If the code units at index ( <id>k</id> + 1) and ( <id>k</id> + 2) within <id>string</id> do not represent hexadecimal digits, throw a <value>URIError</value> exception.</step>
          <step>Let <id>B</id> be the 8-bit value represented by the two hexadecimal digits at index ( <id>k</id> + 1) and ( <id>k</id> + 2).</step>
          <step>If the two most significant bits in <id>B</id> are not 10, throw a <value>URIError</value> exception.</step>
          <step>Increment <id>k</id> by 2.</step>
          <step>Set <id>Octets</id> [ <id>j</id> ] to <id>B</id> .</step>
          <step>Increment <id>j</id> by 1.</step>
        </step-list></step>
        <step>If <id>Octets</id> does not contain a valid UTF-8 encoding of a Unicode code point, throw a <value>URIError</value> exception.</step>
        <step>Let <id>V</id> be the value obtained by applying the UTF-8 transformation to <id>Octets</id> , that is, from a List of octets into a 21-bit value.</step>
        <step>Let <id>S</id> be the String value whose elements are, in order, the elements in UTF16Encoding ( <id>V</id> ).</step>
      </step-list></step>
    </step-list></step>
    <step>Set <id>R</id> to the string-concatenation of the previous value of <id>R</id> and <id>S</id> .</step>
    <step>Increase <id>k</id> by 1.</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>uriString</id> be ? ToString ( <id>encodedURI</id> ).</step>
  <step>Let <id>reservedURISet</id> be a String containing one instance of each code unit valid in uriReserved plus <value>"#"</value> .</step>
  <step>Return ? Decode ( <id>uriString</id> , <id>reservedURISet</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>componentString</id> be ? ToString ( <id>encodedURIComponent</id> ).</step>
  <step>Let <id>reservedURIComponentSet</id> be the empty String.</step>
  <step>Return ? Decode ( <id>componentString</id> , <id>reservedURIComponentSet</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>uriString</id> be ? ToString ( <id>uri</id> ).</step>
  <step>Let <id>unescapedURISet</id> be a String containing one instance of each code unit valid in uriReserved and uriUnescaped plus <value>"#"</value> .</step>
  <step>Return ? Encode ( <id>uriString</id> , <id>unescapedURISet</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>componentString</id> be ? ToString ( <id>uriComponent</id> ).</step>
  <step>Let <id>unescapedURIComponentSet</id> be a String containing one instance of each code unit valid in uriUnescaped .</step>
  <step>Return ? Encode ( <id>componentString</id> , <id>unescapedURIComponentSet</id> ).</step>
</step-list>
<step-list>
  <step>If NewTarget is neither <value>undefined</value> nor the active function, then   <step-list>
    <step>Return ? OrdinaryCreateFromConstructor (NewTarget, <value>"%ObjectPrototype%"</value> ).</step>
  </step-list></step>
  <step>If <id>value</id> is <value>null</value> , <value>undefined</value> or not supplied, return ObjectCreate ( %ObjectPrototype% ).</step>
  <step>Return ! ToObject ( <id>value</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>to</id> be ? ToObject ( <id>target</id> ).</step>
  <step>If only one argument was passed, return <id>to</id> .</step>
  <step>Let <id>sources</id> be the List of argument values starting with the second argument.</step>
  <step>For each element <id>nextSource</id> of <id>sources</id> , in ascending index order, do   <step-list>
    <step>If <id>nextSource</id> is <value>undefined</value> or <value>null</value> , let <id>keys</id> be a new empty List .</step>
    <step>Else,     <step-list>
      <step>Let <id>from</id> be ! ToObject ( <id>nextSource</id> ).</step>
      <step>Let <id>keys</id> be ? <id>from</id> .[[OwnPropertyKeys]]().</step>
    </step-list></step>
    <step>For each element <id>nextKey</id> of <id>keys</id> in List order, do     <step-list>
      <step>Let <id>desc</id> be ? <id>from</id> .[[GetOwnProperty]]( <id>nextKey</id> ).</step>
      <step>If <id>desc</id> is not <value>undefined</value> and <id>desc</id> .[[Enumerable]] is <value>true</value> , then       <step-list>
        <step>Let <id>propValue</id> be ? Get ( <id>from</id> , <id>nextKey</id> ).</step>
        <step>Perform ? Set ( <id>to</id> , <id>nextKey</id> , <id>propValue</id> , <value>true</value> ).</step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
  <step>Return <id>to</id> .</step>
</step-list>
<step-list>
  <step>If Type ( <id>O</id> ) is neither Object nor Null, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>obj</id> be ObjectCreate ( <id>O</id> ).</step>
  <step>If <id>Properties</id> is not <value>undefined</value> , then   <step-list>
    <step>Return ? ObjectDefineProperties ( <id>obj</id> , <id>Properties</id> ).</step>
  </step-list></step>
  <step>Return <id>obj</id> .</step>
</step-list>
<step-list>
  <step>Return ? ObjectDefineProperties ( <id>O</id> , <id>Properties</id> ).</step>
</step-list>
<step-list>
  <step>If Type ( <id>O</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>props</id> be ? ToObject ( <id>Properties</id> ).</step>
  <step>Let <id>keys</id> be ? <id>props</id> .[[OwnPropertyKeys]]().</step>
  <step>Let <id>descriptors</id> be a new empty List .</step>
  <step>For each element <id>nextKey</id> of <id>keys</id> in List order, do   <step-list>
    <step>Let <id>propDesc</id> be ? <id>props</id> .[[GetOwnProperty]]( <id>nextKey</id> ).</step>
    <step>If <id>propDesc</id> is not <value>undefined</value> and <id>propDesc</id> .[[Enumerable]] is <value>true</value> , then     <step-list>
      <step>Let <id>descObj</id> be ? Get ( <id>props</id> , <id>nextKey</id> ).</step>
      <step>Let <id>desc</id> be ? ToPropertyDescriptor ( <id>descObj</id> ).</step>
      <step>Append the pair (a two element List ) consisting of <id>nextKey</id> and <id>desc</id> to the end of <id>descriptors</id> .</step>
    </step-list></step>
  </step-list></step>
  <step>For each <id>pair</id> from <id>descriptors</id> in list order, do   <step-list>
    <step>Let <id>P</id> be the first element of <id>pair</id> .</step>
    <step>Let <id>desc</id> be the second element of <id>pair</id> .</step>
    <step>Perform ? DefinePropertyOrThrow ( <id>O</id> , <id>P</id> , <id>desc</id> ).</step>
  </step-list></step>
  <step>Return <id>O</id> .</step>
</step-list>
<step-list>
  <step>If Type ( <id>O</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>key</id> be ? ToPropertyKey ( <id>P</id> ).</step>
  <step>Let <id>desc</id> be ? ToPropertyDescriptor ( <id>Attributes</id> ).</step>
  <step>Perform ? DefinePropertyOrThrow ( <id>O</id> , <id>key</id> , <id>desc</id> ).</step>
  <step>Return <id>O</id> .</step>
</step-list>
<step-list>
  <step>Let <id>obj</id> be ? ToObject ( <id>O</id> ).</step>
  <step>Let <id>nameList</id> be ? EnumerableOwnPropertyNames ( <id>obj</id> , <value>"key+value"</value> ).</step>
  <step>Return CreateArrayFromList ( <id>nameList</id> ).</step>
</step-list>
<step-list>
  <step>If Type ( <id>O</id> ) is not Object, return <id>O</id> .</step>
  <step>Let <id>status</id> be ? SetIntegrityLevel ( <id>O</id> , <value>"frozen"</value> ).</step>
  <step>If <id>status</id> is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Return <id>O</id> .</step>
</step-list>
<step-list>
  <step>Let <id>obj</id> be ? ToObject ( <id>O</id> ).</step>
  <step>Let <id>key</id> be ? ToPropertyKey ( <id>P</id> ).</step>
  <step>Let <id>desc</id> be ? <id>obj</id> .[[GetOwnProperty]]( <id>key</id> ).</step>
  <step>Return FromPropertyDescriptor ( <id>desc</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>obj</id> be ? ToObject ( <id>O</id> ).</step>
  <step>Let <id>ownKeys</id> be ? <id>obj</id> .[[OwnPropertyKeys]]().</step>
  <step>Let <id>descriptors</id> be ! ObjectCreate ( %ObjectPrototype% ).</step>
  <step>For each element <id>key</id> of <id>ownKeys</id> in List order, do   <step-list>
    <step>Let <id>desc</id> be ? <id>obj</id> .[[GetOwnProperty]]( <id>key</id> ).</step>
    <step>Let <id>descriptor</id> be ! FromPropertyDescriptor ( <id>desc</id> ).</step>
    <step>If <id>descriptor</id> is not <value>undefined</value> , perform ! CreateDataProperty ( <id>descriptors</id> , <id>key</id> , <id>descriptor</id> ).</step>
  </step-list></step>
  <step>Return <id>descriptors</id> .</step>
</step-list>
<step-list>
  <step>Return ? GetOwnPropertyKeys ( <id>O</id> , String).</step>
</step-list>
<step-list>
  <step>Return ? GetOwnPropertyKeys ( <id>O</id> , Symbol).</step>
</step-list>
<step-list>
  <step>Let <id>obj</id> be ? ToObject ( <id>O</id> ).</step>
  <step>Let <id>keys</id> be ? <id>obj</id> .[[OwnPropertyKeys]]().</step>
  <step>Let <id>nameList</id> be a new empty List .</step>
  <step>For each element <id>nextKey</id> of <id>keys</id> in List order, do   <step-list>
    <step>If Type ( <id>nextKey</id> ) is <id>Type</id> , then     <step-list>
      <step>Append <id>nextKey</id> as the last element of <id>nameList</id> .</step>
    </step-list></step>
  </step-list></step>
  <step>Return CreateArrayFromList ( <id>nameList</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>obj</id> be ? ToObject ( <id>O</id> ).</step>
  <step>Return ? <id>obj</id> .[[GetPrototypeOf]]().</step>
</step-list>
<step-list>
  <step>Return SameValue ( <id>value1</id> , <id>value2</id> ).</step>
</step-list>
<step-list>
  <step>If Type ( <id>O</id> ) is not Object, return <value>false</value> .</step>
  <step>Return ? IsExtensible ( <id>O</id> ).</step>
</step-list>
<step-list>
  <step>If Type ( <id>O</id> ) is not Object, return <value>true</value> .</step>
  <step>Return ? TestIntegrityLevel ( <id>O</id> , <value>"frozen"</value> ).</step>
</step-list>
<step-list>
  <step>If Type ( <id>O</id> ) is not Object, return <value>true</value> .</step>
  <step>Return ? TestIntegrityLevel ( <id>O</id> , <value>"sealed"</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>obj</id> be ? ToObject ( <id>O</id> ).</step>
  <step>Let <id>nameList</id> be ? EnumerableOwnPropertyNames ( <id>obj</id> , <value>"key"</value> ).</step>
  <step>Return CreateArrayFromList ( <id>nameList</id> ).</step>
</step-list>
<step-list>
  <step>If Type ( <id>O</id> ) is not Object, return <id>O</id> .</step>
  <step>Let <id>status</id> be ? <id>O</id> .[[PreventExtensions]]().</step>
  <step>If <id>status</id> is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Return <id>O</id> .</step>
</step-list>
<step-list>
  <step>If Type ( <id>O</id> ) is not Object, return <id>O</id> .</step>
  <step>Let <id>status</id> be ? SetIntegrityLevel ( <id>O</id> , <value>"sealed"</value> ).</step>
  <step>If <id>status</id> is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Return <id>O</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? RequireObjectCoercible ( <id>O</id> ).</step>
  <step>If Type ( <id>proto</id> ) is neither Object nor Null, throw a <value>TypeError</value> exception.</step>
  <step>If Type ( <id>O</id> ) is not Object, return <id>O</id> .</step>
  <step>Let <id>status</id> be ? <id>O</id> .[[SetPrototypeOf]]( <id>proto</id> ).</step>
  <step>If <id>status</id> is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Return <id>O</id> .</step>
</step-list>
<step-list>
  <step>Let <id>obj</id> be ? ToObject ( <id>O</id> ).</step>
  <step>Let <id>nameList</id> be ? EnumerableOwnPropertyNames ( <id>obj</id> , <value>"value"</value> ).</step>
  <step>Return CreateArrayFromList ( <id>nameList</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>P</id> be ? ToPropertyKey ( <id>V</id> ).</step>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Return ? HasOwnProperty ( <id>O</id> , <id>P</id> ).</step>
</step-list>
<step-list>
  <step>If Type ( <id>V</id> ) is not Object, return <value>false</value> .</step>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Repeat,   <step-list>
    <step>Let <id>V</id> be ? <id>V</id> .[[GetPrototypeOf]]().</step>
    <step>If <id>V</id> is <value>null</value> , return <value>false</value> .</step>
    <step>If SameValue ( <id>O</id> , <id>V</id> ) is <value>true</value> , return <value>true</value> .</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>P</id> be ? ToPropertyKey ( <id>V</id> ).</step>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Let <id>desc</id> be ? <id>O</id> .[[GetOwnProperty]]( <id>P</id> ).</step>
  <step>If <id>desc</id> is <value>undefined</value> , return <value>false</value> .</step>
  <step>Return <id>desc</id> .[[Enumerable]].</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>Return ? Invoke ( <id>O</id> , <value>"toString"</value> ).</step>
</step-list>
<step-list>
  <step>If the <value>this</value> value is <value>undefined</value> , return <value>"[object Undefined]"</value> .</step>
  <step>If the <value>this</value> value is <value>null</value> , return <value>"[object Null]"</value> .</step>
  <step>Let <id>O</id> be ! ToObject ( <value>this</value> value).</step>
  <step>Let <id>isArray</id> be ? IsArray ( <id>O</id> ).</step>
  <step>If <id>isArray</id> is <value>true</value> , let <id>builtinTag</id> be <value>"Array"</value> .</step>
  <step>Else if <id>O</id> is a String exotic object , let <id>builtinTag</id> be <value>"String"</value> .</step>
  <step>Else if <id>O</id> has a [[ParameterMap]] internal slot, let <id>builtinTag</id> be <value>"Arguments"</value> .</step>
  <step>Else if <id>O</id> has a [[Call]] internal method, let <id>builtinTag</id> be <value>"Function"</value> .</step>
  <step>Else if <id>O</id> has an [[ErrorData]] internal slot, let <id>builtinTag</id> be <value>"Error"</value> .</step>
  <step>Else if <id>O</id> has a [[BooleanData]] internal slot, let <id>builtinTag</id> be <value>"Boolean"</value> .</step>
  <step>Else if <id>O</id> has a [[NumberData]] internal slot, let <id>builtinTag</id> be <value>"Number"</value> .</step>
  <step>Else if <id>O</id> has a [[DateValue]] internal slot, let <id>builtinTag</id> be <value>"Date"</value> .</step>
  <step>Else if <id>O</id> has a [[RegExpMatcher]] internal slot, let <id>builtinTag</id> be <value>"RegExp"</value> .</step>
  <step>Else, let <id>builtinTag</id> be <value>"Object"</value> .</step>
  <step>Let <id>tag</id> be ? Get ( <id>O</id> , @@toStringTag).</step>
  <step>If Type ( <id>tag</id> ) is not String, let <id>tag</id> be <id>builtinTag</id> .</step>
  <step>Return the string-concatenation of <value>"[object "</value> , <id>tag</id> , and <value>"]"</value> .</step>
</step-list>
<step-list>
  <step>Return ? ToObject ( <value>this</value> value).</step>
</step-list>
<step-list>
  <step>Let <id>C</id> be the active function object .</step>
  <step>Let <id>args</id> be the <id>argumentsList</id> that was passed to this function by [[Call]] or [[Construct]].</step>
  <step>Return ? CreateDynamicFunction ( <id>C</id> , NewTarget, <value>"normal"</value> , <id>args</id> ).</step>
</step-list>
<step-list>
  <step>Assert : The execution context stack has at least two elements.</step>
  <step>Let <id>callerContext</id> be the second to top element of the execution context stack .</step>
  <step>Let <id>callerRealm</id> be <id>callerContext</id> 's Realm .</step>
  <step>Let <id>calleeRealm</id> be the current Realm Record .</step>
  <step>Perform ? HostEnsureCanCompileStrings ( <id>callerRealm</id> , <id>calleeRealm</id> ).</step>
  <step>If <id>newTarget</id> is <value>undefined</value> , set <id>newTarget</id> to <id>constructor</id> .</step>
  <step>If <id>kind</id> is <value>"normal"</value> , then   <step-list>
    <step>Let <id>goal</id> be the grammar symbol FunctionBody[~Yield, ~Await] .</step>
    <step>Let <id>parameterGoal</id> be the grammar symbol FormalParameters[~Yield, ~Await] .</step>
    <step>Let <id>fallbackProto</id> be <value>"%FunctionPrototype%"</value> .</step>
  </step-list></step>
  <step>Else if <id>kind</id> is <value>"generator"</value> , then   <step-list>
    <step>Let <id>goal</id> be the grammar symbol GeneratorBody .</step>
    <step>Let <id>parameterGoal</id> be the grammar symbol FormalParameters[+Yield, ~Await] .</step>
    <step>Let <id>fallbackProto</id> be <value>"%Generator%"</value> .</step>
  </step-list></step>
  <step>Else if <id>kind</id> is <value>"async"</value> , then   <step-list>
    <step>Assert : <id>kind</id> is <value>"async"</value> .</step>
    <step>Let <id>goal</id> be the grammar symbol AsyncFunctionBody .</step>
    <step>Let <id>parameterGoal</id> be the grammar symbol FormalParameters[~Yield, +Await] .</step>
    <step>Let <id>fallbackProto</id> be <value>"%AsyncFunctionPrototype%"</value> .</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Assert : <id>kind</id> is <value>"async generator"</value> .</step>
    <step>Let <id>goal</id> be the grammar symbol AsyncGeneratorBody .</step>
    <step>Let <id>parameterGoal</id> be the grammar symbol FormalParameters[+Yield, +Await] .</step>
    <step>Let <id>fallbackProto</id> be <value>"%AsyncGenerator%"</value> .</step>
  </step-list></step>
  <step>Let <id>argCount</id> be the number of elements in <id>args</id> .</step>
  <step>Let <id>P</id> be the empty String.</step>
  <step>If <id>argCount</id> = 0, let <id>bodyText</id> be the empty String.</step>
  <step>Else if <id>argCount</id> = 1, let <id>bodyText</id> be <id>args</id> [0].</step>
  <step>Else <id>argCount</id> > 1,   <step-list>
    <step>Let <id>firstArg</id> be <id>args</id> [0].</step>
    <step>Set <id>P</id> to ? ToString ( <id>firstArg</id> ).</step>
    <step>Let <id>k</id> be 1.</step>
    <step>Repeat, while <id>k</id> < <id>argCount</id> -1     <step-list>
      <step>Let <id>nextArg</id> be <id>args</id> [ <id>k</id> ].</step>
      <step>Let <id>nextArgString</id> be ? ToString ( <id>nextArg</id> ).</step>
      <step>Set <id>P</id> to the string-concatenation of the previous value of <id>P</id> , <value>","</value> (a comma), and <id>nextArgString</id> .</step>
      <step>Increase <id>k</id> by 1.</step>
    </step-list></step>
    <step>Let <id>bodyText</id> be <id>args</id> [ <id>k</id> ].</step>
  </step-list></step>
  <step>Set <id>bodyText</id> to ? ToString ( <id>bodyText</id> ).</step>
  <step>Let <id>parameters</id> be the result of parsing <id>P</id> , interpreted as UTF-16 encoded Unicode text as described in 6.1.4 , using <id>parameterGoal</id> as the goal symbol . Throw a <value>SyntaxError</value> exception if the parse fails.</step>
  <step>Let <id>body</id> be the result of parsing <id>bodyText</id> , interpreted as UTF-16 encoded Unicode text as described in 6.1.4 , using <id>goal</id> as the goal symbol . Throw a <value>SyntaxError</value> exception if the parse fails.</step>
  <step>Let <id>strict</id> be ContainsUseStrict of <id>body</id> .</step>
  <step>If any static semantics errors are detected for <id>parameters</id> or <id>body</id> , throw a <value>SyntaxError</value> or a <value>ReferenceError</value> exception, depending on the type of the error. If <id>strict</id> is <value>true</value> , the Early Error rules for UniqueFormalParameters:FormalParameters are applied. Parsing and early error detection may be interweaved in an implementation-dependent manner.</step>
  <step>If <id>strict</id> is <value>true</value> and IsSimpleParameterList of <id>parameters</id> is <value>false</value> , throw a <value>SyntaxError</value> exception.</step>
  <step>If any element of the BoundNames of <id>parameters</id> also occurs in the LexicallyDeclaredNames of <id>body</id> , throw a <value>SyntaxError</value> exception.</step>
  <step>If <id>body</id> Contains SuperCall is <value>true</value> , throw a <value>SyntaxError</value> exception.</step>
  <step>If <id>parameters</id> Contains SuperCall is <value>true</value> , throw a <value>SyntaxError</value> exception.</step>
  <step>If <id>body</id> Contains SuperProperty is <value>true</value> , throw a <value>SyntaxError</value> exception.</step>
  <step>If <id>parameters</id> Contains SuperProperty is <value>true</value> , throw a <value>SyntaxError</value> exception.</step>
  <step>If <id>kind</id> is <value>"generator"</value> or <value>"async generator"</value> , then   <step-list>
    <step>If <id>parameters</id> Contains YieldExpression is <value>true</value> , throw a <value>SyntaxError</value> exception.</step>
  </step-list></step>
  <step>If <id>kind</id> is <value>"async"</value> or <value>"async generator"</value> , then   <step-list>
    <step>If <id>parameters</id> Contains AwaitExpression is <value>true</value> , throw a <value>SyntaxError</value> exception.</step>
  </step-list></step>
  <step>If <id>strict</id> is <value>true</value> , then   <step-list>
    <step>If BoundNames of <id>parameters</id> contains any duplicate elements, throw a <value>SyntaxError</value> exception.</step>
  </step-list></step>
  <step>Let <id>proto</id> be ? GetPrototypeFromConstructor ( <id>newTarget</id> , <id>fallbackProto</id> ).</step>
  <step>Let <id>F</id> be FunctionAllocate ( <id>proto</id> , <id>strict</id> , <id>kind</id> ).</step>
  <step>Let <id>realmF</id> be <id>F</id> .[[Realm]].</step>
  <step>Let <id>scope</id> be <id>realmF</id> .[[GlobalEnv]].</step>
  <step>Perform FunctionInitialize ( <id>F</id> , <value>Normal</value> , <id>parameters</id> , <id>body</id> , <id>scope</id> ).</step>
  <step>If <id>kind</id> is <value>"generator"</value> , then   <step-list>
    <step>Let <id>prototype</id> be ObjectCreate ( %GeneratorPrototype% ).</step>
    <step>Perform DefinePropertyOrThrow ( <id>F</id> , <value>"prototype"</value> , PropertyDescriptor { [[Value]]: <id>prototype</id> , [[Writable]]: <value>true</value> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>false</value> }).</step>
  </step-list></step>
  <step>Else if <id>kind</id> is <value>"async generator"</value> , then   <step-list>
    <step>Let <id>prototype</id> be ObjectCreate ( %AsyncGeneratorPrototype% ).</step>
    <step>Perform DefinePropertyOrThrow ( <id>F</id> , <value>"prototype"</value> , PropertyDescriptor { [[Value]]: <id>prototype</id> , [[Writable]]: <value>true</value> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>false</value> }).</step>
  </step-list></step>
  <step>Else if <id>kind</id> is <value>"normal"</value> , perform MakeConstructor ( <id>F</id> ).</step>
  <step>NOTE: Async functions are not constructable and do not have a [[Construct]] internal method or a <value>"prototype"</value> property.</step>
  <step>Perform SetFunctionName ( <id>F</id> , <value>"anonymous"</value> ).</step>
  <step>Return <id>F</id> .</step>
</step-list>
<step-list>
  <step>If IsCallable ( <id>func</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>If <id>argArray</id> is <value>undefined</value> or <value>null</value> , then   <step-list>
    <step>Perform PrepareForTailCall ().</step>
    <step>Return ? Call ( <id>func</id> , <id>thisArg</id> ).</step>
  </step-list></step>
  <step>Let <id>argList</id> be ? CreateListFromArrayLike ( <id>argArray</id> ).</step>
  <step>Perform PrepareForTailCall ().</step>
  <step>Return ? Call ( <id>func</id> , <id>thisArg</id> , <id>argList</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>Target</id> be the <value>this</value> value.</step>
  <step>If IsCallable ( <id>Target</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>args</id> be a new (possibly empty) List consisting of all of the argument values provided after <id>thisArg</id> in order.</step>
  <step>Let <id>F</id> be ? BoundFunctionCreate ( <id>Target</id> , <id>thisArg</id> , <id>args</id> ).</step>
  <step>Let <id>targetHasLength</id> be ? HasOwnProperty ( <id>Target</id> , <value>"length"</value> ).</step>
  <step>If <id>targetHasLength</id> is <value>true</value> , then   <step-list>
    <step>Let <id>targetLen</id> be ? Get ( <id>Target</id> , <value>"length"</value> ).</step>
    <step>If Type ( <id>targetLen</id> ) is not Number, let <id>L</id> be 0.</step>
    <step>Else,     <step-list>
      <step>Let <id>targetLen</id> be ToInteger ( <id>targetLen</id> ).</step>
      <step>Let <id>L</id> be the larger of 0 and the result of <id>targetLen</id> minus the number of elements of <id>args</id> .</step>
    </step-list></step>
  </step-list></step>
  <step>Else, let <id>L</id> be 0.</step>
  <step>Perform ! SetFunctionLength ( <id>F</id> , <id>L</id> ).</step>
  <step>Let <id>targetName</id> be ? Get ( <id>Target</id> , <value>"name"</value> ).</step>
  <step>If Type ( <id>targetName</id> ) is not String, let <id>targetName</id> be the empty string.</step>
  <step>Perform SetFunctionName ( <id>F</id> , <id>targetName</id> , <value>"bound"</value> ).</step>
  <step>Return <id>F</id> .</step>
</step-list>
<step-list>
  <step>If IsCallable ( <id>func</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>argList</id> be a new empty List .</step>
  <step>If
 this method was called with more than one argument, then in left to 
right order, starting with the second argument, append each argument as 
the last element of <id>argList</id> .</step>
  <step>Perform PrepareForTailCall ().</step>
  <step>Return ? Call ( <id>func</id> , <id>thisArg</id> , <id>argList</id> ).</step>
</step-list>
<step-list>
  <step>If <id>func</id> is a Bound Function exotic object , then   <step-list>
    <step>Return an implementation-dependent String source code representation of <id>func</id> . The representation must conform to the rules below. It is implementation-dependent whether the representation includes bound function information or information about the target function.</step>
  </step-list></step>
  <step>If Type ( <id>func</id> ) is Object and is either a built-in function object or has an [[ECMAScriptCode]] internal slot, then   <step-list>
    <step>Return an implementation-dependent String source code representation of <id>func</id> . The representation must conform to the rules below.</step>
  </step-list></step>
  <step>Throw a <value>TypeError</value> exception.</step>
</step-list>
<step-list>
  <step>Let <id>F</id> be the <value>this</value> value.</step>
  <step>Return ? OrdinaryHasInstance ( <id>F</id> , <id>V</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>b</id> be ToBoolean ( <id>value</id> ).</step>
  <step>If NewTarget is <value>undefined</value> , return <id>b</id> .</step>
  <step>Let <id>O</id> be ? OrdinaryCreateFromConstructor (NewTarget, <value>"%BooleanPrototype%"</value> , « [[BooleanData]] »).</step>
  <step>Set <id>O</id> .[[BooleanData]] to <id>b</id> .</step>
  <step>Return <id>O</id> .</step>
</step-list>
<step-list>
  <step>If Type ( <id>value</id> ) is Boolean, return <id>value</id> .</step>
  <step>If Type ( <id>value</id> ) is Object and <id>value</id> has a [[BooleanData]] internal slot, then   <step-list>
    <step>Assert : <id>value</id> .[[BooleanData]] is a Boolean value.</step>
    <step>Return <id>value</id> .[[BooleanData]].</step>
  </step-list></step>
  <step>Throw a <value>TypeError</value> exception.</step>
</step-list>
<step-list>
  <step>Let <id>b</id> be ? thisBooleanValue ( <value>this</value> value).</step>
  <step>If <id>b</id> is <value>true</value> , return <value>"true"</value> ; else return <value>"false"</value> .</step>
</step-list>
<step-list>
  <step>Return ? thisBooleanValue ( <value>this</value> value).</step>
</step-list>
<step-list>
  <step>If NewTarget is not <value>undefined</value> , throw a <value>TypeError</value> exception.</step>
  <step>If <id>description</id> is <value>undefined</value> , let <id>descString</id> be <value>undefined</value> .</step>
  <step>Else, let <id>descString</id> be ? ToString ( <id>description</id> ).</step>
  <step>Return a new unique Symbol value whose [[Description]] value is <id>descString</id> .</step>
</step-list>
<step-list>
  <step>Let <id>stringKey</id> be ? ToString ( <id>key</id> ).</step>
  <step>For each element <id>e</id> of the GlobalSymbolRegistry List , do   <step-list>
    <step>If SameValue ( <id>e</id> .[[Key]], <id>stringKey</id> ) is <value>true</value> , return <id>e</id> .[[Symbol]].</step>
  </step-list></step>
  <step>Assert : GlobalSymbolRegistry does not currently contain an entry for <id>stringKey</id> .</step>
  <step>Let <id>newSymbol</id> be a new unique Symbol value whose [[Description]] value is <id>stringKey</id> .</step>
  <step>Append the Record { [[Key]]: <id>stringKey</id> , [[Symbol]]: <id>newSymbol</id> } to the GlobalSymbolRegistry List .</step>
  <step>Return <id>newSymbol</id> .</step>
</step-list>
<step-list>
  <step>If Type ( <id>sym</id> ) is not Symbol, throw a <value>TypeError</value> exception.</step>
  <step>For each element <id>e</id> of the GlobalSymbolRegistry List (see 19.4.2.2 ), do   <step-list>
    <step>If SameValue ( <id>e</id> .[[Symbol]], <id>sym</id> ) is <value>true</value> , return <id>e</id> .[[Key]].</step>
  </step-list></step>
  <step>Assert : GlobalSymbolRegistry does not currently contain an entry for <id>sym</id> .</step>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>If Type ( <id>value</id> ) is Symbol, return <id>value</id> .</step>
  <step>If Type ( <id>value</id> ) is Object and <id>value</id> has a [[SymbolData]] internal slot, then   <step-list>
    <step>Assert : <id>value</id> .[[SymbolData]] is a Symbol value.</step>
    <step>Return <id>value</id> .[[SymbolData]].</step>
  </step-list></step>
  <step>Throw a <value>TypeError</value> exception.</step>
</step-list>
<step-list>
  <step>Let <id>sym</id> be ? thisSymbolValue ( <value>this</value> value).</step>
  <step>Return SymbolDescriptiveString ( <id>sym</id> ).</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>sym</id> ) is Symbol.</step>
  <step>Let <id>desc</id> be <id>sym</id> 's [[Description]] value.</step>
  <step>If <id>desc</id> is <value>undefined</value> , let <id>desc</id> be the empty string.</step>
  <step>Assert : Type ( <id>desc</id> ) is String.</step>
  <step>Return the string-concatenation of <value>"Symbol("</value> , <id>desc</id> , and <value>")"</value> .</step>
</step-list>
<step-list>
  <step>Return ? thisSymbolValue ( <value>this</value> value).</step>
</step-list>
<step-list>
  <step>Return ? thisSymbolValue ( <value>this</value> value).</step>
</step-list>
<step-list>
  <step>If NewTarget is <value>undefined</value> , let <id>newTarget</id> be the active function object , else let <id>newTarget</id> be NewTarget.</step>
  <step>Let <id>O</id> be ? OrdinaryCreateFromConstructor ( <id>newTarget</id> , <value>"%ErrorPrototype%"</value> , « [[ErrorData]] »).</step>
  <step>If <id>message</id> is not <value>undefined</value> , then   <step-list>
    <step>Let <id>msg</id> be ? ToString ( <id>message</id> ).</step>
    <step>Let <id>msgDesc</id> be the PropertyDescriptor { [[Value]]: <id>msg</id> , [[Writable]]: <value>true</value> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>true</value> }.</step>
    <step>Perform ! DefinePropertyOrThrow ( <id>O</id> , <value>"message"</value> , <id>msgDesc</id> ).</step>
  </step-list></step>
  <step>Return <id>O</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>O</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>name</id> be ? Get ( <id>O</id> , <value>"name"</value> ).</step>
  <step>If <id>name</id> is <value>undefined</value> , let <id>name</id> be <value>"Error"</value> ; otherwise let <id>name</id> be ? ToString ( <id>name</id> ).</step>
  <step>Let <id>msg</id> be ? Get ( <id>O</id> , <value>"message"</value> ).</step>
  <step>If <id>msg</id> is <value>undefined</value> , let <id>msg</id> be the empty String; otherwise let <id>msg</id> be ? ToString ( <id>msg</id> ).</step>
  <step>If <id>name</id> is the empty String, return <id>msg</id> .</step>
  <step>If <id>msg</id> is the empty String, return <id>name</id> .</step>
  <step>Return the string-concatenation of <id>name</id> , the code unit 0x003A (COLON), the code unit 0x0020 (SPACE), and <id>msg</id> .</step>
</step-list>
<step-list>
  <step>If NewTarget is <value>undefined</value> , let <id>newTarget</id> be the active function object , else let <id>newTarget</id> be NewTarget.</step>
  <step>Let <id>O</id> be ? OrdinaryCreateFromConstructor ( <id>newTarget</id> , <value>"%NativeErrorPrototype%"</value> , « [[ErrorData]] »).</step>
  <step>If <id>message</id> is not <value>undefined</value> , then   <step-list>
    <step>Let <id>msg</id> be ? ToString ( <id>message</id> ).</step>
    <step>Let <id>msgDesc</id> be the PropertyDescriptor { [[Value]]: <id>msg</id> , [[Writable]]: <value>true</value> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>true</value> }.</step>
    <step>Perform ! DefinePropertyOrThrow ( <id>O</id> , <value>"message"</value> , <id>msgDesc</id> ).</step>
  </step-list></step>
  <step>Return <id>O</id> .</step>
</step-list>
<step-list>
  <step>If no arguments were passed to this function invocation, let <id>n</id> be <value>+0</value> .</step>
  <step>Else, let <id>n</id> be ? ToNumber ( <id>value</id> ).</step>
  <step>If NewTarget is <value>undefined</value> , return <id>n</id> .</step>
  <step>Let <id>O</id> be ? OrdinaryCreateFromConstructor (NewTarget, <value>"%NumberPrototype%"</value> , « [[NumberData]] »).</step>
  <step>Set <id>O</id> .[[NumberData]] to <id>n</id> .</step>
  <step>Return <id>O</id> .</step>
</step-list>
<step-list>
  <step>If Type ( <id>number</id> ) is not Number, return <value>false</value> .</step>
  <step>If <id>number</id> is <value>NaN</value> , <value>+∞</value> , or <value>-∞</value> , return <value>false</value> .</step>
  <step>Otherwise, return <value>true</value> .</step>
</step-list>
<step-list>
  <step>If Type ( <id>number</id> ) is not Number, return <value>false</value> .</step>
  <step>If <id>number</id> is <value>NaN</value> , <value>+∞</value> , or <value>-∞</value> , return <value>false</value> .</step>
  <step>Let <id>integer</id> be ToInteger ( <id>number</id> ).</step>
  <step>If <id>integer</id> is not equal to <id>number</id> , return <value>false</value> .</step>
  <step>Otherwise, return <value>true</value> .</step>
</step-list>
<step-list>
  <step>If Type ( <id>number</id> ) is not Number, return <value>false</value> .</step>
  <step>If <id>number</id> is <value>NaN</value> , return <value>true</value> .</step>
  <step>Otherwise, return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If Type ( <id>number</id> ) is not Number, return <value>false</value> .</step>
  <step>If <id>number</id> is <value>NaN</value> , <value>+∞</value> , or <value>-∞</value> , return <value>false</value> .</step>
  <step>Let <id>integer</id> be ToInteger ( <id>number</id> ).</step>
  <step>If <id>integer</id> is not equal to <id>number</id> , return <value>false</value> .</step>
  <step>If abs ( <id>integer</id> ) ≤ 2 53 -1, return <value>true</value> .</step>
  <step>Otherwise, return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If Type ( <id>value</id> ) is Number, return <id>value</id> .</step>
  <step>If Type ( <id>value</id> ) is Object and <id>value</id> has a [[NumberData]] internal slot, then   <step-list>
    <step>Assert : <id>value</id> .[[NumberData]] is a Number value.</step>
    <step>Return <id>value</id> .[[NumberData]].</step>
  </step-list></step>
  <step>Throw a <value>TypeError</value> exception.</step>
</step-list>
<step-list>
  <step>Let <id>x</id> be ? thisNumberValue ( <value>this</value> value).</step>
  <step>Let <id>f</id> be ? ToInteger ( <id>fractionDigits</id> ).</step>
  <step>Assert : <id>f</id> is 0, when <id>fractionDigits</id> is <value>undefined</value> .</step>
  <step>If <id>x</id> is <value>NaN</value> , return the String <value>"NaN"</value> .</step>
  <step>Let <id>s</id> be the empty String.</step>
  <step>If <id>x</id> < 0, then   <step-list>
    <step>Let <id>s</id> be <value>"-"</value> .</step>
    <step>Let <id>x</id> be - <id>x</id> .</step>
  </step-list></step>
  <step>If <id>x</id> = <value>+∞</value> , then   <step-list>
    <step>Return the string-concatenation of <id>s</id> and <value>"Infinity"</value> .</step>
  </step-list></step>
  <step>If <id>f</id> < 0 or <id>f</id> > 100, throw a <value>RangeError</value> exception.</step>
  <step>If <id>x</id> = 0, then   <step-list>
    <step>Let <id>m</id> be the String value consisting of <id>f</id> +1 occurrences of the code unit 0x0030 (DIGIT ZERO).</step>
    <step>Let <id>e</id> be 0.</step>
  </step-list></step>
  <step>Else <id>x</id> ≠ 0,   <step-list>
    <step>If <id>fractionDigits</id> is not <value>undefined</value> , then     <step-list>
      <step>Let <id>e</id> and <id>n</id> be integers such that 10 f ≤ <id>n</id> < 10 f+1 and for which the exact mathematical value of <id>n</id> × 10 e-f - <id>x</id> is as close to zero as possible. If there are two such sets of <id>e</id> and <id>n</id> , pick the <id>e</id> and <id>n</id> for which <id>n</id> × 10 e-f is larger.</step>
    </step-list></step>
    <step>Else <id>fractionDigits</id> is <value>undefined</value> ,     <step-list>
      <step>Let <id>e</id> , <id>n</id> , and <id>f</id> be integers such that <id>f</id> ≥ 0, 10 f ≤ <id>n</id> < 10 f+1 , the Number value for <id>n</id> × 10 e-f is <id>x</id> , and <id>f</id> is as small as possible. Note that the decimal representation of <id>n</id> has <id>f</id> +1 digits, <id>n</id> is not divisible by 10, and the least significant digit of <id>n</id> is not necessarily uniquely determined by these criteria.</step>
    </step-list></step>
    <step>Let <id>m</id> be the String value consisting of the digits of the decimal representation of <id>n</id> (in order, with no leading zeroes).</step>
  </step-list></step>
  <step>If <id>f</id> ≠ 0, then   <step-list>
    <step>Let <id>a</id> be the first element of <id>m</id> , and let <id>b</id> be the remaining <id>f</id> elements of <id>m</id> .</step>
    <step>Let <id>m</id> be the string-concatenation of <id>a</id> , <value>"."</value> , and <id>b</id> .</step>
  </step-list></step>
  <step>If <id>e</id> = 0, then   <step-list>
    <step>Let <id>c</id> be <value>"+"</value> .</step>
    <step>Let <id>d</id> be <value>"0"</value> .</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>If <id>e</id> > 0, let <id>c</id> be <value>"+"</value> .</step>
    <step>Else <id>e</id> ≤ 0,     <step-list>
      <step>Let <id>c</id> be <value>"-"</value> .</step>
      <step>Let <id>e</id> be - <id>e</id> .</step>
    </step-list></step>
    <step>Let <id>d</id> be the String value consisting of the digits of the decimal representation of <id>e</id> (in order, with no leading zeroes).</step>
  </step-list></step>
  <step>Let <id>m</id> be the string-concatenation of <id>m</id> , <value>"e"</value> , <id>c</id> , and <id>d</id> .</step>
  <step>Return the string-concatenation of <id>s</id> and <id>m</id> .</step>
</step-list>
<step-list>
  <step>Let <id>e</id> , <id>n</id> , and <id>f</id> be integers such that <id>f</id> ≥ 0, 10 f ≤ <id>n</id> < 10 f+1 , the Number value for <id>n</id> × 10 e-f is <id>x</id> , and <id>f</id> is as small as possible. If there are multiple possibilities for <id>n</id> , choose the value of <id>n</id> for which <id>n</id> × 10 e-f is closest in value to <id>x</id> . If there are two such possible values of <id>n</id> , choose the one that is even.</step>
</step-list>
<step-list>
  <step>Let <id>x</id> be ? thisNumberValue ( <value>this</value> value).</step>
  <step>Let <id>f</id> be ? ToInteger ( <id>fractionDigits</id> ). (If <id>fractionDigits</id> is <value>undefined</value> , this step produces the value 0.)</step>
  <step>If <id>f</id> < 0 or <id>f</id> > 100, throw a <value>RangeError</value> exception.</step>
  <step>If <id>x</id> is <value>NaN</value> , return the String <value>"NaN"</value> .</step>
  <step>Let <id>s</id> be the empty String.</step>
  <step>If <id>x</id> < 0, then   <step-list>
    <step>Let <id>s</id> be <value>"-"</value> .</step>
    <step>Let <id>x</id> be - <id>x</id> .</step>
  </step-list></step>
  <step>If <id>x</id> ≥ 10 21 , then   <step-list>
    <step>Let <id>m</id> be ! ToString ( <id>x</id> ).</step>
  </step-list></step>
  <step>Else <id>x</id> < 10 21 ,   <step-list>
    <step>Let <id>n</id> be an integer for which the exact mathematical value of <id>n</id> ÷ 10 f - <id>x</id> is as close to zero as possible. If there are two such <id>n</id> , pick the larger <id>n</id> .</step>
    <step>If <id>n</id> = 0, let <id>m</id> be the String <value>"0"</value> . Otherwise, let <id>m</id> be the String value consisting of the digits of the decimal representation of <id>n</id> (in order, with no leading zeroes).</step>
    <step>If <id>f</id> ≠ 0, then     <step-list>
      <step>Let <id>k</id> be the length of <id>m</id> .</step>
      <step>If <id>k</id> ≤ <id>f</id> , then       <step-list>
        <step>Let <id>z</id> be the String value consisting of <id>f</id> +1- <id>k</id> occurrences of the code unit 0x0030 (DIGIT ZERO).</step>
        <step>Let <id>m</id> be the string-concatenation of <id>z</id> and <id>m</id> .</step>
        <step>Let <id>k</id> be <id>f</id> + 1.</step>
      </step-list></step>
      <step>Let <id>a</id> be the first <id>k</id> - <id>f</id> elements of <id>m</id> , and let <id>b</id> be the remaining <id>f</id> elements of <id>m</id> .</step>
      <step>Let <id>m</id> be the string-concatenation of <id>a</id> , <value>"."</value> , and <id>b</id> .</step>
    </step-list></step>
  </step-list></step>
  <step>Return the string-concatenation of <id>s</id> and <id>m</id> .</step>
</step-list>
<step-list>
  <step>Let <id>x</id> be ? thisNumberValue ( <value>this</value> value).</step>
  <step>If <id>precision</id> is <value>undefined</value> , return ! ToString ( <id>x</id> ).</step>
  <step>Let <id>p</id> be ? ToInteger ( <id>precision</id> ).</step>
  <step>If <id>x</id> is <value>NaN</value> , return the String <value>"NaN"</value> .</step>
  <step>Let <id>s</id> be the empty String.</step>
  <step>If <id>x</id> < 0, then   <step-list>
    <step>Let <id>s</id> be the code unit 0x002D (HYPHEN-MINUS).</step>
    <step>Let <id>x</id> be - <id>x</id> .</step>
  </step-list></step>
  <step>If <id>x</id> = <value>+∞</value> , then   <step-list>
    <step>Return the string-concatenation of <id>s</id> and <value>"Infinity"</value> .</step>
  </step-list></step>
  <step>If <id>p</id> < 1 or <id>p</id> > 100, throw a <value>RangeError</value> exception.</step>
  <step>If <id>x</id> = 0, then   <step-list>
    <step>Let <id>m</id> be the String value consisting of <id>p</id> occurrences of the code unit 0x0030 (DIGIT ZERO).</step>
    <step>Let <id>e</id> be 0.</step>
  </step-list></step>
  <step>Else <id>x</id> ≠ 0,   <step-list>
    <step>Let <id>e</id> and <id>n</id> be integers such that 10 p-1 ≤ <id>n</id> < 10 p and for which the exact mathematical value of <id>n</id> × 10 e-p+1 - <id>x</id> is as close to zero as possible. If there are two such sets of <id>e</id> and <id>n</id> , pick the <id>e</id> and <id>n</id> for which <id>n</id> × 10 e-p+1 is larger.</step>
    <step>Let <id>m</id> be the String value consisting of the digits of the decimal representation of <id>n</id> (in order, with no leading zeroes).</step>
    <step>If <id>e</id> < -6 or <id>e</id> ≥ <id>p</id> , then     <step-list>
      <step>Assert : <id>e</id> ≠ 0.</step>
      <step>If <id>p</id> ≠ 1, then       <step-list>
        <step>Let <id>a</id> be the first element of <id>m</id> , and let <id>b</id> be the remaining <id>p</id> -1 elements of <id>m</id> .</step>
        <step>Let <id>m</id> be the string-concatenation of <id>a</id> , <value>"."</value> , and <id>b</id> .</step>
      </step-list></step>
      <step>If <id>e</id> > 0, then       <step-list>
        <step>Let <id>c</id> be the code unit 0x002B (PLUS SIGN).</step>
      </step-list></step>
      <step>Else <id>e</id> < 0,       <step-list>
        <step>Let <id>c</id> be the code unit 0x002D (HYPHEN-MINUS).</step>
        <step>Let <id>e</id> be - <id>e</id> .</step>
      </step-list></step>
      <step>Let <id>d</id> be the String value consisting of the digits of the decimal representation of <id>e</id> (in order, with no leading zeroes).</step>
      <step>Return the string-concatenation of <id>s</id> , <id>m</id> , the code unit 0x0065 (LATIN SMALL LETTER E), <id>c</id> , and <id>d</id> .</step>
    </step-list></step>
  </step-list></step>
  <step>If <id>e</id> = <id>p</id> -1, return the string-concatenation of <id>s</id> and <id>m</id> .</step>
  <step>If <id>e</id> ≥ 0, then   <step-list>
    <step>Let <id>m</id> be the string-concatenation of the first <id>e</id> +1 elements of <id>m</id> , the code unit 0x002E (FULL STOP), and the remaining <id>p</id> - ( <id>e</id> +1) elements of <id>m</id> .</step>
  </step-list></step>
  <step>Else <id>e</id> < 0,   <step-list>
    <step>Let <id>m</id> be the string-concatenation of the code unit 0x0030 (DIGIT ZERO), the code unit 0x002E (FULL STOP), -( <id>e</id> +1) occurrences of the code unit 0x0030 (DIGIT ZERO), and the String <id>m</id> .</step>
  </step-list></step>
  <step>Return the string-concatenation of <id>s</id> and <id>m</id> .</step>
</step-list>
<step-list>
  <step>Let <id>x</id> be ? thisNumberValue ( <value>this</value> value).</step>
  <step>If <id>radix</id> is not present, let <id>radixNumber</id> be 10.</step>
  <step>Else if <id>radix</id> is <value>undefined</value> , let <id>radixNumber</id> be 10.</step>
  <step>Else, let <id>radixNumber</id> be ? ToInteger ( <id>radix</id> ).</step>
  <step>If <id>radixNumber</id> < 2 or <id>radixNumber</id> > 36, throw a <value>RangeError</value> exception.</step>
  <step>If <id>radixNumber</id> = 10, return ! ToString ( <id>x</id> ).</step>
  <step>Return the String representation of this Number value using the radix specified by <id>radixNumber</id> . Letters <value>a</value> - <value>z</value> are used for digits with values 10 through 35. The precise algorithm is
 implementation-dependent, however the algorithm should be a 
generalization of that specified in 7.1.12.1 .</step>
</step-list>
<step-list>
  <step>Return ? thisNumberValue ( <value>this</value> value).</step>
</step-list>
<step-list>
  <step>Let <id>n</id> be ToUint32 ( <id>x</id> ).</step>
  <step>Let <id>p</id> be the number of leading zero bits in the 32-bit binary representation of <id>n</id> .</step>
  <step>Return <id>p</id> .</step>
</step-list>
<step-list>
  <step>If <id>x</id> is <value>NaN</value> , return <value>NaN</value> .</step>
  <step>If <id>x</id> is one of <value>+0</value> , <value>-0</value> , <value>+∞</value> , <value>-∞</value> , return <id>x</id> .</step>
  <step>Let <id>x32</id> be the result of converting <id>x</id> to a value in IEEE 754-2008 binary32 format using roundTiesToEven.</step>
  <step>Let <id>x64</id> be the result of converting <id>x32</id> to a value in IEEE 754-2008 binary64 format.</step>
  <step>Return the ECMAScript Number value corresponding to <id>x64</id> .</step>
</step-list>
<step-list>
  <step>Let <id>a</id> be ToUint32 ( <id>x</id> ).</step>
  <step>Let <id>b</id> be ToUint32 ( <id>y</id> ).</step>
  <step>Let <id>product</id> be ( <id>a</id> × <id>b</id> ) modulo 2 32 .</step>
  <step>If <id>product</id> ≥ 2 31 , return <id>product</id> - 2 32 ; otherwise return <id>product</id> .</step>
</step-list>
<step-list>
  <step>Return <id>t</id> + LocalTZA ( <id>t</id> , <value>true</value> ).</step>
</step-list>
<step-list>
  <step>Return <id>t</id> - LocalTZA ( <id>t</id> , <value>false</value> ).</step>
</step-list>
<step-list>
  <step>If <id>hour</id> is not finite or <id>min</id> is not finite or <id>sec</id> is not finite or <id>ms</id> is not finite, return <value>NaN</value> .</step>
  <step>Let <id>h</id> be ! ToInteger ( <id>hour</id> ).</step>
  <step>Let <id>m</id> be ! ToInteger ( <id>min</id> ).</step>
  <step>Let <id>s</id> be ! ToInteger ( <id>sec</id> ).</step>
  <step>Let <id>milli</id> be ! ToInteger ( <id>ms</id> ).</step>
  <step>Let <id>t</id> be <id>h</id>  <value>*</value>  msPerHour  <value>+</value>  <id>m</id>  <value>*</value>  msPerMinute  <value>+</value>  <id>s</id>  <value>*</value>  msPerSecond  <value>+</value>  <id>milli</id> , performing the arithmetic according to IEEE 754-2008 rules (that is, as if using the ECMAScript operators <value>*</value> and <value>+</value> ).</step>
  <step>Return <id>t</id> .</step>
</step-list>
<step-list>
  <step>If <id>year</id> is not finite or <id>month</id> is not finite or <id>date</id> is not finite, return <value>NaN</value> .</step>
  <step>Let <id>y</id> be ! ToInteger ( <id>year</id> ).</step>
  <step>Let <id>m</id> be ! ToInteger ( <id>month</id> ).</step>
  <step>Let <id>dt</id> be ! ToInteger ( <id>date</id> ).</step>
  <step>Let <id>ym</id> be <id>y</id> + floor ( <id>m</id> / 12).</step>
  <step>Let <id>mn</id> be <id>m</id>  modulo 12.</step>
  <step>Find a value <id>t</id> such that YearFromTime ( <id>t</id> ) is <id>ym</id> and MonthFromTime ( <id>t</id> ) is <id>mn</id> and DateFromTime ( <id>t</id> ) is 1; but if this is not possible (because some argument is out of range), return <value>NaN</value> .</step>
  <step>Return Day ( <id>t</id> ) + <id>dt</id> - 1.</step>
</step-list>
<step-list>
  <step>If <id>day</id> is not finite or <id>time</id> is not finite, return <value>NaN</value> .</step>
  <step>Return <id>day</id> × msPerDay + <id>time</id> .</step>
</step-list>
<step-list>
  <step>If <id>time</id> is not finite, return <value>NaN</value> .</step>
  <step>If abs ( <id>time</id> ) > 8.64 × 10 15 , return <value>NaN</value> .</step>
  <step>Let <id>clippedTime</id> be ! ToInteger ( <id>time</id> ).</step>
  <step>If <id>clippedTime</id> is <value>-0</value> , set <id>clippedTime</id> to <value>+0</value> .</step>
  <step>Return <id>clippedTime</id> .</step>
</step-list>
<step-list>
  <step>Let <id>numberOfArgs</id> be the number of arguments passed to this function call.</step>
  <step>Assert : <id>numberOfArgs</id> ≥ 2.</step>
  <step>If NewTarget is <value>undefined</value> , then   <step-list>
    <step>Let <id>now</id> be the Number that is the time value (UTC) identifying the current time.</step>
    <step>Return ToDateString ( <id>now</id> ).</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>y</id> be ? ToNumber ( <id>year</id> ).</step>
    <step>Let <id>m</id> be ? ToNumber ( <id>month</id> ).</step>
    <step>If <id>date</id> is present, let <id>dt</id> be ? ToNumber ( <id>date</id> ); else let <id>dt</id> be 1.</step>
    <step>If <id>hours</id> is present, let <id>h</id> be ? ToNumber ( <id>hours</id> ); else let <id>h</id> be 0.</step>
    <step>If <id>minutes</id> is present, let <id>min</id> be ? ToNumber ( <id>minutes</id> ); else let <id>min</id> be 0.</step>
    <step>If <id>seconds</id> is present, let <id>s</id> be ? ToNumber ( <id>seconds</id> ); else let <id>s</id> be 0.</step>
    <step>If <id>ms</id> is present, let <id>milli</id> be ? ToNumber ( <id>ms</id> ); else let <id>milli</id> be 0.</step>
    <step>If <id>y</id> is not <value>NaN</value> and 0 ≤ ToInteger ( <id>y</id> ) ≤ 99, let <id>yr</id> be 1900+ ToInteger ( <id>y</id> ); otherwise, let <id>yr</id> be <id>y</id> .</step>
    <step>Let <id>finalDate</id> be MakeDate ( MakeDay ( <id>yr</id> , <id>m</id> , <id>dt</id> ), MakeTime ( <id>h</id> , <id>min</id> , <id>s</id> , <id>milli</id> )).</step>
    <step>Let <id>O</id> be ? OrdinaryCreateFromConstructor (NewTarget, <value>"%DatePrototype%"</value> , « [[DateValue]] »).</step>
    <step>Set <id>O</id> .[[DateValue]] to TimeClip ( UTC ( <id>finalDate</id> )).</step>
    <step>Return <id>O</id> .</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>numberOfArgs</id> be the number of arguments passed to this function call.</step>
  <step>Assert : <id>numberOfArgs</id> = 1.</step>
  <step>If NewTarget is <value>undefined</value> , then   <step-list>
    <step>Let <id>now</id> be the Number that is the time value (UTC) identifying the current time.</step>
    <step>Return ToDateString ( <id>now</id> ).</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>If Type ( <id>value</id> ) is Object and <id>value</id> has a [[DateValue]] internal slot, then     <step-list>
      <step>Let <id>tv</id> be thisTimeValue ( <id>value</id> ).</step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>Let <id>v</id> be ? ToPrimitive ( <id>value</id> ).</step>
      <step>If Type ( <id>v</id> ) is String, then       <step-list>
        <step>Assert : The next step never returns an abrupt completion because <id>v</id> is a String value.</step>
        <step>Let <id>tv</id> be the result of parsing <id>v</id> as a date, in exactly the same manner as for the <value>parse</value> method ( 20.3.3.2 ).</step>
      </step-list></step>
      <step>Else,       <step-list>
        <step>Let <id>tv</id> be ? ToNumber ( <id>v</id> ).</step>
      </step-list></step>
    </step-list></step>
    <step>Let <id>O</id> be ? OrdinaryCreateFromConstructor (NewTarget, <value>"%DatePrototype%"</value> , « [[DateValue]] »).</step>
    <step>Set <id>O</id> .[[DateValue]] to TimeClip ( <id>tv</id> ).</step>
    <step>Return <id>O</id> .</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>numberOfArgs</id> be the number of arguments passed to this function call.</step>
  <step>Assert : <id>numberOfArgs</id> = 0.</step>
  <step>If NewTarget is <value>undefined</value> , then   <step-list>
    <step>Let <id>now</id> be the Number that is the time value (UTC) identifying the current time.</step>
    <step>Return ToDateString ( <id>now</id> ).</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>O</id> be ? OrdinaryCreateFromConstructor (NewTarget, <value>"%DatePrototype%"</value> , « [[DateValue]] »).</step>
    <step>Set <id>O</id> .[[DateValue]] to the time value (UTC) identifying the current time.</step>
    <step>Return <id>O</id> .</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>y</id> be ? ToNumber ( <id>year</id> ).</step>
  <step>If <id>month</id> is present, let <id>m</id> be ? ToNumber ( <id>month</id> ); else let <id>m</id> be 0.</step>
  <step>If <id>date</id> is present, let <id>dt</id> be ? ToNumber ( <id>date</id> ); else let <id>dt</id> be 1.</step>
  <step>If <id>hours</id> is present, let <id>h</id> be ? ToNumber ( <id>hours</id> ); else let <id>h</id> be 0.</step>
  <step>If <id>minutes</id> is present, let <id>min</id> be ? ToNumber ( <id>minutes</id> ); else let <id>min</id> be 0.</step>
  <step>If <id>seconds</id> is present, let <id>s</id> be ? ToNumber ( <id>seconds</id> ); else let <id>s</id> be 0.</step>
  <step>If <id>ms</id> is present, let <id>milli</id> be ? ToNumber ( <id>ms</id> ); else let <id>milli</id> be 0.</step>
  <step>If <id>y</id> is not <value>NaN</value> and 0 ≤ ToInteger ( <id>y</id> ) ≤ 99, let <id>yr</id> be 1900+ ToInteger ( <id>y</id> ); otherwise, let <id>yr</id> be <id>y</id> .</step>
  <step>Return TimeClip ( MakeDate ( MakeDay ( <id>yr</id> , <id>m</id> , <id>dt</id> ), MakeTime ( <id>h</id> , <id>min</id> , <id>s</id> , <id>milli</id> ))).</step>
</step-list>
<step-list>
  <step>If Type ( <id>value</id> ) is Object and <id>value</id> has a [[DateValue]] internal slot, then   <step-list>
    <step>Return <id>value</id> .[[DateValue]].</step>
  </step-list></step>
  <step>Throw a <value>TypeError</value> exception.</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be ? thisTimeValue ( <value>this</value> value).</step>
  <step>If <id>t</id> is <value>NaN</value> , return <value>NaN</value> .</step>
  <step>Return DateFromTime ( LocalTime ( <id>t</id> )).</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be ? thisTimeValue ( <value>this</value> value).</step>
  <step>If <id>t</id> is <value>NaN</value> , return <value>NaN</value> .</step>
  <step>Return WeekDay ( LocalTime ( <id>t</id> )).</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be ? thisTimeValue ( <value>this</value> value).</step>
  <step>If <id>t</id> is <value>NaN</value> , return <value>NaN</value> .</step>
  <step>Return YearFromTime ( LocalTime ( <id>t</id> )).</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be ? thisTimeValue ( <value>this</value> value).</step>
  <step>If <id>t</id> is <value>NaN</value> , return <value>NaN</value> .</step>
  <step>Return HourFromTime ( LocalTime ( <id>t</id> )).</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be ? thisTimeValue ( <value>this</value> value).</step>
  <step>If <id>t</id> is <value>NaN</value> , return <value>NaN</value> .</step>
  <step>Return msFromTime ( LocalTime ( <id>t</id> )).</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be ? thisTimeValue ( <value>this</value> value).</step>
  <step>If <id>t</id> is <value>NaN</value> , return <value>NaN</value> .</step>
  <step>Return MinFromTime ( LocalTime ( <id>t</id> )).</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be ? thisTimeValue ( <value>this</value> value).</step>
  <step>If <id>t</id> is <value>NaN</value> , return <value>NaN</value> .</step>
  <step>Return MonthFromTime ( LocalTime ( <id>t</id> )).</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be ? thisTimeValue ( <value>this</value> value).</step>
  <step>If <id>t</id> is <value>NaN</value> , return <value>NaN</value> .</step>
  <step>Return SecFromTime ( LocalTime ( <id>t</id> )).</step>
</step-list>
<step-list>
  <step>Return ? thisTimeValue ( <value>this</value> value).</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be ? thisTimeValue ( <value>this</value> value).</step>
  <step>If <id>t</id> is <value>NaN</value> , return <value>NaN</value> .</step>
  <step>Return ( <id>t</id> - LocalTime ( <id>t</id> )) / msPerMinute .</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be ? thisTimeValue ( <value>this</value> value).</step>
  <step>If <id>t</id> is <value>NaN</value> , return <value>NaN</value> .</step>
  <step>Return DateFromTime ( <id>t</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be ? thisTimeValue ( <value>this</value> value).</step>
  <step>If <id>t</id> is <value>NaN</value> , return <value>NaN</value> .</step>
  <step>Return WeekDay ( <id>t</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be ? thisTimeValue ( <value>this</value> value).</step>
  <step>If <id>t</id> is <value>NaN</value> , return <value>NaN</value> .</step>
  <step>Return YearFromTime ( <id>t</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be ? thisTimeValue ( <value>this</value> value).</step>
  <step>If <id>t</id> is <value>NaN</value> , return <value>NaN</value> .</step>
  <step>Return HourFromTime ( <id>t</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be ? thisTimeValue ( <value>this</value> value).</step>
  <step>If <id>t</id> is <value>NaN</value> , return <value>NaN</value> .</step>
  <step>Return msFromTime ( <id>t</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be ? thisTimeValue ( <value>this</value> value).</step>
  <step>If <id>t</id> is <value>NaN</value> , return <value>NaN</value> .</step>
  <step>Return MinFromTime ( <id>t</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be ? thisTimeValue ( <value>this</value> value).</step>
  <step>If <id>t</id> is <value>NaN</value> , return <value>NaN</value> .</step>
  <step>Return MonthFromTime ( <id>t</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be ? thisTimeValue ( <value>this</value> value).</step>
  <step>If <id>t</id> is <value>NaN</value> , return <value>NaN</value> .</step>
  <step>Return SecFromTime ( <id>t</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be LocalTime (? thisTimeValue ( <value>this</value> value)).</step>
  <step>Let <id>dt</id> be ? ToNumber ( <id>date</id> ).</step>
  <step>Let <id>newDate</id> be MakeDate ( MakeDay ( YearFromTime ( <id>t</id> ), MonthFromTime ( <id>t</id> ), <id>dt</id> ), TimeWithinDay ( <id>t</id> )).</step>
  <step>Let <id>u</id> be TimeClip ( UTC ( <id>newDate</id> )).</step>
  <step>Set the [[DateValue]] internal slot of this Date object to <id>u</id> .</step>
  <step>Return <id>u</id> .</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be ? thisTimeValue ( <value>this</value> value).</step>
  <step>If <id>t</id> is <value>NaN</value> , let <id>t</id> be <value>+0</value> ; otherwise, let <id>t</id> be LocalTime ( <id>t</id> ).</step>
  <step>Let <id>y</id> be ? ToNumber ( <id>year</id> ).</step>
  <step>If <id>month</id> is not present, let <id>m</id> be MonthFromTime ( <id>t</id> ); otherwise, let <id>m</id> be ? ToNumber ( <id>month</id> ).</step>
  <step>If <id>date</id> is not present, let <id>dt</id> be DateFromTime ( <id>t</id> ); otherwise, let <id>dt</id> be ? ToNumber ( <id>date</id> ).</step>
  <step>Let <id>newDate</id> be MakeDate ( MakeDay ( <id>y</id> , <id>m</id> , <id>dt</id> ), TimeWithinDay ( <id>t</id> )).</step>
  <step>Let <id>u</id> be TimeClip ( UTC ( <id>newDate</id> )).</step>
  <step>Set the [[DateValue]] internal slot of this Date object to <id>u</id> .</step>
  <step>Return <id>u</id> .</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be LocalTime (? thisTimeValue ( <value>this</value> value)).</step>
  <step>Let <id>h</id> be ? ToNumber ( <id>hour</id> ).</step>
  <step>If <id>min</id> is not present, let <id>m</id> be MinFromTime ( <id>t</id> ); otherwise, let <id>m</id> be ? ToNumber ( <id>min</id> ).</step>
  <step>If <id>sec</id> is not present, let <id>s</id> be SecFromTime ( <id>t</id> ); otherwise, let <id>s</id> be ? ToNumber ( <id>sec</id> ).</step>
  <step>If <id>ms</id> is not present, let <id>milli</id> be msFromTime ( <id>t</id> ); otherwise, let <id>milli</id> be ? ToNumber ( <id>ms</id> ).</step>
  <step>Let <id>date</id> be MakeDate ( Day ( <id>t</id> ), MakeTime ( <id>h</id> , <id>m</id> , <id>s</id> , <id>milli</id> )).</step>
  <step>Let <id>u</id> be TimeClip ( UTC ( <id>date</id> )).</step>
  <step>Set the [[DateValue]] internal slot of this Date object to <id>u</id> .</step>
  <step>Return <id>u</id> .</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be LocalTime (? thisTimeValue ( <value>this</value> value)).</step>
  <step>Let <id>ms</id> be ? ToNumber ( <id>ms</id> ).</step>
  <step>Let <id>time</id> be MakeTime ( HourFromTime ( <id>t</id> ), MinFromTime ( <id>t</id> ), SecFromTime ( <id>t</id> ), <id>ms</id> ).</step>
  <step>Let <id>u</id> be TimeClip ( UTC ( MakeDate ( Day ( <id>t</id> ), <id>time</id> ))).</step>
  <step>Set the [[DateValue]] internal slot of this Date object to <id>u</id> .</step>
  <step>Return <id>u</id> .</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be LocalTime (? thisTimeValue ( <value>this</value> value)).</step>
  <step>Let <id>m</id> be ? ToNumber ( <id>min</id> ).</step>
  <step>If <id>sec</id> is not present, let <id>s</id> be SecFromTime ( <id>t</id> ); otherwise, let <id>s</id> be ? ToNumber ( <id>sec</id> ).</step>
  <step>If <id>ms</id> is not present, let <id>milli</id> be msFromTime ( <id>t</id> ); otherwise, let <id>milli</id> be ? ToNumber ( <id>ms</id> ).</step>
  <step>Let <id>date</id> be MakeDate ( Day ( <id>t</id> ), MakeTime ( HourFromTime ( <id>t</id> ), <id>m</id> , <id>s</id> , <id>milli</id> )).</step>
  <step>Let <id>u</id> be TimeClip ( UTC ( <id>date</id> )).</step>
  <step>Set the [[DateValue]] internal slot of this Date object to <id>u</id> .</step>
  <step>Return <id>u</id> .</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be LocalTime (? thisTimeValue ( <value>this</value> value)).</step>
  <step>Let <id>m</id> be ? ToNumber ( <id>month</id> ).</step>
  <step>If <id>date</id> is not present, let <id>dt</id> be DateFromTime ( <id>t</id> ); otherwise, let <id>dt</id> be ? ToNumber ( <id>date</id> ).</step>
  <step>Let <id>newDate</id> be MakeDate ( MakeDay ( YearFromTime ( <id>t</id> ), <id>m</id> , <id>dt</id> ), TimeWithinDay ( <id>t</id> )).</step>
  <step>Let <id>u</id> be TimeClip ( UTC ( <id>newDate</id> )).</step>
  <step>Set the [[DateValue]] internal slot of this Date object to <id>u</id> .</step>
  <step>Return <id>u</id> .</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be LocalTime (? thisTimeValue ( <value>this</value> value)).</step>
  <step>Let <id>s</id> be ? ToNumber ( <id>sec</id> ).</step>
  <step>If <id>ms</id> is not present, let <id>milli</id> be msFromTime ( <id>t</id> ); otherwise, let <id>milli</id> be ? ToNumber ( <id>ms</id> ).</step>
  <step>Let <id>date</id> be MakeDate ( Day ( <id>t</id> ), MakeTime ( HourFromTime ( <id>t</id> ), MinFromTime ( <id>t</id> ), <id>s</id> , <id>milli</id> )).</step>
  <step>Let <id>u</id> be TimeClip ( UTC ( <id>date</id> )).</step>
  <step>Set the [[DateValue]] internal slot of this Date object to <id>u</id> .</step>
  <step>Return <id>u</id> .</step>
</step-list>
<step-list>
  <step>Perform ? thisTimeValue ( <value>this</value> value).</step>
  <step>Let <id>t</id> be ? ToNumber ( <id>time</id> ).</step>
  <step>Let <id>v</id> be TimeClip ( <id>t</id> ).</step>
  <step>Set the [[DateValue]] internal slot of this Date object to <id>v</id> .</step>
  <step>Return <id>v</id> .</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be ? thisTimeValue ( <value>this</value> value).</step>
  <step>Let <id>dt</id> be ? ToNumber ( <id>date</id> ).</step>
  <step>Let <id>newDate</id> be MakeDate ( MakeDay ( YearFromTime ( <id>t</id> ), MonthFromTime ( <id>t</id> ), <id>dt</id> ), TimeWithinDay ( <id>t</id> )).</step>
  <step>Let <id>v</id> be TimeClip ( <id>newDate</id> ).</step>
  <step>Set the [[DateValue]] internal slot of this Date object to <id>v</id> .</step>
  <step>Return <id>v</id> .</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be ? thisTimeValue ( <value>this</value> value).</step>
  <step>If <id>t</id> is <value>NaN</value> , let <id>t</id> be <value>+0</value> .</step>
  <step>Let <id>y</id> be ? ToNumber ( <id>year</id> ).</step>
  <step>If <id>month</id> is not present, let <id>m</id> be MonthFromTime ( <id>t</id> ); otherwise, let <id>m</id> be ? ToNumber ( <id>month</id> ).</step>
  <step>If <id>date</id> is not present, let <id>dt</id> be DateFromTime ( <id>t</id> ); otherwise, let <id>dt</id> be ? ToNumber ( <id>date</id> ).</step>
  <step>Let <id>newDate</id> be MakeDate ( MakeDay ( <id>y</id> , <id>m</id> , <id>dt</id> ), TimeWithinDay ( <id>t</id> )).</step>
  <step>Let <id>v</id> be TimeClip ( <id>newDate</id> ).</step>
  <step>Set the [[DateValue]] internal slot of this Date object to <id>v</id> .</step>
  <step>Return <id>v</id> .</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be ? thisTimeValue ( <value>this</value> value).</step>
  <step>Let <id>h</id> be ? ToNumber ( <id>hour</id> ).</step>
  <step>If <id>min</id> is not present, let <id>m</id> be MinFromTime ( <id>t</id> ); otherwise, let <id>m</id> be ? ToNumber ( <id>min</id> ).</step>
  <step>If <id>sec</id> is not present, let <id>s</id> be SecFromTime ( <id>t</id> ); otherwise, let <id>s</id> be ? ToNumber ( <id>sec</id> ).</step>
  <step>If <id>ms</id> is not present, let <id>milli</id> be msFromTime ( <id>t</id> ); otherwise, let <id>milli</id> be ? ToNumber ( <id>ms</id> ).</step>
  <step>Let <id>newDate</id> be MakeDate ( Day ( <id>t</id> ), MakeTime ( <id>h</id> , <id>m</id> , <id>s</id> , <id>milli</id> )).</step>
  <step>Let <id>v</id> be TimeClip ( <id>newDate</id> ).</step>
  <step>Set the [[DateValue]] internal slot of this Date object to <id>v</id> .</step>
  <step>Return <id>v</id> .</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be ? thisTimeValue ( <value>this</value> value).</step>
  <step>Let <id>milli</id> be ? ToNumber ( <id>ms</id> ).</step>
  <step>Let <id>time</id> be MakeTime ( HourFromTime ( <id>t</id> ), MinFromTime ( <id>t</id> ), SecFromTime ( <id>t</id> ), <id>milli</id> ).</step>
  <step>Let <id>v</id> be TimeClip ( MakeDate ( Day ( <id>t</id> ), <id>time</id> )).</step>
  <step>Set the [[DateValue]] internal slot of this Date object to <id>v</id> .</step>
  <step>Return <id>v</id> .</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be ? thisTimeValue ( <value>this</value> value).</step>
  <step>Let <id>m</id> be ? ToNumber ( <id>min</id> ).</step>
  <step>If <id>sec</id> is not present, let <id>s</id> be SecFromTime ( <id>t</id> ).</step>
  <step>Else,   <step-list>
    <step>Let <id>s</id> be ? ToNumber ( <id>sec</id> ).</step>
  </step-list></step>
  <step>If <id>ms</id> is not present, let <id>milli</id> be msFromTime ( <id>t</id> ).</step>
  <step>Else,   <step-list>
    <step>Let <id>milli</id> be ? ToNumber ( <id>ms</id> ).</step>
  </step-list></step>
  <step>Let <id>date</id> be MakeDate ( Day ( <id>t</id> ), MakeTime ( HourFromTime ( <id>t</id> ), <id>m</id> , <id>s</id> , <id>milli</id> )).</step>
  <step>Let <id>v</id> be TimeClip ( <id>date</id> ).</step>
  <step>Set the [[DateValue]] internal slot of this Date object to <id>v</id> .</step>
  <step>Return <id>v</id> .</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be ? thisTimeValue ( <value>this</value> value).</step>
  <step>Let <id>m</id> be ? ToNumber ( <id>month</id> ).</step>
  <step>If <id>date</id> is not present, let <id>dt</id> be DateFromTime ( <id>t</id> ).</step>
  <step>Else,   <step-list>
    <step>Let <id>dt</id> be ? ToNumber ( <id>date</id> ).</step>
  </step-list></step>
  <step>Let <id>newDate</id> be MakeDate ( MakeDay ( YearFromTime ( <id>t</id> ), <id>m</id> , <id>dt</id> ), TimeWithinDay ( <id>t</id> )).</step>
  <step>Let <id>v</id> be TimeClip ( <id>newDate</id> ).</step>
  <step>Set the [[DateValue]] internal slot of this Date object to <id>v</id> .</step>
  <step>Return <id>v</id> .</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be ? thisTimeValue ( <value>this</value> value).</step>
  <step>Let <id>s</id> be ? ToNumber ( <id>sec</id> ).</step>
  <step>If <id>ms</id> is not present, let <id>milli</id> be msFromTime ( <id>t</id> ).</step>
  <step>Else,   <step-list>
    <step>Let <id>milli</id> be ? ToNumber ( <id>ms</id> ).</step>
  </step-list></step>
  <step>Let <id>date</id> be MakeDate ( Day ( <id>t</id> ), MakeTime ( HourFromTime ( <id>t</id> ), MinFromTime ( <id>t</id> ), <id>s</id> , <id>milli</id> )).</step>
  <step>Let <id>v</id> be TimeClip ( <id>date</id> ).</step>
  <step>Set the [[DateValue]] internal slot of this Date object to <id>v</id> .</step>
  <step>Return <id>v</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be this Date object .</step>
  <step>Let <id>tv</id> be ? thisTimeValue ( <id>O</id> ).</step>
  <step>If <id>tv</id> is <value>NaN</value> , return <value>"Invalid Date"</value> .</step>
  <step>Let <id>t</id> be LocalTime ( <id>tv</id> ).</step>
  <step>Return DateString ( <id>t</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Let <id>tv</id> be ? ToPrimitive ( <id>O</id> , hint Number).</step>
  <step>If Type ( <id>tv</id> ) is Number and <id>tv</id> is not finite, return <value>null</value> .</step>
  <step>Return ? Invoke ( <id>O</id> , <value>"toISOString"</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>tv</id> be ? thisTimeValue ( <value>this</value> value).</step>
  <step>Return ToDateString ( <id>tv</id> ).</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>tv</id> ) is Number.</step>
  <step>Assert : <id>tv</id> is not <value>NaN</value> .</step>
  <step>Let <id>hour</id> be the String representation of HourFromTime ( <id>tv</id> ), formatted as a two-digit decimal number, padded to the left with a zero if necessary.</step>
  <step>Let <id>minute</id> be the String representation of MinFromTime ( <id>tv</id> ), formatted as a two-digit decimal number, padded to the left with a zero if necessary.</step>
  <step>Let <id>second</id> be the String representation of SecFromTime ( <id>tv</id> ), formatted as a two-digit decimal number, padded to the left with a zero if necessary.</step>
  <step>Return the string-concatenation of <id>hour</id> , <value>":"</value> , <id>minute</id> , <value>":"</value> , <id>second</id> , the code unit 0x0020 (SPACE), and <value>"GMT"</value> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>tv</id> ) is Number.</step>
  <step>Assert : <id>tv</id> is not <value>NaN</value> .</step>
  <step>Let <id>weekday</id> be the Name of the entry in Table 46 with the Number WeekDay ( <id>tv</id> ).</step>
  <step>Let <id>month</id> be the Name of the entry in Table 47 with the Number MonthFromTime ( <id>tv</id> ).</step>
  <step>Let <id>day</id> be the String representation of DateFromTime ( <id>tv</id> ), formatted as a two-digit decimal number, padded to the left with a zero if necessary.</step>
  <step>Let <id>year</id> be the String representation of YearFromTime ( <id>tv</id> ), formatted as a decimal number of at least four digits, padded to the left with zeroes if necessary.</step>
  <step>Return the string-concatenation of <id>weekday</id> , the code unit 0x0020 (SPACE), <id>month</id> , the code unit 0x0020 (SPACE), <id>day</id> , the code unit 0x0020 (SPACE), and <id>year</id> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>tv</id> ) is Number.</step>
  <step>Assert : <id>tv</id> is not <value>NaN</value> .</step>
  <step>Let <id>offset</id> be LocalTZA ( <id>tv</id> , <value>true</value> ).</step>
  <step>If <id>offset</id> ≥ 0, let <id>offsetSign</id> be <value>"+"</value> ; otherwise, let <id>offsetSign</id> be <value>"-"</value> .</step>
  <step>Let <id>offsetMin</id> be the String representation of MinFromTime ( abs ( <id>offset</id> )), formatted as a two-digit decimal number, padded to the left with a zero if necessary.</step>
  <step>Let <id>offsetHour</id> be the String representation of HourFromTime ( abs ( <id>offset</id> )), formatted as a two-digit decimal number, padded to the left with a zero if necessary.</step>
  <step>Let <id>tzName</id> be an implementation-defined string that is either the empty string or the string-concatenation of the code unit 0x0020 (SPACE), the code unit 0x0028 (LEFT 
PARENTHESIS), an implementation-dependent timezone name, and the code 
unit 0x0029 (RIGHT PARENTHESIS).</step>
  <step>Return the string-concatenation of <id>offsetSign</id> , <id>offsetHour</id> , <id>offsetMin</id> , and <id>tzName</id> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>tv</id> ) is Number.</step>
  <step>If <id>tv</id> is <value>NaN</value> , return <value>"Invalid Date"</value> .</step>
  <step>Let <id>t</id> be LocalTime ( <id>tv</id> ).</step>
  <step>Return the string-concatenation of DateString ( <id>t</id> ), the code unit 0x0020 (SPACE), TimeString ( <id>t</id> ), and TimeZoneString ( <id>tv</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be this Date object .</step>
  <step>Let <id>tv</id> be ? thisTimeValue ( <id>O</id> ).</step>
  <step>If <id>tv</id> is <value>NaN</value> , return <value>"Invalid Date"</value> .</step>
  <step>Let <id>t</id> be LocalTime ( <id>tv</id> ).</step>
  <step>Return the string-concatenation of TimeString ( <id>t</id> ) and TimeZoneString ( <id>tv</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be this Date object .</step>
  <step>Let <id>tv</id> be ? thisTimeValue ( <id>O</id> ).</step>
  <step>If <id>tv</id> is <value>NaN</value> , return <value>"Invalid Date"</value> .</step>
  <step>Let <id>weekday</id> be the Name of the entry in Table 46 with the Number WeekDay ( <id>tv</id> ).</step>
  <step>Let <id>month</id> be the Name of the entry in Table 47 with the Number MonthFromTime ( <id>tv</id> ).</step>
  <step>Let <id>day</id> be the String representation of DateFromTime ( <id>tv</id> ), formatted as a two-digit decimal number, padded to the left with a zero if necessary.</step>
  <step>Let <id>year</id> be the String representation of YearFromTime ( <id>tv</id> ), formatted as a decimal number of at least four digits, padded to the left with zeroes if necessary.</step>
  <step>Return the string-concatenation of <id>weekday</id> , <value>","</value> , the code unit 0x0020 (SPACE), <id>day</id> , the code unit 0x0020 (SPACE), <id>month</id> , the code unit 0x0020 (SPACE), <id>year</id> , the code unit 0x0020 (SPACE), and TimeString ( <id>tv</id> ).</step>
</step-list>
<step-list>
  <step>Return ? thisTimeValue ( <value>this</value> value).</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>O</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>hint</id> is the String value <value>"string"</value> or the String value <value>"default"</value> , then   <step-list>
    <step>Let <id>tryFirst</id> be <value>"string"</value> .</step>
  </step-list></step>
  <step>Else if <id>hint</id> is the String value <value>"number"</value> , then   <step-list>
    <step>Let <id>tryFirst</id> be <value>"number"</value> .</step>
  </step-list></step>
  <step>Else, throw a <value>TypeError</value> exception.</step>
  <step>Return ? OrdinaryToPrimitive ( <id>O</id> , <id>tryFirst</id> ).</step>
</step-list>
<step-list>
  <step>If no arguments were passed to this function invocation, let <id>s</id> be <value>""</value> .</step>
  <step>Else,   <step-list>
    <step>If NewTarget is <value>undefined</value> and Type ( <id>value</id> ) is Symbol, return SymbolDescriptiveString ( <id>value</id> ).</step>
    <step>Let <id>s</id> be ? ToString ( <id>value</id> ).</step>
  </step-list></step>
  <step>If NewTarget is <value>undefined</value> , return <id>s</id> .</step>
  <step>Return ? StringCreate ( <id>s</id> , ? GetPrototypeFromConstructor (NewTarget, <value>"%StringPrototype%"</value> )).</step>
</step-list>
<step-list>
  <step>Let <id>codeUnits</id> be a List containing the arguments passed to this function.</step>
  <step>Let <id>length</id> be the number of elements in <id>codeUnits</id> .</step>
  <step>Let <id>elements</id> be a new empty List .</step>
  <step>Let <id>nextIndex</id> be 0.</step>
  <step>Repeat, while <id>nextIndex</id> < <id>length</id>   <step-list>
    <step>Let <id>next</id> be <id>codeUnits</id> [ <id>nextIndex</id> ].</step>
    <step>Let <id>nextCU</id> be ? ToUint16 ( <id>next</id> ).</step>
    <step>Append <id>nextCU</id> to the end of <id>elements</id> .</step>
    <step>Let <id>nextIndex</id> be <id>nextIndex</id> + 1.</step>
  </step-list></step>
  <step>Return the String value whose elements are, in order, the elements in the List  <id>elements</id> . If <id>length</id> is 0, the empty string is returned.</step>
</step-list>
<step-list>
  <step>Let <id>codePoints</id> be a List containing the arguments passed to this function.</step>
  <step>Let <id>length</id> be the number of elements in <id>codePoints</id> .</step>
  <step>Let <id>elements</id> be a new empty List .</step>
  <step>Let <id>nextIndex</id> be 0.</step>
  <step>Repeat, while <id>nextIndex</id> < <id>length</id>   <step-list>
    <step>Let <id>next</id> be <id>codePoints</id> [ <id>nextIndex</id> ].</step>
    <step>Let <id>nextCP</id> be ? ToNumber ( <id>next</id> ).</step>
    <step>If SameValue ( <id>nextCP</id> , ToInteger ( <id>nextCP</id> )) is <value>false</value> , throw a <value>RangeError</value> exception.</step>
    <step>If <id>nextCP</id> < 0 or <id>nextCP</id> > 0x10FFFF, throw a <value>RangeError</value> exception.</step>
    <step>Append the elements of the UTF16Encoding of <id>nextCP</id> to the end of <id>elements</id> .</step>
    <step>Let <id>nextIndex</id> be <id>nextIndex</id> + 1.</step>
  </step-list></step>
  <step>Return the String value whose elements are, in order, the elements in the List  <id>elements</id> . If <id>length</id> is 0, the empty string is returned.</step>
</step-list>
<step-list>
  <step>Let <id>substitutions</id> be a List consisting of all of the arguments passed to this function, starting 
with the second argument. If fewer than two arguments were passed, the List is empty.</step>
  <step>Let <id>numberOfSubstitutions</id> be the number of elements in <id>substitutions</id> .</step>
  <step>Let <id>cooked</id> be ? ToObject ( <id>template</id> ).</step>
  <step>Let <id>raw</id> be ? ToObject (? Get ( <id>cooked</id> , <value>"raw"</value> )).</step>
  <step>Let <id>literalSegments</id> be ? ToLength (? Get ( <id>raw</id> , <value>"length"</value> )).</step>
  <step>If <id>literalSegments</id> ≤ 0, return the empty string.</step>
  <step>Let <id>stringElements</id> be a new empty List .</step>
  <step>Let <id>nextIndex</id> be 0.</step>
  <step>Repeat,   <step-list>
    <step>Let <id>nextKey</id> be ! ToString ( <id>nextIndex</id> ).</step>
    <step>Let <id>nextSeg</id> be ? ToString (? Get ( <id>raw</id> , <id>nextKey</id> )).</step>
    <step>Append in order the code unit elements of <id>nextSeg</id> to the end of <id>stringElements</id> .</step>
    <step>If <id>nextIndex</id> + 1 = <id>literalSegments</id> , then     <step-list>
      <step>Return the String value whose code units are, in order, the elements in the List  <id>stringElements</id> . If <id>stringElements</id> has no elements, the empty string is returned.</step>
    </step-list></step>
    <step>If <id>nextIndex</id> < <id>numberOfSubstitutions</id> , let <id>next</id> be <id>substitutions</id> [ <id>nextIndex</id> ].</step>
    <step>Else, let <id>next</id> be the empty String.</step>
    <step>Let <id>nextSub</id> be ? ToString ( <id>next</id> ).</step>
    <step>Append in order the code unit elements of <id>nextSub</id> to the end of <id>stringElements</id> .</step>
    <step>Let <id>nextIndex</id> be <id>nextIndex</id> + 1.</step>
  </step-list></step>
</step-list>
<step-list>
  <step>If Type ( <id>value</id> ) is String, return <id>value</id> .</step>
  <step>If Type ( <id>value</id> ) is Object and <id>value</id> has a [[StringData]] internal slot, then   <step-list>
    <step>Assert : <id>value</id> .[[StringData]] is a String value.</step>
    <step>Return <id>value</id> .[[StringData]].</step>
  </step-list></step>
  <step>Throw a <value>TypeError</value> exception.</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? RequireObjectCoercible ( <value>this</value> value).</step>
  <step>Let <id>S</id> be ? ToString ( <id>O</id> ).</step>
  <step>Let <id>position</id> be ? ToInteger ( <id>pos</id> ).</step>
  <step>Let <id>size</id> be the length of <id>S</id> .</step>
  <step>If <id>position</id> < 0 or <id>position</id> ≥ <id>size</id> , return the empty String.</step>
  <step>Return the String value of length 1, containing one code unit from <id>S</id> , namely the code unit at index <id>position</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? RequireObjectCoercible ( <value>this</value> value).</step>
  <step>Let <id>S</id> be ? ToString ( <id>O</id> ).</step>
  <step>Let <id>position</id> be ? ToInteger ( <id>pos</id> ).</step>
  <step>Let <id>size</id> be the length of <id>S</id> .</step>
  <step>If <id>position</id> < 0 or <id>position</id> ≥ <id>size</id> , return <value>NaN</value> .</step>
  <step>Return a value of Number type, whose value is the numeric value of the code unit at index <id>position</id> within the String <id>S</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? RequireObjectCoercible ( <value>this</value> value).</step>
  <step>Let <id>S</id> be ? ToString ( <id>O</id> ).</step>
  <step>Let <id>position</id> be ? ToInteger ( <id>pos</id> ).</step>
  <step>Let <id>size</id> be the length of <id>S</id> .</step>
  <step>If <id>position</id> < 0 or <id>position</id> ≥ <id>size</id> , return <value>undefined</value> .</step>
  <step>Let <id>first</id> be the numeric value of the code unit at index <id>position</id> within the String <id>S</id> .</step>
  <step>If <id>first</id> < 0xD800 or <id>first</id> > 0xDBFF or <id>position</id> +1 = <id>size</id> , return <id>first</id> .</step>
  <step>Let <id>second</id> be the numeric value of the code unit at index <id>position</id> +1 within the String <id>S</id> .</step>
  <step>If <id>second</id> < 0xDC00 or <id>second</id> > 0xDFFF, return <id>first</id> .</step>
  <step>Return UTF16Decode ( <id>first</id> , <id>second</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? RequireObjectCoercible ( <value>this</value> value).</step>
  <step>Let <id>S</id> be ? ToString ( <id>O</id> ).</step>
  <step>Let <id>args</id> be a List whose elements are the arguments passed to this function.</step>
  <step>Let <id>R</id> be <id>S</id> .</step>
  <step>Repeat, while <id>args</id> is not empty   <step-list>
    <step>Remove the first element from <id>args</id> and let <id>next</id> be the value of that element.</step>
    <step>Let <id>nextString</id> be ? ToString ( <id>next</id> ).</step>
    <step>Set <id>R</id> to the string-concatenation of the previous value of <id>R</id> and <id>nextString</id> .</step>
  </step-list></step>
  <step>Return <id>R</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? RequireObjectCoercible ( <value>this</value> value).</step>
  <step>Let <id>S</id> be ? ToString ( <id>O</id> ).</step>
  <step>Let <id>isRegExp</id> be ? IsRegExp ( <id>searchString</id> ).</step>
  <step>If <id>isRegExp</id> is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>searchStr</id> be ? ToString ( <id>searchString</id> ).</step>
  <step>Let <id>len</id> be the length of <id>S</id> .</step>
  <step>If <id>endPosition</id> is <value>undefined</value> , let <id>pos</id> be <id>len</id> , else let <id>pos</id> be ? ToInteger ( <id>endPosition</id> ).</step>
  <step>Let <id>end</id> be min ( max ( <id>pos</id> , 0), <id>len</id> ).</step>
  <step>Let <id>searchLength</id> be the length of <id>searchStr</id> .</step>
  <step>Let <id>start</id> be <id>end</id> - <id>searchLength</id> .</step>
  <step>If <id>start</id> is less than 0, return <value>false</value> .</step>
  <step>If the sequence of elements of <id>S</id> starting at <id>start</id> of length <id>searchLength</id> is the same as the full element sequence of <id>searchStr</id> , return <value>true</value> .</step>
  <step>Otherwise, return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? RequireObjectCoercible ( <value>this</value> value).</step>
  <step>Let <id>S</id> be ? ToString ( <id>O</id> ).</step>
  <step>Let <id>isRegExp</id> be ? IsRegExp ( <id>searchString</id> ).</step>
  <step>If <id>isRegExp</id> is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>searchStr</id> be ? ToString ( <id>searchString</id> ).</step>
  <step>Let <id>pos</id> be ? ToInteger ( <id>position</id> ). (If <id>position</id> is <value>undefined</value> , this step produces the value 0.)</step>
  <step>Let <id>len</id> be the length of <id>S</id> .</step>
  <step>Let <id>start</id> be min ( max ( <id>pos</id> , 0), <id>len</id> ).</step>
  <step>Let <id>searchLen</id> be the length of <id>searchStr</id> .</step>
  <step>If there exists any integer <id>k</id> not smaller than <id>start</id> such that <id>k</id> + <id>searchLen</id> is not greater than <id>len</id> , and for all nonnegative integers <id>j</id> less than <id>searchLen</id> , the code unit at index <id>k</id> + <id>j</id> within <id>S</id> is the same as the code unit at index <id>j</id> within <id>searchStr</id> , return <value>true</value> ; but if there is no such integer <id>k</id> , return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? RequireObjectCoercible ( <value>this</value> value).</step>
  <step>Let <id>S</id> be ? ToString ( <id>O</id> ).</step>
  <step>Let <id>searchStr</id> be ? ToString ( <id>searchString</id> ).</step>
  <step>Let <id>pos</id> be ? ToInteger ( <id>position</id> ). (If <id>position</id> is <value>undefined</value> , this step produces the value 0.)</step>
  <step>Let <id>len</id> be the length of <id>S</id> .</step>
  <step>Let <id>start</id> be min ( max ( <id>pos</id> , 0), <id>len</id> ).</step>
  <step>Let <id>searchLen</id> be the length of <id>searchStr</id> .</step>
  <step>Return the smallest possible integer <id>k</id> not smaller than <id>start</id> such that <id>k</id> + <id>searchLen</id> is not greater than <id>len</id> , and for all nonnegative integers <id>j</id> less than <id>searchLen</id> , the code unit at index <id>k</id> + <id>j</id> within <id>S</id> is the same as the code unit at index <id>j</id> within <id>searchStr</id> ; but if there is no such integer <id>k</id> , return the value -1.</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? RequireObjectCoercible ( <value>this</value> value).</step>
  <step>Let <id>S</id> be ? ToString ( <id>O</id> ).</step>
  <step>Let <id>searchStr</id> be ? ToString ( <id>searchString</id> ).</step>
  <step>Let <id>numPos</id> be ? ToNumber ( <id>position</id> ). (If <id>position</id> is <value>undefined</value> , this step produces the value <value>NaN</value> .)</step>
  <step>If <id>numPos</id> is <value>NaN</value> , let <id>pos</id> be <value>+∞</value> ; otherwise, let <id>pos</id> be ToInteger ( <id>numPos</id> ).</step>
  <step>Let <id>len</id> be the length of <id>S</id> .</step>
  <step>Let <id>start</id> be min ( max ( <id>pos</id> , 0), <id>len</id> ).</step>
  <step>Let <id>searchLen</id> be the length of <id>searchStr</id> .</step>
  <step>Return the largest possible nonnegative integer <id>k</id> not larger than <id>start</id> such that <id>k</id> + <id>searchLen</id> is not greater than <id>len</id> , and for all nonnegative integers <id>j</id> less than <id>searchLen</id> , the code unit at index <id>k</id> + <id>j</id> within <id>S</id> is the same as the code unit at index <id>j</id> within <id>searchStr</id> ; but if there is no such integer <id>k</id> , return the value -1.</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? RequireObjectCoercible ( <value>this</value> value).</step>
  <step>Let <id>S</id> be ? ToString ( <id>O</id> ).</step>
  <step>Let <id>That</id> be ? ToString ( <id>that</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? RequireObjectCoercible ( <value>this</value> value).</step>
  <step>If <id>regexp</id> is neither <value>undefined</value> nor <value>null</value> , then   <step-list>
    <step>Let <id>matcher</id> be ? GetMethod ( <id>regexp</id> , @@match).</step>
    <step>If <id>matcher</id> is not <value>undefined</value> , then     <step-list>
      <step>Return ? Call ( <id>matcher</id> , <id>regexp</id> , « <id>O</id> »).</step>
    </step-list></step>
  </step-list></step>
  <step>Let <id>S</id> be ? ToString ( <id>O</id> ).</step>
  <step>Let <id>rx</id> be ? RegExpCreate ( <id>regexp</id> , <value>undefined</value> ).</step>
  <step>Return ? Invoke ( <id>rx</id> , @@match, « <id>S</id> »).</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? RequireObjectCoercible ( <value>this</value> value).</step>
  <step>Let <id>S</id> be ? ToString ( <id>O</id> ).</step>
  <step>If <id>form</id> is not present or <id>form</id> is <value>undefined</value> , let <id>form</id> be <value>"NFC"</value> .</step>
  <step>Let <id>f</id> be ? ToString ( <id>form</id> ).</step>
  <step>If <id>f</id> is not one of <value>"NFC"</value> , <value>"NFD"</value> , <value>"NFKC"</value> , or <value>"NFKD"</value> , throw a <value>RangeError</value> exception.</step>
  <step>Let <id>ns</id> be the String value that is the result of normalizing <id>S</id> into the normalization form named by <id>f</id> as specified in https://unicode.org/reports/tr15/ .</step>
  <step>Return <id>ns</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? RequireObjectCoercible ( <value>this</value> value).</step>
  <step>Let <id>S</id> be ? ToString ( <id>O</id> ).</step>
  <step>Let <id>intMaxLength</id> be ? ToLength ( <id>maxLength</id> ).</step>
  <step>Let <id>stringLength</id> be the length of <id>S</id> .</step>
  <step>If <id>intMaxLength</id> is not greater than <id>stringLength</id> , return <id>S</id> .</step>
  <step>If <id>fillString</id> is <value>undefined</value> , let <id>filler</id> be the String value consisting solely of the code unit 0x0020 (SPACE).</step>
  <step>Else, let <id>filler</id> be ? ToString ( <id>fillString</id> ).</step>
  <step>If <id>filler</id> is the empty String, return <id>S</id> .</step>
  <step>Let <id>fillLen</id> be <id>intMaxLength</id> - <id>stringLength</id> .</step>
  <step>Let <id>truncatedStringFiller</id> be the String value consisting of repeated concatenations of <id>filler</id> truncated to length <id>fillLen</id> .</step>
  <step>Return the string-concatenation of <id>S</id> and <id>truncatedStringFiller</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? RequireObjectCoercible ( <value>this</value> value).</step>
  <step>Let <id>S</id> be ? ToString ( <id>O</id> ).</step>
  <step>Let <id>intMaxLength</id> be ? ToLength ( <id>maxLength</id> ).</step>
  <step>Let <id>stringLength</id> be the length of <id>S</id> .</step>
  <step>If <id>intMaxLength</id> is not greater than <id>stringLength</id> , return <id>S</id> .</step>
  <step>If <id>fillString</id> is <value>undefined</value> , let <id>filler</id> be the String value consisting solely of the code unit 0x0020 (SPACE).</step>
  <step>Else, let <id>filler</id> be ? ToString ( <id>fillString</id> ).</step>
  <step>If <id>filler</id> is the empty String, return <id>S</id> .</step>
  <step>Let <id>fillLen</id> be <id>intMaxLength</id> - <id>stringLength</id> .</step>
  <step>Let <id>truncatedStringFiller</id> be the String value consisting of repeated concatenations of <id>filler</id> truncated to length <id>fillLen</id> .</step>
  <step>Return the string-concatenation of <id>truncatedStringFiller</id> and <id>S</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? RequireObjectCoercible ( <value>this</value> value).</step>
  <step>Let <id>S</id> be ? ToString ( <id>O</id> ).</step>
  <step>Let <id>n</id> be ? ToInteger ( <id>count</id> ).</step>
  <step>If <id>n</id> < 0, throw a <value>RangeError</value> exception.</step>
  <step>If <id>n</id> is <value>+∞</value> , throw a <value>RangeError</value> exception.</step>
  <step>Let <id>T</id> be the String value that is made from <id>n</id> copies of <id>S</id> appended together. If <id>n</id> is 0, <id>T</id> is the empty String.</step>
  <step>Return <id>T</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? RequireObjectCoercible ( <value>this</value> value).</step>
  <step>If <id>searchValue</id> is neither <value>undefined</value> nor <value>null</value> , then   <step-list>
    <step>Let <id>replacer</id> be ? GetMethod ( <id>searchValue</id> , @@replace).</step>
    <step>If <id>replacer</id> is not <value>undefined</value> , then     <step-list>
      <step>Return ? Call ( <id>replacer</id> , <id>searchValue</id> , « <id>O</id> , <id>replaceValue</id> »).</step>
    </step-list></step>
  </step-list></step>
  <step>Let <id>string</id> be ? ToString ( <id>O</id> ).</step>
  <step>Let <id>searchString</id> be ? ToString ( <id>searchValue</id> ).</step>
  <step>Let <id>functionalReplace</id> be IsCallable ( <id>replaceValue</id> ).</step>
  <step>If <id>functionalReplace</id> is <value>false</value> , then   <step-list>
    <step>Let <id>replaceValue</id> be ? ToString ( <id>replaceValue</id> ).</step>
  </step-list></step>
  <step>Search <id>string</id> for the first occurrence of <id>searchString</id> and let <id>pos</id> be the index within <id>string</id> of the first code unit of the matched substring and let <id>matched</id> be <id>searchString</id> . If no occurrences of <id>searchString</id> were found, return <id>string</id> .</step>
  <step>If <id>functionalReplace</id> is <value>true</value> , then   <step-list>
    <step>Let <id>replValue</id> be ? Call ( <id>replaceValue</id> , <value>undefined</value> , « <id>matched</id> , <id>pos</id> , <id>string</id> »).</step>
    <step>Let <id>replStr</id> be ? ToString ( <id>replValue</id> ).</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>captures</id> be a new empty List .</step>
    <step>Let <id>replStr</id> be GetSubstitution ( <id>matched</id> , <id>string</id> , <id>pos</id> , <id>captures</id> , <value>undefined</value> , <id>replaceValue</id> ).</step>
  </step-list></step>
  <step>Let <id>tailPos</id> be <id>pos</id> + the number of code units in <id>matched</id> .</step>
  <step>Let <id>newString</id> be the string-concatenation of the first <id>pos</id> code units of <id>string</id> , <id>replStr</id> , and the trailing substring of <id>string</id> starting at index <id>tailPos</id> . If <id>pos</id> is 0, the first element of the concatenation will be the empty String.</step>
  <step>Return <id>newString</id> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>matched</id> ) is String.</step>
  <step>Let <id>matchLength</id> be the number of code units in <id>matched</id> .</step>
  <step>Assert : Type ( <id>str</id> ) is String.</step>
  <step>Let <id>stringLength</id> be the number of code units in <id>str</id> .</step>
  <step>Assert : <id>position</id> is a nonnegative integer.</step>
  <step>Assert : <id>position</id> ≤ <id>stringLength</id> .</step>
  <step>Assert : <id>captures</id> is a possibly empty List of Strings.</step>
  <step>Assert : Type ( <id>replacement</id> ) is String.</step>
  <step>Let <id>tailPos</id> be <id>position</id> + <id>matchLength</id> .</step>
  <step>Let <id>m</id> be the number of elements in <id>captures</id> .</step>
  <step>If <id>namedCaptures</id> is not <value>undefined</value> , then   <step-list>
    <step>Set <id>namedCaptures</id> to ? ToObject ( <id>namedCaptures</id> ).</step>
  </step-list></step>
  <step>Let <id>result</id> be the String value derived from <id>replacement</id> by copying code unit elements from <id>replacement</id> to <id>result</id> while performing replacements as specified in Table 48 . These <value>$</value> replacements are done left-to-right, and, once such a replacement is 
performed, the new replacement text is not subject to further 
replacements.</step>
  <step>Return <id>result</id> .</step>
</step-list>
<step-list>
  <step>If <id>namedCaptures</id> is <value>undefined</value> , the replacement text is the String <value>"$<"</value> .</step>
  <step>Else,   <step-list>
    <step>Scan until the next <value>></value> U+003E (GREATER-THAN SIGN).</step>
    <step>If none is found, the replacement text is the String <value>"$<"</value> .</step>
    <step>Else,     <step-list>
      <step>Let <id>groupName</id> be the enclosed substring.</step>
      <step>Let <id>capture</id> be ? Get ( <id>namedCaptures</id> , <id>groupName</id> ).</step>
      <step>If <id>capture</id> is <value>undefined</value> , replace the text through <value>></value> with the empty string.</step>
      <step>Otherwise, replace the text through <value>></value> with ? ToString ( <id>capture</id> ).</step>
    </step-list></step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? RequireObjectCoercible ( <value>this</value> value).</step>
  <step>If <id>regexp</id> is neither <value>undefined</value> nor <value>null</value> , then   <step-list>
    <step>Let <id>searcher</id> be ? GetMethod ( <id>regexp</id> , @@search).</step>
    <step>If <id>searcher</id> is not <value>undefined</value> , then     <step-list>
      <step>Return ? Call ( <id>searcher</id> , <id>regexp</id> , « <id>O</id> »).</step>
    </step-list></step>
  </step-list></step>
  <step>Let <id>string</id> be ? ToString ( <id>O</id> ).</step>
  <step>Let <id>rx</id> be ? RegExpCreate ( <id>regexp</id> , <value>undefined</value> ).</step>
  <step>Return ? Invoke ( <id>rx</id> , @@search, « <id>string</id> »).</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? RequireObjectCoercible ( <value>this</value> value).</step>
  <step>Let <id>S</id> be ? ToString ( <id>O</id> ).</step>
  <step>Let <id>len</id> be the length of <id>S</id> .</step>
  <step>Let <id>intStart</id> be ? ToInteger ( <id>start</id> ).</step>
  <step>If <id>end</id> is <value>undefined</value> , let <id>intEnd</id> be <id>len</id> ; else let <id>intEnd</id> be ? ToInteger ( <id>end</id> ).</step>
  <step>If <id>intStart</id> < 0, let <id>from</id> be max ( <id>len</id> + <id>intStart</id> , 0); otherwise let <id>from</id> be min ( <id>intStart</id> , <id>len</id> ).</step>
  <step>If <id>intEnd</id> < 0, let <id>to</id> be max ( <id>len</id> + <id>intEnd</id> , 0); otherwise let <id>to</id> be min ( <id>intEnd</id> , <id>len</id> ).</step>
  <step>Let <id>span</id> be max ( <id>to</id> - <id>from</id> , 0).</step>
  <step>Return the String value containing <id>span</id> consecutive elements from <id>S</id> beginning with the element at index <id>from</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? RequireObjectCoercible ( <value>this</value> value).</step>
  <step>If <id>separator</id> is neither <value>undefined</value> nor <value>null</value> , then   <step-list>
    <step>Let <id>splitter</id> be ? GetMethod ( <id>separator</id> , @@split).</step>
    <step>If <id>splitter</id> is not <value>undefined</value> , then     <step-list>
      <step>Return ? Call ( <id>splitter</id> , <id>separator</id> , « <id>O</id> , <id>limit</id> »).</step>
    </step-list></step>
  </step-list></step>
  <step>Let <id>S</id> be ? ToString ( <id>O</id> ).</step>
  <step>Let <id>A</id> be ! ArrayCreate (0).</step>
  <step>Let <id>lengthA</id> be 0.</step>
  <step>If <id>limit</id> is <value>undefined</value> , let <id>lim</id> be 2 32 -1; else let <id>lim</id> be ? ToUint32 ( <id>limit</id> ).</step>
  <step>Let <id>s</id> be the length of <id>S</id> .</step>
  <step>Let <id>p</id> be 0.</step>
  <step>Let <id>R</id> be ? ToString ( <id>separator</id> ).</step>
  <step>If <id>lim</id> = 0, return <id>A</id> .</step>
  <step>If <id>separator</id> is <value>undefined</value> , then   <step-list>
    <step>Perform ! CreateDataProperty ( <id>A</id> , <value>"0"</value> , <id>S</id> ).</step>
    <step>Return <id>A</id> .</step>
  </step-list></step>
  <step>If <id>s</id> = 0, then   <step-list>
    <step>Let <id>z</id> be SplitMatch ( <id>S</id> , 0, <id>R</id> ).</step>
    <step>If <id>z</id> is not <value>false</value> , return <id>A</id> .</step>
    <step>Perform ! CreateDataProperty ( <id>A</id> , <value>"0"</value> , <id>S</id> ).</step>
    <step>Return <id>A</id> .</step>
  </step-list></step>
  <step>Let <id>q</id> be <id>p</id> .</step>
  <step>Repeat, while <id>q</id> ≠ <id>s</id>   <step-list>
    <step>Let <id>e</id> be SplitMatch ( <id>S</id> , <id>q</id> , <id>R</id> ).</step>
    <step>If <id>e</id> is <value>false</value> , let <id>q</id> be <id>q</id> +1.</step>
    <step>Else <id>e</id> is an integer index ≤ <id>s</id> ,     <step-list>
      <step>If <id>e</id> = <id>p</id> , let <id>q</id> be <id>q</id> +1.</step>
      <step>Else <id>e</id> ≠ <id>p</id> ,       <step-list>
        <step>Let <id>T</id> be the String value equal to the substring of <id>S</id> consisting of the code units at indices <id>p</id> (inclusive) through <id>q</id> (exclusive).</step>
        <step>Perform ! CreateDataProperty ( <id>A</id> , ! ToString ( <id>lengthA</id> ), <id>T</id> ).</step>
        <step>Increment <id>lengthA</id> by 1.</step>
        <step>If <id>lengthA</id> = <id>lim</id> , return <id>A</id> .</step>
        <step>Let <id>p</id> be <id>e</id> .</step>
        <step>Let <id>q</id> be <id>p</id> .</step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
  <step>Let <id>T</id> be the String value equal to the substring of <id>S</id> consisting of the code units at indices <id>p</id> (inclusive) through <id>s</id> (exclusive).</step>
  <step>Perform ! CreateDataProperty ( <id>A</id> , ! ToString ( <id>lengthA</id> ), <id>T</id> ).</step>
  <step>Return <id>A</id> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>R</id> ) is String.</step>
  <step>Let <id>r</id> be the number of code units in <id>R</id> .</step>
  <step>Let <id>s</id> be the number of code units in <id>S</id> .</step>
  <step>If <id>q</id> + <id>r</id> > <id>s</id> , return <value>false</value> .</step>
  <step>If there exists an integer <id>i</id> between 0 (inclusive) and <id>r</id> (exclusive) such that the code unit at index <id>q</id> + <id>i</id> within <id>S</id> is different from the code unit at index <id>i</id> within <id>R</id> , return <value>false</value> .</step>
  <step>Return <id>q</id> + <id>r</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? RequireObjectCoercible ( <value>this</value> value).</step>
  <step>Let <id>S</id> be ? ToString ( <id>O</id> ).</step>
  <step>Let <id>isRegExp</id> be ? IsRegExp ( <id>searchString</id> ).</step>
  <step>If <id>isRegExp</id> is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>searchStr</id> be ? ToString ( <id>searchString</id> ).</step>
  <step>Let <id>pos</id> be ? ToInteger ( <id>position</id> ). (If <id>position</id> is <value>undefined</value> , this step produces the value 0.)</step>
  <step>Let <id>len</id> be the length of <id>S</id> .</step>
  <step>Let <id>start</id> be min ( max ( <id>pos</id> , 0), <id>len</id> ).</step>
  <step>Let <id>searchLength</id> be the length of <id>searchStr</id> .</step>
  <step>If <id>searchLength</id> + <id>start</id> is greater than <id>len</id> , return <value>false</value> .</step>
  <step>If the sequence of elements of <id>S</id> starting at <id>start</id> of length <id>searchLength</id> is the same as the full element sequence of <id>searchStr</id> , return <value>true</value> .</step>
  <step>Otherwise, return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? RequireObjectCoercible ( <value>this</value> value).</step>
  <step>Let <id>S</id> be ? ToString ( <id>O</id> ).</step>
  <step>Let <id>len</id> be the length of <id>S</id> .</step>
  <step>Let <id>intStart</id> be ? ToInteger ( <id>start</id> ).</step>
  <step>If <id>end</id> is <value>undefined</value> , let <id>intEnd</id> be <id>len</id> ; else let <id>intEnd</id> be ? ToInteger ( <id>end</id> ).</step>
  <step>Let <id>finalStart</id> be min ( max ( <id>intStart</id> , 0), <id>len</id> ).</step>
  <step>Let <id>finalEnd</id> be min ( max ( <id>intEnd</id> , 0), <id>len</id> ).</step>
  <step>Let <id>from</id> be min ( <id>finalStart</id> , <id>finalEnd</id> ).</step>
  <step>Let <id>to</id> be max ( <id>finalStart</id> , <id>finalEnd</id> ).</step>
  <step>Return the String value whose length is <id>to</id> - <id>from</id> , containing code units from <id>S</id> , namely the code units with indices <id>from</id> through <id>to</id> - 1, in ascending order.</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? RequireObjectCoercible ( <value>this</value> value).</step>
  <step>Let <id>S</id> be ? ToString ( <id>O</id> ).</step>
  <step>Let <id>cpList</id> be a List containing in order the code points as defined in 6.1.4 of <id>S</id> , starting at the first element of <id>S</id> .</step>
  <step>Let <id>cuList</id> be a List where the elements are the result of toLowercase( <id>cplist</id> ), according to the Unicode Default Case Conversion algorithm.</step>
  <step>Let <id>L</id> be the String value whose elements are the UTF16Encoding of the code points of <id>cuList</id> .</step>
  <step>Return <id>L</id> .</step>
</step-list>
<step-list>
  <step>Return ? thisStringValue ( <value>this</value> value).</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? RequireObjectCoercible ( <value>this</value> value).</step>
  <step>Let <id>S</id> be ? ToString ( <id>O</id> ).</step>
  <step>Let <id>T</id> be the String value that is a copy of <id>S</id> with both leading and trailing white space removed. The definition of white space is the union of WhiteSpace and LineTerminator .
 When determining whether a Unicode code point is in Unicode general 
category “Space_Separator” (“Zs”), code unit sequences are interpreted 
as UTF-16 encoded code point sequences as specified in 6.1.4 .</step>
  <step>Return <id>T</id> .</step>
</step-list>
<step-list>
  <step>Return ? thisStringValue ( <value>this</value> value).</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? RequireObjectCoercible ( <value>this</value> value).</step>
  <step>Let <id>S</id> be ? ToString ( <id>O</id> ).</step>
  <step>Return CreateStringIterator ( <id>S</id> ).</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>string</id> ) is String.</step>
  <step>Let <id>iterator</id> be ObjectCreate ( %StringIteratorPrototype% , « [[IteratedString]], [[StringIteratorNextIndex]] »).</step>
  <step>Set <id>iterator</id> .[[IteratedString]] to <id>string</id> .</step>
  <step>Set <id>iterator</id> .[[StringIteratorNextIndex]] to 0.</step>
  <step>Return <id>iterator</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>O</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>O</id> does not have all of the internal slots of a String Iterator Instance ( 21.1.5.3 ), throw a <value>TypeError</value> exception.</step>
  <step>Let <id>s</id> be <id>O</id> .[[IteratedString]].</step>
  <step>If <id>s</id> is <value>undefined</value> , return CreateIterResultObject ( <value>undefined</value> , <value>true</value> ).</step>
  <step>Let <id>position</id> be <id>O</id> .[[StringIteratorNextIndex]].</step>
  <step>Let <id>len</id> be the length of <id>s</id> .</step>
  <step>If <id>position</id> ≥ <id>len</id> , then   <step-list>
    <step>Set <id>O</id> .[[IteratedString]] to <value>undefined</value> .</step>
    <step>Return CreateIterResultObject ( <value>undefined</value> , <value>true</value> ).</step>
  </step-list></step>
  <step>Let <id>first</id> be the numeric value of the code unit at index <id>position</id> within <id>s</id> .</step>
  <step>If <id>first</id> < 0xD800 or <id>first</id> > 0xDBFF or <id>position</id> +1 = <id>len</id> , let <id>resultString</id> be the String value consisting of the single code unit <id>first</id> .</step>
  <step>Else,   <step-list>
    <step>Let <id>second</id> be the numeric value of the code unit at index <id>position</id> +1 within the String <id>S</id> .</step>
    <step>If <id>second</id> < 0xDC00 or <id>second</id> > 0xDFFF, let <id>resultString</id> be the String value consisting of the single code unit <id>first</id> .</step>
    <step>Else, let <id>resultString</id> be the string-concatenation of the code unit <id>first</id> and the code unit <id>second</id> .</step>
  </step-list></step>
  <step>Let <id>resultSize</id> be the number of code units in <id>resultString</id> .</step>
  <step>Set <id>O</id> .[[StringIteratorNextIndex]] to <id>position</id> + <id>resultSize</id> .</step>
  <step>Return CreateIterResultObject ( <id>resultString</id> , <value>false</value> ).</step>
</step-list>
<step-list>
  <step>Return the MV of NonZeroDigit .</step>
</step-list>
<step-list>
  <step>Let <id>n</id> be the number of code points in DecimalDigits .</step>
  <step>Return (the MV of NonZeroDigit × 10 n ) plus the MV of DecimalDigits .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return the code point value of U+002D (HYPHEN-MINUS).</step>
</step-list>
<step-list>
  <step>Let <id>ch</id> be the code point matched by SourceCharacter .</step>
  <step>Return the code point value of <id>ch</id> .</step>
</step-list>
<step-list>
  <step>Return the code point value of U+0008 (BACKSPACE).</step>
</step-list>
<step-list>
  <step>Return the code point value of U+002D (HYPHEN-MINUS).</step>
</step-list>
<step-list>
  <step>Return the code point value according to Table 50 .</step>
</step-list>
<step-list>
  <step>Let <id>ch</id> be the code point matched by ControlLetter .</step>
  <step>Let <id>i</id> be <id>ch</id> 's code point value.</step>
  <step>Return the remainder of dividing <id>i</id> by 32.</step>
</step-list>
<step-list>
  <step>Return the code point value of U+0000 (NULL).</step>
</step-list>
<step-list>
  <step>Return the numeric value of the code unit that is the SV of HexEscapeSequence .</step>
</step-list>
<step-list>
  <step>Let <id>lead</id> be the CharacterValue of LeadSurrogate .</step>
  <step>Let <id>trail</id> be the CharacterValue of TrailSurrogate .</step>
  <step>Let <id>cp</id> be UTF16Decode ( <id>lead</id> , <id>trail</id> ).</step>
  <step>Return the code point value of <id>cp</id> .</step>
</step-list>
<step-list>
  <step>Return the CharacterValue of LeadSurrogate .</step>
</step-list>
<step-list>
  <step>Return the CharacterValue of TrailSurrogate .</step>
</step-list>
<step-list>
  <step>Return the CharacterValue of NonSurrogate .</step>
</step-list>
<step-list>
  <step>Return the MV of Hex4Digits .</step>
</step-list>
<step-list>
  <step>Return the MV of CodePoint .</step>
</step-list>
<step-list>
  <step>Return the MV of HexDigits .</step>
</step-list>
<step-list>
  <step>Let <id>ch</id> be the code point matched by IdentityEscape .</step>
  <step>Return the code point value of <id>ch</id> .</step>
</step-list>
<step-list>
  <step>Return the List , in source text order, of Unicode code points in the source text matched by this production.</step>
</step-list>
<step-list>
  <step>Return the String value consisting of the sequence of code units corresponding to RegExpIdentifierName . In determining the sequence any occurrences of <value>\</value>  RegExpUnicodeEscapeSequence are first replaced with the code point represented by the RegExpUnicodeEscapeSequence and then the code points of the entire RegExpIdentifierName are converted to code units by UTF16Encoding each code point.</step>
</step-list>
<step-list>
  <step>Evaluate Disjunction with +1 as its <id>direction</id> argument to obtain a Matcher <id>m</id> .</step>
  <step>Return an internal closure that takes two arguments, a String <id>str</id> and an integer <id>index</id> , and performs the following steps:   <step-list>
    <step>Assert : <id>index</id> ≤ the length of <id>str</id> .</step>
    <step>If <id>Unicode</id> is <value>true</value> , let <id>Input</id> be a List consisting of the sequence of code points of <id>str</id> interpreted as a UTF-16 encoded ( 6.1.4 ) Unicode string. Otherwise, let <id>Input</id> be a List consisting of the sequence of code units that are the elements of <id>str</id> . <id>Input</id> will be used throughout the algorithms in 21.2.2 . Each element of <id>Input</id> is considered to be a character.</step>
    <step>Let <id>InputLength</id> be the number of characters contained in <id>Input</id> . This variable will be used throughout the algorithms in 21.2.2 .</step>
    <step>Let <id>listIndex</id> be the index into <id>Input</id> of the character that was obtained from element <id>index</id> of <id>str</id> .</step>
    <step>Let <id>c</id> be a Continuation that always returns its State argument as a successful MatchResult.</step>
    <step>Let <id>cap</id> be a List of <id>NcapturingParens</id>  <value>undefined</value> values, indexed 1 through <id>NcapturingParens</id> .</step>
    <step>Let <id>x</id> be the State ( <id>listIndex</id> , <id>cap</id> ).</step>
    <step>Call <id>m</id> ( <id>x</id> , <id>c</id> ) and return its result.</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Evaluate Alternative to obtain a Matcher <id>m</id> .</step>
  <step>Return <id>m</id> .</step>
</step-list>
<step-list>
  <step>Evaluate Alternative with argument <id>direction</id> to obtain a Matcher <id>m1</id> .</step>
  <step>Evaluate Disjunction with argument <id>direction</id> to obtain a Matcher <id>m2</id> .</step>
  <step>Return an internal Matcher closure that takes two arguments, a State <id>x</id> and a Continuation <id>c</id> , and performs the following steps when evaluated:   <step-list>
    <step>Call <id>m1</id> ( <id>x</id> , <id>c</id> ) and let <id>r</id> be its result.</step>
    <step>If <id>r</id> is not <value>failure</value> , return <id>r</id> .</step>
    <step>Call <id>m2</id> ( <id>x</id> , <id>c</id> ) and return its result.</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Return a Matcher that takes two arguments, a State <id>x</id> and a Continuation <id>c</id> , and returns the result of calling <id>c</id> ( <id>x</id> ).</step>
</step-list>
<step-list>
  <step>Evaluate Alternative with argument <id>direction</id> to obtain a Matcher <id>m1</id> .</step>
  <step>Evaluate Term with argument <id>direction</id> to obtain a Matcher <id>m2</id> .</step>
  <step>If <id>direction</id> is equal to +1, then   <step-list>
    <step>Return an internal Matcher closure that takes two arguments, a State <id>x</id> and a Continuation <id>c</id> , and performs the following steps when evaluated:     <step-list>
      <step>Let <id>d</id> be a Continuation that takes a State argument <id>y</id> and returns the result of calling <id>m2</id> ( <id>y</id> , <id>c</id> ).</step>
      <step>Call <id>m1</id> ( <id>x</id> , <id>d</id> ) and return its result.</step>
    </step-list></step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Assert : <id>direction</id> is equal to -1.</step>
    <step>Return an internal Matcher closure that takes two arguments, a State <id>x</id> and a Continuation <id>c</id> , and performs the following steps when evaluated:     <step-list>
      <step>Let <id>d</id> be a Continuation that takes a State argument <id>y</id> and returns the result of calling <id>m1</id> ( <id>y</id> , <id>c</id> ).</step>
      <step>Call <id>m2</id> ( <id>x</id> , <id>d</id> ) and return its result.</step>
    </step-list></step>
  </step-list></step>
</step-list>
<step-list>
  <step>Return an internal Matcher closure that takes two arguments, a State <id>x</id> and a Continuation <id>c</id> , and performs the following steps when evaluated:   <step-list>
    <step>Evaluate Assertion to obtain an AssertionTester <id>t</id> .</step>
    <step>Call <id>t</id> ( <id>x</id> ) and let <id>r</id> be the resulting Boolean value.</step>
    <step>If <id>r</id> is <value>false</value> , return <value>failure</value> .</step>
    <step>Call <id>c</id> ( <id>x</id> ) and return its result.</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Return the Matcher that is the result of evaluating Atom with argument <id>direction</id> .</step>
</step-list>
<step-list>
  <step>Evaluate Atom with argument <id>direction</id> to obtain a Matcher <id>m</id> .</step>
  <step>Evaluate Quantifier to obtain the three results: an integer <id>min</id> , an integer (or ∞) <id>max</id> , and Boolean <id>greedy</id> .</step>
  <step>Assert : If <id>max</id> is finite, then <id>max</id> is not less than <id>min</id> .</step>
  <step>Let <id>parenIndex</id> be the number of left-capturing parentheses in the entire regular expression that occur to the left of this Term . This is the total number of Atom::(GroupSpecifierDisjunction) Parse Nodes prior to or enclosing this Term .</step>
  <step>Let <id>parenCount</id> be the number of left-capturing parentheses in Atom . This is the total number of Atom::(GroupSpecifierDisjunction) Parse Nodes enclosed by Atom .</step>
  <step>Return an internal Matcher closure that takes two arguments, a State <id>x</id> and a Continuation <id>c</id> , and performs the following steps when evaluated:   <step-list>
    <step>Call RepeatMatcher ( <id>m</id> , <id>min</id> , <id>max</id> , <id>greedy</id> , <id>x</id> , <id>c</id> , <id>parenIndex</id> , <id>parenCount</id> ) and return its result.</step>
  </step-list></step>
</step-list>
<step-list>
  <step>If <id>max</id> is zero, return <id>c</id> ( <id>x</id> ).</step>
  <step>Let <id>d</id> be an internal Continuation closure that takes one State argument <id>y</id> and performs the following steps when evaluated:   <step-list>
    <step>If <id>min</id> is zero and <id>y</id> 's <id>endIndex</id> is equal to <id>x</id> 's <id>endIndex</id> , return <value>failure</value> .</step>
    <step>If <id>min</id> is zero, let <id>min2</id> be zero; otherwise let <id>min2</id> be <id>min</id> -1.</step>
    <step>If <id>max</id> is ∞, let <id>max2</id> be ∞; otherwise let <id>max2</id> be <id>max</id> -1.</step>
    <step>Call RepeatMatcher ( <id>m</id> , <id>min2</id> , <id>max2</id> , <id>greedy</id> , <id>y</id> , <id>c</id> , <id>parenIndex</id> , <id>parenCount</id> ) and return its result.</step>
  </step-list></step>
  <step>Let <id>cap</id> be a copy of <id>x</id> 's <id>captures</id>  List .</step>
  <step>For each integer <id>k</id> that satisfies <id>parenIndex</id> < <id>k</id> and <id>k</id> ≤ <id>parenIndex</id> + <id>parenCount</id> , set <id>cap</id> [ <id>k</id> ] to <value>undefined</value> .</step>
  <step>Let <id>e</id> be <id>x</id> 's <id>endIndex</id> .</step>
  <step>Let <id>xr</id> be the State ( <id>e</id> , <id>cap</id> ).</step>
  <step>If <id>min</id> is not zero, return <id>m</id> ( <id>xr</id> , <id>d</id> ).</step>
  <step>If <id>greedy</id> is <value>false</value> , then   <step-list>
    <step>Call <id>c</id> ( <id>x</id> ) and let <id>z</id> be its result.</step>
    <step>If <id>z</id> is not <value>failure</value> , return <id>z</id> .</step>
    <step>Call <id>m</id> ( <id>xr</id> , <id>d</id> ) and return its result.</step>
  </step-list></step>
  <step>Call <id>m</id> ( <id>xr</id> , <id>d</id> ) and let <id>z</id> be its result.</step>
  <step>If <id>z</id> is not <value>failure</value> , return <id>z</id> .</step>
  <step>Call <id>c</id> ( <id>x</id> ) and return its result.</step>
</step-list>
<step-list>
  <step>Return an internal AssertionTester closure that takes a State argument <id>x</id> and performs the following steps when evaluated:   <step-list>
    <step>Let <id>e</id> be <id>x</id> 's <id>endIndex</id> .</step>
    <step>If <id>e</id> is zero, return <value>true</value> .</step>
    <step>If <id>Multiline</id> is <value>false</value> , return <value>false</value> .</step>
    <step>If the character <id>Input</id> [ <id>e</id> -1] is one of LineTerminator , return <value>true</value> .</step>
    <step>Return <value>false</value> .</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Return an internal AssertionTester closure that takes a State argument <id>x</id> and performs the following steps when evaluated:   <step-list>
    <step>Let <id>e</id> be <id>x</id> 's <id>endIndex</id> .</step>
    <step>If <id>e</id> is equal to <id>InputLength</id> , return <value>true</value> .</step>
    <step>If <id>Multiline</id> is <value>false</value> , return <value>false</value> .</step>
    <step>If the character <id>Input</id> [ <id>e</id> ] is one of LineTerminator , return <value>true</value> .</step>
    <step>Return <value>false</value> .</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Return an internal AssertionTester closure that takes a State argument <id>x</id> and performs the following steps when evaluated:   <step-list>
    <step>Let <id>e</id> be <id>x</id> 's <id>endIndex</id> .</step>
    <step>Call IsWordChar ( <id>e</id> -1) and let <id>a</id> be the Boolean result.</step>
    <step>Call IsWordChar ( <id>e</id> ) and let <id>b</id> be the Boolean result.</step>
    <step>If <id>a</id> is <value>true</value> and <id>b</id> is <value>false</value> , return <value>true</value> .</step>
    <step>If <id>a</id> is <value>false</value> and <id>b</id> is <value>true</value> , return <value>true</value> .</step>
    <step>Return <value>false</value> .</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Return an internal AssertionTester closure that takes a State argument <id>x</id> and performs the following steps when evaluated:   <step-list>
    <step>Let <id>e</id> be <id>x</id> 's <id>endIndex</id> .</step>
    <step>Call IsWordChar ( <id>e</id> -1) and let <id>a</id> be the Boolean result.</step>
    <step>Call IsWordChar ( <id>e</id> ) and let <id>b</id> be the Boolean result.</step>
    <step>If <id>a</id> is <value>true</value> and <id>b</id> is <value>false</value> , return <value>false</value> .</step>
    <step>If <id>a</id> is <value>false</value> and <id>b</id> is <value>true</value> , return <value>false</value> .</step>
    <step>Return <value>true</value> .</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Evaluate Disjunction with +1 as its <id>direction</id> argument to obtain a Matcher <id>m</id> .</step>
  <step>Return an internal Matcher closure that takes two arguments, a State <id>x</id> and a Continuation <id>c</id> , and performs the following steps:   <step-list>
    <step>Let <id>d</id> be a Continuation that always returns its State argument as a successful MatchResult.</step>
    <step>Call <id>m</id> ( <id>x</id> , <id>d</id> ) and let <id>r</id> be its result.</step>
    <step>If <id>r</id> is <value>failure</value> , return <value>failure</value> .</step>
    <step>Let <id>y</id> be <id>r</id> 's State.</step>
    <step>Let <id>cap</id> be <id>y</id> 's <id>captures</id>  List .</step>
    <step>Let <id>xe</id> be <id>x</id> 's <id>endIndex</id> .</step>
    <step>Let <id>z</id> be the State ( <id>xe</id> , <id>cap</id> ).</step>
    <step>Call <id>c</id> ( <id>z</id> ) and return its result.</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Evaluate Disjunction with +1 as its <id>direction</id> argument to obtain a Matcher <id>m</id> .</step>
  <step>Return an internal Matcher closure that takes two arguments, a State <id>x</id> and a Continuation <id>c</id> , and performs the following steps:   <step-list>
    <step>Let <id>d</id> be a Continuation that always returns its State argument as a successful MatchResult.</step>
    <step>Call <id>m</id> ( <id>x</id> , <id>d</id> ) and let <id>r</id> be its result.</step>
    <step>If <id>r</id> is not <value>failure</value> , return <value>failure</value> .</step>
    <step>Call <id>c</id> ( <id>x</id> ) and return its result.</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Evaluate Disjunction with -1 as its <id>direction</id> argument to obtain a Matcher <id>m</id> .</step>
  <step>Return an internal Matcher closure that takes two arguments, a State <id>x</id> and a Continuation <id>c</id> , and performs the following steps:   <step-list>
    <step>Let <id>d</id> be a Continuation that always returns its State argument as a successful MatchResult.</step>
    <step>Call <id>m</id> ( <id>x</id> , <id>d</id> ) and let <id>r</id> be its result.</step>
    <step>If <id>r</id> is <value>failure</value> , return <value>failure</value> .</step>
    <step>Let <id>y</id> be <id>r</id> 's State.</step>
    <step>Let <id>cap</id> be <id>y</id> 's <id>captures</id>  List .</step>
    <step>Let <id>xe</id> be <id>x</id> 's <id>endIndex</id> .</step>
    <step>Let <id>z</id> be the State ( <id>xe</id> , <id>cap</id> ).</step>
    <step>Call <id>c</id> ( <id>z</id> ) and return its result.</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Evaluate Disjunction with -1 as its <id>direction</id> argument to obtain a Matcher <id>m</id> .</step>
  <step>Return an internal Matcher closure that takes two arguments, a State <id>x</id> and a Continuation <id>c</id> , and performs the following steps:   <step-list>
    <step>Let <id>d</id> be a Continuation that always returns its State argument as a successful MatchResult.</step>
    <step>Call <id>m</id> ( <id>x</id> , <id>d</id> ) and let <id>r</id> be its result.</step>
    <step>If <id>r</id> is not <value>failure</value> , return <value>failure</value> .</step>
    <step>Call <id>c</id> ( <id>x</id> ) and return its result.</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>A</id> be a set of characters containing the sixty-three characters: a	b	c	d	e	f	g	h	i	j	k	l	m	n	o	p	q	r	s	t	u	v	w	x	y	z
A	B	C	D	E	F	G	H	I	J	K	L	M	N	O	P	Q	R	S	T	U	V	W	X	Y	Z
0	1	2	3	4	5	6	7	8	9	_</step>
  <step>Let <id>U</id> be an empty set.</step>
  <step>For each character <id>c</id> not in set <id>A</id> where Canonicalize ( <id>c</id> ) is in <id>A</id> , add <id>c</id> to <id>U</id> .</step>
  <step>Assert : Unless <id>Unicode</id> and <id>IgnoreCase</id> are both <value>true</value> , <id>U</id> is empty.</step>
  <step>Add the characters in set <id>U</id> to set <id>A</id> .</step>
  <step>Return <id>A</id> .</step>
</step-list>
<step-list>
  <step>If <id>e</id> is -1 or <id>e</id> is <id>InputLength</id> , return <value>false</value> .</step>
  <step>Let <id>c</id> be the character <id>Input</id> [ <id>e</id> ].</step>
  <step>Let <id>wordChars</id> be the result of ! WordCharacters ().</step>
  <step>If <id>c</id> is in <id>wordChars</id> , return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Evaluate QuantifierPrefix to obtain the two results: an integer <id>min</id> and an integer (or ∞) <id>max</id> .</step>
  <step>Return the three results <id>min</id> , <id>max</id> , and <value>true</value> .</step>
</step-list>
<step-list>
  <step>Evaluate QuantifierPrefix to obtain the two results: an integer <id>min</id> and an integer (or ∞) <id>max</id> .</step>
  <step>Return the three results <id>min</id> , <id>max</id> , and <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return the two results 0 and ∞.</step>
</step-list>
<step-list>
  <step>Return the two results 1 and ∞.</step>
</step-list>
<step-list>
  <step>Return the two results 0 and 1.</step>
</step-list>
<step-list>
  <step>Let <id>i</id> be the MV of DecimalDigits (see 11.8.3 ).</step>
  <step>Return the two results <id>i</id> and <id>i</id> .</step>
</step-list>
<step-list>
  <step>Let <id>i</id> be the MV of DecimalDigits .</step>
  <step>Return the two results <id>i</id> and ∞.</step>
</step-list>
<step-list>
  <step>Let <id>i</id> be the MV of the first DecimalDigits .</step>
  <step>Let <id>j</id> be the MV of the second DecimalDigits .</step>
  <step>Return the two results <id>i</id> and <id>j</id> .</step>
</step-list>
<step-list>
  <step>Let <id>ch</id> be the character matched by PatternCharacter .</step>
  <step>Let <id>A</id> be a one-element CharSet containing the character <id>ch</id> .</step>
  <step>Call CharacterSetMatcher ( <id>A</id> , <value>false</value> , <id>direction</id> ) and return its Matcher result.</step>
</step-list>
<step-list>
  <step>If <id>DotAll</id> is <value>true</value> , then   <step-list>
    <step>Let <id>A</id> be the set of all characters.</step>
  </step-list></step>
  <step>Otherwise, let <id>A</id> be the set of all characters except LineTerminator .</step>
  <step>Call CharacterSetMatcher ( <id>A</id> , <value>false</value> , <id>direction</id> ) and return its Matcher result.</step>
</step-list>
<step-list>
  <step>Return the Matcher that is the result of evaluating AtomEscape with argument <id>direction</id> .</step>
</step-list>
<step-list>
  <step>Evaluate CharacterClass to obtain a CharSet <id>A</id> and a Boolean <id>invert</id> .</step>
  <step>Call CharacterSetMatcher ( <id>A</id> , <id>invert</id> , <id>direction</id> ) and return its Matcher result.</step>
</step-list>
<step-list>
  <step>Evaluate Disjunction with argument <id>direction</id> to obtain a Matcher <id>m</id> .</step>
  <step>Let <id>parenIndex</id> be the number of left-capturing parentheses in the entire regular expression that occur to the left of this Atom . This is the total number of Atom::(GroupSpecifierDisjunction) Parse Nodes prior to or enclosing this Atom .</step>
  <step>Return an internal Matcher closure that takes two arguments, a State <id>x</id> and a Continuation <id>c</id> , and performs the following steps:   <step-list>
    <step>Let <id>d</id> be an internal Continuation closure that takes one State argument <id>y</id> and performs the following steps:     <step-list>
      <step>Let <id>cap</id> be a copy of <id>y</id> 's <id>captures</id>  List .</step>
      <step>Let <id>xe</id> be <id>x</id> 's <id>endIndex</id> .</step>
      <step>Let <id>ye</id> be <id>y</id> 's <id>endIndex</id> .</step>
      <step>If <id>direction</id> is equal to +1, then       <step-list>
        <step>Assert : <id>xe</id> ≤ <id>ye</id> .</step>
        <step>Let <id>s</id> be a new List whose elements are the characters of <id>Input</id> at indices <id>xe</id> (inclusive) through <id>ye</id> (exclusive).</step>
      </step-list></step>
      <step>Else,       <step-list>
        <step>Assert : <id>direction</id> is equal to -1.</step>
        <step>Assert : <id>ye</id> ≤ <id>xe</id> .</step>
        <step>Let <id>s</id> be a new List whose elements are the characters of <id>Input</id> at indices <id>ye</id> (inclusive) through <id>xe</id> (exclusive).</step>
      </step-list></step>
      <step>Set <id>cap</id> [ <id>parenIndex</id> +1] to <id>s</id> .</step>
      <step>Let <id>z</id> be the State ( <id>ye</id> , <id>cap</id> ).</step>
      <step>Call <id>c</id> ( <id>z</id> ) and return its result.</step>
    </step-list></step>
    <step>Call <id>m</id> ( <id>x</id> , <id>d</id> ) and return its result.</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Return the Matcher that is the result of evaluating Disjunction with argument <id>direction</id> .</step>
</step-list>
<step-list>
  <step>Return an internal Matcher closure that takes two arguments, a State <id>x</id> and a Continuation <id>c</id> , and performs the following steps when evaluated:   <step-list>
    <step>Let <id>e</id> be <id>x</id> 's <id>endIndex</id> .</step>
    <step>Let <id>f</id> be <id>e</id> + <id>direction</id> .</step>
    <step>If <id>f</id> < 0 or <id>f</id> > <id>InputLength</id> , return <value>failure</value> .</step>
    <step>Let <id>index</id> be min ( <id>e</id> , <id>f</id> ).</step>
    <step>Let <id>ch</id> be the character <id>Input</id> [ <id>index</id> ].</step>
    <step>Let <id>cc</id> be Canonicalize ( <id>ch</id> ).</step>
    <step>If <id>invert</id> is <value>false</value> , then     <step-list>
      <step>If there does not exist a member <id>a</id> of set <id>A</id> such that Canonicalize ( <id>a</id> ) is <id>cc</id> , return <value>failure</value> .</step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>Assert : <id>invert</id> is <value>true</value> .</step>
      <step>If there exists a member <id>a</id> of set <id>A</id> such that Canonicalize ( <id>a</id> ) is <id>cc</id> , return <value>failure</value> .</step>
    </step-list></step>
    <step>Let <id>cap</id> be <id>x</id> 's <id>captures</id>  List .</step>
    <step>Let <id>y</id> be the State ( <id>f</id> , <id>cap</id> ).</step>
    <step>Call <id>c</id> ( <id>y</id> ) and return its result.</step>
  </step-list></step>
</step-list>
<step-list>
  <step>If <id>IgnoreCase</id> is <value>false</value> , return <id>ch</id> .</step>
  <step>If <id>Unicode</id> is <value>true</value> , then   <step-list>
    <step>If the file CaseFolding.txt of the Unicode Character Database provides a simple or common case folding mapping for <id>ch</id> , return the result of applying that mapping to <id>ch</id> .</step>
    <step>Return <id>ch</id> .</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Assert : <id>ch</id> is a UTF-16 code unit.</step>
    <step>Let <id>s</id> be the String value consisting of the single code unit <id>ch</id> .</step>
    <step>Let <id>u</id> be the same result produced as if by performing the algorithm for <value>String.prototype.toUpperCase</value> using <id>s</id> as the <value>this</value> value.</step>
    <step>Assert : <id>u</id> is a String value.</step>
    <step>If <id>u</id> does not consist of a single code unit, return <id>ch</id> .</step>
    <step>Let <id>cu</id> be <id>u</id> 's single code unit element.</step>
    <step>If the numeric value of <id>ch</id> ≥ 128 and the numeric value of <id>cu</id> < 128, return <id>ch</id> .</step>
    <step>Return <id>cu</id> .</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Assert : <id>p</id> is a List of Unicode code points that is identical to a List of Unicode code points that is a Unicode property name or property alias listed in the “ Property name and aliases” column of Table 51 or Table 52 .</step>
  <step>Let <id>c</id> be the canonical property name of <id>p</id> as given in the “Canonical property name ” column of the corresponding row.</step>
  <step>Return the List of Unicode code points of <id>c</id> .</step>
</step-list>
<step-list>
  <step>Assert : <id>p</id> is a List of Unicode code points that is identical to a List of Unicode code points that is a canonical, unaliased Unicode property name listed in the “Canonical property name ” column of Table 51 .</step>
  <step>Assert : <id>v</id> is a List of Unicode code points that is identical to a List of Unicode code points that is a property value or property value alias for Unicode property <id>p</id> listed in the “Property value and aliases” column of Table 53 or Table 54 .</step>
  <step>Let <id>value</id> be the canonical property value of <id>v</id> as given in the “Canonical property value” column of the corresponding row.</step>
  <step>Return the List of Unicode code points of <id>value</id> .</step>
</step-list>
<step-list>
  <step>Evaluate DecimalEscape to obtain an integer <id>n</id> .</step>
  <step>Assert : <id>n</id> ≤ <id>NcapturingParens</id> .</step>
  <step>Call BackreferenceMatcher ( <id>n</id> , <id>direction</id> ) and return its Matcher result.</step>
</step-list>
<step-list>
  <step>Evaluate CharacterEscape to obtain a character <id>ch</id> .</step>
  <step>Let <id>A</id> be a one-element CharSet containing the character <id>ch</id> .</step>
  <step>Call CharacterSetMatcher ( <id>A</id> , <value>false</value> , <id>direction</id> ) and return its Matcher result.</step>
</step-list>
<step-list>
  <step>Evaluate CharacterClassEscape to obtain a CharSet <id>A</id> .</step>
  <step>Call CharacterSetMatcher ( <id>A</id> , <value>false</value> , <id>direction</id> ) and return its Matcher result.</step>
</step-list>
<step-list>
  <step>Search the enclosing Pattern for an instance of a GroupSpecifier for a RegExpIdentifierName which has a StringValue equal to the StringValue of the RegExpIdentifierName contained in GroupName .</step>
  <step>Assert : A unique such GroupSpecifier is found.</step>
  <step>Let <id>parenIndex</id> be the number of left-capturing parentheses in the entire regular expression that occur to the left of the located GroupSpecifier . This is the total number of Atom::(GroupSpecifierDisjunction) Parse Nodes prior to or enclosing the located GroupSpecifier .</step>
  <step>Call BackreferenceMatcher ( <id>parenIndex</id> , <id>direction</id> ) and return its Matcher result.</step>
</step-list>
<step-list>
  <step>Return an internal Matcher closure that takes two arguments, a State <id>x</id> and a Continuation <id>c</id> , and performs the following steps:   <step-list>
    <step>Let <id>cap</id> be <id>x</id> 's <id>captures</id>  List .</step>
    <step>Let <id>s</id> be <id>cap</id> [ <id>n</id> ].</step>
    <step>If <id>s</id> is <value>undefined</value> , return <id>c</id> ( <id>x</id> ).</step>
    <step>Let <id>e</id> be <id>x</id> 's <id>endIndex</id> .</step>
    <step>Let <id>len</id> be the number of elements in <id>s</id> .</step>
    <step>Let <id>f</id> be <id>e</id> + <id>direction</id> × <id>len</id> .</step>
    <step>If <id>f</id> < 0 or <id>f</id> > <id>InputLength</id> , return <value>failure</value> .</step>
    <step>Let <id>g</id> be min ( <id>e</id> , <id>f</id> ).</step>
    <step>If there exists an integer <id>i</id> between 0 (inclusive) and <id>len</id> (exclusive) such that Canonicalize ( <id>s</id> [ <id>i</id> ]) is not the same character value as Canonicalize ( <id>Input</id> [ <id>g</id> + <id>i</id> ]), return <value>failure</value> .</step>
    <step>Let <id>y</id> be the State ( <id>f</id> , <id>cap</id> ).</step>
    <step>Call <id>c</id> ( <id>y</id> ) and return its result.</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>cv</id> be the CharacterValue of this CharacterEscape .</step>
  <step>Return the character whose character value is <id>cv</id> .</step>
</step-list>
<step-list>
  <step>Return the CapturingGroupNumber of this DecimalEscape .</step>
</step-list>
<step-list>
  <step>Return the ten-element set of characters containing the characters <value>0</value> through <value>9</value> inclusive.</step>
</step-list>
<step-list>
  <step>Return the set of all characters not included in the set returned by CharacterClassEscape::d .</step>
</step-list>
<step-list>
  <step>Return the set of characters containing the characters that are on the right-hand side of the WhiteSpace or LineTerminator productions.</step>
</step-list>
<step-list>
  <step>Return the set of all characters not included in the set returned by CharacterClassEscape::s .</step>
</step-list>
<step-list>
  <step>Return the set of all characters returned by WordCharacters ().</step>
</step-list>
<step-list>
  <step>Return the set of all characters not included in the set returned by CharacterClassEscape::w .</step>
</step-list>
<step-list>
  <step>Let <id>ps</id> be SourceText of UnicodePropertyName .</step>
  <step>Let <id>p</id> be ! UnicodeMatchProperty ( <id>ps</id> ).</step>
  <step>Assert : <id>p</id> is a Unicode property name or property alias listed in the “ Property name and aliases” column of Table 51 .</step>
  <step>Let <id>vs</id> be SourceText of UnicodePropertyValue .</step>
  <step>Let <id>v</id> be ! UnicodeMatchPropertyValue ( <id>p</id> , <id>vs</id> ).</step>
  <step>Return the CharSet containing all Unicode code points whose character database definition includes the property <id>p</id> with value <id>v</id> .</step>
</step-list>
<step-list>
  <step>Let <id>s</id> be SourceText of LoneUnicodePropertyNameOrValue .</step>
  <step>If ! UnicodeMatchPropertyValue ( <value>"General_Category"</value> , <id>s</id> ) is identical to a List of Unicode code points that is the name of a Unicode general category 
or general category alias listed in the “Property value and aliases” 
column of Table 53 , then   <step-list>
    <step>Return
 the CharSet containing all Unicode code points whose character database
 definition includes the property “General_Category” with value <id>s</id> .</step>
  </step-list></step>
  <step>Let <id>p</id> be ! UnicodeMatchProperty ( <id>s</id> ).</step>
  <step>Assert : <id>p</id> is a binary Unicode property or binary property alias listed in the “ Property name and aliases” column of Table 52 .</step>
  <step>Return the CharSet containing all Unicode code points whose character database definition includes the property <id>p</id> with value “True”.</step>
</step-list>
<step-list>
  <step>Evaluate ClassRanges to obtain a CharSet <id>A</id> .</step>
  <step>Return the two results <id>A</id> and <value>false</value> .</step>
</step-list>
<step-list>
  <step>Evaluate ClassRanges to obtain a CharSet <id>A</id> .</step>
  <step>Return the two results <id>A</id> and <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return the empty CharSet.</step>
</step-list>
<step-list>
  <step>Return the CharSet that is the result of evaluating NonemptyClassRanges .</step>
</step-list>
<step-list>
  <step>Return the CharSet that is the result of evaluating ClassAtom .</step>
</step-list>
<step-list>
  <step>Evaluate ClassAtom to obtain a CharSet <id>A</id> .</step>
  <step>Evaluate NonemptyClassRangesNoDash to obtain a CharSet <id>B</id> .</step>
  <step>Return the union of CharSets <id>A</id> and <id>B</id> .</step>
</step-list>
<step-list>
  <step>Evaluate the first ClassAtom to obtain a CharSet <id>A</id> .</step>
  <step>Evaluate the second ClassAtom to obtain a CharSet <id>B</id> .</step>
  <step>Evaluate ClassRanges to obtain a CharSet <id>C</id> .</step>
  <step>Call CharacterRange ( <id>A</id> , <id>B</id> ) and let <id>D</id> be the resulting CharSet.</step>
  <step>Return the union of CharSets <id>D</id> and <id>C</id> .</step>
</step-list>
<step-list>
  <step>Assert : <id>A</id> and <id>B</id> each contain exactly one character.</step>
  <step>Let <id>a</id> be the one character in CharSet <id>A</id> .</step>
  <step>Let <id>b</id> be the one character in CharSet <id>B</id> .</step>
  <step>Let <id>i</id> be the character value of character <id>a</id> .</step>
  <step>Let <id>j</id> be the character value of character <id>b</id> .</step>
  <step>Assert : <id>i</id> ≤ <id>j</id> .</step>
  <step>Return the set containing all characters numbered <id>i</id> through <id>j</id> , inclusive.</step>
</step-list>
<step-list>
  <step>Return the CharSet that is the result of evaluating ClassAtom .</step>
</step-list>
<step-list>
  <step>Evaluate ClassAtomNoDash to obtain a CharSet <id>A</id> .</step>
  <step>Evaluate NonemptyClassRangesNoDash to obtain a CharSet <id>B</id> .</step>
  <step>Return the union of CharSets <id>A</id> and <id>B</id> .</step>
</step-list>
<step-list>
  <step>Evaluate ClassAtomNoDash to obtain a CharSet <id>A</id> .</step>
  <step>Evaluate ClassAtom to obtain a CharSet <id>B</id> .</step>
  <step>Evaluate ClassRanges to obtain a CharSet <id>C</id> .</step>
  <step>Call CharacterRange ( <id>A</id> , <id>B</id> ) and let <id>D</id> be the resulting CharSet.</step>
  <step>Return the union of CharSets <id>D</id> and <id>C</id> .</step>
</step-list>
<step-list>
  <step>Return the CharSet containing the single character <value>-</value> U+002D (HYPHEN-MINUS).</step>
</step-list>
<step-list>
  <step>Return the CharSet that is the result of evaluating ClassAtomNoDash .</step>
</step-list>
<step-list>
  <step>Return the CharSet containing the character matched by SourceCharacter .</step>
</step-list>
<step-list>
  <step>Return the CharSet that is the result of evaluating ClassEscape .</step>
</step-list>
<step-list>
  <step>Let <id>cv</id> be the CharacterValue of this ClassEscape .</step>
  <step>Let <id>c</id> be the character whose character value is <id>cv</id> .</step>
  <step>Return the CharSet containing the single character <id>c</id> .</step>
</step-list>
<step-list>
  <step>Return the CharSet that is the result of evaluating CharacterClassEscape .</step>
</step-list>
<step-list>
  <step>Let <id>patternIsRegExp</id> be ? IsRegExp ( <id>pattern</id> ).</step>
  <step>If NewTarget is <value>undefined</value> , then   <step-list>
    <step>Let <id>newTarget</id> be the active function object .</step>
    <step>If <id>patternIsRegExp</id> is <value>true</value> and <id>flags</id> is <value>undefined</value> , then     <step-list>
      <step>Let <id>patternConstructor</id> be ? Get ( <id>pattern</id> , <value>"constructor"</value> ).</step>
      <step>If SameValue ( <id>newTarget</id> , <id>patternConstructor</id> ) is <value>true</value> , return <id>pattern</id> .</step>
    </step-list></step>
  </step-list></step>
  <step>Else, let <id>newTarget</id> be NewTarget.</step>
  <step>If Type ( <id>pattern</id> ) is Object and <id>pattern</id> has a [[RegExpMatcher]] internal slot, then   <step-list>
    <step>Let <id>P</id> be <id>pattern</id> .[[OriginalSource]].</step>
    <step>If <id>flags</id> is <value>undefined</value> , let <id>F</id> be <id>pattern</id> .[[OriginalFlags]].</step>
    <step>Else, let <id>F</id> be <id>flags</id> .</step>
  </step-list></step>
  <step>Else if <id>patternIsRegExp</id> is <value>true</value> , then   <step-list>
    <step>Let <id>P</id> be ? Get ( <id>pattern</id> , <value>"source"</value> ).</step>
    <step>If <id>flags</id> is <value>undefined</value> , then     <step-list>
      <step>Let <id>F</id> be ? Get ( <id>pattern</id> , <value>"flags"</value> ).</step>
    </step-list></step>
    <step>Else, let <id>F</id> be <id>flags</id> .</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>P</id> be <id>pattern</id> .</step>
    <step>Let <id>F</id> be <id>flags</id> .</step>
  </step-list></step>
  <step>Let <id>O</id> be ? RegExpAlloc ( <id>newTarget</id> ).</step>
  <step>Return ? RegExpInitialize ( <id>O</id> , <id>P</id> , <id>F</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>obj</id> be ? OrdinaryCreateFromConstructor ( <id>newTarget</id> , <value>"%RegExpPrototype%"</value> , « [[RegExpMatcher]], [[OriginalSource]], [[OriginalFlags]] »).</step>
  <step>Perform ! DefinePropertyOrThrow ( <id>obj</id> , <value>"lastIndex"</value> , PropertyDescriptor { [[Writable]]: <value>true</value> , [[Enumerable]]: <value>false</value> , [[Configurable]]: <value>false</value> }).</step>
  <step>Return <id>obj</id> .</step>
</step-list>
<step-list>
  <step>If <id>pattern</id> is <value>undefined</value> , let <id>P</id> be the empty String.</step>
  <step>Else, let <id>P</id> be ? ToString ( <id>pattern</id> ).</step>
  <step>If <id>flags</id> is <value>undefined</value> , let <id>F</id> be the empty String.</step>
  <step>Else, let <id>F</id> be ? ToString ( <id>flags</id> ).</step>
  <step>If <id>F</id> contains any code unit other than <value>"g"</value> , <value>"i"</value> , <value>"m"</value> , <value>"s"</value> , <value>"u"</value> , or <value>"y"</value> or if it contains the same code unit more than once, throw a <value>SyntaxError</value> exception.</step>
  <step>If <id>F</id> contains <value>"u"</value> , let <id>BMP</id> be <value>false</value> ; else let <id>BMP</id> be <value>true</value> .</step>
  <step>If <id>BMP</id> is <value>true</value> , then   <step-list>
    <step>Parse <id>P</id> using the grammars in 21.2.1 and interpreting each of its 16-bit elements as a Unicode BMP code point. UTF-16 decoding is not applied to the elements. The goal symbol for the parse is Pattern[~U, ~N] . If the result of parsing contains a GroupName , reparse with the goal symbol  Pattern[~U, +N] and use this result instead. Throw a <value>SyntaxError</value> exception if <id>P</id> did not conform to the grammar, if any elements of <id>P</id> were not matched by the parse, or if any Early Error conditions exist.</step>
    <step>Let <id>patternCharacters</id> be a List whose elements are the code unit elements of <id>P</id> .</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Parse <id>P</id> using the grammars in 21.2.1 and interpreting <id>P</id> as UTF-16 encoded Unicode code points ( 6.1.4 ). The goal symbol for the parse is Pattern[+U, +N] . Throw a <value>SyntaxError</value> exception if <id>P</id> did not conform to the grammar, if any elements of <id>P</id> were not matched by the parse, or if any Early Error conditions exist.</step>
    <step>Let <id>patternCharacters</id> be a List whose elements are the code points resulting from applying UTF-16 decoding to <id>P</id> 's sequence of elements.</step>
  </step-list></step>
  <step>Set <id>obj</id> .[[OriginalSource]] to <id>P</id> .</step>
  <step>Set <id>obj</id> .[[OriginalFlags]] to <id>F</id> .</step>
  <step>Set <id>obj</id> .[[RegExpMatcher]] to the internal procedure that evaluates the above parse of <id>P</id> by applying the semantics provided in 21.2.2 using <id>patternCharacters</id> as the pattern's List of SourceCharacter values and <id>F</id> as the flag parameters.</step>
  <step>Perform ? Set ( <id>obj</id> , <value>"lastIndex"</value> , 0, <value>true</value> ).</step>
  <step>Return <id>obj</id> .</step>
</step-list>
<step-list>
  <step>Let <id>obj</id> be ? RegExpAlloc ( %RegExp% ).</step>
  <step>Return ? RegExpInitialize ( <id>obj</id> , <id>P</id> , <id>F</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>S</id> be a String in the form of a Pattern[~U] ( Pattern[+U] if <id>F</id> contains <value>"u"</value> ) equivalent to <id>P</id> interpreted as UTF-16 encoded Unicode code points ( 6.1.4 ), in which certain code points are escaped as described below. <id>S</id> may or may not be identical to <id>P</id> ; however, the internal procedure that would result from evaluating <id>S</id> as a Pattern[~U] ( Pattern[+U] if <id>F</id> contains <value>"u"</value> )
 must behave identically to the internal procedure given by the 
constructed object's [[RegExpMatcher]] internal slot. Multiple calls to 
this abstract operation using the same values for <id>P</id> and <id>F</id> must produce identical results.</step>
  <step>The code points <value>/</value> or any LineTerminator occurring in the pattern shall be escaped in <id>S</id> as necessary to ensure that the string-concatenation of <value>"/"</value> , <id>S</id> , <value>"/"</value> , and <id>F</id> can be parsed (in an appropriate lexical context) as a RegularExpressionLiteral that behaves identically to the constructed regular expression. For example, if <id>P</id> is <value>"/"</value> , then <id>S</id> could be <value>"\/"</value> or <value>"\u002F"</value> , among other possibilities, but not <value>"/"</value> , because <value>///</value> followed by <id>F</id> would be parsed as a SingleLineComment rather than a RegularExpressionLiteral . If <id>P</id> is the empty String, this specification can be met by letting <id>S</id> be <value>"(?:)"</value> .</step>
  <step>Return <id>S</id> .</step>
</step-list>
<step-list>
  <step>Return the <value>this</value> value.</step>
</step-list>
<step-list>
  <step>Let <id>R</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>R</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>R</id> does not have a [[RegExpMatcher]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>S</id> be ? ToString ( <id>string</id> ).</step>
  <step>Return ? RegExpBuiltinExec ( <id>R</id> , <id>S</id> ).</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>R</id> ) is Object.</step>
  <step>Assert : Type ( <id>S</id> ) is String.</step>
  <step>Let <id>exec</id> be ? Get ( <id>R</id> , <value>"exec"</value> ).</step>
  <step>If IsCallable ( <id>exec</id> ) is <value>true</value> , then   <step-list>
    <step>Let <id>result</id> be ? Call ( <id>exec</id> , <id>R</id> , « <id>S</id> »).</step>
    <step>If Type ( <id>result</id> ) is neither Object or Null, throw a <value>TypeError</value> exception.</step>
    <step>Return <id>result</id> .</step>
  </step-list></step>
  <step>If <id>R</id> does not have a [[RegExpMatcher]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Return ? RegExpBuiltinExec ( <id>R</id> , <id>S</id> ).</step>
</step-list>
<step-list>
  <step>Assert : <id>R</id> is an initialized RegExp instance.</step>
  <step>Assert : Type ( <id>S</id> ) is String.</step>
  <step>Let <id>length</id> be the number of code units in <id>S</id> .</step>
  <step>Let <id>lastIndex</id> be ? ToLength (? Get ( <id>R</id> , <value>"lastIndex"</value> )).</step>
  <step>Let <id>flags</id> be <id>R</id> .[[OriginalFlags]].</step>
  <step>If <id>flags</id> contains <value>"g"</value> , let <id>global</id> be <value>true</value> , else let <id>global</id> be <value>false</value> .</step>
  <step>If <id>flags</id> contains <value>"y"</value> , let <id>sticky</id> be <value>true</value> , else let <id>sticky</id> be <value>false</value> .</step>
  <step>If <id>global</id> is <value>false</value> and <id>sticky</id> is <value>false</value> , set <id>lastIndex</id> to 0.</step>
  <step>Let <id>matcher</id> be <id>R</id> .[[RegExpMatcher]].</step>
  <step>If <id>flags</id> contains <value>"u"</value> , let <id>fullUnicode</id> be <value>true</value> , else let <id>fullUnicode</id> be <value>false</value> .</step>
  <step>Let <id>matchSucceeded</id> be <value>false</value> .</step>
  <step>Repeat, while <id>matchSucceeded</id> is <value>false</value>   <step-list>
    <step>If <id>lastIndex</id> > <id>length</id> , then     <step-list>
      <step>If <id>global</id> is <value>true</value> or <id>sticky</id> is <value>true</value> , then       <step-list>
        <step>Perform ? Set ( <id>R</id> , <value>"lastIndex"</value> , 0, <value>true</value> ).</step>
      </step-list></step>
      <step>Return <value>null</value> .</step>
    </step-list></step>
    <step>Let <id>r</id> be <id>matcher</id> ( <id>S</id> , <id>lastIndex</id> ).</step>
    <step>If <id>r</id> is <value>failure</value> , then     <step-list>
      <step>If <id>sticky</id> is <value>true</value> , then       <step-list>
        <step>Perform ? Set ( <id>R</id> , <value>"lastIndex"</value> , 0, <value>true</value> ).</step>
        <step>Return <value>null</value> .</step>
      </step-list></step>
      <step>Set <id>lastIndex</id> to AdvanceStringIndex ( <id>S</id> , <id>lastIndex</id> , <id>fullUnicode</id> ).</step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>Assert : <id>r</id> is a State.</step>
      <step>Set <id>matchSucceeded</id> to <value>true</value> .</step>
    </step-list></step>
  </step-list></step>
  <step>Let <id>e</id> be <id>r</id> 's <id>endIndex</id> value.</step>
  <step>If <id>fullUnicode</id> is <value>true</value> , then   <step-list>
    <step><id>e</id> is an index into the <id>Input</id> character list, derived from <id>S</id> , matched by <id>matcher</id> . Let <id>eUTF</id> be the smallest index into <id>S</id> that corresponds to the character at element <id>e</id> of <id>Input</id> . If <id>e</id> is greater than or equal to the number of elements in <id>Input</id> , then <id>eUTF</id> is the number of code units in <id>S</id> .</step>
    <step>Set <id>e</id> to <id>eUTF</id> .</step>
  </step-list></step>
  <step>If <id>global</id> is <value>true</value> or <id>sticky</id> is <value>true</value> , then   <step-list>
    <step>Perform ? Set ( <id>R</id> , <value>"lastIndex"</value> , <id>e</id> , <value>true</value> ).</step>
  </step-list></step>
  <step>Let <id>n</id> be the number of elements in <id>r</id> 's <id>captures</id>  List . (This is the same value as 21.2.2.1 's <id>NcapturingParens</id> .)</step>
  <step>Assert : <id>n</id> < 2 32 -1.</step>
  <step>Let <id>A</id> be ! ArrayCreate ( <id>n</id> + 1).</step>
  <step>Assert : The value of <id>A</id> 's <value>"length"</value> property is <id>n</id> + 1.</step>
  <step>Perform ! CreateDataProperty ( <id>A</id> , <value>"index"</value> , <id>lastIndex</id> ).</step>
  <step>Perform ! CreateDataProperty ( <id>A</id> , <value>"input"</value> , <id>S</id> ).</step>
  <step>Let <id>matchedSubstr</id> be the matched substring (i.e. the portion of <id>S</id> between offset <id>lastIndex</id> inclusive and offset <id>e</id> exclusive).</step>
  <step>Perform ! CreateDataProperty ( <id>A</id> , <value>"0"</value> , <id>matchedSubstr</id> ).</step>
  <step>If <id>R</id> contains any GroupName , then   <step-list>
    <step>Let <id>groups</id> be ObjectCreate ( <value>null</value> ).</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>groups</id> be <value>undefined</value> .</step>
  </step-list></step>
  <step>Perform ! CreateDataProperty ( <id>A</id> , <value>"groups"</value> , <id>groups</id> ).</step>
  <step>For each integer <id>i</id> such that <id>i</id> > 0 and <id>i</id> ≤ <id>n</id> , do   <step-list>
    <step>Let <id>captureI</id> be <id>i</id> th element of <id>r</id> 's <id>captures</id>  List .</step>
    <step>If <id>captureI</id> is <value>undefined</value> , let <id>capturedValue</id> be <value>undefined</value> .</step>
    <step>Else if <id>fullUnicode</id> is <value>true</value> , then     <step-list>
      <step>Assert : <id>captureI</id> is a List of code points.</step>
      <step>Let <id>capturedValue</id> be the String value whose code units are the UTF16Encoding of the code points of <id>captureI</id> .</step>
    </step-list></step>
    <step>Else <id>fullUnicode</id> is <value>false</value> ,     <step-list>
      <step>Assert : <id>captureI</id> is a List of code units.</step>
      <step>Let <id>capturedValue</id> be the String value consisting of the code units of <id>captureI</id> .</step>
    </step-list></step>
    <step>Perform ! CreateDataProperty ( <id>A</id> , ! ToString ( <id>i</id> ), <id>capturedValue</id> ).</step>
    <step>If the <id>i</id> th capture of <id>R</id> was defined with a GroupName , then     <step-list>
      <step>Let <id>s</id> be the StringValue of the corresponding RegExpIdentifierName .</step>
      <step>Perform ! CreateDataProperty ( <id>groups</id> , <id>s</id> , <id>capturedValue</id> ).</step>
    </step-list></step>
  </step-list></step>
  <step>Return <id>A</id> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>S</id> ) is String.</step>
  <step>Assert : <id>index</id> is an integer such that 0≤ <id>index</id> ≤2 53 -1.</step>
  <step>Assert : Type ( <id>unicode</id> ) is Boolean.</step>
  <step>If <id>unicode</id> is <value>false</value> , return <id>index</id> +1.</step>
  <step>Let <id>length</id> be the number of code units in <id>S</id> .</step>
  <step>If <id>index</id> +1 ≥ <id>length</id> , return <id>index</id> +1.</step>
  <step>Let <id>first</id> be the numeric value of the code unit at index <id>index</id> within <id>S</id> .</step>
  <step>If <id>first</id> < 0xD800 or <id>first</id> > 0xDBFF, return <id>index</id> +1.</step>
  <step>Let <id>second</id> be the numeric value of the code unit at index <id>index</id> +1 within <id>S</id> .</step>
  <step>If <id>second</id> < 0xDC00 or <id>second</id> > 0xDFFF, return <id>index</id> +1.</step>
  <step>Return <id>index</id> +2.</step>
</step-list>
<step-list>
  <step>Let <id>R</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>R</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>R</id> does not have an [[OriginalFlags]] internal slot, then   <step-list>
    <step>If SameValue ( <id>R</id> , %RegExpPrototype% ) is <value>true</value> , return <value>undefined</value> .</step>
    <step>Otherwise, throw a <value>TypeError</value> exception.</step>
  </step-list></step>
  <step>Let <id>flags</id> be <id>R</id> .[[OriginalFlags]].</step>
  <step>If <id>flags</id> contains the code unit 0x0073 (LATIN SMALL LETTER S), return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>R</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>R</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>result</id> be the empty String.</step>
  <step>Let <id>global</id> be ToBoolean (? Get ( <id>R</id> , <value>"global"</value> )).</step>
  <step>If <id>global</id> is <value>true</value> , append the code unit 0x0067 (LATIN SMALL LETTER G) as the last code unit of <id>result</id> .</step>
  <step>Let <id>ignoreCase</id> be ToBoolean (? Get ( <id>R</id> , <value>"ignoreCase"</value> )).</step>
  <step>If <id>ignoreCase</id> is <value>true</value> , append the code unit 0x0069 (LATIN SMALL LETTER I) as the last code unit of <id>result</id> .</step>
  <step>Let <id>multiline</id> be ToBoolean (? Get ( <id>R</id> , <value>"multiline"</value> )).</step>
  <step>If <id>multiline</id> is <value>true</value> , append the code unit 0x006D (LATIN SMALL LETTER M) as the last code unit of <id>result</id> .</step>
  <step>Let <id>dotAll</id> be ToBoolean (? Get ( <id>R</id> , <value>"dotAll"</value> )).</step>
  <step>If <id>dotAll</id> is <value>true</value> , append the code unit 0x0073 (LATIN SMALL LETTER S) as the last code unit of <id>result</id> .</step>
  <step>Let <id>unicode</id> be ToBoolean (? Get ( <id>R</id> , <value>"unicode"</value> )).</step>
  <step>If <id>unicode</id> is <value>true</value> , append the code unit 0x0075 (LATIN SMALL LETTER U) as the last code unit of <id>result</id> .</step>
  <step>Let <id>sticky</id> be ToBoolean (? Get ( <id>R</id> , <value>"sticky"</value> )).</step>
  <step>If <id>sticky</id> is <value>true</value> , append the code unit 0x0079 (LATIN SMALL LETTER Y) as the last code unit of <id>result</id> .</step>
  <step>Return <id>result</id> .</step>
</step-list>
<step-list>
  <step>Let <id>R</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>R</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>R</id> does not have an [[OriginalFlags]] internal slot, then   <step-list>
    <step>If SameValue ( <id>R</id> , %RegExpPrototype% ) is <value>true</value> , return <value>undefined</value> .</step>
    <step>Otherwise, throw a <value>TypeError</value> exception.</step>
  </step-list></step>
  <step>Let <id>flags</id> be <id>R</id> .[[OriginalFlags]].</step>
  <step>If <id>flags</id> contains the code unit 0x0067 (LATIN SMALL LETTER G), return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>R</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>R</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>R</id> does not have an [[OriginalFlags]] internal slot, then   <step-list>
    <step>If SameValue ( <id>R</id> , %RegExpPrototype% ) is <value>true</value> , return <value>undefined</value> .</step>
    <step>Otherwise, throw a <value>TypeError</value> exception.</step>
  </step-list></step>
  <step>Let <id>flags</id> be <id>R</id> .[[OriginalFlags]].</step>
  <step>If <id>flags</id> contains the code unit 0x0069 (LATIN SMALL LETTER I), return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>rx</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>rx</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>S</id> be ? ToString ( <id>string</id> ).</step>
  <step>Let <id>global</id> be ToBoolean (? Get ( <id>rx</id> , <value>"global"</value> )).</step>
  <step>If <id>global</id> is <value>false</value> , then   <step-list>
    <step>Return ? RegExpExec ( <id>rx</id> , <id>S</id> ).</step>
  </step-list></step>
  <step>Else <id>global</id> is <value>true</value> ,   <step-list>
    <step>Let <id>fullUnicode</id> be ToBoolean (? Get ( <id>rx</id> , <value>"unicode"</value> )).</step>
    <step>Perform ? Set ( <id>rx</id> , <value>"lastIndex"</value> , 0, <value>true</value> ).</step>
    <step>Let <id>A</id> be ! ArrayCreate (0).</step>
    <step>Let <id>n</id> be 0.</step>
    <step>Repeat,     <step-list>
      <step>Let <id>result</id> be ? RegExpExec ( <id>rx</id> , <id>S</id> ).</step>
      <step>If <id>result</id> is <value>null</value> , then       <step-list>
        <step>If <id>n</id> =0, return <value>null</value> .</step>
        <step>Return <id>A</id> .</step>
      </step-list></step>
      <step>Else <id>result</id> is not <value>null</value> ,       <step-list>
        <step>Let <id>matchStr</id> be ? ToString (? Get ( <id>result</id> , <value>"0"</value> )).</step>
        <step>Let <id>status</id> be CreateDataProperty ( <id>A</id> , ! ToString ( <id>n</id> ), <id>matchStr</id> ).</step>
        <step>Assert : <id>status</id> is <value>true</value> .</step>
        <step>If <id>matchStr</id> is the empty String, then         <step-list>
          <step>Let <id>thisIndex</id> be ? ToLength (? Get ( <id>rx</id> , <value>"lastIndex"</value> )).</step>
          <step>Let <id>nextIndex</id> be AdvanceStringIndex ( <id>S</id> , <id>thisIndex</id> , <id>fullUnicode</id> ).</step>
          <step>Perform ? Set ( <id>rx</id> , <value>"lastIndex"</value> , <id>nextIndex</id> , <value>true</value> ).</step>
        </step-list></step>
        <step>Increment <id>n</id> .</step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>R</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>R</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>R</id> does not have an [[OriginalFlags]] internal slot, then   <step-list>
    <step>If SameValue ( <id>R</id> , %RegExpPrototype% ) is <value>true</value> , return <value>undefined</value> .</step>
    <step>Otherwise, throw a <value>TypeError</value> exception.</step>
  </step-list></step>
  <step>Let <id>flags</id> be <id>R</id> .[[OriginalFlags]].</step>
  <step>If <id>flags</id> contains the code unit 0x006D (LATIN SMALL LETTER M), return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>rx</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>rx</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>S</id> be ? ToString ( <id>string</id> ).</step>
  <step>Let <id>lengthS</id> be the number of code unit elements in <id>S</id> .</step>
  <step>Let <id>functionalReplace</id> be IsCallable ( <id>replaceValue</id> ).</step>
  <step>If <id>functionalReplace</id> is <value>false</value> , then   <step-list>
    <step>Let <id>replaceValue</id> be ? ToString ( <id>replaceValue</id> ).</step>
  </step-list></step>
  <step>Let <id>global</id> be ToBoolean (? Get ( <id>rx</id> , <value>"global"</value> )).</step>
  <step>If <id>global</id> is <value>true</value> , then   <step-list>
    <step>Let <id>fullUnicode</id> be ToBoolean (? Get ( <id>rx</id> , <value>"unicode"</value> )).</step>
    <step>Perform ? Set ( <id>rx</id> , <value>"lastIndex"</value> , 0, <value>true</value> ).</step>
  </step-list></step>
  <step>Let <id>results</id> be a new empty List .</step>
  <step>Let <id>done</id> be <value>false</value> .</step>
  <step>Repeat, while <id>done</id> is <value>false</value>   <step-list>
    <step>Let <id>result</id> be ? RegExpExec ( <id>rx</id> , <id>S</id> ).</step>
    <step>If <id>result</id> is <value>null</value> , set <id>done</id> to <value>true</value> .</step>
    <step>Else <id>result</id> is not <value>null</value> ,     <step-list>
      <step>Append <id>result</id> to the end of <id>results</id> .</step>
      <step>If <id>global</id> is <value>false</value> , set <id>done</id> to <value>true</value> .</step>
      <step>Else,       <step-list>
        <step>Let <id>matchStr</id> be ? ToString (? Get ( <id>result</id> , <value>"0"</value> )).</step>
        <step>If <id>matchStr</id> is the empty String, then         <step-list>
          <step>Let <id>thisIndex</id> be ? ToLength (? Get ( <id>rx</id> , <value>"lastIndex"</value> )).</step>
          <step>Let <id>nextIndex</id> be AdvanceStringIndex ( <id>S</id> , <id>thisIndex</id> , <id>fullUnicode</id> ).</step>
          <step>Perform ? Set ( <id>rx</id> , <value>"lastIndex"</value> , <id>nextIndex</id> , <value>true</value> ).</step>
        </step-list></step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
  <step>Let <id>accumulatedResult</id> be the empty String value.</step>
  <step>Let <id>nextSourcePosition</id> be 0.</step>
  <step>For each <id>result</id> in <id>results</id> , do   <step-list>
    <step>Let <id>nCaptures</id> be ? ToLength (? Get ( <id>result</id> , <value>"length"</value> )).</step>
    <step>Let <id>nCaptures</id> be max ( <id>nCaptures</id> - 1, 0).</step>
    <step>Let <id>matched</id> be ? ToString (? Get ( <id>result</id> , <value>"0"</value> )).</step>
    <step>Let <id>matchLength</id> be the number of code units in <id>matched</id> .</step>
    <step>Let <id>position</id> be ? ToInteger (? Get ( <id>result</id> , <value>"index"</value> )).</step>
    <step>Let <id>position</id> be max ( min ( <id>position</id> , <id>lengthS</id> ), 0).</step>
    <step>Let <id>n</id> be 1.</step>
    <step>Let <id>captures</id> be a new empty List .</step>
    <step>Repeat, while <id>n</id> ≤ <id>nCaptures</id>     <step-list>
      <step>Let <id>capN</id> be ? Get ( <id>result</id> , ! ToString ( <id>n</id> )).</step>
      <step>If <id>capN</id> is not <value>undefined</value> , then       <step-list>
        <step>Let <id>capN</id> be ? ToString ( <id>capN</id> ).</step>
      </step-list></step>
      <step>Append <id>capN</id> as the last element of <id>captures</id> .</step>
      <step>Let <id>n</id> be <id>n</id> +1.</step>
    </step-list></step>
    <step>Let <id>namedCaptures</id> be ? Get ( <id>result</id> , <value>"groups"</value> ).</step>
    <step>If <id>functionalReplace</id> is <value>true</value> , then     <step-list>
      <step>Let <id>replacerArgs</id> be « <id>matched</id> ».</step>
      <step>Append in list order the elements of <id>captures</id> to the end of the List  <id>replacerArgs</id> .</step>
      <step>Append <id>position</id> and <id>S</id> to <id>replacerArgs</id> .</step>
      <step>If <id>namedCaptures</id> is not <value>undefined</value> , then       <step-list>
        <step>Append <id>namedCaptures</id> as the last element of <id>replacerArgs</id> .</step>
      </step-list></step>
      <step>Let <id>replValue</id> be ? Call ( <id>replaceValue</id> , <value>undefined</value> , <id>replacerArgs</id> ).</step>
      <step>Let <id>replacement</id> be ? ToString ( <id>replValue</id> ).</step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>Let <id>replacement</id> be GetSubstitution ( <id>matched</id> , <id>S</id> , <id>position</id> , <id>captures</id> , <id>namedCaptures</id> , <id>replaceValue</id> ).</step>
    </step-list></step>
    <step>If <id>position</id> ≥ <id>nextSourcePosition</id> , then     <step-list>
      <step>NOTE: <id>position</id> should not normally move backwards. If it does, it is an indication of 
an ill-behaving RegExp subclass or use of an access triggered 
side-effect to change the global flag or other characteristics of <id>rx</id> . In such cases, the corresponding substitution is ignored.</step>
      <step>Let <id>accumulatedResult</id> be the string-concatenation of the current value of <id>accumulatedResult</id> , the substring of <id>S</id> consisting of the code units from <id>nextSourcePosition</id> (inclusive) up to <id>position</id> (exclusive), and <id>replacement</id> .</step>
      <step>Let <id>nextSourcePosition</id> be <id>position</id> + <id>matchLength</id> .</step>
    </step-list></step>
  </step-list></step>
  <step>If <id>nextSourcePosition</id> ≥ <id>lengthS</id> , return <id>accumulatedResult</id> .</step>
  <step>Return the string-concatenation of <id>accumulatedResult</id> and the substring of <id>S</id> consisting of the code units from <id>nextSourcePosition</id> (inclusive) up through the final code unit of <id>S</id> (inclusive).</step>
</step-list>
<step-list>
  <step>Let <id>rx</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>rx</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>S</id> be ? ToString ( <id>string</id> ).</step>
  <step>Let <id>previousLastIndex</id> be ? Get ( <id>rx</id> , <value>"lastIndex"</value> ).</step>
  <step>If SameValue ( <id>previousLastIndex</id> , 0) is <value>false</value> , then   <step-list>
    <step>Perform ? Set ( <id>rx</id> , <value>"lastIndex"</value> , 0, <value>true</value> ).</step>
  </step-list></step>
  <step>Let <id>result</id> be ? RegExpExec ( <id>rx</id> , <id>S</id> ).</step>
  <step>Let <id>currentLastIndex</id> be ? Get ( <id>rx</id> , <value>"lastIndex"</value> ).</step>
  <step>If SameValue ( <id>currentLastIndex</id> , <id>previousLastIndex</id> ) is <value>false</value> , then   <step-list>
    <step>Perform ? Set ( <id>rx</id> , <value>"lastIndex"</value> , <id>previousLastIndex</id> , <value>true</value> ).</step>
  </step-list></step>
  <step>If <id>result</id> is <value>null</value> , return -1.</step>
  <step>Return ? Get ( <id>result</id> , <value>"index"</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>R</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>R</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>R</id> does not have an [[OriginalSource]] internal slot, then   <step-list>
    <step>If SameValue ( <id>R</id> , %RegExpPrototype% ) is <value>true</value> , return <value>"(?:)"</value> .</step>
    <step>Otherwise, throw a <value>TypeError</value> exception.</step>
  </step-list></step>
  <step>Assert : <id>R</id> has an [[OriginalFlags]] internal slot.</step>
  <step>Let <id>src</id> be <id>R</id> .[[OriginalSource]].</step>
  <step>Let <id>flags</id> be <id>R</id> .[[OriginalFlags]].</step>
  <step>Return EscapeRegExpPattern ( <id>src</id> , <id>flags</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>rx</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>rx</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>S</id> be ? ToString ( <id>string</id> ).</step>
  <step>Let <id>C</id> be ? SpeciesConstructor ( <id>rx</id> , %RegExp% ).</step>
  <step>Let <id>flags</id> be ? ToString (? Get ( <id>rx</id> , <value>"flags"</value> )).</step>
  <step>If <id>flags</id> contains <value>"u"</value> , let <id>unicodeMatching</id> be <value>true</value> .</step>
  <step>Else, let <id>unicodeMatching</id> be <value>false</value> .</step>
  <step>If <id>flags</id> contains <value>"y"</value> , let <id>newFlags</id> be <id>flags</id> .</step>
  <step>Else, let <id>newFlags</id> be the string-concatenation of <id>flags</id> and <value>"y"</value> .</step>
  <step>Let <id>splitter</id> be ? Construct ( <id>C</id> , « <id>rx</id> , <id>newFlags</id> »).</step>
  <step>Let <id>A</id> be ! ArrayCreate (0).</step>
  <step>Let <id>lengthA</id> be 0.</step>
  <step>If <id>limit</id> is <value>undefined</value> , let <id>lim</id> be 2 32 -1; else let <id>lim</id> be ? ToUint32 ( <id>limit</id> ).</step>
  <step>Let <id>size</id> be the length of <id>S</id> .</step>
  <step>Let <id>p</id> be 0.</step>
  <step>If <id>lim</id> = 0, return <id>A</id> .</step>
  <step>If <id>size</id> = 0, then   <step-list>
    <step>Let <id>z</id> be ? RegExpExec ( <id>splitter</id> , <id>S</id> ).</step>
    <step>If <id>z</id> is not <value>null</value> , return <id>A</id> .</step>
    <step>Perform ! CreateDataProperty ( <id>A</id> , <value>"0"</value> , <id>S</id> ).</step>
    <step>Return <id>A</id> .</step>
  </step-list></step>
  <step>Let <id>q</id> be <id>p</id> .</step>
  <step>Repeat, while <id>q</id> < <id>size</id>   <step-list>
    <step>Perform ? Set ( <id>splitter</id> , <value>"lastIndex"</value> , <id>q</id> , <value>true</value> ).</step>
    <step>Let <id>z</id> be ? RegExpExec ( <id>splitter</id> , <id>S</id> ).</step>
    <step>If <id>z</id> is <value>null</value> , let <id>q</id> be AdvanceStringIndex ( <id>S</id> , <id>q</id> , <id>unicodeMatching</id> ).</step>
    <step>Else <id>z</id> is not <value>null</value> ,     <step-list>
      <step>Let <id>e</id> be ? ToLength (? Get ( <id>splitter</id> , <value>"lastIndex"</value> )).</step>
      <step>Let <id>e</id> be min ( <id>e</id> , <id>size</id> ).</step>
      <step>If <id>e</id> = <id>p</id> , let <id>q</id> be AdvanceStringIndex ( <id>S</id> , <id>q</id> , <id>unicodeMatching</id> ).</step>
      <step>Else <id>e</id> ≠ <id>p</id> ,       <step-list>
        <step>Let <id>T</id> be the String value equal to the substring of <id>S</id> consisting of the elements at indices <id>p</id> (inclusive) through <id>q</id> (exclusive).</step>
        <step>Perform ! CreateDataProperty ( <id>A</id> , ! ToString ( <id>lengthA</id> ), <id>T</id> ).</step>
        <step>Let <id>lengthA</id> be <id>lengthA</id> + 1.</step>
        <step>If <id>lengthA</id> = <id>lim</id> , return <id>A</id> .</step>
        <step>Let <id>p</id> be <id>e</id> .</step>
        <step>Let <id>numberOfCaptures</id> be ? ToLength (? Get ( <id>z</id> , <value>"length"</value> )).</step>
        <step>Let <id>numberOfCaptures</id> be max ( <id>numberOfCaptures</id> -1, 0).</step>
        <step>Let <id>i</id> be 1.</step>
        <step>Repeat, while <id>i</id> ≤ <id>numberOfCaptures</id> ,         <step-list>
          <step>Let <id>nextCapture</id> be ? Get ( <id>z</id> , ! ToString ( <id>i</id> )).</step>
          <step>Perform ! CreateDataProperty ( <id>A</id> , ! ToString ( <id>lengthA</id> ), <id>nextCapture</id> ).</step>
          <step>Let <id>i</id> be <id>i</id> + 1.</step>
          <step>Let <id>lengthA</id> be <id>lengthA</id> + 1.</step>
          <step>If <id>lengthA</id> = <id>lim</id> , return <id>A</id> .</step>
        </step-list></step>
        <step>Let <id>q</id> be <id>p</id> .</step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
  <step>Let <id>T</id> be the String value equal to the substring of <id>S</id> consisting of the elements at indices <id>p</id> (inclusive) through <id>size</id> (exclusive).</step>
  <step>Perform ! CreateDataProperty ( <id>A</id> , ! ToString ( <id>lengthA</id> ), <id>T</id> ).</step>
  <step>Return <id>A</id> .</step>
</step-list>
<step-list>
  <step>Let <id>R</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>R</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>R</id> does not have an [[OriginalFlags]] internal slot, then   <step-list>
    <step>If SameValue ( <id>R</id> , %RegExpPrototype% ) is <value>true</value> , return <value>undefined</value> .</step>
    <step>Otherwise, throw a <value>TypeError</value> exception.</step>
  </step-list></step>
  <step>Let <id>flags</id> be <id>R</id> .[[OriginalFlags]].</step>
  <step>If <id>flags</id> contains the code unit 0x0079 (LATIN SMALL LETTER Y), return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>R</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>R</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>string</id> be ? ToString ( <id>S</id> ).</step>
  <step>Let <id>match</id> be ? RegExpExec ( <id>R</id> , <id>string</id> ).</step>
  <step>If <id>match</id> is not <value>null</value> , return <value>true</value> ; else return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>R</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>R</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>pattern</id> be ? ToString (? Get ( <id>R</id> , <value>"source"</value> )).</step>
  <step>Let <id>flags</id> be ? ToString (? Get ( <id>R</id> , <value>"flags"</value> )).</step>
  <step>Let <id>result</id> be the string-concatenation of <value>"/"</value> , <id>pattern</id> , <value>"/"</value> , and <id>flags</id> .</step>
  <step>Return <id>result</id> .</step>
</step-list>
<step-list>
  <step>Let <id>R</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>R</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>R</id> does not have an [[OriginalFlags]] internal slot, then   <step-list>
    <step>If SameValue ( <id>R</id> , %RegExpPrototype% ) is <value>true</value> , return <value>undefined</value> .</step>
    <step>Otherwise, throw a <value>TypeError</value> exception.</step>
  </step-list></step>
  <step>Let <id>flags</id> be <id>R</id> .[[OriginalFlags]].</step>
  <step>If <id>flags</id> contains the code unit 0x0075 (LATIN SMALL LETTER U), return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>numberOfArgs</id> be the number of arguments passed to this function call.</step>
  <step>Assert : <id>numberOfArgs</id> = 0.</step>
  <step>If NewTarget is <value>undefined</value> , let <id>newTarget</id> be the active function object , else let <id>newTarget</id> be NewTarget.</step>
  <step>Let <id>proto</id> be ? GetPrototypeFromConstructor ( <id>newTarget</id> , <value>"%ArrayPrototype%"</value> ).</step>
  <step>Return ! ArrayCreate (0, <id>proto</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>numberOfArgs</id> be the number of arguments passed to this function call.</step>
  <step>Assert : <id>numberOfArgs</id> = 1.</step>
  <step>If NewTarget is <value>undefined</value> , let <id>newTarget</id> be the active function object , else let <id>newTarget</id> be NewTarget.</step>
  <step>Let <id>proto</id> be ? GetPrototypeFromConstructor ( <id>newTarget</id> , <value>"%ArrayPrototype%"</value> ).</step>
  <step>Let <id>array</id> be ! ArrayCreate (0, <id>proto</id> ).</step>
  <step>If Type ( <id>len</id> ) is not Number, then   <step-list>
    <step>Let <id>defineStatus</id> be CreateDataProperty ( <id>array</id> , <value>"0"</value> , <id>len</id> ).</step>
    <step>Assert : <id>defineStatus</id> is <value>true</value> .</step>
    <step>Let <id>intLen</id> be 1.</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>intLen</id> be ToUint32 ( <id>len</id> ).</step>
    <step>If <id>intLen</id> ≠ <id>len</id> , throw a <value>RangeError</value> exception.</step>
  </step-list></step>
  <step>Perform ! Set ( <id>array</id> , <value>"length"</value> , <id>intLen</id> , <value>true</value> ).</step>
  <step>Return <id>array</id> .</step>
</step-list>
<step-list>
  <step>Let <id>numberOfArgs</id> be the number of arguments passed to this function call.</step>
  <step>Assert : <id>numberOfArgs</id> ≥ 2.</step>
  <step>If NewTarget is <value>undefined</value> , let <id>newTarget</id> be the active function object , else let <id>newTarget</id> be NewTarget.</step>
  <step>Let <id>proto</id> be ? GetPrototypeFromConstructor ( <id>newTarget</id> , <value>"%ArrayPrototype%"</value> ).</step>
  <step>Let <id>array</id> be ? ArrayCreate ( <id>numberOfArgs</id> , <id>proto</id> ).</step>
  <step>Let <id>k</id> be 0.</step>
  <step>Let <id>items</id> be a zero-origined List containing the argument items in order.</step>
  <step>Repeat, while <id>k</id> < <id>numberOfArgs</id>   <step-list>
    <step>Let <id>Pk</id> be ! ToString ( <id>k</id> ).</step>
    <step>Let <id>itemK</id> be <id>items</id> [ <id>k</id> ].</step>
    <step>Let <id>defineStatus</id> be CreateDataProperty ( <id>array</id> , <id>Pk</id> , <id>itemK</id> ).</step>
    <step>Assert : <id>defineStatus</id> is <value>true</value> .</step>
    <step>Increase <id>k</id> by 1.</step>
  </step-list></step>
  <step>Assert : The value of <id>array</id> 's <value>length</value> property is <id>numberOfArgs</id> .</step>
  <step>Return <id>array</id> .</step>
</step-list>
<step-list>
  <step>Let <id>C</id> be the <value>this</value> value.</step>
  <step>If <id>mapfn</id> is <value>undefined</value> , let <id>mapping</id> be <value>false</value> .</step>
  <step>Else,   <step-list>
    <step>If IsCallable ( <id>mapfn</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
    <step>If <id>thisArg</id> is present, let <id>T</id> be <id>thisArg</id> ; else let <id>T</id> be <value>undefined</value> .</step>
    <step>Let <id>mapping</id> be <value>true</value> .</step>
  </step-list></step>
  <step>Let <id>usingIterator</id> be ? GetMethod ( <id>items</id> , @@iterator).</step>
  <step>If <id>usingIterator</id> is not <value>undefined</value> , then   <step-list>
    <step>If IsConstructor ( <id>C</id> ) is <value>true</value> , then     <step-list>
      <step>Let <id>A</id> be ? Construct ( <id>C</id> ).</step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>Let <id>A</id> be ! ArrayCreate (0).</step>
    </step-list></step>
    <step>Let <id>iteratorRecord</id> be ? GetIterator ( <id>items</id> , <value>sync</value> , <id>usingIterator</id> ).</step>
    <step>Let <id>k</id> be 0.</step>
    <step>Repeat,     <step-list>
      <step>If <id>k</id> ≥ 2 53 -1, then       <step-list>
        <step>Let <id>error</id> be ThrowCompletion (a newly created <value>TypeError</value> object).</step>
        <step>Return ? IteratorClose ( <id>iteratorRecord</id> , <id>error</id> ).</step>
      </step-list></step>
      <step>Let <id>Pk</id> be ! ToString ( <id>k</id> ).</step>
      <step>Let <id>next</id> be ? IteratorStep ( <id>iteratorRecord</id> ).</step>
      <step>If <id>next</id> is <value>false</value> , then       <step-list>
        <step>Perform ? Set ( <id>A</id> , <value>"length"</value> , <id>k</id> , <value>true</value> ).</step>
        <step>Return <id>A</id> .</step>
      </step-list></step>
      <step>Let <id>nextValue</id> be ? IteratorValue ( <id>next</id> ).</step>
      <step>If <id>mapping</id> is <value>true</value> , then       <step-list>
        <step>Let <id>mappedValue</id> be Call ( <id>mapfn</id> , <id>T</id> , « <id>nextValue</id> , <id>k</id> »).</step>
        <step>If <id>mappedValue</id> is an abrupt completion , return ? IteratorClose ( <id>iteratorRecord</id> , <id>mappedValue</id> ).</step>
        <step>Let <id>mappedValue</id> be <id>mappedValue</id> .[[Value]].</step>
      </step-list></step>
      <step>Else, let <id>mappedValue</id> be <id>nextValue</id> .</step>
      <step>Let <id>defineStatus</id> be CreateDataPropertyOrThrow ( <id>A</id> , <id>Pk</id> , <id>mappedValue</id> ).</step>
      <step>If <id>defineStatus</id> is an abrupt completion , return ? IteratorClose ( <id>iteratorRecord</id> , <id>defineStatus</id> ).</step>
      <step>Increase <id>k</id> by 1.</step>
    </step-list></step>
  </step-list></step>
  <step>NOTE: <id>items</id> is not an Iterable so assume it is an array-like object.</step>
  <step>Let <id>arrayLike</id> be ! ToObject ( <id>items</id> ).</step>
  <step>Let <id>len</id> be ? ToLength (? Get ( <id>arrayLike</id> , <value>"length"</value> )).</step>
  <step>If IsConstructor ( <id>C</id> ) is <value>true</value> , then   <step-list>
    <step>Let <id>A</id> be ? Construct ( <id>C</id> , « <id>len</id> »).</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>A</id> be ? ArrayCreate ( <id>len</id> ).</step>
  </step-list></step>
  <step>Let <id>k</id> be 0.</step>
  <step>Repeat, while <id>k</id> < <id>len</id>   <step-list>
    <step>Let <id>Pk</id> be ! ToString ( <id>k</id> ).</step>
    <step>Let <id>kValue</id> be ? Get ( <id>arrayLike</id> , <id>Pk</id> ).</step>
    <step>If <id>mapping</id> is <value>true</value> , then     <step-list>
      <step>Let <id>mappedValue</id> be ? Call ( <id>mapfn</id> , <id>T</id> , « <id>kValue</id> , <id>k</id> »).</step>
    </step-list></step>
    <step>Else, let <id>mappedValue</id> be <id>kValue</id> .</step>
    <step>Perform ? CreateDataPropertyOrThrow ( <id>A</id> , <id>Pk</id> , <id>mappedValue</id> ).</step>
    <step>Increase <id>k</id> by 1.</step>
  </step-list></step>
  <step>Perform ? Set ( <id>A</id> , <value>"length"</value> , <id>len</id> , <value>true</value> ).</step>
  <step>Return <id>A</id> .</step>
</step-list>
<step-list>
  <step>Return ? IsArray ( <id>arg</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>len</id> be the actual number of arguments passed to this function.</step>
  <step>Let <id>items</id> be the List of arguments passed to this function.</step>
  <step>Let <id>C</id> be the <value>this</value> value.</step>
  <step>If IsConstructor ( <id>C</id> ) is <value>true</value> , then   <step-list>
    <step>Let <id>A</id> be ? Construct ( <id>C</id> , « <id>len</id> »).</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>A</id> be ? ArrayCreate ( <id>len</id> ).</step>
  </step-list></step>
  <step>Let <id>k</id> be 0.</step>
  <step>Repeat, while <id>k</id> < <id>len</id>   <step-list>
    <step>Let <id>kValue</id> be <id>items</id> [ <id>k</id> ].</step>
    <step>Let <id>Pk</id> be ! ToString ( <id>k</id> ).</step>
    <step>Perform ? CreateDataPropertyOrThrow ( <id>A</id> , <id>Pk</id> , <id>kValue</id> ).</step>
    <step>Increase <id>k</id> by 1.</step>
  </step-list></step>
  <step>Perform ? Set ( <id>A</id> , <value>"length"</value> , <id>len</id> , <value>true</value> ).</step>
  <step>Return <id>A</id> .</step>
</step-list>
<step-list>
  <step>Return the <value>this</value> value.</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Let <id>A</id> be ? ArraySpeciesCreate ( <id>O</id> , 0).</step>
  <step>Let <id>n</id> be 0.</step>
  <step>Let <id>items</id> be a List whose first element is <id>O</id> and whose subsequent elements are, in left to right order, the arguments that were passed to this function invocation.</step>
  <step>Repeat, while <id>items</id> is not empty   <step-list>
    <step>Remove the first element from <id>items</id> and let <id>E</id> be the value of the element.</step>
    <step>Let <id>spreadable</id> be ? IsConcatSpreadable ( <id>E</id> ).</step>
    <step>If <id>spreadable</id> is <value>true</value> , then     <step-list>
      <step>Let <id>k</id> be 0.</step>
      <step>Let <id>len</id> be ? ToLength (? Get ( <id>E</id> , <value>"length"</value> )).</step>
      <step>If <id>n</id> + <id>len</id> > 2 53 -1, throw a <value>TypeError</value> exception.</step>
      <step>Repeat, while <id>k</id> < <id>len</id>       <step-list>
        <step>Let <id>P</id> be ! ToString ( <id>k</id> ).</step>
        <step>Let <id>exists</id> be ? HasProperty ( <id>E</id> , <id>P</id> ).</step>
        <step>If <id>exists</id> is <value>true</value> , then         <step-list>
          <step>Let <id>subElement</id> be ? Get ( <id>E</id> , <id>P</id> ).</step>
          <step>Perform ? CreateDataPropertyOrThrow ( <id>A</id> , ! ToString ( <id>n</id> ), <id>subElement</id> ).</step>
        </step-list></step>
        <step>Increase <id>n</id> by 1.</step>
        <step>Increase <id>k</id> by 1.</step>
      </step-list></step>
    </step-list></step>
    <step>Else <id>E</id> is added as a single item rather than spread,     <step-list>
      <step>If <id>n</id> ≥2 53 -1, throw a <value>TypeError</value> exception.</step>
      <step>Perform ? CreateDataPropertyOrThrow ( <id>A</id> , ! ToString ( <id>n</id> ), <id>E</id> ).</step>
      <step>Increase <id>n</id> by 1.</step>
    </step-list></step>
  </step-list></step>
  <step>Perform ? Set ( <id>A</id> , <value>"length"</value> , <id>n</id> , <value>true</value> ).</step>
  <step>Return <id>A</id> .</step>
</step-list>
<step-list>
  <step>If Type ( <id>O</id> ) is not Object, return <value>false</value> .</step>
  <step>Let <id>spreadable</id> be ? Get ( <id>O</id> , @@isConcatSpreadable).</step>
  <step>If <id>spreadable</id> is not <value>undefined</value> , return ToBoolean ( <id>spreadable</id> ).</step>
  <step>Return ? IsArray ( <id>O</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Let <id>len</id> be ? ToLength (? Get ( <id>O</id> , <value>"length"</value> )).</step>
  <step>Let <id>relativeTarget</id> be ? ToInteger ( <id>target</id> ).</step>
  <step>If <id>relativeTarget</id> < 0, let <id>to</id> be max (( <id>len</id> + <id>relativeTarget</id> ), 0); else let <id>to</id> be min ( <id>relativeTarget</id> , <id>len</id> ).</step>
  <step>Let <id>relativeStart</id> be ? ToInteger ( <id>start</id> ).</step>
  <step>If <id>relativeStart</id> < 0, let <id>from</id> be max (( <id>len</id> + <id>relativeStart</id> ), 0); else let <id>from</id> be min ( <id>relativeStart</id> , <id>len</id> ).</step>
  <step>If <id>end</id> is <value>undefined</value> , let <id>relativeEnd</id> be <id>len</id> ; else let <id>relativeEnd</id> be ? ToInteger ( <id>end</id> ).</step>
  <step>If <id>relativeEnd</id> < 0, let <id>final</id> be max (( <id>len</id> + <id>relativeEnd</id> ), 0); else let <id>final</id> be min ( <id>relativeEnd</id> , <id>len</id> ).</step>
  <step>Let <id>count</id> be min ( <id>final</id> - <id>from</id> , <id>len</id> - <id>to</id> ).</step>
  <step>If <id>from</id> < <id>to</id> and <id>to</id> < <id>from</id> + <id>count</id> , then   <step-list>
    <step>Let <id>direction</id> be -1.</step>
    <step>Let <id>from</id> be <id>from</id> + <id>count</id> - 1.</step>
    <step>Let <id>to</id> be <id>to</id> + <id>count</id> - 1.</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>direction</id> be 1.</step>
  </step-list></step>
  <step>Repeat, while <id>count</id> > 0   <step-list>
    <step>Let <id>fromKey</id> be ! ToString ( <id>from</id> ).</step>
    <step>Let <id>toKey</id> be ! ToString ( <id>to</id> ).</step>
    <step>Let <id>fromPresent</id> be ? HasProperty ( <id>O</id> , <id>fromKey</id> ).</step>
    <step>If <id>fromPresent</id> is <value>true</value> , then     <step-list>
      <step>Let <id>fromVal</id> be ? Get ( <id>O</id> , <id>fromKey</id> ).</step>
      <step>Perform ? Set ( <id>O</id> , <id>toKey</id> , <id>fromVal</id> , <value>true</value> ).</step>
    </step-list></step>
    <step>Else <id>fromPresent</id> is <value>false</value> ,     <step-list>
      <step>Perform ? DeletePropertyOrThrow ( <id>O</id> , <id>toKey</id> ).</step>
    </step-list></step>
    <step>Let <id>from</id> be <id>from</id> + <id>direction</id> .</step>
    <step>Let <id>to</id> be <id>to</id> + <id>direction</id> .</step>
    <step>Let <id>count</id> be <id>count</id> - 1.</step>
  </step-list></step>
  <step>Return <id>O</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Return CreateArrayIterator ( <id>O</id> , <value>"key+value"</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Let <id>len</id> be ? ToLength (? Get ( <id>O</id> , <value>"length"</value> )).</step>
  <step>If IsCallable ( <id>callbackfn</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>If <id>thisArg</id> is present, let <id>T</id> be <id>thisArg</id> ; else let <id>T</id> be <value>undefined</value> .</step>
  <step>Let <id>k</id> be 0.</step>
  <step>Repeat, while <id>k</id> < <id>len</id>   <step-list>
    <step>Let <id>Pk</id> be ! ToString ( <id>k</id> ).</step>
    <step>Let <id>kPresent</id> be ? HasProperty ( <id>O</id> , <id>Pk</id> ).</step>
    <step>If <id>kPresent</id> is <value>true</value> , then     <step-list>
      <step>Let <id>kValue</id> be ? Get ( <id>O</id> , <id>Pk</id> ).</step>
      <step>Let <id>testResult</id> be ToBoolean (? Call ( <id>callbackfn</id> , <id>T</id> , « <id>kValue</id> , <id>k</id> , <id>O</id> »)).</step>
      <step>If <id>testResult</id> is <value>false</value> , return <value>false</value> .</step>
    </step-list></step>
    <step>Increase <id>k</id> by 1.</step>
  </step-list></step>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Let <id>len</id> be ? ToLength (? Get ( <id>O</id> , <value>"length"</value> )).</step>
  <step>Let <id>relativeStart</id> be ? ToInteger ( <id>start</id> ).</step>
  <step>If <id>relativeStart</id> < 0, let <id>k</id> be max (( <id>len</id> + <id>relativeStart</id> ), 0); else let <id>k</id> be min ( <id>relativeStart</id> , <id>len</id> ).</step>
  <step>If <id>end</id> is <value>undefined</value> , let <id>relativeEnd</id> be <id>len</id> ; else let <id>relativeEnd</id> be ? ToInteger ( <id>end</id> ).</step>
  <step>If <id>relativeEnd</id> < 0, let <id>final</id> be max (( <id>len</id> + <id>relativeEnd</id> ), 0); else let <id>final</id> be min ( <id>relativeEnd</id> , <id>len</id> ).</step>
  <step>Repeat, while <id>k</id> < <id>final</id>   <step-list>
    <step>Let <id>Pk</id> be ! ToString ( <id>k</id> ).</step>
    <step>Perform ? Set ( <id>O</id> , <id>Pk</id> , <id>value</id> , <value>true</value> ).</step>
    <step>Increase <id>k</id> by 1.</step>
  </step-list></step>
  <step>Return <id>O</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Let <id>len</id> be ? ToLength (? Get ( <id>O</id> , <value>"length"</value> )).</step>
  <step>If IsCallable ( <id>callbackfn</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>If <id>thisArg</id> is present, let <id>T</id> be <id>thisArg</id> ; else let <id>T</id> be <value>undefined</value> .</step>
  <step>Let <id>A</id> be ? ArraySpeciesCreate ( <id>O</id> , 0).</step>
  <step>Let <id>k</id> be 0.</step>
  <step>Let <id>to</id> be 0.</step>
  <step>Repeat, while <id>k</id> < <id>len</id>   <step-list>
    <step>Let <id>Pk</id> be ! ToString ( <id>k</id> ).</step>
    <step>Let <id>kPresent</id> be ? HasProperty ( <id>O</id> , <id>Pk</id> ).</step>
    <step>If <id>kPresent</id> is <value>true</value> , then     <step-list>
      <step>Let <id>kValue</id> be ? Get ( <id>O</id> , <id>Pk</id> ).</step>
      <step>Let <id>selected</id> be ToBoolean (? Call ( <id>callbackfn</id> , <id>T</id> , « <id>kValue</id> , <id>k</id> , <id>O</id> »)).</step>
      <step>If <id>selected</id> is <value>true</value> , then       <step-list>
        <step>Perform ? CreateDataPropertyOrThrow ( <id>A</id> , ! ToString ( <id>to</id> ), <id>kValue</id> ).</step>
        <step>Increase <id>to</id> by 1.</step>
      </step-list></step>
    </step-list></step>
    <step>Increase <id>k</id> by 1.</step>
  </step-list></step>
  <step>Return <id>A</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Let <id>len</id> be ? ToLength (? Get ( <id>O</id> , <value>"length"</value> )).</step>
  <step>If IsCallable ( <id>predicate</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>If <id>thisArg</id> is present, let <id>T</id> be <id>thisArg</id> ; else let <id>T</id> be <value>undefined</value> .</step>
  <step>Let <id>k</id> be 0.</step>
  <step>Repeat, while <id>k</id> < <id>len</id>   <step-list>
    <step>Let <id>Pk</id> be ! ToString ( <id>k</id> ).</step>
    <step>Let <id>kValue</id> be ? Get ( <id>O</id> , <id>Pk</id> ).</step>
    <step>Let <id>testResult</id> be ToBoolean (? Call ( <id>predicate</id> , <id>T</id> , « <id>kValue</id> , <id>k</id> , <id>O</id> »)).</step>
    <step>If <id>testResult</id> is <value>true</value> , return <id>kValue</id> .</step>
    <step>Increase <id>k</id> by 1.</step>
  </step-list></step>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Let <id>len</id> be ? ToLength (? Get ( <id>O</id> , <value>"length"</value> )).</step>
  <step>If IsCallable ( <id>predicate</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>If <id>thisArg</id> is present, let <id>T</id> be <id>thisArg</id> ; else let <id>T</id> be <value>undefined</value> .</step>
  <step>Let <id>k</id> be 0.</step>
  <step>Repeat, while <id>k</id> < <id>len</id>   <step-list>
    <step>Let <id>Pk</id> be ! ToString ( <id>k</id> ).</step>
    <step>Let <id>kValue</id> be ? Get ( <id>O</id> , <id>Pk</id> ).</step>
    <step>Let <id>testResult</id> be ToBoolean (? Call ( <id>predicate</id> , <id>T</id> , « <id>kValue</id> , <id>k</id> , <id>O</id> »)).</step>
    <step>If <id>testResult</id> is <value>true</value> , return <id>k</id> .</step>
    <step>Increase <id>k</id> by 1.</step>
  </step-list></step>
  <step>Return -1.</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Let <id>len</id> be ? ToLength (? Get ( <id>O</id> , <value>"length"</value> )).</step>
  <step>If IsCallable ( <id>callbackfn</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>If <id>thisArg</id> is present, let <id>T</id> be <id>thisArg</id> ; else let <id>T</id> be <value>undefined</value> .</step>
  <step>Let <id>k</id> be 0.</step>
  <step>Repeat, while <id>k</id> < <id>len</id>   <step-list>
    <step>Let <id>Pk</id> be ! ToString ( <id>k</id> ).</step>
    <step>Let <id>kPresent</id> be ? HasProperty ( <id>O</id> , <id>Pk</id> ).</step>
    <step>If <id>kPresent</id> is <value>true</value> , then     <step-list>
      <step>Let <id>kValue</id> be ? Get ( <id>O</id> , <id>Pk</id> ).</step>
      <step>Perform ? Call ( <id>callbackfn</id> , <id>T</id> , « <id>kValue</id> , <id>k</id> , <id>O</id> »).</step>
    </step-list></step>
    <step>Increase <id>k</id> by 1.</step>
  </step-list></step>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Let <id>len</id> be ? ToLength (? Get ( <id>O</id> , <value>"length"</value> )).</step>
  <step>If <id>len</id> is 0, return <value>false</value> .</step>
  <step>Let <id>n</id> be ? ToInteger ( <id>fromIndex</id> ). (If <id>fromIndex</id> is <value>undefined</value> , this step produces the value 0.)</step>
  <step>If <id>n</id> ≥ 0, then   <step-list>
    <step>Let <id>k</id> be <id>n</id> .</step>
  </step-list></step>
  <step>Else <id>n</id> < 0,   <step-list>
    <step>Let <id>k</id> be <id>len</id> + <id>n</id> .</step>
    <step>If <id>k</id> < 0, let <id>k</id> be 0.</step>
  </step-list></step>
  <step>Repeat, while <id>k</id> < <id>len</id>   <step-list>
    <step>Let <id>elementK</id> be the result of ? Get ( <id>O</id> , ! ToString ( <id>k</id> )).</step>
    <step>If SameValueZero ( <id>searchElement</id> , <id>elementK</id> ) is <value>true</value> , return <value>true</value> .</step>
    <step>Increase <id>k</id> by 1.</step>
  </step-list></step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Let <id>len</id> be ? ToLength (? Get ( <id>O</id> , <value>"length"</value> )).</step>
  <step>If <id>len</id> is 0, return -1.</step>
  <step>Let <id>n</id> be ? ToInteger ( <id>fromIndex</id> ). (If <id>fromIndex</id> is <value>undefined</value> , this step produces the value 0.)</step>
  <step>If <id>n</id> ≥ <id>len</id> , return -1.</step>
  <step>If <id>n</id> ≥ 0, then   <step-list>
    <step>If <id>n</id> is <value>-0</value> , let <id>k</id> be <value>+0</value> ; else let <id>k</id> be <id>n</id> .</step>
  </step-list></step>
  <step>Else <id>n</id> < 0,   <step-list>
    <step>Let <id>k</id> be <id>len</id> + <id>n</id> .</step>
    <step>If <id>k</id> < 0, let <id>k</id> be 0.</step>
  </step-list></step>
  <step>Repeat, while <id>k</id> < <id>len</id>   <step-list>
    <step>Let <id>kPresent</id> be ? HasProperty ( <id>O</id> , ! ToString ( <id>k</id> )).</step>
    <step>If <id>kPresent</id> is <value>true</value> , then     <step-list>
      <step>Let <id>elementK</id> be ? Get ( <id>O</id> , ! ToString ( <id>k</id> )).</step>
      <step>Let <id>same</id> be the result of performing Strict Equality Comparison  <id>searchElement</id> === <id>elementK</id> .</step>
      <step>If <id>same</id> is <value>true</value> , return <id>k</id> .</step>
    </step-list></step>
    <step>Increase <id>k</id> by 1.</step>
  </step-list></step>
  <step>Return -1.</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Let <id>len</id> be ? ToLength (? Get ( <id>O</id> , <value>"length"</value> )).</step>
  <step>If <id>separator</id> is <value>undefined</value> , let <id>sep</id> be the single-element String <value>","</value> .</step>
  <step>Else, let <id>sep</id> be ? ToString ( <id>separator</id> ).</step>
  <step>Let <id>R</id> be the empty String.</step>
  <step>Let <id>k</id> be 0.</step>
  <step>Repeat, while <id>k</id> < <id>len</id>   <step-list>
    <step>If <id>k</id> > 0, let <id>R</id> be the string-concatenation of <id>R</id> and <id>sep</id> .</step>
    <step>Let <id>element</id> be ? Get ( <id>O</id> , ! ToString ( <id>k</id> )).</step>
    <step>If <id>element</id> is <value>undefined</value> or <value>null</value> , let <id>next</id> be the empty String; otherwise, let <id>next</id> be ? ToString ( <id>element</id> ).</step>
    <step>Set <id>R</id> to the string-concatenation of <id>R</id> and <id>next</id> .</step>
    <step>Increase <id>k</id> by 1.</step>
  </step-list></step>
  <step>Return <id>R</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Return CreateArrayIterator ( <id>O</id> , <value>"key"</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Let <id>len</id> be ? ToLength (? Get ( <id>O</id> , <value>"length"</value> )).</step>
  <step>If <id>len</id> is 0, return -1.</step>
  <step>If <id>fromIndex</id> is present, let <id>n</id> be ? ToInteger ( <id>fromIndex</id> ); else let <id>n</id> be <id>len</id> -1.</step>
  <step>If <id>n</id> ≥ 0, then   <step-list>
    <step>If <id>n</id> is <value>-0</value> , let <id>k</id> be <value>+0</value> ; else let <id>k</id> be min ( <id>n</id> , <id>len</id> - 1).</step>
  </step-list></step>
  <step>Else <id>n</id> < 0,   <step-list>
    <step>Let <id>k</id> be <id>len</id> + <id>n</id> .</step>
  </step-list></step>
  <step>Repeat, while <id>k</id> ≥ 0   <step-list>
    <step>Let <id>kPresent</id> be ? HasProperty ( <id>O</id> , ! ToString ( <id>k</id> )).</step>
    <step>If <id>kPresent</id> is <value>true</value> , then     <step-list>
      <step>Let <id>elementK</id> be ? Get ( <id>O</id> , ! ToString ( <id>k</id> )).</step>
      <step>Let <id>same</id> be the result of performing Strict Equality Comparison  <id>searchElement</id> === <id>elementK</id> .</step>
      <step>If <id>same</id> is <value>true</value> , return <id>k</id> .</step>
    </step-list></step>
    <step>Decrease <id>k</id> by 1.</step>
  </step-list></step>
  <step>Return -1.</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Let <id>len</id> be ? ToLength (? Get ( <id>O</id> , <value>"length"</value> )).</step>
  <step>If IsCallable ( <id>callbackfn</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>If <id>thisArg</id> is present, let <id>T</id> be <id>thisArg</id> ; else let <id>T</id> be <value>undefined</value> .</step>
  <step>Let <id>A</id> be ? ArraySpeciesCreate ( <id>O</id> , <id>len</id> ).</step>
  <step>Let <id>k</id> be 0.</step>
  <step>Repeat, while <id>k</id> < <id>len</id>   <step-list>
    <step>Let <id>Pk</id> be ! ToString ( <id>k</id> ).</step>
    <step>Let <id>kPresent</id> be ? HasProperty ( <id>O</id> , <id>Pk</id> ).</step>
    <step>If <id>kPresent</id> is <value>true</value> , then     <step-list>
      <step>Let <id>kValue</id> be ? Get ( <id>O</id> , <id>Pk</id> ).</step>
      <step>Let <id>mappedValue</id> be ? Call ( <id>callbackfn</id> , <id>T</id> , « <id>kValue</id> , <id>k</id> , <id>O</id> »).</step>
      <step>Perform ? CreateDataPropertyOrThrow ( <id>A</id> , <id>Pk</id> , <id>mappedValue</id> ).</step>
    </step-list></step>
    <step>Increase <id>k</id> by 1.</step>
  </step-list></step>
  <step>Return <id>A</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Let <id>len</id> be ? ToLength (? Get ( <id>O</id> , <value>"length"</value> )).</step>
  <step>If <id>len</id> is zero, then   <step-list>
    <step>Perform ? Set ( <id>O</id> , <value>"length"</value> , 0, <value>true</value> ).</step>
    <step>Return <value>undefined</value> .</step>
  </step-list></step>
  <step>Else <id>len</id> > 0,   <step-list>
    <step>Let <id>newLen</id> be <id>len</id> -1.</step>
    <step>Let <id>index</id> be ! ToString ( <id>newLen</id> ).</step>
    <step>Let <id>element</id> be ? Get ( <id>O</id> , <id>index</id> ).</step>
    <step>Perform ? DeletePropertyOrThrow ( <id>O</id> , <id>index</id> ).</step>
    <step>Perform ? Set ( <id>O</id> , <value>"length"</value> , <id>newLen</id> , <value>true</value> ).</step>
    <step>Return <id>element</id> .</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Let <id>len</id> be ? ToLength (? Get ( <id>O</id> , <value>"length"</value> )).</step>
  <step>Let <id>items</id> be a List whose elements are, in left to right order, the arguments that were passed to this function invocation.</step>
  <step>Let <id>argCount</id> be the number of elements in <id>items</id> .</step>
  <step>If <id>len</id> + <id>argCount</id> > 2 53 -1, throw a <value>TypeError</value> exception.</step>
  <step>Repeat, while <id>items</id> is not empty   <step-list>
    <step>Remove the first element from <id>items</id> and let <id>E</id> be the value of the element.</step>
    <step>Perform ? Set ( <id>O</id> , ! ToString ( <id>len</id> ), <id>E</id> , <value>true</value> ).</step>
    <step>Let <id>len</id> be <id>len</id> +1.</step>
  </step-list></step>
  <step>Perform ? Set ( <id>O</id> , <value>"length"</value> , <id>len</id> , <value>true</value> ).</step>
  <step>Return <id>len</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Let <id>len</id> be ? ToLength (? Get ( <id>O</id> , <value>"length"</value> )).</step>
  <step>If IsCallable ( <id>callbackfn</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>If <id>len</id> is 0 and <id>initialValue</id> is not present, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>k</id> be 0.</step>
  <step>Let <id>accumulator</id> be <value>undefined</value> .</step>
  <step>If <id>initialValue</id> is present, then   <step-list>
    <step>Set <id>accumulator</id> to <id>initialValue</id> .</step>
  </step-list></step>
  <step>Else <id>initialValue</id> is not present,   <step-list>
    <step>Let <id>kPresent</id> be <value>false</value> .</step>
    <step>Repeat, while <id>kPresent</id> is <value>false</value> and <id>k</id> < <id>len</id>     <step-list>
      <step>Let <id>Pk</id> be ! ToString ( <id>k</id> ).</step>
      <step>Let <id>kPresent</id> be ? HasProperty ( <id>O</id> , <id>Pk</id> ).</step>
      <step>If <id>kPresent</id> is <value>true</value> , then       <step-list>
        <step>Set <id>accumulator</id> to ? Get ( <id>O</id> , <id>Pk</id> ).</step>
      </step-list></step>
      <step>Increase <id>k</id> by 1.</step>
    </step-list></step>
    <step>If <id>kPresent</id> is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  </step-list></step>
  <step>Repeat, while <id>k</id> < <id>len</id>   <step-list>
    <step>Let <id>Pk</id> be ! ToString ( <id>k</id> ).</step>
    <step>Let <id>kPresent</id> be ? HasProperty ( <id>O</id> , <id>Pk</id> ).</step>
    <step>If <id>kPresent</id> is <value>true</value> , then     <step-list>
      <step>Let <id>kValue</id> be ? Get ( <id>O</id> , <id>Pk</id> ).</step>
      <step>Set <id>accumulator</id> to ? Call ( <id>callbackfn</id> , <value>undefined</value> , « <id>accumulator</id> , <id>kValue</id> , <id>k</id> , <id>O</id> »).</step>
    </step-list></step>
    <step>Increase <id>k</id> by 1.</step>
  </step-list></step>
  <step>Return <id>accumulator</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Let <id>len</id> be ? ToLength (? Get ( <id>O</id> , <value>"length"</value> )).</step>
  <step>If IsCallable ( <id>callbackfn</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>If <id>len</id> is 0 and <id>initialValue</id> is not present, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>k</id> be <id>len</id> -1.</step>
  <step>Let <id>accumulator</id> be <value>undefined</value> .</step>
  <step>If <id>initialValue</id> is present, then   <step-list>
    <step>Set <id>accumulator</id> to <id>initialValue</id> .</step>
  </step-list></step>
  <step>Else <id>initialValue</id> is not present,   <step-list>
    <step>Let <id>kPresent</id> be <value>false</value> .</step>
    <step>Repeat, while <id>kPresent</id> is <value>false</value> and <id>k</id> ≥ 0     <step-list>
      <step>Let <id>Pk</id> be ! ToString ( <id>k</id> ).</step>
      <step>Let <id>kPresent</id> be ? HasProperty ( <id>O</id> , <id>Pk</id> ).</step>
      <step>If <id>kPresent</id> is <value>true</value> , then       <step-list>
        <step>Set <id>accumulator</id> to ? Get ( <id>O</id> , <id>Pk</id> ).</step>
      </step-list></step>
      <step>Decrease <id>k</id> by 1.</step>
    </step-list></step>
    <step>If <id>kPresent</id> is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  </step-list></step>
  <step>Repeat, while <id>k</id> ≥ 0   <step-list>
    <step>Let <id>Pk</id> be ! ToString ( <id>k</id> ).</step>
    <step>Let <id>kPresent</id> be ? HasProperty ( <id>O</id> , <id>Pk</id> ).</step>
    <step>If <id>kPresent</id> is <value>true</value> , then     <step-list>
      <step>Let <id>kValue</id> be ? Get ( <id>O</id> , <id>Pk</id> ).</step>
      <step>Set <id>accumulator</id> to ? Call ( <id>callbackfn</id> , <value>undefined</value> , « <id>accumulator</id> , <id>kValue</id> , <id>k</id> , <id>O</id> »).</step>
    </step-list></step>
    <step>Decrease <id>k</id> by 1.</step>
  </step-list></step>
  <step>Return <id>accumulator</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Let <id>len</id> be ? ToLength (? Get ( <id>O</id> , <value>"length"</value> )).</step>
  <step>Let <id>middle</id> be floor ( <id>len</id> /2).</step>
  <step>Let <id>lower</id> be 0.</step>
  <step>Repeat, while <id>lower</id> ≠ <id>middle</id>   <step-list>
    <step>Let <id>upper</id> be <id>len</id> - <id>lower</id> - 1.</step>
    <step>Let <id>upperP</id> be ! ToString ( <id>upper</id> ).</step>
    <step>Let <id>lowerP</id> be ! ToString ( <id>lower</id> ).</step>
    <step>Let <id>lowerExists</id> be ? HasProperty ( <id>O</id> , <id>lowerP</id> ).</step>
    <step>If <id>lowerExists</id> is <value>true</value> , then     <step-list>
      <step>Let <id>lowerValue</id> be ? Get ( <id>O</id> , <id>lowerP</id> ).</step>
    </step-list></step>
    <step>Let <id>upperExists</id> be ? HasProperty ( <id>O</id> , <id>upperP</id> ).</step>
    <step>If <id>upperExists</id> is <value>true</value> , then     <step-list>
      <step>Let <id>upperValue</id> be ? Get ( <id>O</id> , <id>upperP</id> ).</step>
    </step-list></step>
    <step>If <id>lowerExists</id> is <value>true</value> and <id>upperExists</id> is <value>true</value> , then     <step-list>
      <step>Perform ? Set ( <id>O</id> , <id>lowerP</id> , <id>upperValue</id> , <value>true</value> ).</step>
      <step>Perform ? Set ( <id>O</id> , <id>upperP</id> , <id>lowerValue</id> , <value>true</value> ).</step>
    </step-list></step>
    <step>Else if <id>lowerExists</id> is <value>false</value> and <id>upperExists</id> is <value>true</value> , then     <step-list>
      <step>Perform ? Set ( <id>O</id> , <id>lowerP</id> , <id>upperValue</id> , <value>true</value> ).</step>
      <step>Perform ? DeletePropertyOrThrow ( <id>O</id> , <id>upperP</id> ).</step>
    </step-list></step>
    <step>Else if <id>lowerExists</id> is <value>true</value> and <id>upperExists</id> is <value>false</value> , then     <step-list>
      <step>Perform ? DeletePropertyOrThrow ( <id>O</id> , <id>lowerP</id> ).</step>
      <step>Perform ? Set ( <id>O</id> , <id>upperP</id> , <id>lowerValue</id> , <value>true</value> ).</step>
    </step-list></step>
    <step>Else both <id>lowerExists</id> and <id>upperExists</id> are <value>false</value> ,     <step-list>
      <step>No action is required.</step>
    </step-list></step>
    <step>Increase <id>lower</id> by 1.</step>
  </step-list></step>
  <step>Return <id>O</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Let <id>len</id> be ? ToLength (? Get ( <id>O</id> , <value>"length"</value> )).</step>
  <step>If <id>len</id> is zero, then   <step-list>
    <step>Perform ? Set ( <id>O</id> , <value>"length"</value> , 0, <value>true</value> ).</step>
    <step>Return <value>undefined</value> .</step>
  </step-list></step>
  <step>Let <id>first</id> be ? Get ( <id>O</id> , <value>"0"</value> ).</step>
  <step>Let <id>k</id> be 1.</step>
  <step>Repeat, while <id>k</id> < <id>len</id>   <step-list>
    <step>Let <id>from</id> be ! ToString ( <id>k</id> ).</step>
    <step>Let <id>to</id> be ! ToString ( <id>k</id> -1).</step>
    <step>Let <id>fromPresent</id> be ? HasProperty ( <id>O</id> , <id>from</id> ).</step>
    <step>If <id>fromPresent</id> is <value>true</value> , then     <step-list>
      <step>Let <id>fromVal</id> be ? Get ( <id>O</id> , <id>from</id> ).</step>
      <step>Perform ? Set ( <id>O</id> , <id>to</id> , <id>fromVal</id> , <value>true</value> ).</step>
    </step-list></step>
    <step>Else <id>fromPresent</id> is <value>false</value> ,     <step-list>
      <step>Perform ? DeletePropertyOrThrow ( <id>O</id> , <id>to</id> ).</step>
    </step-list></step>
    <step>Increase <id>k</id> by 1.</step>
  </step-list></step>
  <step>Perform ? DeletePropertyOrThrow ( <id>O</id> , ! ToString ( <id>len</id> -1)).</step>
  <step>Perform ? Set ( <id>O</id> , <value>"length"</value> , <id>len</id> -1, <value>true</value> ).</step>
  <step>Return <id>first</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Let <id>len</id> be ? ToLength (? Get ( <id>O</id> , <value>"length"</value> )).</step>
  <step>Let <id>relativeStart</id> be ? ToInteger ( <id>start</id> ).</step>
  <step>If <id>relativeStart</id> < 0, let <id>k</id> be max (( <id>len</id> + <id>relativeStart</id> ), 0); else let <id>k</id> be min ( <id>relativeStart</id> , <id>len</id> ).</step>
  <step>If <id>end</id> is <value>undefined</value> , let <id>relativeEnd</id> be <id>len</id> ; else let <id>relativeEnd</id> be ? ToInteger ( <id>end</id> ).</step>
  <step>If <id>relativeEnd</id> < 0, let <id>final</id> be max (( <id>len</id> + <id>relativeEnd</id> ), 0); else let <id>final</id> be min ( <id>relativeEnd</id> , <id>len</id> ).</step>
  <step>Let <id>count</id> be max ( <id>final</id> - <id>k</id> , 0).</step>
  <step>Let <id>A</id> be ? ArraySpeciesCreate ( <id>O</id> , <id>count</id> ).</step>
  <step>Let <id>n</id> be 0.</step>
  <step>Repeat, while <id>k</id> < <id>final</id>   <step-list>
    <step>Let <id>Pk</id> be ! ToString ( <id>k</id> ).</step>
    <step>Let <id>kPresent</id> be ? HasProperty ( <id>O</id> , <id>Pk</id> ).</step>
    <step>If <id>kPresent</id> is <value>true</value> , then     <step-list>
      <step>Let <id>kValue</id> be ? Get ( <id>O</id> , <id>Pk</id> ).</step>
      <step>Perform ? CreateDataPropertyOrThrow ( <id>A</id> , ! ToString ( <id>n</id> ), <id>kValue</id> ).</step>
    </step-list></step>
    <step>Increase <id>k</id> by 1.</step>
    <step>Increase <id>n</id> by 1.</step>
  </step-list></step>
  <step>Perform ? Set ( <id>A</id> , <value>"length"</value> , <id>n</id> , <value>true</value> ).</step>
  <step>Return <id>A</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Let <id>len</id> be ? ToLength (? Get ( <id>O</id> , <value>"length"</value> )).</step>
  <step>If IsCallable ( <id>callbackfn</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>If <id>thisArg</id> is present, let <id>T</id> be <id>thisArg</id> ; else let <id>T</id> be <value>undefined</value> .</step>
  <step>Let <id>k</id> be 0.</step>
  <step>Repeat, while <id>k</id> < <id>len</id>   <step-list>
    <step>Let <id>Pk</id> be ! ToString ( <id>k</id> ).</step>
    <step>Let <id>kPresent</id> be ? HasProperty ( <id>O</id> , <id>Pk</id> ).</step>
    <step>If <id>kPresent</id> is <value>true</value> , then     <step-list>
      <step>Let <id>kValue</id> be ? Get ( <id>O</id> , <id>Pk</id> ).</step>
      <step>Let <id>testResult</id> be ToBoolean (? Call ( <id>callbackfn</id> , <id>T</id> , « <id>kValue</id> , <id>k</id> , <id>O</id> »)).</step>
      <step>If <id>testResult</id> is <value>true</value> , return <value>true</value> .</step>
    </step-list></step>
    <step>Increase <id>k</id> by 1.</step>
  </step-list></step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If <id>comparefn</id> is not <value>undefined</value> and IsCallable ( <id>comparefn</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>obj</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Let <id>len</id> be ? ToLength (? Get ( <id>obj</id> , <value>"length"</value> )).</step>
</step-list>
<step-list>
  <step>For each integer <id>i</id> in the range 0≤ <id>i</id> < <id>len</id> , do   <step-list>
    <step>Let <id>elem</id> be <id>obj</id> .[[GetOwnProperty]](! ToString ( <id>i</id> )).</step>
    <step>If <id>elem</id> is <value>undefined</value> , return <value>true</value> .</step>
  </step-list></step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Perform an implementation-dependent sequence of calls to the [[Get]] and [[Set]] internal methods of <id>obj</id> , to the DeletePropertyOrThrow and HasOwnProperty abstract operation with <id>obj</id> as the first argument, and to SortCompare (described below), such that: The property key argument for each call to [[Get]], [[Set]], HasOwnProperty, or DeletePropertyOrThrow is the string representation of a nonnegative integer less than len.
The arguments for calls to SortCompare are values returned by a previous call to the [[Get]] internal method, unless the properties accessed by those previous calls did not exist according to HasOwnProperty. If both prospective arguments to SortCompare correspond to non-existent properties, use +0 instead of calling SortCompare. If only the first prospective argument is non-existent use +1. If only the second prospective argument is non-existent use -1.
If obj is not sparse then DeletePropertyOrThrow must not be called.
If any [[Set]] call returns false a TypeError exception is thrown.
If an abrupt completion is returned from any of these operations, it is immediately returned as the value of this function.</step>
  <step>Return <id>obj</id> .</step>
</step-list>
<step-list>
  <step>If <id>x</id> and <id>y</id> are both <value>undefined</value> , return <value>+0</value> .</step>
  <step>If <id>x</id> is <value>undefined</value> , return 1.</step>
  <step>If <id>y</id> is <value>undefined</value> , return -1.</step>
  <step>If <id>comparefn</id> is not <value>undefined</value> , then   <step-list>
    <step>Let <id>v</id> be ? ToNumber (? Call ( <id>comparefn</id> , <value>undefined</value> , « <id>x</id> , <id>y</id> »)).</step>
    <step>If <id>v</id> is <value>NaN</value> , return <value>+0</value> .</step>
    <step>Return <id>v</id> .</step>
  </step-list></step>
  <step>Let <id>xString</id> be ? ToString ( <id>x</id> ).</step>
  <step>Let <id>yString</id> be ? ToString ( <id>y</id> ).</step>
  <step>Let <id>xSmaller</id> be the result of performing Abstract Relational Comparison  <id>xString</id> < <id>yString</id> .</step>
  <step>If <id>xSmaller</id> is <value>true</value> , return -1.</step>
  <step>Let <id>ySmaller</id> be the result of performing Abstract Relational Comparison  <id>yString</id> < <id>xString</id> .</step>
  <step>If <id>ySmaller</id> is <value>true</value> , return 1.</step>
  <step>Return <value>+0</value> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Let <id>len</id> be ? ToLength (? Get ( <id>O</id> , <value>"length"</value> )).</step>
  <step>Let <id>relativeStart</id> be ? ToInteger ( <id>start</id> ).</step>
  <step>If <id>relativeStart</id> < 0, let <id>actualStart</id> be max (( <id>len</id> + <id>relativeStart</id> ), 0); else let <id>actualStart</id> be min ( <id>relativeStart</id> , <id>len</id> ).</step>
  <step>If the number of actual arguments is 0, then   <step-list>
    <step>Let <id>insertCount</id> be 0.</step>
    <step>Let <id>actualDeleteCount</id> be 0.</step>
  </step-list></step>
  <step>Else if the number of actual arguments is 1, then   <step-list>
    <step>Let <id>insertCount</id> be 0.</step>
    <step>Let <id>actualDeleteCount</id> be <id>len</id> - <id>actualStart</id> .</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>insertCount</id> be the number of actual arguments minus 2.</step>
    <step>Let <id>dc</id> be ? ToInteger ( <id>deleteCount</id> ).</step>
    <step>Let <id>actualDeleteCount</id> be min ( max ( <id>dc</id> , 0), <id>len</id> - <id>actualStart</id> ).</step>
  </step-list></step>
  <step>If <id>len</id> + <id>insertCount</id> - <id>actualDeleteCount</id> > 2 53 -1, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>A</id> be ? ArraySpeciesCreate ( <id>O</id> , <id>actualDeleteCount</id> ).</step>
  <step>Let <id>k</id> be 0.</step>
  <step>Repeat, while <id>k</id> < <id>actualDeleteCount</id>   <step-list>
    <step>Let <id>from</id> be ! ToString ( <id>actualStart</id> + <id>k</id> ).</step>
    <step>Let <id>fromPresent</id> be ? HasProperty ( <id>O</id> , <id>from</id> ).</step>
    <step>If <id>fromPresent</id> is <value>true</value> , then     <step-list>
      <step>Let <id>fromValue</id> be ? Get ( <id>O</id> , <id>from</id> ).</step>
      <step>Perform ? CreateDataPropertyOrThrow ( <id>A</id> , ! ToString ( <id>k</id> ), <id>fromValue</id> ).</step>
    </step-list></step>
    <step>Increment <id>k</id> by 1.</step>
  </step-list></step>
  <step>Perform ? Set ( <id>A</id> , <value>"length"</value> , <id>actualDeleteCount</id> , <value>true</value> ).</step>
  <step>Let <id>items</id> be a List whose elements are, in left to right order, the portion of the actual 
argument list starting with the third argument. The list is empty if 
fewer than three arguments were passed.</step>
  <step>Let <id>itemCount</id> be the number of elements in <id>items</id> .</step>
  <step>If <id>itemCount</id> < <id>actualDeleteCount</id> , then   <step-list>
    <step>Let <id>k</id> be <id>actualStart</id> .</step>
    <step>Repeat, while <id>k</id> < ( <id>len</id> - <id>actualDeleteCount</id> )     <step-list>
      <step>Let <id>from</id> be ! ToString ( <id>k</id> + <id>actualDeleteCount</id> ).</step>
      <step>Let <id>to</id> be ! ToString ( <id>k</id> + <id>itemCount</id> ).</step>
      <step>Let <id>fromPresent</id> be ? HasProperty ( <id>O</id> , <id>from</id> ).</step>
      <step>If <id>fromPresent</id> is <value>true</value> , then       <step-list>
        <step>Let <id>fromValue</id> be ? Get ( <id>O</id> , <id>from</id> ).</step>
        <step>Perform ? Set ( <id>O</id> , <id>to</id> , <id>fromValue</id> , <value>true</value> ).</step>
      </step-list></step>
      <step>Else <id>fromPresent</id> is <value>false</value> ,       <step-list>
        <step>Perform ? DeletePropertyOrThrow ( <id>O</id> , <id>to</id> ).</step>
      </step-list></step>
      <step>Increase <id>k</id> by 1.</step>
    </step-list></step>
    <step>Let <id>k</id> be <id>len</id> .</step>
    <step>Repeat, while <id>k</id> > ( <id>len</id> - <id>actualDeleteCount</id> + <id>itemCount</id> )     <step-list>
      <step>Perform ? DeletePropertyOrThrow ( <id>O</id> , ! ToString ( <id>k</id> -1)).</step>
      <step>Decrease <id>k</id> by 1.</step>
    </step-list></step>
  </step-list></step>
  <step>Else if <id>itemCount</id> > <id>actualDeleteCount</id> , then   <step-list>
    <step>Let <id>k</id> be ( <id>len</id> - <id>actualDeleteCount</id> ).</step>
    <step>Repeat, while <id>k</id> > <id>actualStart</id>     <step-list>
      <step>Let <id>from</id> be ! ToString ( <id>k</id> + <id>actualDeleteCount</id> - 1).</step>
      <step>Let <id>to</id> be ! ToString ( <id>k</id> + <id>itemCount</id> - 1).</step>
      <step>Let <id>fromPresent</id> be ? HasProperty ( <id>O</id> , <id>from</id> ).</step>
      <step>If <id>fromPresent</id> is <value>true</value> , then       <step-list>
        <step>Let <id>fromValue</id> be ? Get ( <id>O</id> , <id>from</id> ).</step>
        <step>Perform ? Set ( <id>O</id> , <id>to</id> , <id>fromValue</id> , <value>true</value> ).</step>
      </step-list></step>
      <step>Else <id>fromPresent</id> is <value>false</value> ,       <step-list>
        <step>Perform ? DeletePropertyOrThrow ( <id>O</id> , <id>to</id> ).</step>
      </step-list></step>
      <step>Decrease <id>k</id> by 1.</step>
    </step-list></step>
  </step-list></step>
  <step>Let <id>k</id> be <id>actualStart</id> .</step>
  <step>Repeat, while <id>items</id> is not empty   <step-list>
    <step>Remove the first element from <id>items</id> and let <id>E</id> be the value of that element.</step>
    <step>Perform ? Set ( <id>O</id> , ! ToString ( <id>k</id> ), <id>E</id> , <value>true</value> ).</step>
    <step>Increase <id>k</id> by 1.</step>
  </step-list></step>
  <step>Perform ? Set ( <id>O</id> , <value>"length"</value> , <id>len</id> - <id>actualDeleteCount</id> + <id>itemCount</id> , <value>true</value> ).</step>
  <step>Return <id>A</id> .</step>
</step-list>
<step-list>
  <step>Let <id>array</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Let <id>len</id> be ? ToLength (? Get ( <id>array</id> , <value>"length"</value> )).</step>
  <step>Let <id>separator</id> be the String value for the list-separator String appropriate for the 
host environment's current locale (this is derived in an 
implementation-defined way).</step>
  <step>Let <id>R</id> be the empty String.</step>
  <step>Let <id>k</id> be 0.</step>
  <step>Repeat, while <id>k</id> < <id>len</id>   <step-list>
    <step>If <id>k</id> > 0, then     <step-list>
      <step>Set <id>R</id> to the string-concatenation of <id>R</id> and <id>separator</id> .</step>
    </step-list></step>
    <step>Let <id>nextElement</id> be ? Get ( <id>array</id> , ! ToString ( <id>k</id> )).</step>
    <step>If <id>nextElement</id> is not <value>undefined</value> or <value>null</value> , then     <step-list>
      <step>Let <id>S</id> be ? ToString (? Invoke ( <id>nextElement</id> , <value>"toLocaleString"</value> )).</step>
      <step>Set <id>R</id> to the string-concatenation of <id>R</id> and <id>S</id> .</step>
    </step-list></step>
    <step>Increase <id>k</id> by 1.</step>
  </step-list></step>
  <step>Return <id>R</id> .</step>
</step-list>
<step-list>
  <step>Let <id>array</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Let <id>func</id> be ? Get ( <id>array</id> , <value>"join"</value> ).</step>
  <step>If IsCallable ( <id>func</id> ) is <value>false</value> , let <id>func</id> be the intrinsic function %ObjProto_toString% .</step>
  <step>Return ? Call ( <id>func</id> , <id>array</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Let <id>len</id> be ? ToLength (? Get ( <id>O</id> , <value>"length"</value> )).</step>
  <step>Let <id>argCount</id> be the number of actual arguments.</step>
  <step>If <id>argCount</id> > 0, then   <step-list>
    <step>If <id>len</id> + <id>argCount</id> > 2 53 -1, throw a <value>TypeError</value> exception.</step>
    <step>Let <id>k</id> be <id>len</id> .</step>
    <step>Repeat, while <id>k</id> > 0,     <step-list>
      <step>Let <id>from</id> be ! ToString ( <id>k</id> -1).</step>
      <step>Let <id>to</id> be ! ToString ( <id>k</id> + <id>argCount</id> -1).</step>
      <step>Let <id>fromPresent</id> be ? HasProperty ( <id>O</id> , <id>from</id> ).</step>
      <step>If <id>fromPresent</id> is <value>true</value> , then       <step-list>
        <step>Let <id>fromValue</id> be ? Get ( <id>O</id> , <id>from</id> ).</step>
        <step>Perform ? Set ( <id>O</id> , <id>to</id> , <id>fromValue</id> , <value>true</value> ).</step>
      </step-list></step>
      <step>Else <id>fromPresent</id> is <value>false</value> ,       <step-list>
        <step>Perform ? DeletePropertyOrThrow ( <id>O</id> , <id>to</id> ).</step>
      </step-list></step>
      <step>Decrease <id>k</id> by 1.</step>
    </step-list></step>
    <step>Let <id>j</id> be 0.</step>
    <step>Let <id>items</id> be a List whose elements are, in left to right order, the arguments that were passed to this function invocation.</step>
    <step>Repeat, while <id>items</id> is not empty     <step-list>
      <step>Remove the first element from <id>items</id> and let <id>E</id> be the value of that element.</step>
      <step>Perform ? Set ( <id>O</id> , ! ToString ( <id>j</id> ), <id>E</id> , <value>true</value> ).</step>
      <step>Increase <id>j</id> by 1.</step>
    </step-list></step>
  </step-list></step>
  <step>Perform ? Set ( <id>O</id> , <value>"length"</value> , <id>len</id> + <id>argCount</id> , <value>true</value> ).</step>
  <step>Return <id>len</id> + <id>argCount</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Return CreateArrayIterator ( <id>O</id> , <value>"value"</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>unscopableList</id> be ObjectCreate ( <value>null</value> ).</step>
  <step>Perform CreateDataProperty ( <id>unscopableList</id> , <value>"copyWithin"</value> , <value>true</value> ).</step>
  <step>Perform CreateDataProperty ( <id>unscopableList</id> , <value>"entries"</value> , <value>true</value> ).</step>
  <step>Perform CreateDataProperty ( <id>unscopableList</id> , <value>"fill"</value> , <value>true</value> ).</step>
  <step>Perform CreateDataProperty ( <id>unscopableList</id> , <value>"find"</value> , <value>true</value> ).</step>
  <step>Perform CreateDataProperty ( <id>unscopableList</id> , <value>"findIndex"</value> , <value>true</value> ).</step>
  <step>Perform CreateDataProperty ( <id>unscopableList</id> , <value>"includes"</value> , <value>true</value> ).</step>
  <step>Perform CreateDataProperty ( <id>unscopableList</id> , <value>"keys"</value> , <value>true</value> ).</step>
  <step>Perform CreateDataProperty ( <id>unscopableList</id> , <value>"values"</value> , <value>true</value> ).</step>
  <step>Assert : Each of the above calls will return <value>true</value> .</step>
  <step>Return <id>unscopableList</id> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>array</id> ) is Object.</step>
  <step>Let <id>iterator</id> be ObjectCreate ( %ArrayIteratorPrototype% , « [[IteratedObject]], [[ArrayIteratorNextIndex]], [[ArrayIterationKind]] »).</step>
  <step>Set <id>iterator</id> .[[IteratedObject]] to <id>array</id> .</step>
  <step>Set <id>iterator</id> .[[ArrayIteratorNextIndex]] to 0.</step>
  <step>Set <id>iterator</id> .[[ArrayIterationKind]] to <id>kind</id> .</step>
  <step>Return <id>iterator</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>O</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>O</id> does not have all of the internal slots of an Array Iterator Instance ( 22.1.5.3 ), throw a <value>TypeError</value> exception.</step>
  <step>Let <id>a</id> be <id>O</id> .[[IteratedObject]].</step>
  <step>If <id>a</id> is <value>undefined</value> , return CreateIterResultObject ( <value>undefined</value> , <value>true</value> ).</step>
  <step>Let <id>index</id> be <id>O</id> .[[ArrayIteratorNextIndex]].</step>
  <step>Let <id>itemKind</id> be <id>O</id> .[[ArrayIterationKind]].</step>
  <step>If <id>a</id> has a [[TypedArrayName]] internal slot, then   <step-list>
    <step>If IsDetachedBuffer ( <id>a</id> .[[ViewedArrayBuffer]]) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
    <step>Let <id>len</id> be <id>a</id> .[[ArrayLength]].</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>len</id> be ? ToLength (? Get ( <id>a</id> , <value>"length"</value> )).</step>
  </step-list></step>
  <step>If <id>index</id> ≥ <id>len</id> , then   <step-list>
    <step>Set <id>O</id> .[[IteratedObject]] to <value>undefined</value> .</step>
    <step>Return CreateIterResultObject ( <value>undefined</value> , <value>true</value> ).</step>
  </step-list></step>
  <step>Set <id>O</id> .[[ArrayIteratorNextIndex]] to <id>index</id> +1.</step>
  <step>If <id>itemKind</id> is <value>"key"</value> , return CreateIterResultObject ( <id>index</id> , <value>false</value> ).</step>
  <step>Let <id>elementKey</id> be ! ToString ( <id>index</id> ).</step>
  <step>Let <id>elementValue</id> be ? Get ( <id>a</id> , <id>elementKey</id> ).</step>
  <step>If <id>itemKind</id> is <value>"value"</value> , let <id>result</id> be <id>elementValue</id> .</step>
  <step>Else,   <step-list>
    <step>Assert : <id>itemKind</id> is <value>"key+value"</value> .</step>
    <step>Let <id>result</id> be CreateArrayFromList (« <id>index</id> , <id>elementValue</id> »).</step>
  </step-list></step>
  <step>Return CreateIterResultObject ( <id>result</id> , <value>false</value> ).</step>
</step-list>
<step-list>
  <step>Throw a <value>TypeError</value> exception.</step>
</step-list>
<step-list>
  <step>Let <id>C</id> be the <value>this</value> value.</step>
  <step>If IsConstructor ( <id>C</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>If <id>mapfn</id> is present and <id>mapfn</id> is not <value>undefined</value> , then   <step-list>
    <step>If IsCallable ( <id>mapfn</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
    <step>Let <id>mapping</id> be <value>true</value> .</step>
  </step-list></step>
  <step>Else, let <id>mapping</id> be <value>false</value> .</step>
  <step>If <id>thisArg</id> is present, let <id>T</id> be <id>thisArg</id> ; else let <id>T</id> be <value>undefined</value> .</step>
  <step>Let <id>usingIterator</id> be ? GetMethod ( <id>source</id> , @@iterator).</step>
  <step>If <id>usingIterator</id> is not <value>undefined</value> , then   <step-list>
    <step>Let <id>values</id> be ? IterableToList ( <id>source</id> , <id>usingIterator</id> ).</step>
    <step>Let <id>len</id> be the number of elements in <id>values</id> .</step>
    <step>Let <id>targetObj</id> be ? TypedArrayCreate ( <id>C</id> , « <id>len</id> »).</step>
    <step>Let <id>k</id> be 0.</step>
    <step>Repeat, while <id>k</id> < <id>len</id>     <step-list>
      <step>Let <id>Pk</id> be ! ToString ( <id>k</id> ).</step>
      <step>Let <id>kValue</id> be the first element of <id>values</id> and remove that element from <id>values</id> .</step>
      <step>If <id>mapping</id> is <value>true</value> , then       <step-list>
        <step>Let <id>mappedValue</id> be ? Call ( <id>mapfn</id> , <id>T</id> , « <id>kValue</id> , <id>k</id> »).</step>
      </step-list></step>
      <step>Else, let <id>mappedValue</id> be <id>kValue</id> .</step>
      <step>Perform ? Set ( <id>targetObj</id> , <id>Pk</id> , <id>mappedValue</id> , <value>true</value> ).</step>
      <step>Increase <id>k</id> by 1.</step>
    </step-list></step>
    <step>Assert : <id>values</id> is now an empty List .</step>
    <step>Return <id>targetObj</id> .</step>
  </step-list></step>
  <step>NOTE: <id>source</id> is not an Iterable so assume it is already an array-like object.</step>
  <step>Let <id>arrayLike</id> be ! ToObject ( <id>source</id> ).</step>
  <step>Let <id>len</id> be ? ToLength (? Get ( <id>arrayLike</id> , <value>"length"</value> )).</step>
  <step>Let <id>targetObj</id> be ? TypedArrayCreate ( <id>C</id> , « <id>len</id> »).</step>
  <step>Let <id>k</id> be 0.</step>
  <step>Repeat, while <id>k</id> < <id>len</id>   <step-list>
    <step>Let <id>Pk</id> be ! ToString ( <id>k</id> ).</step>
    <step>Let <id>kValue</id> be ? Get ( <id>arrayLike</id> , <id>Pk</id> ).</step>
    <step>If <id>mapping</id> is <value>true</value> , then     <step-list>
      <step>Let <id>mappedValue</id> be ? Call ( <id>mapfn</id> , <id>T</id> , « <id>kValue</id> , <id>k</id> »).</step>
    </step-list></step>
    <step>Else, let <id>mappedValue</id> be <id>kValue</id> .</step>
    <step>Perform ? Set ( <id>targetObj</id> , <id>Pk</id> , <id>mappedValue</id> , <value>true</value> ).</step>
    <step>Increase <id>k</id> by 1.</step>
  </step-list></step>
  <step>Return <id>targetObj</id> .</step>
</step-list>
<step-list>
  <step>Let <id>iteratorRecord</id> be ? GetIterator ( <id>items</id> , <value>sync</value> , <id>method</id> ).</step>
  <step>Let <id>values</id> be a new empty List .</step>
  <step>Let <id>next</id> be <value>true</value> .</step>
  <step>Repeat, while <id>next</id> is not <value>false</value>   <step-list>
    <step>Set <id>next</id> to ? IteratorStep ( <id>iteratorRecord</id> ).</step>
    <step>If <id>next</id> is not <value>false</value> , then     <step-list>
      <step>Let <id>nextValue</id> be ? IteratorValue ( <id>next</id> ).</step>
      <step>Append <id>nextValue</id> to the end of the List  <id>values</id> .</step>
    </step-list></step>
  </step-list></step>
  <step>Return <id>values</id> .</step>
</step-list>
<step-list>
  <step>Let <id>len</id> be the actual number of arguments passed to this function.</step>
  <step>Let <id>items</id> be the List of arguments passed to this function.</step>
  <step>Let <id>C</id> be the <value>this</value> value.</step>
  <step>If IsConstructor ( <id>C</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>newObj</id> be ? TypedArrayCreate ( <id>C</id> , « <id>len</id> »).</step>
  <step>Let <id>k</id> be 0.</step>
  <step>Repeat, while <id>k</id> < <id>len</id>   <step-list>
    <step>Let <id>kValue</id> be <id>items</id> [ <id>k</id> ].</step>
    <step>Let <id>Pk</id> be ! ToString ( <id>k</id> ).</step>
    <step>Perform ? Set ( <id>newObj</id> , <id>Pk</id> , <id>kValue</id> , <value>true</value> ).</step>
    <step>Increase <id>k</id> by 1.</step>
  </step-list></step>
  <step>Return <id>newObj</id> .</step>
</step-list>
<step-list>
  <step>Return the <value>this</value> value.</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>O</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>O</id> does not have a [[TypedArrayName]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Assert : <id>O</id> has a [[ViewedArrayBuffer]] internal slot.</step>
  <step>Let <id>buffer</id> be <id>O</id> .[[ViewedArrayBuffer]].</step>
  <step>Return <id>buffer</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>O</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>O</id> does not have a [[TypedArrayName]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Assert : <id>O</id> has a [[ViewedArrayBuffer]] internal slot.</step>
  <step>Let <id>buffer</id> be <id>O</id> .[[ViewedArrayBuffer]].</step>
  <step>If IsDetachedBuffer ( <id>buffer</id> ) is <value>true</value> , return 0.</step>
  <step>Let <id>size</id> be <id>O</id> .[[ByteLength]].</step>
  <step>Return <id>size</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>O</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>O</id> does not have a [[TypedArrayName]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Assert : <id>O</id> has a [[ViewedArrayBuffer]] internal slot.</step>
  <step>Let <id>buffer</id> be <id>O</id> .[[ViewedArrayBuffer]].</step>
  <step>If IsDetachedBuffer ( <id>buffer</id> ) is <value>true</value> , return 0.</step>
  <step>Let <id>offset</id> be <id>O</id> .[[ByteOffset]].</step>
  <step>Return <id>offset</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be <value>this</value> value.</step>
  <step>Perform ? ValidateTypedArray ( <id>O</id> ).</step>
  <step>Let <id>len</id> be <id>O</id> .[[ArrayLength]].</step>
  <step>Let <id>relativeTarget</id> be ? ToInteger ( <id>target</id> ).</step>
  <step>If <id>relativeTarget</id> < 0, let <id>to</id> be max (( <id>len</id> + <id>relativeTarget</id> ), 0); else let <id>to</id> be min ( <id>relativeTarget</id> , <id>len</id> ).</step>
  <step>Let <id>relativeStart</id> be ? ToInteger ( <id>start</id> ).</step>
  <step>If <id>relativeStart</id> < 0, let <id>from</id> be max (( <id>len</id> + <id>relativeStart</id> ), 0); else let <id>from</id> be min ( <id>relativeStart</id> , <id>len</id> ).</step>
  <step>If <id>end</id> is <value>undefined</value> , let <id>relativeEnd</id> be <id>len</id> ; else let <id>relativeEnd</id> be ? ToInteger ( <id>end</id> ).</step>
  <step>If <id>relativeEnd</id> < 0, let <id>final</id> be max (( <id>len</id> + <id>relativeEnd</id> ), 0); else let <id>final</id> be min ( <id>relativeEnd</id> , <id>len</id> ).</step>
  <step>Let <id>count</id> be min ( <id>final</id> - <id>from</id> , <id>len</id> - <id>to</id> ).</step>
  <step>If <id>count</id> > 0, then   <step-list>
    <step>NOTE: The copying must be performed in a manner that preserves the bit-level encoding of the source data.</step>
    <step>Let <id>buffer</id> be <id>O</id> .[[ViewedArrayBuffer]].</step>
    <step>If IsDetachedBuffer ( <id>buffer</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
    <step>Let <id>typedArrayName</id> be the String value of <id>O</id> .[[TypedArrayName]].</step>
    <step>Let <id>elementSize</id> be the Number value of the Element Size value specified in Table 56 for <id>typedArrayName</id> .</step>
    <step>Let <id>byteOffset</id> be <id>O</id> .[[ByteOffset]].</step>
    <step>Let <id>toByteIndex</id> be <id>to</id> × <id>elementSize</id> + <id>byteOffset</id> .</step>
    <step>Let <id>fromByteIndex</id> be <id>from</id> × <id>elementSize</id> + <id>byteOffset</id> .</step>
    <step>Let <id>countBytes</id> be <id>count</id> × <id>elementSize</id> .</step>
    <step>If <id>fromByteIndex</id> < <id>toByteIndex</id> and <id>toByteIndex</id> < <id>fromByteIndex</id> + <id>countBytes</id> , then     <step-list>
      <step>Let <id>direction</id> be -1.</step>
      <step>Let <id>fromByteIndex</id> be <id>fromByteIndex</id> + <id>countBytes</id> - 1.</step>
      <step>Let <id>toByteIndex</id> be <id>toByteIndex</id> + <id>countBytes</id> - 1.</step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>Let <id>direction</id> be 1.</step>
    </step-list></step>
    <step>Repeat, while <id>countBytes</id> > 0     <step-list>
      <step>Let <id>value</id> be GetValueFromBuffer ( <id>buffer</id> , <id>fromByteIndex</id> , <value>"Uint8"</value> , <value>true</value> , <value>"Unordered"</value> ).</step>
      <step>Perform SetValueInBuffer ( <id>buffer</id> , <id>toByteIndex</id> , <value>"Uint8"</value> , <id>value</id> , <value>true</value> , <value>"Unordered"</value> ).</step>
      <step>Let <id>fromByteIndex</id> be <id>fromByteIndex</id> + <id>direction</id> .</step>
      <step>Let <id>toByteIndex</id> be <id>toByteIndex</id> + <id>direction</id> .</step>
      <step>Let <id>countBytes</id> be <id>countBytes</id> - 1.</step>
    </step-list></step>
  </step-list></step>
  <step>Return <id>O</id> .</step>
</step-list>
<step-list>
  <step>If Type ( <id>O</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>O</id> does not have a [[TypedArrayName]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Assert : <id>O</id> has a [[ViewedArrayBuffer]] internal slot.</step>
  <step>Let <id>buffer</id> be <id>O</id> .[[ViewedArrayBuffer]].</step>
  <step>If IsDetachedBuffer ( <id>buffer</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  <step>Return <id>buffer</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>Perform ? ValidateTypedArray ( <id>O</id> ).</step>
  <step>Return CreateArrayIterator ( <id>O</id> , <value>"key+value"</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>Perform ? ValidateTypedArray ( <id>O</id> ).</step>
  <step>Let <id>len</id> be <id>O</id> .[[ArrayLength]].</step>
  <step>Let <id>value</id> be ? ToNumber ( <id>value</id> ).</step>
  <step>Let <id>relativeStart</id> be ? ToInteger ( <id>start</id> ).</step>
  <step>If <id>relativeStart</id> < 0, let <id>k</id> be max (( <id>len</id> + <id>relativeStart</id> ), 0); else let <id>k</id> be min ( <id>relativeStart</id> , <id>len</id> ).</step>
  <step>If <id>end</id> is <value>undefined</value> , let <id>relativeEnd</id> be <id>len</id> ; else let <id>relativeEnd</id> be ? ToInteger ( <id>end</id> ).</step>
  <step>If <id>relativeEnd</id> < 0, let <id>final</id> be max (( <id>len</id> + <id>relativeEnd</id> ), 0); else let <id>final</id> be min ( <id>relativeEnd</id> , <id>len</id> ).</step>
  <step>If IsDetachedBuffer ( <id>O</id> .[[ViewedArrayBuffer]]) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  <step>Repeat, while <id>k</id> < <id>final</id>   <step-list>
    <step>Let <id>Pk</id> be ! ToString ( <id>k</id> ).</step>
    <step>Perform ! Set ( <id>O</id> , <id>Pk</id> , <id>value</id> , <value>true</value> ).</step>
    <step>Increase <id>k</id> by 1.</step>
  </step-list></step>
  <step>Return <id>O</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>Perform ? ValidateTypedArray ( <id>O</id> ).</step>
  <step>Let <id>len</id> be <id>O</id> .[[ArrayLength]].</step>
  <step>If IsCallable ( <id>callbackfn</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>If <id>thisArg</id> is present, let <id>T</id> be <id>thisArg</id> ; else let <id>T</id> be <value>undefined</value> .</step>
  <step>Let <id>kept</id> be a new empty List .</step>
  <step>Let <id>k</id> be 0.</step>
  <step>Let <id>captured</id> be 0.</step>
  <step>Repeat, while <id>k</id> < <id>len</id>   <step-list>
    <step>Let <id>Pk</id> be ! ToString ( <id>k</id> ).</step>
    <step>Let <id>kValue</id> be ? Get ( <id>O</id> , <id>Pk</id> ).</step>
    <step>Let <id>selected</id> be ToBoolean (? Call ( <id>callbackfn</id> , <id>T</id> , « <id>kValue</id> , <id>k</id> , <id>O</id> »)).</step>
    <step>If <id>selected</id> is <value>true</value> , then     <step-list>
      <step>Append <id>kValue</id> to the end of <id>kept</id> .</step>
      <step>Increase <id>captured</id> by 1.</step>
    </step-list></step>
    <step>Increase <id>k</id> by 1.</step>
  </step-list></step>
  <step>Let <id>A</id> be ? TypedArraySpeciesCreate ( <id>O</id> , « <id>captured</id> »).</step>
  <step>Let <id>n</id> be 0.</step>
  <step>For each element <id>e</id> of <id>kept</id> , do   <step-list>
    <step>Perform ! Set ( <id>A</id> , ! ToString ( <id>n</id> ), <id>e</id> , <value>true</value> ).</step>
    <step>Increment <id>n</id> by 1.</step>
  </step-list></step>
  <step>Return <id>A</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>Perform ? ValidateTypedArray ( <id>O</id> ).</step>
  <step>Return CreateArrayIterator ( <id>O</id> , <value>"key"</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>O</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>O</id> does not have a [[TypedArrayName]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Assert : <id>O</id> has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.</step>
  <step>Let <id>buffer</id> be <id>O</id> .[[ViewedArrayBuffer]].</step>
  <step>If IsDetachedBuffer ( <id>buffer</id> ) is <value>true</value> , return 0.</step>
  <step>Let <id>length</id> be <id>O</id> .[[ArrayLength]].</step>
  <step>Return <id>length</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>Perform ? ValidateTypedArray ( <id>O</id> ).</step>
  <step>Let <id>len</id> be <id>O</id> .[[ArrayLength]].</step>
  <step>If IsCallable ( <id>callbackfn</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>If <id>thisArg</id> is present, let <id>T</id> be <id>thisArg</id> ; else let <id>T</id> be <value>undefined</value> .</step>
  <step>Let <id>A</id> be ? TypedArraySpeciesCreate ( <id>O</id> , « <id>len</id> »).</step>
  <step>Let <id>k</id> be 0.</step>
  <step>Repeat, while <id>k</id> < <id>len</id>   <step-list>
    <step>Let <id>Pk</id> be ! ToString ( <id>k</id> ).</step>
    <step>Let <id>kValue</id> be ? Get ( <id>O</id> , <id>Pk</id> ).</step>
    <step>Let <id>mappedValue</id> be ? Call ( <id>callbackfn</id> , <id>T</id> , « <id>kValue</id> , <id>k</id> , <id>O</id> »).</step>
    <step>Perform ? Set ( <id>A</id> , <id>Pk</id> , <id>mappedValue</id> , <value>true</value> ).</step>
    <step>Increase <id>k</id> by 1.</step>
  </step-list></step>
  <step>Return <id>A</id> .</step>
</step-list>
<step-list>
  <step>Assert : <id>array</id> is any ECMAScript language value other than an Object with a [[TypedArrayName]] internal slot. If it is such an Object, the definition in 22.2.3.23.2 applies.</step>
  <step>Let <id>target</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>target</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>target</id> does not have a [[TypedArrayName]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Assert : <id>target</id> has a [[ViewedArrayBuffer]] internal slot.</step>
  <step>Let <id>targetOffset</id> be ? ToInteger ( <id>offset</id> ).</step>
  <step>If <id>targetOffset</id> < 0, throw a <value>RangeError</value> exception.</step>
  <step>Let <id>targetBuffer</id> be <id>target</id> .[[ViewedArrayBuffer]].</step>
  <step>If IsDetachedBuffer ( <id>targetBuffer</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>targetLength</id> be <id>target</id> .[[ArrayLength]].</step>
  <step>Let <id>targetName</id> be the String value of <id>target</id> .[[TypedArrayName]].</step>
  <step>Let <id>targetElementSize</id> be the Number value of the Element Size value specified in Table 56 for <id>targetName</id> .</step>
  <step>Let <id>targetType</id> be the String value of the Element Type value in Table 56 for <id>targetName</id> .</step>
  <step>Let <id>targetByteOffset</id> be <id>target</id> .[[ByteOffset]].</step>
  <step>Let <id>src</id> be ? ToObject ( <id>array</id> ).</step>
  <step>Let <id>srcLength</id> be ? ToLength (? Get ( <id>src</id> , <value>"length"</value> )).</step>
  <step>If <id>srcLength</id> + <id>targetOffset</id> > <id>targetLength</id> , throw a <value>RangeError</value> exception.</step>
  <step>Let <id>targetByteIndex</id> be <id>targetOffset</id> × <id>targetElementSize</id> + <id>targetByteOffset</id> .</step>
  <step>Let <id>k</id> be 0.</step>
  <step>Let <id>limit</id> be <id>targetByteIndex</id> + <id>targetElementSize</id> × <id>srcLength</id> .</step>
  <step>Repeat, while <id>targetByteIndex</id> < <id>limit</id>   <step-list>
    <step>Let <id>Pk</id> be ! ToString ( <id>k</id> ).</step>
    <step>Let <id>kNumber</id> be ? ToNumber (? Get ( <id>src</id> , <id>Pk</id> )).</step>
    <step>If IsDetachedBuffer ( <id>targetBuffer</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
    <step>Perform SetValueInBuffer ( <id>targetBuffer</id> , <id>targetByteIndex</id> , <id>targetType</id> , <id>kNumber</id> , <value>true</value> , <value>"Unordered"</value> ).</step>
    <step>Set <id>k</id> to <id>k</id> + 1.</step>
    <step>Set <id>targetByteIndex</id> to <id>targetByteIndex</id> + <id>targetElementSize</id> .</step>
  </step-list></step>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Assert : <id>typedArray</id> has a [[TypedArrayName]] internal slot. If it does not, the definition in 22.2.3.23.1 applies.</step>
  <step>Let <id>target</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>target</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>target</id> does not have a [[TypedArrayName]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Assert : <id>target</id> has a [[ViewedArrayBuffer]] internal slot.</step>
  <step>Let <id>targetOffset</id> be ? ToInteger ( <id>offset</id> ).</step>
  <step>If <id>targetOffset</id> < 0, throw a <value>RangeError</value> exception.</step>
  <step>Let <id>targetBuffer</id> be <id>target</id> .[[ViewedArrayBuffer]].</step>
  <step>If IsDetachedBuffer ( <id>targetBuffer</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>targetLength</id> be <id>target</id> .[[ArrayLength]].</step>
  <step>Let <id>srcBuffer</id> be <id>typedArray</id> .[[ViewedArrayBuffer]].</step>
  <step>If IsDetachedBuffer ( <id>srcBuffer</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>targetName</id> be the String value of <id>target</id> .[[TypedArrayName]].</step>
  <step>Let <id>targetType</id> be the String value of the Element Type value in Table 56 for <id>targetName</id> .</step>
  <step>Let <id>targetElementSize</id> be the Number value of the Element Size value specified in Table 56 for <id>targetName</id> .</step>
  <step>Let <id>targetByteOffset</id> be <id>target</id> .[[ByteOffset]].</step>
  <step>Let <id>srcName</id> be the String value of <id>typedArray</id> .[[TypedArrayName]].</step>
  <step>Let <id>srcType</id> be the String value of the Element Type value in Table 56 for <id>srcName</id> .</step>
  <step>Let <id>srcElementSize</id> be the Number value of the Element Size value specified in Table 56 for <id>srcName</id> .</step>
  <step>Let <id>srcLength</id> be <id>typedArray</id> .[[ArrayLength]].</step>
  <step>Let <id>srcByteOffset</id> be <id>typedArray</id> .[[ByteOffset]].</step>
  <step>If <id>srcLength</id> + <id>targetOffset</id> > <id>targetLength</id> , throw a <value>RangeError</value> exception.</step>
  <step>If both IsSharedArrayBuffer ( <id>srcBuffer</id> ) and IsSharedArrayBuffer ( <id>targetBuffer</id> ) are <value>true</value> , then   <step-list>
    <step>If <id>srcBuffer</id> .[[ArrayBufferData]] and <id>targetBuffer</id> .[[ArrayBufferData]] are the same Shared Data Block values, let <id>same</id> be <value>true</value> ; else let <id>same</id> be <value>false</value> .</step>
  </step-list></step>
  <step>Else, let <id>same</id> be SameValue ( <id>srcBuffer</id> , <id>targetBuffer</id> ).</step>
  <step>If <id>same</id> is <value>true</value> , then   <step-list>
    <step>Let <id>srcByteLength</id> be <id>typedArray</id> .[[ByteLength]].</step>
    <step>Let <id>srcBuffer</id> be ? CloneArrayBuffer ( <id>srcBuffer</id> , <id>srcByteOffset</id> , <id>srcByteLength</id> , %ArrayBuffer% ).</step>
    <step>NOTE: %ArrayBuffer% is used to clone <id>srcBuffer</id> because is it known to not have any observable side-effects.</step>
    <step>Let <id>srcByteIndex</id> be 0.</step>
  </step-list></step>
  <step>Else, let <id>srcByteIndex</id> be <id>srcByteOffset</id> .</step>
  <step>Let <id>targetByteIndex</id> be <id>targetOffset</id> × <id>targetElementSize</id> + <id>targetByteOffset</id> .</step>
  <step>Let <id>limit</id> be <id>targetByteIndex</id> + <id>targetElementSize</id> × <id>srcLength</id> .</step>
  <step>If SameValue ( <id>srcType</id> , <id>targetType</id> ) is <value>true</value> , then   <step-list>
    <step>NOTE: If <id>srcType</id> and <id>targetType</id> are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.</step>
    <step>Repeat, while <id>targetByteIndex</id> < <id>limit</id>     <step-list>
      <step>Let <id>value</id> be GetValueFromBuffer ( <id>srcBuffer</id> , <id>srcByteIndex</id> , <value>"Uint8"</value> , <value>true</value> , <value>"Unordered"</value> ).</step>
      <step>Perform SetValueInBuffer ( <id>targetBuffer</id> , <id>targetByteIndex</id> , <value>"Uint8"</value> , <id>value</id> , <value>true</value> , <value>"Unordered"</value> ).</step>
      <step>Set <id>srcByteIndex</id> to <id>srcByteIndex</id> + 1.</step>
      <step>Set <id>targetByteIndex</id> to <id>targetByteIndex</id> + 1.</step>
    </step-list></step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Repeat, while <id>targetByteIndex</id> < <id>limit</id>     <step-list>
      <step>Let <id>value</id> be GetValueFromBuffer ( <id>srcBuffer</id> , <id>srcByteIndex</id> , <id>srcType</id> , <value>true</value> , <value>"Unordered"</value> ).</step>
      <step>Perform SetValueInBuffer ( <id>targetBuffer</id> , <id>targetByteIndex</id> , <id>targetType</id> , <id>value</id> , <value>true</value> , <value>"Unordered"</value> ).</step>
      <step>Set <id>srcByteIndex</id> to <id>srcByteIndex</id> + <id>srcElementSize</id> .</step>
      <step>Set <id>targetByteIndex</id> to <id>targetByteIndex</id> + <id>targetElementSize</id> .</step>
    </step-list></step>
  </step-list></step>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>Perform ? ValidateTypedArray ( <id>O</id> ).</step>
  <step>Let <id>len</id> be <id>O</id> .[[ArrayLength]].</step>
  <step>Let <id>relativeStart</id> be ? ToInteger ( <id>start</id> ).</step>
  <step>If <id>relativeStart</id> < 0, let <id>k</id> be max (( <id>len</id> + <id>relativeStart</id> ), 0); else let <id>k</id> be min ( <id>relativeStart</id> , <id>len</id> ).</step>
  <step>If <id>end</id> is <value>undefined</value> , let <id>relativeEnd</id> be <id>len</id> ; else let <id>relativeEnd</id> be ? ToInteger ( <id>end</id> ).</step>
  <step>If <id>relativeEnd</id> < 0, let <id>final</id> be max (( <id>len</id> + <id>relativeEnd</id> ), 0); else let <id>final</id> be min ( <id>relativeEnd</id> , <id>len</id> ).</step>
  <step>Let <id>count</id> be max ( <id>final</id> - <id>k</id> , 0).</step>
  <step>Let <id>A</id> be ? TypedArraySpeciesCreate ( <id>O</id> , « <id>count</id> »).</step>
  <step>Let <id>srcName</id> be the String value of <id>O</id> .[[TypedArrayName]].</step>
  <step>Let <id>srcType</id> be the String value of the Element Type value in Table 56 for <id>srcName</id> .</step>
  <step>Let <id>targetName</id> be the String value of <id>A</id> .[[TypedArrayName]].</step>
  <step>Let <id>targetType</id> be the String value of the Element Type value in Table 56 for <id>targetName</id> .</step>
  <step>If SameValue ( <id>srcType</id> , <id>targetType</id> ) is <value>false</value> , then   <step-list>
    <step>Let <id>n</id> be 0.</step>
    <step>Repeat, while <id>k</id> < <id>final</id>     <step-list>
      <step>Let <id>Pk</id> be ! ToString ( <id>k</id> ).</step>
      <step>Let <id>kValue</id> be ? Get ( <id>O</id> , <id>Pk</id> ).</step>
      <step>Perform ! Set ( <id>A</id> , ! ToString ( <id>n</id> ), <id>kValue</id> ).</step>
      <step>Increase <id>k</id> by 1.</step>
      <step>Increase <id>n</id> by 1.</step>
    </step-list></step>
  </step-list></step>
  <step>Else if <id>count</id> > 0, then   <step-list>
    <step>Let <id>srcBuffer</id> be <id>O</id> .[[ViewedArrayBuffer]].</step>
    <step>If IsDetachedBuffer ( <id>srcBuffer</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
    <step>Let <id>targetBuffer</id> be <id>A</id> .[[ViewedArrayBuffer]].</step>
    <step>Let <id>elementSize</id> be the Number value of the Element Size value specified in Table 56 for <id>srcType</id> .</step>
    <step>NOTE: If <id>srcType</id> and <id>targetType</id> are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.</step>
    <step>Let <id>srcByteOffet</id> be <id>O</id> .[[ByteOffset]].</step>
    <step>Let <id>targetByteIndex</id> be <id>A</id> .[[ByteOffset]].</step>
    <step>Let <id>srcByteIndex</id> be ( <id>k</id> × <id>elementSize</id> ) + <id>srcByteOffet</id> .</step>
    <step>Let <id>limit</id> be <id>targetByteIndex</id> + <id>count</id> × <id>elementSize</id> .</step>
    <step>Repeat, while <id>targetByteIndex</id> < <id>limit</id>     <step-list>
      <step>Let <id>value</id> be GetValueFromBuffer ( <id>srcBuffer</id> , <id>srcByteIndex</id> , <value>"Uint8"</value> , <value>true</value> , <value>"Unordered"</value> ).</step>
      <step>Perform SetValueInBuffer ( <id>targetBuffer</id> , <id>targetByteIndex</id> , <value>"Uint8"</value> , <id>value</id> , <value>true</value> , <value>"Unordered"</value> ).</step>
      <step>Increase <id>srcByteIndex</id> by 1.</step>
      <step>Increase <id>targetByteIndex</id> by 1.</step>
    </step-list></step>
  </step-list></step>
  <step>Return <id>A</id> .</step>
</step-list>
<step-list>
  <step>If <id>comparefn</id> is not <value>undefined</value> and IsCallable ( <id>comparefn</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>obj</id> be the <value>this</value> value.</step>
  <step>Let <id>buffer</id> be ? ValidateTypedArray ( <id>obj</id> ).</step>
  <step>Let <id>len</id> be <id>obj</id> .[[ArrayLength]].</step>
</step-list>
<step-list>
  <step>Assert : Both Type ( <id>x</id> ) and Type ( <id>y</id> ) is Number.</step>
  <step>If <id>comparefn</id> is not <value>undefined</value> , then   <step-list>
    <step>Let <id>v</id> be ? ToNumber (? Call ( <id>comparefn</id> , <value>undefined</value> , « <id>x</id> , <id>y</id> »)).</step>
    <step>If IsDetachedBuffer ( <id>buffer</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
    <step>If <id>v</id> is <value>NaN</value> , return <value>+0</value> .</step>
    <step>Return <id>v</id> .</step>
  </step-list></step>
  <step>If <id>x</id> and <id>y</id> are both <value>NaN</value> , return <value>+0</value> .</step>
  <step>If <id>x</id> is <value>NaN</value> , return 1.</step>
  <step>If <id>y</id> is <value>NaN</value> , return -1.</step>
  <step>If <id>x</id> < <id>y</id> , return -1.</step>
  <step>If <id>x</id> > <id>y</id> , return 1.</step>
  <step>If <id>x</id> is <value>-0</value> and <id>y</id> is <value>+0</value> , return -1.</step>
  <step>If <id>x</id> is <value>+0</value> and <id>y</id> is <value>-0</value> , return 1.</step>
  <step>Return <value>+0</value> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>O</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>O</id> does not have a [[TypedArrayName]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Assert : <id>O</id> has a [[ViewedArrayBuffer]] internal slot.</step>
  <step>Let <id>buffer</id> be <id>O</id> .[[ViewedArrayBuffer]].</step>
  <step>Let <id>srcLength</id> be <id>O</id> .[[ArrayLength]].</step>
  <step>Let <id>relativeBegin</id> be ? ToInteger ( <id>begin</id> ).</step>
  <step>If <id>relativeBegin</id> < 0, let <id>beginIndex</id> be max (( <id>srcLength</id> + <id>relativeBegin</id> ), 0); else let <id>beginIndex</id> be min ( <id>relativeBegin</id> , <id>srcLength</id> ).</step>
  <step>If <id>end</id> is <value>undefined</value> , let <id>relativeEnd</id> be <id>srcLength</id> ; else, let <id>relativeEnd</id> be ? ToInteger ( <id>end</id> ).</step>
  <step>If <id>relativeEnd</id> < 0, let <id>endIndex</id> be max (( <id>srcLength</id> + <id>relativeEnd</id> ), 0); else let <id>endIndex</id> be min ( <id>relativeEnd</id> , <id>srcLength</id> ).</step>
  <step>Let <id>newLength</id> be max ( <id>endIndex</id> - <id>beginIndex</id> , 0).</step>
  <step>Let <id>constructorName</id> be the String value of <id>O</id> .[[TypedArrayName]].</step>
  <step>Let <id>elementSize</id> be the Number value of the Element Size value specified in Table 56 for <id>constructorName</id> .</step>
  <step>Let <id>srcByteOffset</id> be <id>O</id> .[[ByteOffset]].</step>
  <step>Let <id>beginByteOffset</id> be <id>srcByteOffset</id> + <id>beginIndex</id> × <id>elementSize</id> .</step>
  <step>Let <id>argumentsList</id> be « <id>buffer</id> , <id>beginByteOffset</id> , <id>newLength</id> ».</step>
  <step>Return ? TypedArraySpeciesCreate ( <id>O</id> , <id>argumentsList</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>Perform ? ValidateTypedArray ( <id>O</id> ).</step>
  <step>Return CreateArrayIterator ( <id>O</id> , <value>"value"</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>O</id> ) is not Object, return <value>undefined</value> .</step>
  <step>If <id>O</id> does not have a [[TypedArrayName]] internal slot, return <value>undefined</value> .</step>
  <step>Let <id>name</id> be <id>O</id> .[[TypedArrayName]].</step>
  <step>Assert : <id>name</id> is a String value.</step>
  <step>Return <id>name</id> .</step>
</step-list>
<step-list>
  <step>If NewTarget is <value>undefined</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>constructorName</id> be the String value of the Constructor Name value specified in Table 56 for this <id>TypedArray</id>  constructor .</step>
  <step>Return ? AllocateTypedArray ( <id>constructorName</id> , NewTarget, <value>"%TypedArrayPrototype%"</value> , 0).</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>length</id> ) is not Object.</step>
  <step>If NewTarget is <value>undefined</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>elementLength</id> be ? ToIndex ( <id>length</id> ).</step>
  <step>Let <id>constructorName</id> be the String value of the Constructor Name value specified in Table 56 for this <id>TypedArray</id>  constructor .</step>
  <step>Return ? AllocateTypedArray ( <id>constructorName</id> , NewTarget, <value>"%TypedArrayPrototype%"</value> , <id>elementLength</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>proto</id> be ? GetPrototypeFromConstructor ( <id>newTarget</id> , <id>defaultProto</id> ).</step>
  <step>Let <id>obj</id> be IntegerIndexedObjectCreate ( <id>proto</id> , « [[ViewedArrayBuffer]], [[TypedArrayName]], [[ByteLength]], [[ByteOffset]], [[ArrayLength]] »).</step>
  <step>Assert : <id>obj</id> .[[ViewedArrayBuffer]] is <value>undefined</value> .</step>
  <step>Set <id>obj</id> .[[TypedArrayName]] to <id>constructorName</id> .</step>
  <step>If <id>length</id> is not present, then   <step-list>
    <step>Set <id>obj</id> .[[ByteLength]] to 0.</step>
    <step>Set <id>obj</id> .[[ByteOffset]] to 0.</step>
    <step>Set <id>obj</id> .[[ArrayLength]] to 0.</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Perform ? AllocateTypedArrayBuffer ( <id>obj</id> , <id>length</id> ).</step>
  </step-list></step>
  <step>Return <id>obj</id> .</step>
</step-list>
<step-list>
  <step>Assert : <id>O</id> is an Object that has a [[ViewedArrayBuffer]] internal slot.</step>
  <step>Assert : <id>O</id> .[[ViewedArrayBuffer]] is <value>undefined</value> .</step>
  <step>Assert : <id>length</id> ≥ 0.</step>
  <step>Let <id>constructorName</id> be the String value of <id>O</id> .[[TypedArrayName]].</step>
  <step>Let <id>elementSize</id> be the Element Size value in Table 56 for <id>constructorName</id> .</step>
  <step>Let <id>byteLength</id> be <id>elementSize</id> × <id>length</id> .</step>
  <step>Let <id>data</id> be ? AllocateArrayBuffer ( %ArrayBuffer% , <id>byteLength</id> ).</step>
  <step>Set <id>O</id> .[[ViewedArrayBuffer]] to <id>data</id> .</step>
  <step>Set <id>O</id> .[[ByteLength]] to <id>byteLength</id> .</step>
  <step>Set <id>O</id> .[[ByteOffset]] to 0.</step>
  <step>Set <id>O</id> .[[ArrayLength]] to <id>length</id> .</step>
  <step>Return <id>O</id> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>typedArray</id> ) is Object and <id>typedArray</id> has a [[TypedArrayName]] internal slot.</step>
  <step>If NewTarget is <value>undefined</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>constructorName</id> be the String value of the Constructor Name value specified in Table 56 for this <id>TypedArray</id>  constructor .</step>
  <step>Let <id>O</id> be ? AllocateTypedArray ( <id>constructorName</id> , NewTarget, <value>"%TypedArrayPrototype%"</value> ).</step>
  <step>Let <id>srcArray</id> be <id>typedArray</id> .</step>
  <step>Let <id>srcData</id> be <id>srcArray</id> .[[ViewedArrayBuffer]].</step>
  <step>If IsDetachedBuffer ( <id>srcData</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>elementType</id> be the String value of the Element Type value in Table 56 for <id>constructorName</id> .</step>
  <step>Let <id>elementLength</id> be <id>srcArray</id> .[[ArrayLength]].</step>
  <step>Let <id>srcName</id> be the String value of <id>srcArray</id> .[[TypedArrayName]].</step>
  <step>Let <id>srcType</id> be the String value of the Element Type value in Table 56 for <id>srcName</id> .</step>
  <step>Let <id>srcElementSize</id> be the Element Size value in Table 56 for <id>srcName</id> .</step>
  <step>Let <id>srcByteOffset</id> be <id>srcArray</id> .[[ByteOffset]].</step>
  <step>Let <id>elementSize</id> be the Element Size value in Table 56 for <id>constructorName</id> .</step>
  <step>Let <id>byteLength</id> be <id>elementSize</id> × <id>elementLength</id> .</step>
  <step>If IsSharedArrayBuffer ( <id>srcData</id> ) is <value>false</value> , then   <step-list>
    <step>Let <id>bufferConstructor</id> be ? SpeciesConstructor ( <id>srcData</id> , %ArrayBuffer% ).</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>bufferConstructor</id> be %ArrayBuffer% .</step>
  </step-list></step>
  <step>If SameValue ( <id>elementType</id> , <id>srcType</id> ) is <value>true</value> , then   <step-list>
    <step>If IsDetachedBuffer ( <id>srcData</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
    <step>Let <id>data</id> be ? CloneArrayBuffer ( <id>srcData</id> , <id>srcByteOffset</id> , <id>byteLength</id> , <id>bufferConstructor</id> ).</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>data</id> be ? AllocateArrayBuffer ( <id>bufferConstructor</id> , <id>byteLength</id> ).</step>
    <step>If IsDetachedBuffer ( <id>srcData</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
    <step>Let <id>srcByteIndex</id> be <id>srcByteOffset</id> .</step>
    <step>Let <id>targetByteIndex</id> be 0.</step>
    <step>Let <id>count</id> be <id>elementLength</id> .</step>
    <step>Repeat, while <id>count</id> > 0     <step-list>
      <step>Let <id>value</id> be GetValueFromBuffer ( <id>srcData</id> , <id>srcByteIndex</id> , <id>srcType</id> , <value>true</value> , <value>"Unordered"</value> ).</step>
      <step>Perform SetValueInBuffer ( <id>data</id> , <id>targetByteIndex</id> , <id>elementType</id> , <id>value</id> , <value>true</value> , <value>"Unordered"</value> ).</step>
      <step>Set <id>srcByteIndex</id> to <id>srcByteIndex</id> + <id>srcElementSize</id> .</step>
      <step>Set <id>targetByteIndex</id> to <id>targetByteIndex</id> + <id>elementSize</id> .</step>
      <step>Decrement <id>count</id> by 1.</step>
    </step-list></step>
  </step-list></step>
  <step>Set <id>O</id> .[[ViewedArrayBuffer]] to <id>data</id> .</step>
  <step>Set <id>O</id> .[[ByteLength]] to <id>byteLength</id> .</step>
  <step>Set <id>O</id> .[[ByteOffset]] to 0.</step>
  <step>Set <id>O</id> .[[ArrayLength]] to <id>elementLength</id> .</step>
  <step>Return <id>O</id> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>object</id> ) is Object and <id>object</id> does not have either a [[TypedArrayName]] or an [[ArrayBufferData]] internal slot.</step>
  <step>If NewTarget is <value>undefined</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>constructorName</id> be the String value of the Constructor Name value specified in Table 56 for this <id>TypedArray</id>  constructor .</step>
  <step>Let <id>O</id> be ? AllocateTypedArray ( <id>constructorName</id> , NewTarget, <value>"%TypedArrayPrototype%"</value> ).</step>
  <step>Let <id>usingIterator</id> be ? GetMethod ( <id>object</id> , @@iterator).</step>
  <step>If <id>usingIterator</id> is not <value>undefined</value> , then   <step-list>
    <step>Let <id>values</id> be ? IterableToList ( <id>object</id> , <id>usingIterator</id> ).</step>
    <step>Let <id>len</id> be the number of elements in <id>values</id> .</step>
    <step>Perform ? AllocateTypedArrayBuffer ( <id>O</id> , <id>len</id> ).</step>
    <step>Let <id>k</id> be 0.</step>
    <step>Repeat, while <id>k</id> < <id>len</id>     <step-list>
      <step>Let <id>Pk</id> be ! ToString ( <id>k</id> ).</step>
      <step>Let <id>kValue</id> be the first element of <id>values</id> and remove that element from <id>values</id> .</step>
      <step>Perform ? Set ( <id>O</id> , <id>Pk</id> , <id>kValue</id> , <value>true</value> ).</step>
      <step>Increase <id>k</id> by 1.</step>
    </step-list></step>
    <step>Assert : <id>values</id> is now an empty List .</step>
    <step>Return <id>O</id> .</step>
  </step-list></step>
  <step>NOTE: <id>object</id> is not an Iterable so assume it is already an array-like object.</step>
  <step>Let <id>arrayLike</id> be <id>object</id> .</step>
  <step>Let <id>len</id> be ? ToLength (? Get ( <id>arrayLike</id> , <value>"length"</value> )).</step>
  <step>Perform ? AllocateTypedArrayBuffer ( <id>O</id> , <id>len</id> ).</step>
  <step>Let <id>k</id> be 0.</step>
  <step>Repeat, while <id>k</id> < <id>len</id>   <step-list>
    <step>Let <id>Pk</id> be ! ToString ( <id>k</id> ).</step>
    <step>Let <id>kValue</id> be ? Get ( <id>arrayLike</id> , <id>Pk</id> ).</step>
    <step>Perform ? Set ( <id>O</id> , <id>Pk</id> , <id>kValue</id> , <value>true</value> ).</step>
    <step>Increase <id>k</id> by 1.</step>
  </step-list></step>
  <step>Return <id>O</id> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>buffer</id> ) is Object and <id>buffer</id> has an [[ArrayBufferData]] internal slot.</step>
  <step>If NewTarget is <value>undefined</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>constructorName</id> be the String value of the Constructor Name value specified in Table 56 for this <id>TypedArray</id>  constructor .</step>
  <step>Let <id>O</id> be ? AllocateTypedArray ( <id>constructorName</id> , NewTarget, <value>"%TypedArrayPrototype%"</value> ).</step>
  <step>Let <id>elementSize</id> be the Number value of the Element Size value in Table 56 for <id>constructorName</id> .</step>
  <step>Let <id>offset</id> be ? ToIndex ( <id>byteOffset</id> ).</step>
  <step>If <id>offset</id>  modulo  <id>elementSize</id> ≠ 0, throw a <value>RangeError</value> exception.</step>
  <step>If <id>length</id> is present and <id>length</id> is not <value>undefined</value> , then   <step-list>
    <step>Let <id>newLength</id> be ? ToIndex ( <id>length</id> ).</step>
  </step-list></step>
  <step>If IsDetachedBuffer ( <id>buffer</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>bufferByteLength</id> be <id>buffer</id> .[[ArrayBufferByteLength]].</step>
  <step>If <id>length</id> is either not present or <value>undefined</value> , then   <step-list>
    <step>If <id>bufferByteLength</id>  modulo  <id>elementSize</id> ≠ 0, throw a <value>RangeError</value> exception.</step>
    <step>Let <id>newByteLength</id> be <id>bufferByteLength</id> - <id>offset</id> .</step>
    <step>If <id>newByteLength</id> < 0, throw a <value>RangeError</value> exception.</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>newByteLength</id> be <id>newLength</id> × <id>elementSize</id> .</step>
    <step>If <id>offset</id> + <id>newByteLength</id> > <id>bufferByteLength</id> , throw a <value>RangeError</value> exception.</step>
  </step-list></step>
  <step>Set <id>O</id> .[[ViewedArrayBuffer]] to <id>buffer</id> .</step>
  <step>Set <id>O</id> .[[ByteLength]] to <id>newByteLength</id> .</step>
  <step>Set <id>O</id> .[[ByteOffset]] to <id>offset</id> .</step>
  <step>Set <id>O</id> .[[ArrayLength]] to <id>newByteLength</id> / <id>elementSize</id> .</step>
  <step>Return <id>O</id> .</step>
</step-list>
<step-list>
  <step>Let <id>newTypedArray</id> be ? Construct ( <id>constructor</id> , <id>argumentList</id> ).</step>
  <step>Perform ? ValidateTypedArray ( <id>newTypedArray</id> ).</step>
  <step>If <id>argumentList</id> is a List of a single Number, then   <step-list>
    <step>If <id>newTypedArray</id> .[[ArrayLength]] < <id>argumentList</id> [0], throw a <value>TypeError</value> exception.</step>
  </step-list></step>
  <step>Return <id>newTypedArray</id> .</step>
</step-list>
<step-list>
  <step>Assert : <id>exemplar</id> is an Object that has a [[TypedArrayName]] internal slot.</step>
  <step>Let <id>defaultConstructor</id> be the intrinsic object listed in column one of Table 56 for <id>exemplar</id> .[[TypedArrayName]].</step>
  <step>Let <id>constructor</id> be ? SpeciesConstructor ( <id>exemplar</id> , <id>defaultConstructor</id> ).</step>
  <step>Return ? TypedArrayCreate ( <id>constructor</id> , <id>argumentList</id> ).</step>
</step-list>
<step-list>
  <step>If NewTarget is <value>undefined</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>map</id> be ? OrdinaryCreateFromConstructor (NewTarget, <value>"%MapPrototype%"</value> , « [[MapData]] »).</step>
  <step>Set <id>map</id> .[[MapData]] to a new empty List .</step>
  <step>If <id>iterable</id> is not present, let <id>iterable</id> be <value>undefined</value> .</step>
  <step>If <id>iterable</id> is either <value>undefined</value> or <value>null</value> , return <id>map</id> .</step>
  <step>Let <id>adder</id> be ? Get ( <id>map</id> , <value>"set"</value> ).</step>
  <step>If IsCallable ( <id>adder</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>iteratorRecord</id> be ? GetIterator ( <id>iterable</id> ).</step>
  <step>Repeat,   <step-list>
    <step>Let <id>next</id> be ? IteratorStep ( <id>iteratorRecord</id> ).</step>
    <step>If <id>next</id> is <value>false</value> , return <id>map</id> .</step>
    <step>Let <id>nextItem</id> be ? IteratorValue ( <id>next</id> ).</step>
    <step>If Type ( <id>nextItem</id> ) is not Object, then     <step-list>
      <step>Let <id>error</id> be ThrowCompletion (a newly created <value>TypeError</value> object).</step>
      <step>Return ? IteratorClose ( <id>iteratorRecord</id> , <id>error</id> ).</step>
    </step-list></step>
    <step>Let <id>k</id> be Get ( <id>nextItem</id> , <value>"0"</value> ).</step>
    <step>If <id>k</id> is an abrupt completion , return ? IteratorClose ( <id>iteratorRecord</id> , <id>k</id> ).</step>
    <step>Let <id>v</id> be Get ( <id>nextItem</id> , <value>"1"</value> ).</step>
    <step>If <id>v</id> is an abrupt completion , return ? IteratorClose ( <id>iteratorRecord</id> , <id>v</id> ).</step>
    <step>Let <id>status</id> be Call ( <id>adder</id> , <id>map</id> , « <id>k</id> .[[Value]], <id>v</id> .[[Value]] »).</step>
    <step>If <id>status</id> is an abrupt completion , return ? IteratorClose ( <id>iteratorRecord</id> , <id>status</id> ).</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Return the <value>this</value> value.</step>
</step-list>
<step-list>
  <step>Let <id>M</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>M</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>M</id> does not have a [[MapData]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>entries</id> be the List that is <id>M</id> .[[MapData]].</step>
  <step>For each Record { [[Key]], [[Value]] } <id>p</id> that is an element of <id>entries</id> , do   <step-list>
    <step>Set <id>p</id> .[[Key]] to <value>empty</value> .</step>
    <step>Set <id>p</id> .[[Value]] to <value>empty</value> .</step>
  </step-list></step>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Let <id>M</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>M</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>M</id> does not have a [[MapData]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>entries</id> be the List that is <id>M</id> .[[MapData]].</step>
  <step>For each Record { [[Key]], [[Value]] } <id>p</id> that is an element of <id>entries</id> , do   <step-list>
    <step>If <id>p</id> .[[Key]] is not <value>empty</value> and SameValueZero ( <id>p</id> .[[Key]], <id>key</id> ) is <value>true</value> , then     <step-list>
      <step>Set <id>p</id> .[[Key]] to <value>empty</value> .</step>
      <step>Set <id>p</id> .[[Value]] to <value>empty</value> .</step>
      <step>Return <value>true</value> .</step>
    </step-list></step>
  </step-list></step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>M</id> be the <value>this</value> value.</step>
  <step>Return ? CreateMapIterator ( <id>M</id> , <value>"key+value"</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>M</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>M</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>M</id> does not have a [[MapData]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>If IsCallable ( <id>callbackfn</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>If <id>thisArg</id> is present, let <id>T</id> be <id>thisArg</id> ; else let <id>T</id> be <value>undefined</value> .</step>
  <step>Let <id>entries</id> be the List that is <id>M</id> .[[MapData]].</step>
  <step>For each Record { [[Key]], [[Value]] } <id>e</id> that is an element of <id>entries</id> , in original key insertion order, do   <step-list>
    <step>If <id>e</id> .[[Key]] is not <value>empty</value> , then     <step-list>
      <step>Perform ? Call ( <id>callbackfn</id> , <id>T</id> , « <id>e</id> .[[Value]], <id>e</id> .[[Key]], <id>M</id> »).</step>
    </step-list></step>
  </step-list></step>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Let <id>M</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>M</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>M</id> does not have a [[MapData]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>entries</id> be the List that is <id>M</id> .[[MapData]].</step>
  <step>For each Record { [[Key]], [[Value]] } <id>p</id> that is an element of <id>entries</id> , do   <step-list>
    <step>If <id>p</id> .[[Key]] is not <value>empty</value> and SameValueZero ( <id>p</id> .[[Key]], <id>key</id> ) is <value>true</value> , return <id>p</id> .[[Value]].</step>
  </step-list></step>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Let <id>M</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>M</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>M</id> does not have a [[MapData]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>entries</id> be the List that is <id>M</id> .[[MapData]].</step>
  <step>For each Record { [[Key]], [[Value]] } <id>p</id> that is an element of <id>entries</id> , do   <step-list>
    <step>If <id>p</id> .[[Key]] is not <value>empty</value> and SameValueZero ( <id>p</id> .[[Key]], <id>key</id> ) is <value>true</value> , return <value>true</value> .</step>
  </step-list></step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>M</id> be the <value>this</value> value.</step>
  <step>Return ? CreateMapIterator ( <id>M</id> , <value>"key"</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>M</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>M</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>M</id> does not have a [[MapData]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>entries</id> be the List that is <id>M</id> .[[MapData]].</step>
  <step>For each Record { [[Key]], [[Value]] } <id>p</id> that is an element of <id>entries</id> , do   <step-list>
    <step>If <id>p</id> .[[Key]] is not <value>empty</value> and SameValueZero ( <id>p</id> .[[Key]], <id>key</id> ) is <value>true</value> , then     <step-list>
      <step>Set <id>p</id> .[[Value]] to <id>value</id> .</step>
      <step>Return <id>M</id> .</step>
    </step-list></step>
  </step-list></step>
  <step>If <id>key</id> is <value>-0</value> , let <id>key</id> be <value>+0</value> .</step>
  <step>Let <id>p</id> be the Record { [[Key]]: <id>key</id> , [[Value]]: <id>value</id> }.</step>
  <step>Append <id>p</id> as the last element of <id>entries</id> .</step>
  <step>Return <id>M</id> .</step>
</step-list>
<step-list>
  <step>Let <id>M</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>M</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>M</id> does not have a [[MapData]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>entries</id> be the List that is <id>M</id> .[[MapData]].</step>
  <step>Let <id>count</id> be 0.</step>
  <step>For each Record { [[Key]], [[Value]] } <id>p</id> that is an element of <id>entries</id> , do   <step-list>
    <step>If <id>p</id> .[[Key]] is not <value>empty</value> , set <id>count</id> to <id>count</id> +1.</step>
  </step-list></step>
  <step>Return <id>count</id> .</step>
</step-list>
<step-list>
  <step>Let <id>M</id> be the <value>this</value> value.</step>
  <step>Return ? CreateMapIterator ( <id>M</id> , <value>"value"</value> ).</step>
</step-list>
<step-list>
  <step>If Type ( <id>map</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>map</id> does not have a [[MapData]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>iterator</id> be ObjectCreate ( %MapIteratorPrototype% , « [[Map]], [[MapNextIndex]], [[MapIterationKind]] »).</step>
  <step>Set <id>iterator</id> .[[Map]] to <id>map</id> .</step>
  <step>Set <id>iterator</id> .[[MapNextIndex]] to 0.</step>
  <step>Set <id>iterator</id> .[[MapIterationKind]] to <id>kind</id> .</step>
  <step>Return <id>iterator</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>O</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>O</id> does not have all of the internal slots of a Map Iterator Instance ( 23.1.5.3 ), throw a <value>TypeError</value> exception.</step>
  <step>Let <id>m</id> be <id>O</id> .[[Map]].</step>
  <step>Let <id>index</id> be <id>O</id> .[[MapNextIndex]].</step>
  <step>Let <id>itemKind</id> be <id>O</id> .[[MapIterationKind]].</step>
  <step>If <id>m</id> is <value>undefined</value> , return CreateIterResultObject ( <value>undefined</value> , <value>true</value> ).</step>
  <step>Assert : <id>m</id> has a [[MapData]] internal slot.</step>
  <step>Let <id>entries</id> be the List that is <id>m</id> .[[MapData]].</step>
  <step>Let <id>numEntries</id> be the number of elements of <id>entries</id> .</step>
  <step>NOTE: <id>numEntries</id> must be redetermined each time this method is evaluated.</step>
  <step>Repeat, while <id>index</id> is less than <id>numEntries</id> ,   <step-list>
    <step>Let <id>e</id> be the Record { [[Key]], [[Value]] } that is the value of <id>entries</id> [ <id>index</id> ].</step>
    <step>Set <id>index</id> to <id>index</id> +1.</step>
    <step>Set <id>O</id> .[[MapNextIndex]] to <id>index</id> .</step>
    <step>If <id>e</id> .[[Key]] is not <value>empty</value> , then     <step-list>
      <step>If <id>itemKind</id> is <value>"key"</value> , let <id>result</id> be <id>e</id> .[[Key]].</step>
      <step>Else if <id>itemKind</id> is <value>"value"</value> , let <id>result</id> be <id>e</id> .[[Value]].</step>
      <step>Else,       <step-list>
        <step>Assert : <id>itemKind</id> is <value>"key+value"</value> .</step>
        <step>Let <id>result</id> be CreateArrayFromList (« <id>e</id> .[[Key]], <id>e</id> .[[Value]] »).</step>
      </step-list></step>
      <step>Return CreateIterResultObject ( <id>result</id> , <value>false</value> ).</step>
    </step-list></step>
  </step-list></step>
  <step>Set <id>O</id> .[[Map]] to <value>undefined</value> .</step>
  <step>Return CreateIterResultObject ( <value>undefined</value> , <value>true</value> ).</step>
</step-list>
<step-list>
  <step>If NewTarget is <value>undefined</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>set</id> be ? OrdinaryCreateFromConstructor (NewTarget, <value>"%SetPrototype%"</value> , « [[SetData]] »).</step>
  <step>Set <id>set</id> .[[SetData]] to a new empty List .</step>
  <step>If <id>iterable</id> is not present, let <id>iterable</id> be <value>undefined</value> .</step>
  <step>If <id>iterable</id> is either <value>undefined</value> or <value>null</value> , return <id>set</id> .</step>
  <step>Let <id>adder</id> be ? Get ( <id>set</id> , <value>"add"</value> ).</step>
  <step>If IsCallable ( <id>adder</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>iteratorRecord</id> be ? GetIterator ( <id>iterable</id> ).</step>
  <step>Repeat,   <step-list>
    <step>Let <id>next</id> be ? IteratorStep ( <id>iteratorRecord</id> ).</step>
    <step>If <id>next</id> is <value>false</value> , return <id>set</id> .</step>
    <step>Let <id>nextValue</id> be ? IteratorValue ( <id>next</id> ).</step>
    <step>Let <id>status</id> be Call ( <id>adder</id> , <id>set</id> , « <id>nextValue</id> .[[Value]] »).</step>
    <step>If <id>status</id> is an abrupt completion , return ? IteratorClose ( <id>iteratorRecord</id> , <id>status</id> ).</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Return the <value>this</value> value.</step>
</step-list>
<step-list>
  <step>Let <id>S</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>S</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>S</id> does not have a [[SetData]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>entries</id> be the List that is <id>S</id> .[[SetData]].</step>
  <step>For each <id>e</id> that is an element of <id>entries</id> , do   <step-list>
    <step>If <id>e</id> is not <value>empty</value> and SameValueZero ( <id>e</id> , <id>value</id> ) is <value>true</value> , then     <step-list>
      <step>Return <id>S</id> .</step>
    </step-list></step>
  </step-list></step>
  <step>If <id>value</id> is <value>-0</value> , let <id>value</id> be <value>+0</value> .</step>
  <step>Append <id>value</id> as the last element of <id>entries</id> .</step>
  <step>Return <id>S</id> .</step>
</step-list>
<step-list>
  <step>Let <id>S</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>S</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>S</id> does not have a [[SetData]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>entries</id> be the List that is <id>S</id> .[[SetData]].</step>
  <step>For each <id>e</id> that is an element of <id>entries</id> , do   <step-list>
    <step>Replace the element of <id>entries</id> whose value is <id>e</id> with an element whose value is <value>empty</value> .</step>
  </step-list></step>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Let <id>S</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>S</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>S</id> does not have a [[SetData]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>entries</id> be the List that is <id>S</id> .[[SetData]].</step>
  <step>For each <id>e</id> that is an element of <id>entries</id> , do   <step-list>
    <step>If <id>e</id> is not <value>empty</value> and SameValueZero ( <id>e</id> , <id>value</id> ) is <value>true</value> , then     <step-list>
      <step>Replace the element of <id>entries</id> whose value is <id>e</id> with an element whose value is <value>empty</value> .</step>
      <step>Return <value>true</value> .</step>
    </step-list></step>
  </step-list></step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>S</id> be the <value>this</value> value.</step>
  <step>Return ? CreateSetIterator ( <id>S</id> , <value>"key+value"</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>S</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>S</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>S</id> does not have a [[SetData]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>If IsCallable ( <id>callbackfn</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>If <id>thisArg</id> is present, let <id>T</id> be <id>thisArg</id> ; else let <id>T</id> be <value>undefined</value> .</step>
  <step>Let <id>entries</id> be the List that is <id>S</id> .[[SetData]].</step>
  <step>For each <id>e</id> that is an element of <id>entries</id> , in original insertion order, do   <step-list>
    <step>If <id>e</id> is not <value>empty</value> , then     <step-list>
      <step>Perform ? Call ( <id>callbackfn</id> , <id>T</id> , « <id>e</id> , <id>e</id> , <id>S</id> »).</step>
    </step-list></step>
  </step-list></step>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Let <id>S</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>S</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>S</id> does not have a [[SetData]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>entries</id> be the List that is <id>S</id> .[[SetData]].</step>
  <step>For each <id>e</id> that is an element of <id>entries</id> , do   <step-list>
    <step>If <id>e</id> is not <value>empty</value> and SameValueZero ( <id>e</id> , <id>value</id> ) is <value>true</value> , return <value>true</value> .</step>
  </step-list></step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>S</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>S</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>S</id> does not have a [[SetData]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>entries</id> be the List that is <id>S</id> .[[SetData]].</step>
  <step>Let <id>count</id> be 0.</step>
  <step>For each <id>e</id> that is an element of <id>entries</id> , do   <step-list>
    <step>If <id>e</id> is not <value>empty</value> , set <id>count</id> to <id>count</id> +1.</step>
  </step-list></step>
  <step>Return <id>count</id> .</step>
</step-list>
<step-list>
  <step>Let <id>S</id> be the <value>this</value> value.</step>
  <step>Return ? CreateSetIterator ( <id>S</id> , <value>"value"</value> ).</step>
</step-list>
<step-list>
  <step>If Type ( <id>set</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>set</id> does not have a [[SetData]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>iterator</id> be ObjectCreate ( %SetIteratorPrototype% , « [[IteratedSet]], [[SetNextIndex]], [[SetIterationKind]] »).</step>
  <step>Set <id>iterator</id> .[[IteratedSet]] to <id>set</id> .</step>
  <step>Set <id>iterator</id> .[[SetNextIndex]] to 0.</step>
  <step>Set <id>iterator</id> .[[SetIterationKind]] to <id>kind</id> .</step>
  <step>Return <id>iterator</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>O</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>O</id> does not have all of the internal slots of a Set Iterator Instance ( 23.2.5.3 ), throw a <value>TypeError</value> exception.</step>
  <step>Let <id>s</id> be <id>O</id> .[[IteratedSet]].</step>
  <step>Let <id>index</id> be <id>O</id> .[[SetNextIndex]].</step>
  <step>Let <id>itemKind</id> be <id>O</id> .[[SetIterationKind]].</step>
  <step>If <id>s</id> is <value>undefined</value> , return CreateIterResultObject ( <value>undefined</value> , <value>true</value> ).</step>
  <step>Assert : <id>s</id> has a [[SetData]] internal slot.</step>
  <step>Let <id>entries</id> be the List that is <id>s</id> .[[SetData]].</step>
  <step>Let <id>numEntries</id> be the number of elements of <id>entries</id> .</step>
  <step>NOTE: <id>numEntries</id> must be redetermined each time this method is evaluated.</step>
  <step>Repeat, while <id>index</id> is less than <id>numEntries</id> ,   <step-list>
    <step>Let <id>e</id> be <id>entries</id> [ <id>index</id> ].</step>
    <step>Set <id>index</id> to <id>index</id> +1.</step>
    <step>Set <id>O</id> .[[SetNextIndex]] to <id>index</id> .</step>
    <step>If <id>e</id> is not <value>empty</value> , then     <step-list>
      <step>If <id>itemKind</id> is <value>"key+value"</value> , then       <step-list>
        <step>Return CreateIterResultObject ( CreateArrayFromList (« <id>e</id> , <id>e</id> »), <value>false</value> ).</step>
      </step-list></step>
      <step>Return CreateIterResultObject ( <id>e</id> , <value>false</value> ).</step>
    </step-list></step>
  </step-list></step>
  <step>Set <id>O</id> .[[IteratedSet]] to <value>undefined</value> .</step>
  <step>Return CreateIterResultObject ( <value>undefined</value> , <value>true</value> ).</step>
</step-list>
<step-list>
  <step>If NewTarget is <value>undefined</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>map</id> be ? OrdinaryCreateFromConstructor (NewTarget, <value>"%WeakMapPrototype%"</value> , « [[WeakMapData]] »).</step>
  <step>Set <id>map</id> .[[WeakMapData]] to a new empty List .</step>
  <step>If <id>iterable</id> is not present, let <id>iterable</id> be <value>undefined</value> .</step>
  <step>If <id>iterable</id> is either <value>undefined</value> or <value>null</value> , return <id>map</id> .</step>
  <step>Let <id>adder</id> be ? Get ( <id>map</id> , <value>"set"</value> ).</step>
  <step>If IsCallable ( <id>adder</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>iteratorRecord</id> be ? GetIterator ( <id>iterable</id> ).</step>
  <step>Repeat,   <step-list>
    <step>Let <id>next</id> be ? IteratorStep ( <id>iterRecord</id> ).</step>
    <step>If <id>next</id> is <value>false</value> , return <id>map</id> .</step>
    <step>Let <id>nextItem</id> be ? IteratorValue ( <id>next</id> ).</step>
    <step>If Type ( <id>nextItem</id> ) is not Object, then     <step-list>
      <step>Let <id>error</id> be ThrowCompletion (a newly created <value>TypeError</value> object).</step>
      <step>Return ? IteratorClose ( <id>iteratorRecord</id> , <id>error</id> ).</step>
    </step-list></step>
    <step>Let <id>k</id> be Get ( <id>nextItem</id> , <value>"0"</value> ).</step>
    <step>If <id>k</id> is an abrupt completion , return ? IteratorClose ( <id>iteratorRecord</id> , <id>k</id> ).</step>
    <step>Let <id>v</id> be Get ( <id>nextItem</id> , <value>"1"</value> ).</step>
    <step>If <id>v</id> is an abrupt completion , return ? IteratorClose ( <id>iteratorRecord</id> , <id>v</id> ).</step>
    <step>Let <id>status</id> be Call ( <id>adder</id> , <id>map</id> , « <id>k</id> .[[Value]], <id>v</id> .[[Value]] »).</step>
    <step>If <id>status</id> is an abrupt completion , return ? IteratorClose ( <id>iteratorRecord</id> , <id>status</id> ).</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>M</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>M</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>M</id> does not have a [[WeakMapData]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>entries</id> be the List that is <id>M</id> .[[WeakMapData]].</step>
  <step>If Type ( <id>key</id> ) is not Object, return <value>false</value> .</step>
  <step>For each Record { [[Key]], [[Value]] } <id>p</id> that is an element of <id>entries</id> , do   <step-list>
    <step>If <id>p</id> .[[Key]] is not <value>empty</value> and SameValue ( <id>p</id> .[[Key]], <id>key</id> ) is <value>true</value> , then     <step-list>
      <step>Set <id>p</id> .[[Key]] to <value>empty</value> .</step>
      <step>Set <id>p</id> .[[Value]] to <value>empty</value> .</step>
      <step>Return <value>true</value> .</step>
    </step-list></step>
  </step-list></step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>M</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>M</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>M</id> does not have a [[WeakMapData]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>entries</id> be the List that is <id>M</id> .[[WeakMapData]].</step>
  <step>If Type ( <id>key</id> ) is not Object, return <value>undefined</value> .</step>
  <step>For each Record { [[Key]], [[Value]] } <id>p</id> that is an element of <id>entries</id> , do   <step-list>
    <step>If <id>p</id> .[[Key]] is not <value>empty</value> and SameValue ( <id>p</id> .[[Key]], <id>key</id> ) is <value>true</value> , return <id>p</id> .[[Value]].</step>
  </step-list></step>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Let <id>M</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>M</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>M</id> does not have a [[WeakMapData]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>entries</id> be the List that is <id>M</id> .[[WeakMapData]].</step>
  <step>If Type ( <id>key</id> ) is not Object, return <value>false</value> .</step>
  <step>For each Record { [[Key]], [[Value]] } <id>p</id> that is an element of <id>entries</id> , do   <step-list>
    <step>If <id>p</id> .[[Key]] is not <value>empty</value> and SameValue ( <id>p</id> .[[Key]], <id>key</id> ) is <value>true</value> , return <value>true</value> .</step>
  </step-list></step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>M</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>M</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>M</id> does not have a [[WeakMapData]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>entries</id> be the List that is <id>M</id> .[[WeakMapData]].</step>
  <step>If Type ( <id>key</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>For each Record { [[Key]], [[Value]] } <id>p</id> that is an element of <id>entries</id> , do   <step-list>
    <step>If <id>p</id> .[[Key]] is not <value>empty</value> and SameValue ( <id>p</id> .[[Key]], <id>key</id> ) is <value>true</value> , then     <step-list>
      <step>Set <id>p</id> .[[Value]] to <id>value</id> .</step>
      <step>Return <id>M</id> .</step>
    </step-list></step>
  </step-list></step>
  <step>Let <id>p</id> be the Record { [[Key]]: <id>key</id> , [[Value]]: <id>value</id> }.</step>
  <step>Append <id>p</id> as the last element of <id>entries</id> .</step>
  <step>Return <id>M</id> .</step>
</step-list>
<step-list>
  <step>If NewTarget is <value>undefined</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>set</id> be ? OrdinaryCreateFromConstructor (NewTarget, <value>"%WeakSetPrototype%"</value> , « [[WeakSetData]] »).</step>
  <step>Set <id>set</id> .[[WeakSetData]] to a new empty List .</step>
  <step>If <id>iterable</id> is not present, let <id>iterable</id> be <value>undefined</value> .</step>
  <step>If <id>iterable</id> is either <value>undefined</value> or <value>null</value> , return <id>set</id> .</step>
  <step>Let <id>adder</id> be ? Get ( <id>set</id> , <value>"add"</value> ).</step>
  <step>If IsCallable ( <id>adder</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>iteratorRecord</id> be ? GetIterator ( <id>iterable</id> ).</step>
  <step>Repeat,   <step-list>
    <step>Let <id>next</id> be ? IteratorStep ( <id>iteratorRecord</id> ).</step>
    <step>If <id>next</id> is <value>false</value> , return <id>set</id> .</step>
    <step>Let <id>nextValue</id> be ? IteratorValue ( <id>next</id> ).</step>
    <step>Let <id>status</id> be Call ( <id>adder</id> , <id>set</id> , « <id>nextValue</id> »).</step>
    <step>If <id>status</id> is an abrupt completion , return ? IteratorClose ( <id>iteratorRecord</id> , <id>status</id> ).</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>S</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>S</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>S</id> does not have a [[WeakSetData]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>If Type ( <id>value</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>entries</id> be the List that is <id>S</id> .[[WeakSetData]].</step>
  <step>For each <id>e</id> that is an element of <id>entries</id> , do   <step-list>
    <step>If <id>e</id> is not <value>empty</value> and SameValue ( <id>e</id> , <id>value</id> ) is <value>true</value> , then     <step-list>
      <step>Return <id>S</id> .</step>
    </step-list></step>
  </step-list></step>
  <step>Append <id>value</id> as the last element of <id>entries</id> .</step>
  <step>Return <id>S</id> .</step>
</step-list>
<step-list>
  <step>Let <id>S</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>S</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>S</id> does not have a [[WeakSetData]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>If Type ( <id>value</id> ) is not Object, return <value>false</value> .</step>
  <step>Let <id>entries</id> be the List that is <id>S</id> .[[WeakSetData]].</step>
  <step>For each <id>e</id> that is an element of <id>entries</id> , do   <step-list>
    <step>If <id>e</id> is not <value>empty</value> and SameValue ( <id>e</id> , <id>value</id> ) is <value>true</value> , then     <step-list>
      <step>Replace the element of <id>entries</id> whose value is <id>e</id> with an element whose value is <value>empty</value> .</step>
      <step>Return <value>true</value> .</step>
    </step-list></step>
  </step-list></step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>S</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>S</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>S</id> does not have a [[WeakSetData]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>entries</id> be the List that is <id>S</id> .[[WeakSetData]].</step>
  <step>If Type ( <id>value</id> ) is not Object, return <value>false</value> .</step>
  <step>For each <id>e</id> that is an element of <id>entries</id> , do   <step-list>
    <step>If <id>e</id> is not <value>empty</value> and SameValue ( <id>e</id> , <id>value</id> ) is <value>true</value> , return <value>true</value> .</step>
  </step-list></step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>obj</id> be ? OrdinaryCreateFromConstructor ( <id>constructor</id> , <value>"%ArrayBufferPrototype%"</value> , « [[ArrayBufferData]], [[ArrayBufferByteLength]], [[ArrayBufferDetachKey]] »).</step>
  <step>Assert : <id>byteLength</id> is an integer value ≥ 0.</step>
  <step>Let <id>block</id> be ? CreateByteDataBlock ( <id>byteLength</id> ).</step>
  <step>Set <id>obj</id> .[[ArrayBufferData]] to <id>block</id> .</step>
  <step>Set <id>obj</id> .[[ArrayBufferByteLength]] to <id>byteLength</id> .</step>
  <step>Return <id>obj</id> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>arrayBuffer</id> ) is Object and it has an [[ArrayBufferData]] internal slot.</step>
  <step>If <id>arrayBuffer</id> .[[ArrayBufferData]] is <value>null</value> , return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>arrayBuffer</id> ) is Object and it has [[ArrayBufferData]], [[ArrayBufferByteLength]], and [[ArrayBufferDetachKey]] internal slots.</step>
  <step>Assert : IsSharedArrayBuffer ( <id>arrayBuffer</id> ) is <value>false</value> .</step>
  <step>If <id>key</id> is not present, set <id>key</id> to <value>undefined</value> .</step>
  <step>If SameValue ( <id>arrayBuffer</id> .[[ArrayBufferDetachKey]], <id>key</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Set <id>arrayBuffer</id> .[[ArrayBufferData]] to <value>null</value> .</step>
  <step>Set <id>arrayBuffer</id> .[[ArrayBufferByteLength]] to 0.</step>
  <step>Return NormalCompletion ( <value>null</value> ).</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>srcBuffer</id> ) is Object and it has an [[ArrayBufferData]] internal slot.</step>
  <step>Assert : IsConstructor ( <id>cloneConstructor</id> ) is <value>true</value> .</step>
  <step>Let <id>targetBuffer</id> be ? AllocateArrayBuffer ( <id>cloneConstructor</id> , <id>srcLength</id> ).</step>
  <step>If IsDetachedBuffer ( <id>srcBuffer</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>srcBlock</id> be <id>srcBuffer</id> .[[ArrayBufferData]].</step>
  <step>Let <id>targetBlock</id> be <id>targetBuffer</id> .[[ArrayBufferData]].</step>
  <step>Perform CopyDataBlockBytes ( <id>targetBlock</id> , 0, <id>srcBlock</id> , <id>srcByteOffset</id> , <id>srcLength</id> ).</step>
  <step>Return <id>targetBuffer</id> .</step>
</step-list>
<step-list>
  <step>Let <id>elementSize</id> be the Number value of the Element Size value specified in Table 56 for Element Type <id>type</id> .</step>
  <step>If <id>isLittleEndian</id> is <value>false</value> , reverse the order of the elements of <id>rawBytes</id> .</step>
  <step>If <id>type</id> is <value>"Float32"</value> , then   <step-list>
    <step>Let <id>value</id> be the byte elements of <id>rawBytes</id> concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2008 binary32 value.</step>
    <step>If <id>value</id> is an IEEE 754-2008 binary32 NaN value, return the <value>NaN</value> Number value.</step>
    <step>Return the Number value that corresponds to <id>value</id> .</step>
  </step-list></step>
  <step>If <id>type</id> is <value>"Float64"</value> , then   <step-list>
    <step>Let <id>value</id> be the byte elements of <id>rawBytes</id> concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2008 binary64 value.</step>
    <step>If <id>value</id> is an IEEE 754-2008 binary64 NaN value, return the <value>NaN</value> Number value.</step>
    <step>Return the Number value that corresponds to <id>value</id> .</step>
  </step-list></step>
  <step>If the first code unit of <id>type</id> is the code unit 0x0055 (LATIN CAPITAL LETTER U), then   <step-list>
    <step>Let <id>intValue</id> be the byte elements of <id>rawBytes</id> concatenated and interpreted as a bit string encoding of an unsigned little-endian binary number.</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>intValue</id> be the byte elements of <id>rawBytes</id> concatenated and interpreted as a bit string encoding of a binary little-endian 2's complement number of bit length <id>elementSize</id> × 8.</step>
  </step-list></step>
  <step>Return the Number value that corresponds to <id>intValue</id> .</step>
</step-list>
<step-list>
  <step>Assert : IsDetachedBuffer ( <id>arrayBuffer</id> ) is <value>false</value> .</step>
  <step>Assert : There are sufficient bytes in <id>arrayBuffer</id> starting at <id>byteIndex</id> to represent a value of <id>type</id> .</step>
  <step>Assert : <id>byteIndex</id> is an integer value ≥ 0.</step>
  <step>Let <id>block</id> be <id>arrayBuffer</id> .[[ArrayBufferData]].</step>
  <step>Let <id>elementSize</id> be the Number value of the Element Size value specified in Table 56 for Element Type <id>type</id> .</step>
  <step>If IsSharedArrayBuffer ( <id>arrayBuffer</id> ) is <value>true</value> , then   <step-list>
    <step>Let <id>execution</id> be the [[CandidateExecution]] field of the surrounding agent 's Agent Record .</step>
    <step>Let <id>eventList</id> be the [[EventList]] field of the element in <id>execution</id> .[[EventLists]] whose [[AgentSignifier]] is AgentSignifier ().</step>
    <step>If <id>isTypedArray</id> is <value>true</value> and <id>type</id> is <value>"Int8"</value> , <value>"Uint8"</value> , <value>"Int16"</value> , <value>"Uint16"</value> , <value>"Int32"</value> , or <value>"Uint32"</value> , let <id>noTear</id> be <value>true</value> ; otherwise let <id>noTear</id> be <value>false</value> .</step>
    <step>Let <id>rawValue</id> be a List of length <id>elementSize</id> of nondeterministically chosen byte values.</step>
    <step>NOTE: In implementations, <id>rawValue</id> is the result of a non-atomic or atomic read instruction on the 
underlying hardware. The nondeterminism is a semantic prescription of 
the memory model to describe observable behaviour of hardware with weak consistency.</step>
    <step>Let <id>readEvent</id> be ReadSharedMemory { [[Order]]: <id>order</id> , [[NoTear]]: <id>noTear</id> , [[Block]]: <id>block</id> , [[ByteIndex]]: <id>byteIndex</id> , [[ElementSize]]: <id>elementSize</id> }.</step>
    <step>Append <id>readEvent</id> to <id>eventList</id> .</step>
    <step>Append Chosen Value Record { [[Event]]: <id>readEvent</id> , [[ChosenValue]]: <id>rawValue</id> } to <id>execution</id> .[[ChosenValues]].</step>
  </step-list></step>
  <step>Else, let <id>rawValue</id> be a List of <id>elementSize</id> containing, in order, the <id>elementSize</id> sequence of bytes starting with <id>block</id> [ <id>byteIndex</id> ].</step>
  <step>If <id>isLittleEndian</id> is not present, set <id>isLittleEndian</id> to the value of the [[LittleEndian]] field of the surrounding agent 's Agent Record .</step>
  <step>Return RawBytesToNumber ( <id>type</id> , <id>rawValue</id> , <id>isLittleEndian</id> ).</step>
</step-list>
<step-list>
  <step>If <id>type</id> is <value>"Float32"</value> , then   <step-list>
    <step>Let <id>rawBytes</id> be a List containing the 4 bytes that are the result of converting <id>value</id> to IEEE 754-2008 binary32 format using “Round to nearest, ties to even” rounding mode. If <id>isLittleEndian</id> is <value>false</value> , the bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If <id>value</id> is <value>NaN</value> , <id>rawBytes</id> may be set to any implementation chosen IEEE 754-2008 binary32 format 
Not-a-Number encoding. An implementation must always choose the same 
encoding for each implementation distinguishable <value>NaN</value> value.</step>
  </step-list></step>
  <step>Else if <id>type</id> is <value>"Float64"</value> , then   <step-list>
    <step>Let <id>rawBytes</id> be a List containing the 8 bytes that are the IEEE 754-2008 binary64 format encoding of <id>value</id> . If <id>isLittleEndian</id> is <value>false</value> , the bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If <id>value</id> is <value>NaN</value> , <id>rawBytes</id> may be set to any implementation chosen IEEE 754-2008 binary64 format 
Not-a-Number encoding. An implementation must always choose the same 
encoding for each implementation distinguishable <value>NaN</value> value.</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>n</id> be the Number value of the Element Size specified in Table 56 for Element Type <id>type</id> .</step>
    <step>Let <id>convOp</id> be the abstract operation named in the Conversion Operation column in Table 56 for Element Type <id>type</id> .</step>
    <step>Let <id>intValue</id> be <id>convOp</id> ( <id>value</id> ).</step>
    <step>If <id>intValue</id> ≥ 0, then     <step-list>
      <step>Let <id>rawBytes</id> be a List containing the <id>n</id> -byte binary encoding of <id>intValue</id> . If <id>isLittleEndian</id> is <value>false</value> , the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.</step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>Let <id>rawBytes</id> be a List containing the <id>n</id> -byte binary 2's complement encoding of <id>intValue</id> . If <id>isLittleEndian</id> is <value>false</value> , the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.</step>
    </step-list></step>
  </step-list></step>
  <step>Return <id>rawBytes</id> .</step>
</step-list>
<step-list>
  <step>Assert : IsDetachedBuffer ( <id>arrayBuffer</id> ) is <value>false</value> .</step>
  <step>Assert : There are sufficient bytes in <id>arrayBuffer</id> starting at <id>byteIndex</id> to represent a value of <id>type</id> .</step>
  <step>Assert : <id>byteIndex</id> is an integer value ≥ 0.</step>
  <step>Assert : Type ( <id>value</id> ) is Number.</step>
  <step>Let <id>block</id> be <id>arrayBuffer</id> .[[ArrayBufferData]].</step>
  <step>Let <id>elementSize</id> be the Number value of the Element Size value specified in Table 56 for Element Type <id>type</id> .</step>
  <step>If <id>isLittleEndian</id> is not present, set <id>isLittleEndian</id> to the value of the [[LittleEndian]] field of the surrounding agent 's Agent Record .</step>
  <step>Let <id>rawBytes</id> be NumberToRawBytes ( <id>type</id> , <id>value</id> , <id>isLittleEndian</id> ).</step>
  <step>If IsSharedArrayBuffer ( <id>arrayBuffer</id> ) is <value>true</value> , then   <step-list>
    <step>Let <id>execution</id> be the [[CandidateExecution]] field of the surrounding agent 's Agent Record .</step>
    <step>Let <id>eventList</id> be the [[EventList]] field of the element in <id>execution</id> .[[EventLists]] whose [[AgentSignifier]] is AgentSignifier ().</step>
    <step>If <id>isTypedArray</id> is <value>true</value> and <id>type</id> is <value>"Int8"</value> , <value>"Uint8"</value> , <value>"Int16"</value> , <value>"Uint16"</value> , <value>"Int32"</value> , or <value>"Uint32"</value> , let <id>noTear</id> be <value>true</value> ; otherwise let <id>noTear</id> be <value>false</value> .</step>
    <step>Append WriteSharedMemory { [[Order]]: <id>order</id> , [[NoTear]]: <id>noTear</id> , [[Block]]: <id>block</id> , [[ByteIndex]]: <id>byteIndex</id> , [[ElementSize]]: <id>elementSize</id> , [[Payload]]: <id>rawBytes</id> } to <id>eventList</id> .</step>
  </step-list></step>
  <step>Else, store the individual bytes of <id>rawBytes</id> into <id>block</id> , in order, starting at <id>block</id> [ <id>byteIndex</id> ].</step>
  <step>Return NormalCompletion ( <value>undefined</value> ).</step>
</step-list>
<step-list>
  <step>Assert : IsSharedArrayBuffer ( <id>arrayBuffer</id> ) is <value>true</value> .</step>
  <step>Assert : There are sufficient bytes in <id>arrayBuffer</id> starting at <id>byteIndex</id> to represent a value of <id>type</id> .</step>
  <step>Assert : <id>byteIndex</id> is an integer value ≥ 0.</step>
  <step>Assert : Type ( <id>value</id> ) is Number.</step>
  <step>Let <id>block</id> be <id>arrayBuffer</id> .[[ArrayBufferData]].</step>
  <step>Let <id>elementSize</id> be the Number value of the Element Size value specified in Table 56 for Element Type <id>type</id> .</step>
  <step>If <id>isLittleEndian</id> is not present, set <id>isLittleEndian</id> to the value of the [[LittleEndian]] field of the surrounding agent 's Agent Record .</step>
  <step>Let <id>rawBytes</id> be NumberToRawBytes ( <id>type</id> , <id>value</id> , <id>isLittleEndian</id> ).</step>
  <step>Let <id>execution</id> be the [[CandidateExecution]] field of the surrounding agent 's Agent Record .</step>
  <step>Let <id>eventList</id> be the [[EventList]] field of the element in <id>execution</id> .[[EventLists]] whose [[AgentSignifier]] is AgentSignifier ().</step>
  <step>Let <id>rawBytesRead</id> be a List of length <id>elementSize</id> of nondeterministically chosen byte values.</step>
  <step>NOTE: In implementations, <id>rawBytesRead</id> is the result of a load-link, of a load-exclusive, or of an operand of a
 read-modify-write instruction on the underlying hardware. The 
nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.</step>
  <step>Let <id>rmwEvent</id> be ReadModifyWriteSharedMemory { [[Order]]: <value>"SeqCst"</value> , [[NoTear]]: <value>true</value> , [[Block]]: <id>block</id> , [[ByteIndex]]: <id>byteIndex</id> , [[ElementSize]]: <id>elementSize</id> , [[Payload]]: <id>rawBytes</id> , [[ModifyOp]]: <id>op</id> }.</step>
  <step>Append <id>rmwEvent</id> to <id>eventList</id> .</step>
  <step>Append Chosen Value Record { [[Event]]: <id>rmwEvent</id> , [[ChosenValue]]: <id>rawBytesRead</id> } to <id>execution</id> .[[ChosenValues]].</step>
  <step>Return RawBytesToNumber ( <id>type</id> , <id>rawBytesRead</id> , <id>isLittleEndian</id> ).</step>
</step-list>
<step-list>
  <step>If NewTarget is <value>undefined</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>byteLength</id> be ? ToIndex ( <id>length</id> ).</step>
  <step>Return ? AllocateArrayBuffer (NewTarget, <id>byteLength</id> ).</step>
</step-list>
<step-list>
  <step>If Type ( <id>arg</id> ) is not Object, return <value>false</value> .</step>
  <step>If <id>arg</id> has a [[ViewedArrayBuffer]] internal slot, return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return the <value>this</value> value.</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>O</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>O</id> does not have an [[ArrayBufferData]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>If IsSharedArrayBuffer ( <id>O</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  <step>If IsDetachedBuffer ( <id>O</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>length</id> be <id>O</id> .[[ArrayBufferByteLength]].</step>
  <step>Return <id>length</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>O</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>O</id> does not have an [[ArrayBufferData]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>If IsSharedArrayBuffer ( <id>O</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  <step>If IsDetachedBuffer ( <id>O</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>len</id> be <id>O</id> .[[ArrayBufferByteLength]].</step>
  <step>Let <id>relativeStart</id> be ? ToInteger ( <id>start</id> ).</step>
  <step>If <id>relativeStart</id> < 0, let <id>first</id> be max (( <id>len</id> + <id>relativeStart</id> ), 0); else let <id>first</id> be min ( <id>relativeStart</id> , <id>len</id> ).</step>
  <step>If <id>end</id> is <value>undefined</value> , let <id>relativeEnd</id> be <id>len</id> ; else let <id>relativeEnd</id> be ? ToInteger ( <id>end</id> ).</step>
  <step>If <id>relativeEnd</id> < 0, let <id>final</id> be max (( <id>len</id> + <id>relativeEnd</id> ), 0); else let <id>final</id> be min ( <id>relativeEnd</id> , <id>len</id> ).</step>
  <step>Let <id>newLen</id> be max ( <id>final</id> - <id>first</id> , 0).</step>
  <step>Let <id>ctor</id> be ? SpeciesConstructor ( <id>O</id> , %ArrayBuffer% ).</step>
  <step>Let <id>new</id> be ? Construct ( <id>ctor</id> , « <id>newLen</id> »).</step>
  <step>If <id>new</id> does not have an [[ArrayBufferData]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>If IsSharedArrayBuffer ( <id>new</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  <step>If IsDetachedBuffer ( <id>new</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  <step>If SameValue ( <id>new</id> , <id>O</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  <step>If <id>new</id> .[[ArrayBufferByteLength]] < <id>newLen</id> , throw a <value>TypeError</value> exception.</step>
  <step>NOTE: Side-effects of the above steps may have detached <id>O</id> .</step>
  <step>If IsDetachedBuffer ( <id>O</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>fromBuf</id> be <id>O</id> .[[ArrayBufferData]].</step>
  <step>Let <id>toBuf</id> be <id>new</id> .[[ArrayBufferData]].</step>
  <step>Perform CopyDataBlockBytes ( <id>toBuf</id> , 0, <id>fromBuf</id> , <id>first</id> , <id>newLen</id> ).</step>
  <step>Return <id>new</id> .</step>
</step-list>
<step-list>
  <step>Let <id>obj</id> be ? OrdinaryCreateFromConstructor ( <id>constructor</id> , <value>"%SharedArrayBufferPrototype%"</value> , « [[ArrayBufferData]], [[ArrayBufferByteLength]] »).</step>
  <step>Assert : <id>byteLength</id> is a nonnegative integer.</step>
  <step>Let <id>block</id> be ? CreateSharedByteDataBlock ( <id>byteLength</id> ).</step>
  <step>Set <id>obj</id> .[[ArrayBufferData]] to <id>block</id> .</step>
  <step>Set <id>obj</id> .[[ArrayBufferByteLength]] to <id>byteLength</id> .</step>
  <step>Return <id>obj</id> .</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>obj</id> ) is Object and it has an [[ArrayBufferData]] internal slot.</step>
  <step>Let <id>bufferData</id> be <id>obj</id> .[[ArrayBufferData]].</step>
  <step>If <id>bufferData</id> is <value>null</value> , return <value>false</value> .</step>
  <step>If <id>bufferData</id> is a Data Block , return <value>false</value> .</step>
  <step>Assert : <id>bufferData</id> is a Shared Data Block .</step>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>If NewTarget is <value>undefined</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>byteLength</id> be ? ToIndex ( <id>length</id> ).</step>
  <step>Return ? AllocateSharedArrayBuffer (NewTarget, <id>byteLength</id> ).</step>
</step-list>
<step-list>
  <step>Return the <value>this</value> value.</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>O</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>O</id> does not have an [[ArrayBufferData]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>If IsSharedArrayBuffer ( <id>O</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>length</id> be <id>O</id> .[[ArrayBufferByteLength]].</step>
  <step>Return <id>length</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>O</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>O</id> does not have an [[ArrayBufferData]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>If IsSharedArrayBuffer ( <id>O</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>len</id> be <id>O</id> .[[ArrayBufferByteLength]].</step>
  <step>Let <id>relativeStart</id> be ? ToInteger ( <id>start</id> ).</step>
  <step>If <id>relativeStart</id> < 0, let <id>first</id> be max (( <id>len</id> + <id>relativeStart</id> ), 0); else let <id>first</id> be min ( <id>relativeStart</id> , <id>len</id> ).</step>
  <step>If <id>end</id> is <value>undefined</value> , let <id>relativeEnd</id> be <id>len</id> ; else let <id>relativeEnd</id> be ? ToInteger ( <id>end</id> ).</step>
  <step>If <id>relativeEnd</id> < 0, let <id>final</id> be max (( <id>len</id> + <id>relativeEnd</id> ), 0); else let <id>final</id> be min ( <id>relativeEnd</id> , <id>len</id> ).</step>
  <step>Let <id>newLen</id> be max ( <id>final</id> - <id>first</id> , 0).</step>
  <step>Let <id>ctor</id> be ? SpeciesConstructor ( <id>O</id> , %SharedArrayBuffer% ).</step>
  <step>Let <id>new</id> be ? Construct ( <id>ctor</id> , « <id>newLen</id> »).</step>
  <step>If <id>new</id> does not have an [[ArrayBufferData]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>If IsSharedArrayBuffer ( <id>new</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>If <id>new</id> .[[ArrayBufferData]] and <id>O</id> .[[ArrayBufferData]] are the same Shared Data Block values, throw a <value>TypeError</value> exception.</step>
  <step>If <id>new</id> .[[ArrayBufferByteLength]] < <id>newLen</id> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>fromBuf</id> be <id>O</id> .[[ArrayBufferData]].</step>
  <step>Let <id>toBuf</id> be <id>new</id> .[[ArrayBufferData]].</step>
  <step>Perform CopyDataBlockBytes ( <id>toBuf</id> , 0, <id>fromBuf</id> , <id>first</id> , <id>newLen</id> ).</step>
  <step>Return <id>new</id> .</step>
</step-list>
<step-list>
  <step>If Type ( <id>view</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>view</id> does not have a [[DataView]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Assert : <id>view</id> has a [[ViewedArrayBuffer]] internal slot.</step>
  <step>Let <id>getIndex</id> be ? ToIndex ( <id>requestIndex</id> ).</step>
  <step>Set <id>isLittleEndian</id> to ToBoolean ( <id>isLittleEndian</id> ).</step>
  <step>Let <id>buffer</id> be <id>view</id> .[[ViewedArrayBuffer]].</step>
  <step>If IsDetachedBuffer ( <id>buffer</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>viewOffset</id> be <id>view</id> .[[ByteOffset]].</step>
  <step>Let <id>viewSize</id> be <id>view</id> .[[ByteLength]].</step>
  <step>Let <id>elementSize</id> be the Number value of the Element Size value specified in Table 56 for Element Type <id>type</id> .</step>
  <step>If <id>getIndex</id> + <id>elementSize</id> > <id>viewSize</id> , throw a <value>RangeError</value> exception.</step>
  <step>Let <id>bufferIndex</id> be <id>getIndex</id> + <id>viewOffset</id> .</step>
  <step>Return GetValueFromBuffer ( <id>buffer</id> , <id>bufferIndex</id> , <id>type</id> , <value>false</value> , <value>"Unordered"</value> , <id>isLittleEndian</id> ).</step>
</step-list>
<step-list>
  <step>If Type ( <id>view</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>view</id> does not have a [[DataView]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Assert : <id>view</id> has a [[ViewedArrayBuffer]] internal slot.</step>
  <step>Let <id>getIndex</id> be ? ToIndex ( <id>requestIndex</id> ).</step>
  <step>Let <id>numberValue</id> be ? ToNumber ( <id>value</id> ).</step>
  <step>Set <id>isLittleEndian</id> to ToBoolean ( <id>isLittleEndian</id> ).</step>
  <step>Let <id>buffer</id> be <id>view</id> .[[ViewedArrayBuffer]].</step>
  <step>If IsDetachedBuffer ( <id>buffer</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>viewOffset</id> be <id>view</id> .[[ByteOffset]].</step>
  <step>Let <id>viewSize</id> be <id>view</id> .[[ByteLength]].</step>
  <step>Let <id>elementSize</id> be the Number value of the Element Size value specified in Table 56 for Element Type <id>type</id> .</step>
  <step>If <id>getIndex</id> + <id>elementSize</id> > <id>viewSize</id> , throw a <value>RangeError</value> exception.</step>
  <step>Let <id>bufferIndex</id> be <id>getIndex</id> + <id>viewOffset</id> .</step>
  <step>Return SetValueInBuffer ( <id>buffer</id> , <id>bufferIndex</id> , <id>type</id> , <id>numberValue</id> , <value>false</value> , <value>"Unordered"</value> , <id>isLittleEndian</id> ).</step>
</step-list>
<step-list>
  <step>If NewTarget is <value>undefined</value> , throw a <value>TypeError</value> exception.</step>
  <step>If Type ( <id>buffer</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>buffer</id> does not have an [[ArrayBufferData]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>offset</id> be ? ToIndex ( <id>byteOffset</id> ).</step>
  <step>If IsDetachedBuffer ( <id>buffer</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>bufferByteLength</id> be <id>buffer</id> .[[ArrayBufferByteLength]].</step>
  <step>If <id>offset</id> > <id>bufferByteLength</id> , throw a <value>RangeError</value> exception.</step>
  <step>If <id>byteLength</id> is either not present or <value>undefined</value> , then   <step-list>
    <step>Let <id>viewByteLength</id> be <id>bufferByteLength</id> - <id>offset</id> .</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>viewByteLength</id> be ? ToIndex ( <id>byteLength</id> ).</step>
    <step>If <id>offset</id> + <id>viewByteLength</id> > <id>bufferByteLength</id> , throw a <value>RangeError</value> exception.</step>
  </step-list></step>
  <step>Let <id>O</id> be ? OrdinaryCreateFromConstructor (NewTarget, <value>"%DataViewPrototype%"</value> , « [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], [[ByteOffset]] »).</step>
  <step>Set <id>O</id> .[[ViewedArrayBuffer]] to <id>buffer</id> .</step>
  <step>Set <id>O</id> .[[ByteLength]] to <id>viewByteLength</id> .</step>
  <step>Set <id>O</id> .[[ByteOffset]] to <id>offset</id> .</step>
  <step>Return <id>O</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>O</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>O</id> does not have a [[DataView]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Assert : <id>O</id> has a [[ViewedArrayBuffer]] internal slot.</step>
  <step>Let <id>buffer</id> be <id>O</id> .[[ViewedArrayBuffer]].</step>
  <step>Return <id>buffer</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>O</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>O</id> does not have a [[DataView]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Assert : <id>O</id> has a [[ViewedArrayBuffer]] internal slot.</step>
  <step>Let <id>buffer</id> be <id>O</id> .[[ViewedArrayBuffer]].</step>
  <step>If IsDetachedBuffer ( <id>buffer</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>size</id> be <id>O</id> .[[ByteLength]].</step>
  <step>Return <id>size</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>O</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>O</id> does not have a [[DataView]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Assert : <id>O</id> has a [[ViewedArrayBuffer]] internal slot.</step>
  <step>Let <id>buffer</id> be <id>O</id> .[[ViewedArrayBuffer]].</step>
  <step>If IsDetachedBuffer ( <id>buffer</id> ) is <value>true</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>offset</id> be <id>O</id> .[[ByteOffset]].</step>
  <step>Return <id>offset</id> .</step>
</step-list>
<step-list>
  <step>Let <id>v</id> be the <value>this</value> value.</step>
  <step>If <id>littleEndian</id> is not present, let <id>littleEndian</id> be <value>false</value> .</step>
  <step>Return ? GetViewValue ( <id>v</id> , <id>byteOffset</id> , <id>littleEndian</id> , <value>"Float32"</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>v</id> be the <value>this</value> value.</step>
  <step>If <id>littleEndian</id> is not present, let <id>littleEndian</id> be <value>false</value> .</step>
  <step>Return ? GetViewValue ( <id>v</id> , <id>byteOffset</id> , <id>littleEndian</id> , <value>"Float64"</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>v</id> be the <value>this</value> value.</step>
  <step>Return ? GetViewValue ( <id>v</id> , <id>byteOffset</id> , <value>true</value> , <value>"Int8"</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>v</id> be the <value>this</value> value.</step>
  <step>If <id>littleEndian</id> is not present, let <id>littleEndian</id> be <value>false</value> .</step>
  <step>Return ? GetViewValue ( <id>v</id> , <id>byteOffset</id> , <id>littleEndian</id> , <value>"Int16"</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>v</id> be the <value>this</value> value.</step>
  <step>If <id>littleEndian</id> is not present, let <id>littleEndian</id> be <value>false</value> .</step>
  <step>Return ? GetViewValue ( <id>v</id> , <id>byteOffset</id> , <id>littleEndian</id> , <value>"Int32"</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>v</id> be the <value>this</value> value.</step>
  <step>Return ? GetViewValue ( <id>v</id> , <id>byteOffset</id> , <value>true</value> , <value>"Uint8"</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>v</id> be the <value>this</value> value.</step>
  <step>If <id>littleEndian</id> is not present, let <id>littleEndian</id> be <value>false</value> .</step>
  <step>Return ? GetViewValue ( <id>v</id> , <id>byteOffset</id> , <id>littleEndian</id> , <value>"Uint16"</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>v</id> be the <value>this</value> value.</step>
  <step>If <id>littleEndian</id> is not present, let <id>littleEndian</id> be <value>false</value> .</step>
  <step>Return ? GetViewValue ( <id>v</id> , <id>byteOffset</id> , <id>littleEndian</id> , <value>"Uint32"</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>v</id> be the <value>this</value> value.</step>
  <step>If <id>littleEndian</id> is not present, let <id>littleEndian</id> be <value>false</value> .</step>
  <step>Return ? SetViewValue ( <id>v</id> , <id>byteOffset</id> , <id>littleEndian</id> , <value>"Float32"</value> , <id>value</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>v</id> be the <value>this</value> value.</step>
  <step>If <id>littleEndian</id> is not present, let <id>littleEndian</id> be <value>false</value> .</step>
  <step>Return ? SetViewValue ( <id>v</id> , <id>byteOffset</id> , <id>littleEndian</id> , <value>"Float64"</value> , <id>value</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>v</id> be the <value>this</value> value.</step>
  <step>Return ? SetViewValue ( <id>v</id> , <id>byteOffset</id> , <value>true</value> , <value>"Int8"</value> , <id>value</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>v</id> be the <value>this</value> value.</step>
  <step>If <id>littleEndian</id> is not present, let <id>littleEndian</id> be <value>false</value> .</step>
  <step>Return ? SetViewValue ( <id>v</id> , <id>byteOffset</id> , <id>littleEndian</id> , <value>"Int16"</value> , <id>value</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>v</id> be the <value>this</value> value.</step>
  <step>If <id>littleEndian</id> is not present, let <id>littleEndian</id> be <value>false</value> .</step>
  <step>Return ? SetViewValue ( <id>v</id> , <id>byteOffset</id> , <id>littleEndian</id> , <value>"Int32"</value> , <id>value</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>v</id> be the <value>this</value> value.</step>
  <step>Return ? SetViewValue ( <id>v</id> , <id>byteOffset</id> , <value>true</value> , <value>"Uint8"</value> , <id>value</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>v</id> be the <value>this</value> value.</step>
  <step>If <id>littleEndian</id> is not present, let <id>littleEndian</id> be <value>false</value> .</step>
  <step>Return ? SetViewValue ( <id>v</id> , <id>byteOffset</id> , <id>littleEndian</id> , <value>"Uint16"</value> , <id>value</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>v</id> be the <value>this</value> value.</step>
  <step>If <id>littleEndian</id> is not present, let <id>littleEndian</id> be <value>false</value> .</step>
  <step>Return ? SetViewValue ( <id>v</id> , <id>byteOffset</id> , <id>littleEndian</id> , <value>"Uint32"</value> , <id>value</id> ).</step>
</step-list>
<step-list>
  <step>If <id>onlyInt32</id> is not present, set <id>onlyInt32</id> to <value>false</value> .</step>
  <step>If Type ( <id>typedArray</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>typedArray</id> does not have a [[TypedArrayName]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>typeName</id> be <id>typedArray</id> .[[TypedArrayName]].</step>
  <step>If <id>onlyInt32</id> is <value>true</value> , then   <step-list>
    <step>If <id>typeName</id> is not <value>"Int32Array"</value> , throw a <value>TypeError</value> exception.</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>If <id>typeName</id> is not <value>"Int8Array"</value> , <value>"Uint8Array"</value> , <value>"Int16Array"</value> , <value>"Uint16Array"</value> , <value>"Int32Array"</value> , or <value>"Uint32Array"</value> , throw a <value>TypeError</value> exception.</step>
  </step-list></step>
  <step>Assert : <id>typedArray</id> has a [[ViewedArrayBuffer]] internal slot.</step>
  <step>Let <id>buffer</id> be <id>typedArray</id> .[[ViewedArrayBuffer]].</step>
  <step>If IsSharedArrayBuffer ( <id>buffer</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Return <id>buffer</id> .</step>
</step-list>
<step-list>
  <step>Assert : <id>typedArray</id> is an Object that has a [[ViewedArrayBuffer]] internal slot.</step>
  <step>Let <id>accessIndex</id> be ? ToIndex ( <id>requestIndex</id> ).</step>
  <step>Let <id>length</id> be <id>typedArray</id> .[[ArrayLength]].</step>
  <step>Assert : <id>accessIndex</id> ≥ 0.</step>
  <step>If <id>accessIndex</id> ≥ <id>length</id> , throw a <value>RangeError</value> exception.</step>
  <step>Return <id>accessIndex</id> .</step>
</step-list>
<step-list>
  <step>Assert : <id>block</id> is a Shared Data Block .</step>
  <step>Assert : <id>i</id> and <id>i</id> +3 are valid byte offsets within the memory of <id>block</id> .</step>
  <step>Assert : <id>i</id> is divisible by 4.</step>
  <step>Return the WaiterList that is referenced by the pair ( <id>block</id> , <id>i</id> ).</step>
</step-list>
<step-list>
  <step>Assert : The calling agent is not in the critical section for any WaiterList .</step>
  <step>Wait until no agent is in the critical section for <id>WL</id> , then enter the critical section for <id>WL</id> (without allowing any other agent to enter).</step>
</step-list>
<step-list>
  <step>Assert : The calling agent is in the critical section for <id>WL</id> .</step>
  <step>Leave the critical section for <id>WL</id> .</step>
</step-list>
<step-list>
  <step>Assert : The calling agent is in the critical section for <id>WL</id> .</step>
  <step>Assert : <id>W</id> is not on the list of waiters in any WaiterList .</step>
  <step>Add <id>W</id> to the end of the list of waiters in <id>WL</id> .</step>
</step-list>
<step-list>
  <step>Assert : The calling agent is in the critical section for <id>WL</id> .</step>
  <step>Assert : <id>W</id> is on the list of waiters in <id>WL</id> .</step>
  <step>Remove <id>W</id> from the list of waiters in <id>WL</id> .</step>
</step-list>
<step-list>
  <step>Assert : The calling agent is in the critical section for <id>WL</id> .</step>
  <step>Let <id>L</id> be a new empty List .</step>
  <step>Let <id>S</id> be a reference to the list of waiters in <id>WL</id> .</step>
  <step>Repeat, while <id>c</id> > 0 and <id>S</id> is not an empty List ,   <step-list>
    <step>Let <id>W</id> be the first waiter in <id>S</id> .</step>
    <step>Add <id>W</id> to the end of <id>L</id> .</step>
    <step>Remove <id>W</id> from <id>S</id> .</step>
    <step>Subtract 1 from <id>c</id> .</step>
  </step-list></step>
  <step>Return <id>L</id> .</step>
</step-list>
<step-list>
  <step>Assert : The calling agent is in the critical section for <id>WL</id> .</step>
  <step>Assert : <id>W</id> is equal to AgentSignifier ().</step>
  <step>Assert : <id>W</id> is on the list of waiters in <id>WL</id> .</step>
  <step>Assert : AgentCanSuspend () is <value>true</value> .</step>
  <step>Perform LeaveCriticalSection ( <id>WL</id> ) and suspend <id>W</id> for up to <id>timeout</id> milliseconds, performing the combined operation in such a way that a 
wakeup that arrives after the critical section is exited but before the 
suspension takes effect is not lost. <id>W</id> can wake up either because the timeout expired or because it was woken explicitly by another agent calling WakeWaiter ( <id>WL</id> , <id>W</id> ), and not for any other reasons at all.</step>
  <step>Perform EnterCriticalSection ( <id>WL</id> ).</step>
  <step>If <id>W</id> was woken explicitly by another agent calling WakeWaiter ( <id>WL</id> , <id>W</id> ), return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Assert : The calling agent is in the critical section for <id>WL</id> .</step>
  <step>Assert : <id>W</id> is on the list of waiters in <id>WL</id> .</step>
  <step>Wake the agent  <id>W</id> .</step>
</step-list>
<step-list>
  <step>Let <id>buffer</id> be ? ValidateSharedIntegerTypedArray ( <id>typedArray</id> ).</step>
  <step>Let <id>i</id> be ? ValidateAtomicAccess ( <id>typedArray</id> , <id>index</id> ).</step>
  <step>Let <id>v</id> be ? ToInteger ( <id>value</id> ).</step>
  <step>Let <id>arrayTypeName</id> be <id>typedArray</id> .[[TypedArrayName]].</step>
  <step>Let <id>elementSize</id> be the Number value of the Element Size value specified in Table 56 for <id>arrayTypeName</id> .</step>
  <step>Let <id>elementType</id> be the String value of the Element Type value in Table 56 for <id>arrayTypeName</id> .</step>
  <step>Let <id>offset</id> be <id>typedArray</id> .[[ByteOffset]].</step>
  <step>Let <id>indexedPosition</id> be ( <id>i</id> × <id>elementSize</id> ) + <id>offset</id> .</step>
  <step>Return GetModifySetValueInBuffer ( <id>buffer</id> , <id>indexedPosition</id> , <id>elementType</id> , <id>v</id> , <id>op</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>buffer</id> be ? ValidateSharedIntegerTypedArray ( <id>typedArray</id> ).</step>
  <step>Let <id>i</id> be ? ValidateAtomicAccess ( <id>typedArray</id> , <id>index</id> ).</step>
  <step>Let <id>arrayTypeName</id> be <id>typedArray</id> .[[TypedArrayName]].</step>
  <step>Let <id>elementSize</id> be the Number value of the Element Size value specified in Table 56 for <id>arrayTypeName</id> .</step>
  <step>Let <id>elementType</id> be the String value of the Element Type value in Table 56 for <id>arrayTypeName</id> .</step>
  <step>Let <id>offset</id> be <id>typedArray</id> .[[ByteOffset]].</step>
  <step>Let <id>indexedPosition</id> be ( <id>i</id> × <id>elementSize</id> ) + <id>offset</id> .</step>
  <step>Return GetValueFromBuffer ( <id>buffer</id> , <id>indexedPosition</id> , <id>elementType</id> , <value>true</value> , <value>"SeqCst"</value> ).</step>
</step-list>
<step-list>
  <step>Return ? AtomicReadModifyWrite ( <id>typedArray</id> , <id>index</id> , <id>value</id> , <value>add</value> ).</step>
</step-list>
<step-list>
  <step>Return ? AtomicReadModifyWrite ( <id>typedArray</id> , <id>index</id> , <id>value</id> , <value>and</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>buffer</id> be ? ValidateSharedIntegerTypedArray ( <id>typedArray</id> ).</step>
  <step>Let <id>i</id> be ? ValidateAtomicAccess ( <id>typedArray</id> , <id>index</id> ).</step>
  <step>Let <id>expected</id> be ? ToInteger ( <id>expectedValue</id> ).</step>
  <step>Let <id>replacement</id> be ? ToInteger ( <id>replacementValue</id> ).</step>
  <step>Let <id>arrayTypeName</id> be <id>typedArray</id> .[[TypedArrayName]].</step>
  <step>Let <id>elementType</id> be the String value of the Element Type value in Table 56 for <id>arrayTypeName</id> .</step>
  <step>Let <id>isLittleEndian</id> be the value of the [[LittleEndian]] field of the surrounding agent 's Agent Record .</step>
  <step>Let <id>expectedBytes</id> be NumberToRawBytes ( <id>elementType</id> , <id>expected</id> , <id>isLittleEndian</id> ).</step>
  <step>Let <id>elementSize</id> be the Number value of the Element Size value specified in Table 56 for <id>arrayTypeName</id> .</step>
  <step>Let <id>offset</id> be <id>typedArray</id> .[[ByteOffset]].</step>
  <step>Let <id>indexedPosition</id> be ( <id>i</id> × <id>elementSize</id> ) + <id>offset</id> .</step>
  <step>Let <value>compareExchange</value> denote a semantic function of two List of byte values arguments that returns the second argument if the first argument is element-wise equal to <id>expectedBytes</id> .</step>
  <step>Return GetModifySetValueInBuffer ( <id>buffer</id> , <id>indexedPosition</id> , <id>elementType</id> , <id>replacement</id> , <value>compareExchange</value> ).</step>
</step-list>
<step-list>
  <step>Return ? AtomicReadModifyWrite ( <id>typedArray</id> , <id>index</id> , <id>value</id> , <value>second</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>n</id> be ? ToInteger ( <id>size</id> ).</step>
  <step>Let <id>AR</id> be the Agent Record of the surrounding agent .</step>
  <step>If <id>n</id> equals 1, return <id>AR</id> .[[IsLockFree1]].</step>
  <step>If <id>n</id> equals 2, return <id>AR</id> .[[IsLockFree2]].</step>
  <step>If <id>n</id> equals 4, return <value>true</value> .</step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return ? AtomicLoad ( <id>typedArray</id> , <id>index</id> ).</step>
</step-list>
<step-list>
  <step>Return ? AtomicReadModifyWrite ( <id>typedArray</id> , <id>index</id> , <id>value</id> , <value>or</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>buffer</id> be ? ValidateSharedIntegerTypedArray ( <id>typedArray</id> ).</step>
  <step>Let <id>i</id> be ? ValidateAtomicAccess ( <id>typedArray</id> , <id>index</id> ).</step>
  <step>Let <id>v</id> be ? ToInteger ( <id>value</id> ).</step>
  <step>Let <id>arrayTypeName</id> be <id>typedArray</id> .[[TypedArrayName]].</step>
  <step>Let <id>elementSize</id> be the Number value of the Element Size value specified in Table 56 for <id>arrayTypeName</id> .</step>
  <step>Let <id>elementType</id> be the String value of the Element Type value in Table 56 for <id>arrayTypeName</id> .</step>
  <step>Let <id>offset</id> be <id>typedArray</id> .[[ByteOffset]].</step>
  <step>Let <id>indexedPosition</id> be ( <id>i</id> × <id>elementSize</id> ) + <id>offset</id> .</step>
  <step>Perform SetValueInBuffer ( <id>buffer</id> , <id>indexedPosition</id> , <id>elementType</id> , <id>v</id> , <value>true</value> , <value>"SeqCst"</value> ).</step>
  <step>Return <id>v</id> .</step>
</step-list>
<step-list>
  <step>Return ? AtomicReadModifyWrite ( <id>typedArray</id> , <id>index</id> , <id>value</id> , <value>subtract</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>buffer</id> be ? ValidateSharedIntegerTypedArray ( <id>typedArray</id> , <value>true</value> ).</step>
  <step>Let <id>i</id> be ? ValidateAtomicAccess ( <id>typedArray</id> , <id>index</id> ).</step>
  <step>Let <id>v</id> be ? ToInt32 ( <id>value</id> ).</step>
  <step>Let <id>q</id> be ? ToNumber ( <id>timeout</id> ).</step>
  <step>If <id>q</id> is <value>NaN</value> , let <id>t</id> be <value>+∞</value> , else let <id>t</id> be max ( <id>q</id> , 0).</step>
  <step>Let <id>B</id> be AgentCanSuspend ().</step>
  <step>If <id>B</id> is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>block</id> be <id>buffer</id> .[[ArrayBufferData]].</step>
  <step>Let <id>offset</id> be <id>typedArray</id> .[[ByteOffset]].</step>
  <step>Let <id>indexedPosition</id> be ( <id>i</id> × 4) + <id>offset</id> .</step>
  <step>Let <id>WL</id> be GetWaiterList ( <id>block</id> , <id>indexedPosition</id> ).</step>
  <step>Perform EnterCriticalSection ( <id>WL</id> ).</step>
  <step>Let <id>w</id> be ! AtomicLoad ( <id>typedArray</id> , <id>i</id> ).</step>
  <step>If <id>v</id> is not equal to <id>w</id> , then   <step-list>
    <step>Perform LeaveCriticalSection ( <id>WL</id> ).</step>
    <step>Return the String <value>"not-equal"</value> .</step>
  </step-list></step>
  <step>Let <id>W</id> be AgentSignifier ().</step>
  <step>Perform AddWaiter ( <id>WL</id> , <id>W</id> ).</step>
  <step>Let <id>awoken</id> be Suspend ( <id>WL</id> , <id>W</id> , <id>t</id> ).</step>
  <step>If <id>awoken</id> is <value>true</value> , then   <step-list>
    <step>Assert : <id>W</id> is not on the list of waiters in <id>WL</id> .</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Perform RemoveWaiter ( <id>WL</id> , <id>W</id> ).</step>
  </step-list></step>
  <step>Perform LeaveCriticalSection ( <id>WL</id> ).</step>
  <step>If <id>awoken</id> is <value>true</value> , return the String <value>"ok"</value> .</step>
  <step>Return the String <value>"timed-out"</value> .</step>
</step-list>
<step-list>
  <step>Let <id>buffer</id> be ? ValidateSharedIntegerTypedArray ( <id>typedArray</id> , <value>true</value> ).</step>
  <step>Let <id>i</id> be ? ValidateAtomicAccess ( <id>typedArray</id> , <id>index</id> ).</step>
  <step>If <id>count</id> is <value>undefined</value> , let <id>c</id> be <value>+∞</value> .</step>
  <step>Else,   <step-list>
    <step>Let <id>intCount</id> be ? ToInteger ( <id>count</id> ).</step>
    <step>Let <id>c</id> be max ( <id>intCount</id> , 0).</step>
  </step-list></step>
  <step>Let <id>block</id> be <id>buffer</id> .[[ArrayBufferData]].</step>
  <step>Let <id>offset</id> be <id>typedArray</id> .[[ByteOffset]].</step>
  <step>Let <id>indexedPosition</id> be ( <id>i</id> × 4) + <id>offset</id> .</step>
  <step>Let <id>WL</id> be GetWaiterList ( <id>block</id> , <id>indexedPosition</id> ).</step>
  <step>Let <id>n</id> be 0.</step>
  <step>Perform EnterCriticalSection ( <id>WL</id> ).</step>
  <step>Let <id>S</id> be RemoveWaiters ( <id>WL</id> , <id>c</id> ).</step>
  <step>Repeat, while <id>S</id> is not an empty List ,   <step-list>
    <step>Let <id>W</id> be the first agent in <id>S</id> .</step>
    <step>Remove <id>W</id> from the front of <id>S</id> .</step>
    <step>Perform WakeWaiter ( <id>WL</id> , <id>W</id> ).</step>
    <step>Add 1 to <id>n</id> .</step>
  </step-list></step>
  <step>Perform LeaveCriticalSection ( <id>WL</id> ).</step>
  <step>Return <id>n</id> .</step>
</step-list>
<step-list>
  <step>Return ? AtomicReadModifyWrite ( <id>typedArray</id> , <id>index</id> , <id>value</id> , <value>xor</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>JText</id> be ? ToString ( <id>text</id> ).</step>
  <step>Parse <id>JText</id> interpreted as UTF-16 encoded Unicode points ( 6.1.4 ) as a JSON text as specified in ECMA-404. Throw a <value>SyntaxError</value> exception if <id>JText</id> is not a valid JSON text as defined in that specification.</step>
  <step>Let <id>scriptText</id> be the string-concatenation of <value>"("</value> , <id>JText</id> , and <value>");"</value> .</step>
  <step>Let <id>completion</id> be the result of parsing and evaluating <id>scriptText</id> as if it was the source text of an ECMAScript Script , but using the alternative definition of DoubleStringCharacter provided below. The extended PropertyDefinitionEvaluation semantics defined in B.3.1 must not be used during the evaluation.</step>
  <step>Let <id>unfiltered</id> be <id>completion</id> .[[Value]].</step>
  <step>Assert : <id>unfiltered</id> is either a String, Number, Boolean, Null, or an Object that is defined by either an ArrayLiteral or an ObjectLiteral .</step>
  <step>If IsCallable ( <id>reviver</id> ) is <value>true</value> , then   <step-list>
    <step>Let <id>root</id> be ObjectCreate ( %ObjectPrototype% ).</step>
    <step>Let <id>rootName</id> be the empty String.</step>
    <step>Let <id>status</id> be CreateDataProperty ( <id>root</id> , <id>rootName</id> , <id>unfiltered</id> ).</step>
    <step>Assert : <id>status</id> is <value>true</value> .</step>
    <step>Return ? InternalizeJSONProperty ( <id>root</id> , <id>rootName</id> ).</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Return <id>unfiltered</id> .</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>val</id> be ? Get ( <id>holder</id> , <id>name</id> ).</step>
  <step>If Type ( <id>val</id> ) is Object, then   <step-list>
    <step>Let <id>isArray</id> be ? IsArray ( <id>val</id> ).</step>
    <step>If <id>isArray</id> is <value>true</value> , then     <step-list>
      <step>Let <id>I</id> be 0.</step>
      <step>Let <id>len</id> be ? ToLength (? Get ( <id>val</id> , <value>"length"</value> )).</step>
      <step>Repeat, while <id>I</id> < <id>len</id> ,       <step-list>
        <step>Let <id>newElement</id> be ? InternalizeJSONProperty ( <id>val</id> , ! ToString ( <id>I</id> )).</step>
        <step>If <id>newElement</id> is <value>undefined</value> , then         <step-list>
          <step>Perform ? <id>val</id> .[[Delete]](! ToString ( <id>I</id> )).</step>
        </step-list></step>
        <step>Else,         <step-list>
          <step>Perform ? CreateDataProperty ( <id>val</id> , ! ToString ( <id>I</id> ), <id>newElement</id> ).</step>
          <step>NOTE: This algorithm intentionally does not throw an exception if CreateDataProperty returns <value>false</value> .</step>
        </step-list></step>
        <step>Add 1 to <id>I</id> .</step>
      </step-list></step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>Let <id>keys</id> be ? EnumerableOwnPropertyNames ( <id>val</id> , <value>"key"</value> ).</step>
      <step>For each String <id>P</id> in <id>keys</id> , do       <step-list>
        <step>Let <id>newElement</id> be ? InternalizeJSONProperty ( <id>val</id> , <id>P</id> ).</step>
        <step>If <id>newElement</id> is <value>undefined</value> , then         <step-list>
          <step>Perform ? <id>val</id> .[[Delete]]( <id>P</id> ).</step>
        </step-list></step>
        <step>Else,         <step-list>
          <step>Perform ? CreateDataProperty ( <id>val</id> , <id>P</id> , <id>newElement</id> ).</step>
          <step>NOTE: This algorithm intentionally does not throw an exception if CreateDataProperty returns <value>false</value> .</step>
        </step-list></step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
  <step>Return ? Call ( <id>reviver</id> , <id>holder</id> , « <id>name</id> , <id>val</id> »).</step>
</step-list>
<step-list>
  <step>Let <id>stack</id> be a new empty List .</step>
  <step>Let <id>indent</id> be the empty String.</step>
  <step>Let <id>PropertyList</id> and <id>ReplacerFunction</id> be <value>undefined</value> .</step>
  <step>If Type ( <id>replacer</id> ) is Object, then   <step-list>
    <step>If IsCallable ( <id>replacer</id> ) is <value>true</value> , then     <step-list>
      <step>Let <id>ReplacerFunction</id> be <id>replacer</id> .</step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>Let <id>isArray</id> be ? IsArray ( <id>replacer</id> ).</step>
      <step>If <id>isArray</id> is <value>true</value> , then       <step-list>
        <step>Let <id>PropertyList</id> be a new empty List .</step>
        <step>Let <id>len</id> be ? ToLength (? Get ( <id>replacer</id> , <value>"length"</value> )).</step>
        <step>Let <id>k</id> be 0.</step>
        <step>Repeat, while <id>k</id> < <id>len</id> ,         <step-list>
          <step>Let <id>v</id> be ? Get ( <id>replacer</id> , ! ToString ( <id>k</id> )).</step>
          <step>Let <id>item</id> be <value>undefined</value> .</step>
          <step>If Type ( <id>v</id> ) is String, let <id>item</id> be <id>v</id> .</step>
          <step>Else if Type ( <id>v</id> ) is Number, let <id>item</id> be ! ToString ( <id>v</id> ).</step>
          <step>Else if Type ( <id>v</id> ) is Object, then           <step-list>
            <step>If <id>v</id> has a [[StringData]] or [[NumberData]] internal slot, let <id>item</id> be ? ToString ( <id>v</id> ).</step>
          </step-list></step>
          <step>If <id>item</id> is not <value>undefined</value> and <id>item</id> is not currently an element of <id>PropertyList</id> , then           <step-list>
            <step>Append <id>item</id> to the end of <id>PropertyList</id> .</step>
          </step-list></step>
          <step>Let <id>k</id> be <id>k</id> +1.</step>
        </step-list></step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
  <step>If Type ( <id>space</id> ) is Object, then   <step-list>
    <step>If <id>space</id> has a [[NumberData]] internal slot, then     <step-list>
      <step>Let <id>space</id> be ? ToNumber ( <id>space</id> ).</step>
    </step-list></step>
    <step>Else if <id>space</id> has a [[StringData]] internal slot, then     <step-list>
      <step>Let <id>space</id> be ? ToString ( <id>space</id> ).</step>
    </step-list></step>
  </step-list></step>
  <step>If Type ( <id>space</id> ) is Number, then   <step-list>
    <step>Let <id>space</id> be min (10, ToInteger ( <id>space</id> )).</step>
    <step>Set <id>gap</id> to the String value containing <id>space</id> occurrences of the code unit 0x0020 (SPACE). This will be the empty String if <id>space</id> is less than 1.</step>
  </step-list></step>
  <step>Else if Type ( <id>space</id> ) is String, then   <step-list>
    <step>If the length of <id>space</id> is 10 or less, set <id>gap</id> to <id>space</id> ; otherwise set <id>gap</id> to the String value consisting of the first 10 elements of <id>space</id> .</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Set <id>gap</id> to the empty String.</step>
  </step-list></step>
  <step>Let <id>wrapper</id> be ObjectCreate ( %ObjectPrototype% ).</step>
  <step>Let <id>status</id> be CreateDataProperty ( <id>wrapper</id> , the empty String, <id>value</id> ).</step>
  <step>Assert : <id>status</id> is <value>true</value> .</step>
  <step>Return ? SerializeJSONProperty (the empty String, <id>wrapper</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>value</id> be ? Get ( <id>holder</id> , <id>key</id> ).</step>
  <step>If Type ( <id>value</id> ) is Object, then   <step-list>
    <step>Let <id>toJSON</id> be ? Get ( <id>value</id> , <value>"toJSON"</value> ).</step>
    <step>If IsCallable ( <id>toJSON</id> ) is <value>true</value> , then     <step-list>
      <step>Set <id>value</id> to ? Call ( <id>toJSON</id> , <id>value</id> , « <id>key</id> »).</step>
    </step-list></step>
  </step-list></step>
  <step>If <id>ReplacerFunction</id> is not <value>undefined</value> , then   <step-list>
    <step>Set <id>value</id> to ? Call ( <id>ReplacerFunction</id> , <id>holder</id> , « <id>key</id> , <id>value</id> »).</step>
  </step-list></step>
  <step>If Type ( <id>value</id> ) is Object, then   <step-list>
    <step>If <id>value</id> has a [[NumberData]] internal slot, then     <step-list>
      <step>Set <id>value</id> to ? ToNumber ( <id>value</id> ).</step>
    </step-list></step>
    <step>Else if <id>value</id> has a [[StringData]] internal slot, then     <step-list>
      <step>Set <id>value</id> to ? ToString ( <id>value</id> ).</step>
    </step-list></step>
    <step>Else if <id>value</id> has a [[BooleanData]] internal slot, then     <step-list>
      <step>Set <id>value</id> to <id>value</id> .[[BooleanData]].</step>
    </step-list></step>
  </step-list></step>
  <step>If <id>value</id> is <value>null</value> , return <value>"null"</value> .</step>
  <step>If <id>value</id> is <value>true</value> , return <value>"true"</value> .</step>
  <step>If <id>value</id> is <value>false</value> , return <value>"false"</value> .</step>
  <step>If Type ( <id>value</id> ) is String, return QuoteJSONString ( <id>value</id> ).</step>
  <step>If Type ( <id>value</id> ) is Number, then   <step-list>
    <step>If <id>value</id> is finite, return ! ToString ( <id>value</id> ).</step>
    <step>Return <value>"null"</value> .</step>
  </step-list></step>
  <step>If Type ( <id>value</id> ) is Object and IsCallable ( <id>value</id> ) is <value>false</value> , then   <step-list>
    <step>Let <id>isArray</id> be ? IsArray ( <id>value</id> ).</step>
    <step>If <id>isArray</id> is <value>true</value> , return ? SerializeJSONArray ( <id>value</id> ).</step>
    <step>Return ? SerializeJSONObject ( <id>value</id> ).</step>
  </step-list></step>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Let <id>product</id> be the String value consisting solely of the code unit 0x0022 (QUOTATION MARK).</step>
  <step>For each code unit <id>C</id> in <id>value</id> , do   <step-list>
    <step>If the numeric value of <id>C</id> is listed in the Code Unit Value column of Table 59 , then     <step-list>
      <step>Set <id>product</id> to the string-concatenation of <id>product</id> and the Escape Sequence for <id>C</id> as specified in Table 59 .</step>
    </step-list></step>
    <step>Else if <id>C</id> has a numeric value less than 0x0020 (SPACE), then     <step-list>
      <step>Set <id>product</id> to the string-concatenation of <id>product</id> and UnicodeEscape ( <id>C</id> ).</step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>Set <id>product</id> to the string-concatenation of <id>product</id> and <id>C</id> .</step>
    </step-list></step>
  </step-list></step>
  <step>Set <id>product</id> to the string-concatenation of <id>product</id> and the code unit 0x0022 (QUOTATION MARK).</step>
  <step>Return <id>product</id> .</step>
</step-list>
<step-list>
  <step>Let <id>n</id> be the numeric value of <id>C</id> .</step>
  <step>Assert : <id>n</id> ≤ 0xFFFF.</step>
  <step>Return the string-concatenation of: the code unit 0x005C (REVERSE SOLIDUS)
"u"
the String representation of n, formatted as a four-digit lowercase hexadecimal number, padded to the left with zeroes if necessary</step>
</step-list>
<step-list>
  <step>If <id>stack</id> contains <id>value</id> , throw a <value>TypeError</value> exception because the structure is cyclical.</step>
  <step>Append <id>value</id> to <id>stack</id> .</step>
  <step>Let <id>stepback</id> be <id>indent</id> .</step>
  <step>Set <id>indent</id> to the string-concatenation of <id>indent</id> and <id>gap</id> .</step>
  <step>If <id>PropertyList</id> is not <value>undefined</value> , then   <step-list>
    <step>Let <id>K</id> be <id>PropertyList</id> .</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>K</id> be ? EnumerableOwnPropertyNames ( <id>value</id> , <value>"key"</value> ).</step>
  </step-list></step>
  <step>Let <id>partial</id> be a new empty List .</step>
  <step>For each element <id>P</id> of <id>K</id> , do   <step-list>
    <step>Let <id>strP</id> be ? SerializeJSONProperty ( <id>P</id> , <id>value</id> ).</step>
    <step>If <id>strP</id> is not <value>undefined</value> , then     <step-list>
      <step>Let <id>member</id> be QuoteJSONString ( <id>P</id> ).</step>
      <step>Set <id>member</id> to the string-concatenation of <id>member</id> and <value>":"</value> .</step>
      <step>If <id>gap</id> is not the empty String, then       <step-list>
        <step>Set <id>member</id> to the string-concatenation of <id>member</id> and the code unit 0x0020 (SPACE).</step>
      </step-list></step>
      <step>Set <id>member</id> to the string-concatenation of <id>member</id> and <id>strP</id> .</step>
      <step>Append <id>member</id> to <id>partial</id> .</step>
    </step-list></step>
  </step-list></step>
  <step>If <id>partial</id> is empty, then   <step-list>
    <step>Let <id>final</id> be <value>"{}"</value> .</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>If <id>gap</id> is the empty String, then     <step-list>
      <step>Let <id>properties</id> be the String value formed by concatenating all the element Strings of <id>partial</id> with each adjacent pair of Strings separated with the code unit 0x002C 
(COMMA). A comma is not inserted either before the first String or after
 the last String.</step>
      <step>Let <id>final</id> be the string-concatenation of <value>"{"</value> , <id>properties</id> , and <value>"}"</value> .</step>
    </step-list></step>
    <step>Else <id>gap</id> is not the empty String,     <step-list>
      <step>Let <id>separator</id> be the string-concatenation of the code unit 0x002C (COMMA), the code unit 0x000A (LINE FEED), and <id>indent</id> .</step>
      <step>Let <id>properties</id> be the String value formed by concatenating all the element Strings of <id>partial</id> with each adjacent pair of Strings separated with <id>separator</id> . The <id>separator</id> String is not inserted either before the first String or after the last String.</step>
      <step>Let <id>final</id> be the string-concatenation of <value>"{"</value> , the code unit 0x000A (LINE FEED), <id>indent</id> , <id>properties</id> , the code unit 0x000A (LINE FEED), <id>stepback</id> , and <value>"}"</value> .</step>
    </step-list></step>
  </step-list></step>
  <step>Remove the last element of <id>stack</id> .</step>
  <step>Set <id>indent</id> to <id>stepback</id> .</step>
  <step>Return <id>final</id> .</step>
</step-list>
<step-list>
  <step>If <id>stack</id> contains <id>value</id> , throw a <value>TypeError</value> exception because the structure is cyclical.</step>
  <step>Append <id>value</id> to <id>stack</id> .</step>
  <step>Let <id>stepback</id> be <id>indent</id> .</step>
  <step>Set <id>indent</id> to the string-concatenation of <id>indent</id> and <id>gap</id> .</step>
  <step>Let <id>partial</id> be a new empty List .</step>
  <step>Let <id>len</id> be ? ToLength (? Get ( <id>value</id> , <value>"length"</value> )).</step>
  <step>Let <id>index</id> be 0.</step>
  <step>Repeat, while <id>index</id> < <id>len</id>   <step-list>
    <step>Let <id>strP</id> be ? SerializeJSONProperty (! ToString ( <id>index</id> ), <id>value</id> ).</step>
    <step>If <id>strP</id> is <value>undefined</value> , then     <step-list>
      <step>Append <value>"null"</value> to <id>partial</id> .</step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>Append <id>strP</id> to <id>partial</id> .</step>
    </step-list></step>
    <step>Increment <id>index</id> by 1.</step>
  </step-list></step>
  <step>If <id>partial</id> is empty, then   <step-list>
    <step>Let <id>final</id> be <value>"[]"</value> .</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>If <id>gap</id> is the empty String, then     <step-list>
      <step>Let <id>properties</id> be the String value formed by concatenating all the element Strings of <id>partial</id> with each adjacent pair of Strings separated with the code unit 0x002C 
(COMMA). A comma is not inserted either before the first String or after
 the last String.</step>
      <step>Let <id>final</id> be the string-concatenation of <value>"["</value> , <id>properties</id> , and <value>"]"</value> .</step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>Let <id>separator</id> be the string-concatenation of the code unit 0x002C (COMMA), the code unit 0x000A (LINE FEED), and <id>indent</id> .</step>
      <step>Let <id>properties</id> be the String value formed by concatenating all the element Strings of <id>partial</id> with each adjacent pair of Strings separated with <id>separator</id> . The <id>separator</id> String is not inserted either before the first String or after the last String.</step>
      <step>Let <id>final</id> be the string-concatenation of <value>"["</value> , the code unit 0x000A (LINE FEED), <id>indent</id> , <id>properties</id> , the code unit 0x000A (LINE FEED), <id>stepback</id> , and <value>"]"</value> .</step>
    </step-list></step>
  </step-list></step>
  <step>Remove the last element of <id>stack</id> .</step>
  <step>Set <id>indent</id> to <id>stepback</id> .</step>
  <step>Return <id>final</id> .</step>
</step-list>
<step-list>
  <step>Return the <value>this</value> value.</step>
</step-list>
<step-list>
  <step>Return the <value>this</value> value.</step>
</step-list>
<step-list>
  <step>Let <id>asyncIterator</id> be ! ObjectCreate ( %AsyncFromSyncIteratorPrototype% , « [[SyncIteratorRecord]] »).</step>
  <step>Set <id>asyncIterator</id> .[[SyncIteratorRecord]] to <id>syncIteratorRecord</id> .</step>
  <step>Return ? GetIterator ( <id>asyncIterator</id> , <value>async</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>Let <id>promiseCapability</id> be ! NewPromiseCapability ( %Promise% ).</step>
  <step>If Type ( <id>O</id> ) is not Object, or if <id>O</id> does not have a [[SyncIteratorRecord]] internal slot, then   <step-list>
    <step>Let <id>invalidIteratorError</id> be a newly created <value>TypeError</value> object.</step>
    <step>Perform ! Call ( <id>promiseCapability</id> .[[Reject]], <value>undefined</value> , « <id>invalidIteratorError</id> »).</step>
    <step>Return <id>promiseCapability</id> .[[Promise]].</step>
  </step-list></step>
  <step>Let <id>syncIteratorRecord</id> be <id>O</id> .[[SyncIteratorRecord]].</step>
  <step>Let <id>nextResult</id> be IteratorNext ( <id>syncIteratorRecord</id> , <id>value</id> ).</step>
  <step>IfAbruptRejectPromise ( <id>nextResult</id> , <id>promiseCapability</id> ).</step>
  <step>Let <id>nextDone</id> be IteratorComplete ( <id>nextResult</id> ).</step>
  <step>IfAbruptRejectPromise ( <id>nextDone</id> , <id>promiseCapability</id> ).</step>
  <step>Let <id>nextValue</id> be IteratorValue ( <id>nextResult</id> ).</step>
  <step>IfAbruptRejectPromise ( <id>nextValue</id> , <id>promiseCapability</id> ).</step>
  <step>Let <id>valueWrapperCapability</id> be ! NewPromiseCapability ( %Promise% ).</step>
  <step>Perform ! Call ( <id>valueWrapperCapability</id> .[[Resolve]], <value>undefined</value> , « <id>nextValue</id> »).</step>
  <step>Let <id>steps</id> be the algorithm steps defined in Async-from-Sync Iterator Value Unwrap Functions .</step>
  <step>Let <id>onFulfilled</id> be CreateBuiltinFunction ( <id>steps</id> , « [[Done]] »).</step>
  <step>Set <id>onFulfilled</id> .[[Done]] to <id>nextDone</id> .</step>
  <step>Perform ! PerformPromiseThen ( <id>valueWrapperCapability</id> .[[Promise]], <id>onFulfilled</id> , <value>undefined</value> , <id>promiseCapability</id> ).</step>
  <step>Return <id>promiseCapability</id> .[[Promise]].</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>Let <id>promiseCapability</id> be ! NewPromiseCapability ( %Promise% ).</step>
  <step>If Type ( <id>O</id> ) is not Object, or if <id>O</id> does not have a [[SyncIteratorRecord]] internal slot, then   <step-list>
    <step>Let <id>invalidIteratorError</id> be a newly created <value>TypeError</value> object.</step>
    <step>Perform ! Call ( <id>promiseCapability</id> .[[Reject]], <value>undefined</value> , « <id>invalidIteratorError</id> »).</step>
    <step>Return <id>promiseCapability</id> .[[Promise]].</step>
  </step-list></step>
  <step>Let <id>syncIterator</id> be <id>O</id> .[[SyncIteratorRecord]].[[Iterator]].</step>
  <step>Let <id>return</id> be GetMethod ( <id>syncIterator</id> , <value>"return"</value> ).</step>
  <step>IfAbruptRejectPromise ( <id>return</id> , <id>promiseCapability</id> ).</step>
  <step>If <id>return</id> is <value>undefined</value> , then   <step-list>
    <step>Let <id>iterResult</id> be ! CreateIterResultObject ( <id>value</id> , <value>true</value> ).</step>
    <step>Perform ! Call ( <id>promiseCapability</id> .[[Resolve]], <value>undefined</value> , « <id>iterResult</id> »).</step>
    <step>Return <id>promiseCapability</id> .[[Promise]].</step>
  </step-list></step>
  <step>Let <id>returnResult</id> be Call ( <id>return</id> , <id>syncIterator</id> , « <id>value</id> »).</step>
  <step>IfAbruptRejectPromise ( <id>returnResult</id> , <id>promiseCapability</id> ).</step>
  <step>If Type ( <id>returnResult</id> ) is not Object, then   <step-list>
    <step>Perform ! Call ( <id>promiseCapability</id> .[[Reject]], <value>undefined</value> , « a newly created <value>TypeError</value> object »).</step>
    <step>Return <id>promiseCapability</id> .[[Promise]].</step>
  </step-list></step>
  <step>Let <id>returnDone</id> be IteratorComplete ( <id>returnResult</id> ).</step>
  <step>IfAbruptRejectPromise ( <id>returnDone</id> , <id>promiseCapability</id> ).</step>
  <step>Let <id>returnValue</id> be IteratorValue ( <id>returnResult</id> ).</step>
  <step>IfAbruptRejectPromise ( <id>returnValue</id> , <id>promiseCapability</id> ).</step>
  <step>Let <id>valueWrapperCapability</id> be ! NewPromiseCapability ( %Promise% ).</step>
  <step>Perform ! Call ( <id>valueWrapperCapability</id> .[[Resolve]], <value>undefined</value> , « <id>returnValue</id> »).</step>
  <step>Let <id>steps</id> be the algorithm steps defined in Async-from-Sync Iterator Value Unwrap Functions .</step>
  <step>Let <id>onFulfilled</id> be CreateBuiltinFunction ( <id>steps</id> , « [[Done]] »).</step>
  <step>Set <id>onFulfilled</id> .[[Done]] to <id>returnDone</id> .</step>
  <step>Perform ! PerformPromiseThen ( <id>valueWrapperCapability</id> .[[Promise]], <id>onFulfilled</id> , <value>undefined</value> , <id>promiseCapability</id> ).</step>
  <step>Return <id>promiseCapability</id> .[[Promise]].</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>Let <id>promiseCapability</id> be ! NewPromiseCapability ( %Promise% ).</step>
  <step>If Type ( <id>O</id> ) is not Object, or if <id>O</id> does not have a [[SyncIteratorRecord]] internal slot, then   <step-list>
    <step>Let <id>invalidIteratorError</id> be a newly created <value>TypeError</value> object.</step>
    <step>Perform ! Call ( <id>promiseCapability</id> .[[Reject]], <value>undefined</value> , « <id>invalidIteratorError</id> »).</step>
    <step>Return <id>promiseCapability</id> .[[Promise]].</step>
  </step-list></step>
  <step>Let <id>syncIterator</id> be <id>O</id> .[[SyncIteratorRecord]].[[Iterator]].</step>
  <step>Let <id>throw</id> be GetMethod ( <id>syncIterator</id> , <value>"throw"</value> ).</step>
  <step>IfAbruptRejectPromise ( <id>throw</id> , <id>promiseCapability</id> ).</step>
  <step>If <id>throw</id> is <value>undefined</value> , then   <step-list>
    <step>Perform ! Call ( <id>promiseCapability</id> .[[Reject]], <value>undefined</value> , « <id>value</id> »).</step>
    <step>Return <id>promiseCapability</id> .[[Promise]].</step>
  </step-list></step>
  <step>Let <id>throwResult</id> be Call ( <id>throw</id> , <id>syncIterator</id> , « <id>value</id> »).</step>
  <step>IfAbruptRejectPromise ( <id>throwResult</id> , <id>promiseCapability</id> ).</step>
  <step>If Type ( <id>throwResult</id> ) is not Object, then   <step-list>
    <step>Perform ! Call ( <id>promiseCapability</id> .[[Reject]], <value>undefined</value> , « a newly created <value>TypeError</value> object »).</step>
    <step>Return <id>promiseCapability</id> .[[Promise]].</step>
  </step-list></step>
  <step>Let <id>throwDone</id> be IteratorComplete ( <id>throwResult</id> ).</step>
  <step>IfAbruptRejectPromise ( <id>throwDone</id> , <id>promiseCapability</id> ).</step>
  <step>Let <id>throwValue</id> be IteratorValue ( <id>throwResult</id> ).</step>
  <step>IfAbruptRejectPromise ( <id>throwValue</id> , <id>promiseCapability</id> ).</step>
  <step>Let <id>valueWrapperCapability</id> be ! NewPromiseCapability ( %Promise% ).</step>
  <step>Perform ! Call ( <id>valueWrapperCapability</id> .[[Resolve]], <value>undefined</value> , « <id>throwValue</id> »).</step>
  <step>Let <id>steps</id> be the algorithm steps defined in Async-from-Sync Iterator Value Unwrap Functions .</step>
  <step>Let <id>onFulfilled</id> be CreateBuiltinFunction ( <id>steps</id> , « [[Done]] »).</step>
  <step>Set <id>onFulfilled</id> .[[Done]] to <id>throwDone</id> .</step>
  <step>Perform ! PerformPromiseThen ( <id>valueWrapperCapability</id> .[[Promise]], <id>onFulfilled</id> , <value>undefined</value> , <id>promiseCapability</id> ).</step>
  <step>Return <id>promiseCapability</id> .[[Promise]].</step>
</step-list>
<step-list>
  <step>Return ! CreateIterResultObject ( <id>value</id> , <id>F</id> .[[Done]]).</step>
</step-list>
<step-list>
  <step>Let <id>C</id> be the active function object .</step>
  <step>Let <id>args</id> be the <id>argumentsList</id> that was passed to this function by [[Call]] or [[Construct]].</step>
  <step>Return ? CreateDynamicFunction ( <id>C</id> , NewTarget, <value>"generator"</value> , <id>args</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>C</id> be the active function object .</step>
  <step>Let <id>args</id> be the <id>argumentsList</id> that was passed to this function by [[Call]] or [[Construct]].</step>
  <step>Return ? CreateDynamicFunction ( <id>C</id> , NewTarget, <value>"async generator"</value> , <id>args</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>g</id> be the <value>this</value> value.</step>
  <step>Return ? GeneratorResume ( <id>g</id> , <id>value</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>g</id> be the <value>this</value> value.</step>
  <step>Let <id>C</id> be Completion { [[Type]]: <value>return</value> , [[Value]]: <id>value</id> , [[Target]]: <value>empty</value> }.</step>
  <step>Return ? GeneratorResumeAbrupt ( <id>g</id> , <id>C</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>g</id> be the <value>this</value> value.</step>
  <step>Let <id>C</id> be ThrowCompletion ( <id>exception</id> ).</step>
  <step>Return ? GeneratorResumeAbrupt ( <id>g</id> , <id>C</id> ).</step>
</step-list>
<step-list>
  <step>Assert : The value of <id>generator</id> .[[GeneratorState]] is <value>undefined</value> .</step>
  <step>Let <id>genContext</id> be the running execution context .</step>
  <step>Set the Generator component of <id>genContext</id> to <id>generator</id> .</step>
  <step>Set the code evaluation state of <id>genContext</id> such that when evaluation is resumed for that execution context the following steps will be performed:   <step-list>
    <step>Let <id>result</id> be the result of evaluating <id>generatorBody</id> .</step>
    <step>Assert : If we return here, the generator either threw an exception or performed either an implicit or explicit return.</step>
    <step>Remove <id>genContext</id> from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context .</step>
    <step>Set <id>generator</id> .[[GeneratorState]] to <value>"completed"</value> .</step>
    <step>Once a generator enters the <value>"completed"</value> state it never leaves it and its associated execution context is never resumed. Any execution state associated with <id>generator</id> can be discarded at this point.</step>
    <step>If <id>result</id> .[[Type]] is <value>normal</value> , let <id>resultValue</id> be <value>undefined</value> .</step>
    <step>Else if <id>result</id> .[[Type]] is <value>return</value> , let <id>resultValue</id> be <id>result</id> .[[Value]].</step>
    <step>Else,     <step-list>
      <step>Assert : <id>result</id> .[[Type]] is <value>throw</value> .</step>
      <step>Return Completion ( <id>result</id> ).</step>
    </step-list></step>
    <step>Return CreateIterResultObject ( <id>resultValue</id> , <value>true</value> ).</step>
  </step-list></step>
  <step>Set <id>generator</id> .[[GeneratorContext]] to <id>genContext</id> .</step>
  <step>Set <id>generator</id> .[[GeneratorState]] to <value>"suspendedStart"</value> .</step>
  <step>Return NormalCompletion ( <value>undefined</value> ).</step>
</step-list>
<step-list>
  <step>If Type ( <id>generator</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If <id>generator</id> does not have a [[GeneratorState]] internal slot, throw a <value>TypeError</value> exception.</step>
  <step>Assert : <id>generator</id> also has a [[GeneratorContext]] internal slot.</step>
  <step>Let <id>state</id> be <id>generator</id> .[[GeneratorState]].</step>
  <step>If <id>state</id> is <value>"executing"</value> , throw a <value>TypeError</value> exception.</step>
  <step>Return <id>state</id> .</step>
</step-list>
<step-list>
  <step>Let <id>state</id> be ? GeneratorValidate ( <id>generator</id> ).</step>
  <step>If <id>state</id> is <value>"completed"</value> , return CreateIterResultObject ( <value>undefined</value> , <value>true</value> ).</step>
  <step>Assert : <id>state</id> is either <value>"suspendedStart"</value> or <value>"suspendedYield"</value> .</step>
  <step>Let <id>genContext</id> be <id>generator</id> .[[GeneratorContext]].</step>
  <step>Let <id>methodContext</id> be the running execution context .</step>
  <step>Suspend  <id>methodContext</id> .</step>
  <step>Set <id>generator</id> .[[GeneratorState]] to <value>"executing"</value> .</step>
  <step>Push <id>genContext</id> onto the execution context stack ; <id>genContext</id> is now the running execution context .</step>
  <step>Resume the suspended evaluation of <id>genContext</id> using NormalCompletion ( <id>value</id> ) as the result of the operation that suspended it. Let <id>result</id> be the value returned by the resumed computation.</step>
  <step>Assert : When we return here, <id>genContext</id> has already been removed from the execution context stack and <id>methodContext</id> is the currently running execution context .</step>
  <step>Return Completion ( <id>result</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>state</id> be ? GeneratorValidate ( <id>generator</id> ).</step>
  <step>If <id>state</id> is <value>"suspendedStart"</value> , then   <step-list>
    <step>Set <id>generator</id> .[[GeneratorState]] to <value>"completed"</value> .</step>
    <step>Once a generator enters the <value>"completed"</value> state it never leaves it and its associated execution context is never resumed. Any execution state associated with <id>generator</id> can be discarded at this point.</step>
    <step>Set <id>state</id> to <value>"completed"</value> .</step>
  </step-list></step>
  <step>If <id>state</id> is <value>"completed"</value> , then   <step-list>
    <step>If <id>abruptCompletion</id> .[[Type]] is <value>return</value> , then     <step-list>
      <step>Return CreateIterResultObject ( <id>abruptCompletion</id> .[[Value]], <value>true</value> ).</step>
    </step-list></step>
    <step>Return Completion ( <id>abruptCompletion</id> ).</step>
  </step-list></step>
  <step>Assert : <id>state</id> is <value>"suspendedYield"</value> .</step>
  <step>Let <id>genContext</id> be <id>generator</id> .[[GeneratorContext]].</step>
  <step>Let <id>methodContext</id> be the running execution context .</step>
  <step>Suspend  <id>methodContext</id> .</step>
  <step>Set <id>generator</id> .[[GeneratorState]] to <value>"executing"</value> .</step>
  <step>Push <id>genContext</id> onto the execution context stack ; <id>genContext</id> is now the running execution context .</step>
  <step>Resume the suspended evaluation of <id>genContext</id> using <id>abruptCompletion</id> as the result of the operation that suspended it. Let <id>result</id> be the completion record returned by the resumed computation.</step>
  <step>Assert : When we return here, <id>genContext</id> has already been removed from the execution context stack and <id>methodContext</id> is the currently running execution context .</step>
  <step>Return Completion ( <id>result</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>genContext</id> be the running execution context .</step>
  <step>If <id>genContext</id> does not have a Generator component, return <value>non-generator</value> .</step>
  <step>Let <id>generator</id> be the Generator component of <id>genContext</id> .</step>
  <step>If <id>generator</id> has an [[AsyncGeneratorState]] internal slot, return <value>async</value> .</step>
  <step>Else, return <value>sync</value> .</step>
</step-list>
<step-list>
  <step>Assert : <id>iterNextObj</id> is an Object that implements the IteratorResult interface.</step>
  <step>Let <id>genContext</id> be the running execution context .</step>
  <step>Assert : <id>genContext</id> is the execution context of a generator.</step>
  <step>Let <id>generator</id> be the value of the Generator component of <id>genContext</id> .</step>
  <step>Assert : GetGeneratorKind () is <value>sync</value> .</step>
  <step>Set <id>generator</id> .[[GeneratorState]] to <value>"suspendedYield"</value> .</step>
  <step>Remove <id>genContext</id> from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context .</step>
  <step>Set the code evaluation state of <id>genContext</id> such that when evaluation is resumed with a Completion  <id>resumptionValue</id> the following steps will be performed:   <step-list>
    <step>Return <id>resumptionValue</id> .</step>
    <step>NOTE: This returns to the evaluation of the YieldExpression that originally called this abstract operation.</step>
  </step-list></step>
  <step>Return NormalCompletion ( <id>iterNextObj</id> ).</step>
  <step>NOTE: This returns to the evaluation of the operation that had most previously resumed evaluation of <id>genContext</id> .</step>
</step-list>
<step-list>
  <step>Let <id>generator</id> be the <value>this</value> value.</step>
  <step>Let <id>completion</id> be NormalCompletion ( <id>value</id> ).</step>
  <step>Return ! AsyncGeneratorEnqueue ( <id>generator</id> , <id>completion</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>generator</id> be the <value>this</value> value.</step>
  <step>Let <id>completion</id> be Completion { [[Type]]: <value>return</value> , [[Value]]: <id>value</id> , [[Target]]: <value>empty</value> }.</step>
  <step>Return ! AsyncGeneratorEnqueue ( <id>generator</id> , <id>completion</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>generator</id> be the <value>this</value> value.</step>
  <step>Let <id>completion</id> be ThrowCompletion ( <id>exception</id> ).</step>
  <step>Return ! AsyncGeneratorEnqueue ( <id>generator</id> , <id>completion</id> ).</step>
</step-list>
<step-list>
  <step>Assert : <id>generator</id> is an AsyncGenerator instance.</step>
  <step>Assert : <id>generator</id> .[[AsyncGeneratorState]] is <value>undefined</value> .</step>
  <step>Let <id>genContext</id> be the running execution context .</step>
  <step>Set the Generator component of <id>genContext</id> to <id>generator</id> .</step>
  <step>Set the code evaluation state of <id>genContext</id> such that when evaluation is resumed for that execution context the following steps will be performed:   <step-list>
    <step>Let <id>result</id> be the result of evaluating <id>generatorBody</id> .</step>
    <step>Assert : If we return here, the async generator either threw an exception or performed either an implicit or explicit return.</step>
    <step>Remove <id>genContext</id> from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context .</step>
    <step>Set <id>generator</id> .[[AsyncGeneratorState]] to <value>"completed"</value> .</step>
    <step>If <id>result</id> is a normal completion, let <id>resultValue</id> be <value>undefined</value> .</step>
    <step>Else,     <step-list>
      <step>Let <id>resultValue</id> be <id>result</id> .[[Value]].</step>
      <step>If <id>result</id> .[[Type]] is not <value>return</value> , then       <step-list>
        <step>Return ! AsyncGeneratorReject ( <id>generator</id> , <id>resultValue</id> ).</step>
      </step-list></step>
    </step-list></step>
    <step>Return ! AsyncGeneratorResolve ( <id>generator</id> , <id>resultValue</id> , <value>true</value> ).</step>
  </step-list></step>
  <step>Set <id>generator</id> .[[AsyncGeneratorContext]] to <id>genContext</id> .</step>
  <step>Set <id>generator</id> .[[AsyncGeneratorState]] to <value>"suspendedStart"</value> .</step>
  <step>Set <id>generator</id> .[[AsyncGeneratorQueue]] to a new empty List .</step>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Assert : <id>generator</id> is an AsyncGenerator instance.</step>
  <step>Let <id>queue</id> be <id>generator</id> .[[AsyncGeneratorQueue]].</step>
  <step>Assert : <id>queue</id> is not an empty List .</step>
  <step>Remove the first element from <id>queue</id> and let <id>next</id> be the value of that element.</step>
  <step>Let <id>promiseCapability</id> be <id>next</id> .[[Capability]].</step>
  <step>Let <id>iteratorResult</id> be ! CreateIterResultObject ( <id>value</id> , <id>done</id> ).</step>
  <step>Perform ! Call ( <id>promiseCapability</id> .[[Resolve]], <value>undefined</value> , « <id>iteratorResult</id> »).</step>
  <step>Perform ! AsyncGeneratorResumeNext ( <id>generator</id> ).</step>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Assert : <id>generator</id> is an AsyncGenerator instance.</step>
  <step>Let <id>queue</id> be <id>generator</id> .[[AsyncGeneratorQueue]].</step>
  <step>Assert : <id>queue</id> is not an empty List .</step>
  <step>Remove the first element from <id>queue</id> and let <id>next</id> be the value of that element.</step>
  <step>Let <id>promiseCapability</id> be <id>next</id> .[[Capability]].</step>
  <step>Perform ! Call ( <id>promiseCapability</id> .[[Reject]], <value>undefined</value> , « <id>exception</id> »).</step>
  <step>Perform ! AsyncGeneratorResumeNext ( <id>generator</id> ).</step>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Assert : <id>generator</id> is an AsyncGenerator instance.</step>
  <step>Let <id>state</id> be <id>generator</id> .[[AsyncGeneratorState]].</step>
  <step>Assert : <id>state</id> is not <value>"executing"</value> .</step>
  <step>If <id>state</id> is <value>"awaiting-return"</value> , return <value>undefined</value> .</step>
  <step>Let <id>queue</id> be <id>generator</id> .[[AsyncGeneratorQueue]].</step>
  <step>If <id>queue</id> is an empty List , return <value>undefined</value> .</step>
  <step>Let <id>next</id> be the value of the first element of <id>queue</id> .</step>
  <step>Assert : <id>next</id> is an AsyncGeneratorRequest record.</step>
  <step>Let <id>completion</id> be <id>next</id> .[[Completion]].</step>
  <step>If <id>completion</id> is an abrupt completion , then   <step-list>
    <step>If <id>state</id> is <value>"suspendedStart"</value> , then     <step-list>
      <step>Set <id>generator</id> .[[AsyncGeneratorState]] to <value>"completed"</value> .</step>
      <step>Set <id>state</id> to <value>"completed"</value> .</step>
    </step-list></step>
    <step>If <id>state</id> is <value>"completed"</value> , then     <step-list>
      <step>If <id>completion</id> .[[Type]] is <value>return</value> , then       <step-list>
        <step>Set <id>generator</id> .[[AsyncGeneratorState]] to <value>"awaiting-return"</value> .</step>
        <step>Let <id>promiseCapability</id> be ! NewPromiseCapability ( %Promise% ).</step>
        <step>Perform ! Call ( <id>promiseCapability</id> .[[Resolve]], <value>undefined</value> , « <id>completion</id> .[[Value]] »).</step>
        <step>Let <id>stepsFulfilled</id> be the algorithm steps defined in AsyncGeneratorResumeNext Return Processor Fulfilled Functions .</step>
        <step>Let <id>onFulfilled</id> be CreateBuiltinFunction ( <id>stepsFulfilled</id> , « [[Generator]] »).</step>
        <step>Set <id>onFulfilled</id> .[[Generator]] to <id>generator</id> .</step>
        <step>Let <id>stepsRejected</id> be the algorithm steps defined in AsyncGeneratorResumeNext Return Processor Rejected Functions .</step>
        <step>Let <id>onRejected</id> be CreateBuiltinFunction ( <id>stepsRejected</id> , « [[Generator]] »).</step>
        <step>Set <id>onRejected</id> .[[Generator]] to <id>generator</id> .</step>
        <step>Let <id>throwawayCapability</id> be ! NewPromiseCapability ( %Promise% ).</step>
        <step>Set <id>throwawayCapability</id> .[[Promise]].[[PromiseIsHandled]] to <value>true</value> .</step>
        <step>Perform ! PerformPromiseThen ( <id>promiseCapability</id> .[[Promise]], <id>onFulfilled</id> , <id>onRejected</id> , <id>throwawayCapability</id> ).</step>
        <step>Return <value>undefined</value> .</step>
      </step-list></step>
      <step>Else,       <step-list>
        <step>Assert : <id>completion</id> .[[Type]] is <value>throw</value> .</step>
        <step>Perform ! AsyncGeneratorReject ( <id>generator</id> , <id>completion</id> .[[Value]]).</step>
        <step>Return <value>undefined</value> .</step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
  <step>Else if <id>state</id> is <value>"completed"</value> , return ! AsyncGeneratorResolve ( <id>generator</id> , <value>undefined</value> , <value>true</value> ).</step>
  <step>Assert : <id>state</id> is either <value>"suspendedStart"</value> or <value>"suspendedYield"</value> .</step>
  <step>Let <id>genContext</id> be <id>generator</id> .[[AsyncGeneratorContext]].</step>
  <step>Let <id>callerContext</id> be the running execution context .</step>
  <step>Suspend  <id>callerContext</id> .</step>
  <step>Set <id>generator</id> .[[AsyncGeneratorState]] to <value>"executing"</value> .</step>
  <step>Push <id>genContext</id> onto the execution context stack ; <id>genContext</id> is now the running execution context .</step>
  <step>Resume the suspended evaluation of <id>genContext</id> using <id>completion</id> as the result of the operation that suspended it. Let <id>result</id> be the completion record returned by the resumed computation.</step>
  <step>Assert : <id>result</id> is never an abrupt completion .</step>
  <step>Assert : When we return here, <id>genContext</id> has already been removed from the execution context stack and <id>callerContext</id> is the currently running execution context .</step>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Set <id>F</id> .[[Generator]].[[AsyncGeneratorState]] to <value>"completed"</value> .</step>
  <step>Return ! AsyncGeneratorResolve ( <id>F</id> .[[Generator]], <id>value</id> , <value>true</value> ).</step>
</step-list>
<step-list>
  <step>Set <id>F</id> .[[Generator]].[[AsyncGeneratorState]] to <value>"completed"</value> .</step>
  <step>Return ! AsyncGeneratorReject ( <id>F</id> .[[Generator]], <id>reason</id> ).</step>
</step-list>
<step-list>
  <step>Assert : <id>completion</id> is a Completion Record .</step>
  <step>Let <id>promiseCapability</id> be ! NewPromiseCapability ( %Promise% ).</step>
  <step>If Type ( <id>generator</id> ) is not Object, or if <id>generator</id> does not have an [[AsyncGeneratorState]] internal slot, then   <step-list>
    <step>Let <id>badGeneratorError</id> be a newly created <value>TypeError</value> object.</step>
    <step>Perform ! Call ( <id>promiseCapability</id> .[[Reject]], <value>undefined</value> , « <id>badGeneratorError</id> »).</step>
    <step>Return <id>promiseCapability</id> .[[Promise]].</step>
  </step-list></step>
  <step>Let <id>queue</id> be <id>generator</id> .[[AsyncGeneratorQueue]].</step>
  <step>Let <id>request</id> be AsyncGeneratorRequest { [[Completion]]: <id>completion</id> , [[Capability]]: <id>promiseCapability</id> }.</step>
  <step>Append <id>request</id> to the end of <id>queue</id> .</step>
  <step>Let <id>state</id> be <id>generator</id> .[[AsyncGeneratorState]].</step>
  <step>If <id>state</id> is not <value>"executing"</value> , then   <step-list>
    <step>Perform ! AsyncGeneratorResumeNext ( <id>generator</id> ).</step>
  </step-list></step>
  <step>Return <id>promiseCapability</id> .[[Promise]].</step>
</step-list>
<step-list>
  <step>Let <id>genContext</id> be the running execution context .</step>
  <step>Assert : <id>genContext</id> is the execution context of a generator.</step>
  <step>Let <id>generator</id> be the value of the Generator component of <id>genContext</id> .</step>
  <step>Assert : GetGeneratorKind () is <value>async</value> .</step>
  <step>Set <id>value</id> to ? Await ( <id>value</id> ).</step>
  <step>Set <id>generator</id> .[[AsyncGeneratorState]] to <value>"suspendedYield"</value> .</step>
  <step>Remove <id>genContext</id> from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context .</step>
  <step>Set the code evaluation state of <id>genContext</id> such that when evaluation is resumed with a Completion  <id>resumptionValue</id> the following steps will be performed:   <step-list>
    <step>If <id>resumptionValue</id> .[[Type]] is not <value>return</value> , return Completion ( <id>resumptionValue</id> ).</step>
    <step>Let <id>awaited</id> be Await ( <id>resumptionValue</id> .[[Value]]).</step>
    <step>If <id>awaited</id> .[[Type]] is <value>throw</value> , return Completion ( <id>awaited</id> ).</step>
    <step>Assert : <id>awaited</id> .[[Type]] is <value>normal</value> .</step>
    <step>Return Completion { [[Type]]: <value>return</value> , [[Value]]: <id>awaited</id> .[[Value]], [[Target]]: <value>empty</value> }.</step>
    <step>NOTE: When one of the above steps returns, it returns to the evaluation of the YieldExpression production that originally called this abstract operation.</step>
  </step-list></step>
  <step>Return ! AsyncGeneratorResolve ( <id>generator</id> , <id>value</id> , <value>false</value> ).</step>
  <step>NOTE: This returns to the evaluation of the operation that had most previously resumed evaluation of <id>genContext</id> .</step>
</step-list>
<step-list>
  <step>IfAbruptRejectPromise ( <id>value</id> , <id>capability</id> ).</step>
</step-list>
<step-list>
  <step>If <id>value</id> is an abrupt completion , then   <step-list>
    <step>Perform ? Call ( <id>capability</id> .[[Reject]], <value>undefined</value> , « <id>value</id> .[[Value]] »).</step>
    <step>Return <id>capability</id> .[[Promise]].</step>
  </step-list></step>
  <step>Else if <id>value</id> is a Completion Record , let <id>value</id> be <id>value</id> .[[Value]].</step>
</step-list>
<step-list>
  <step>Let <id>alreadyResolved</id> be a new Record { [[Value]]: <value>false</value> }.</step>
  <step>Let <id>stepsResolve</id> be the algorithm steps defined in Promise Resolve Functions ( 25.6.1.3.2 ).</step>
  <step>Let <id>resolve</id> be CreateBuiltinFunction ( <id>stepsResolve</id> , « [[Promise]], [[AlreadyResolved]] »).</step>
  <step>Set <id>resolve</id> .[[Promise]] to <id>promise</id> .</step>
  <step>Set <id>resolve</id> .[[AlreadyResolved]] to <id>alreadyResolved</id> .</step>
  <step>Let <id>stepsReject</id> be the algorithm steps defined in Promise Reject Functions ( 25.6.1.3.1 ).</step>
  <step>Let <id>reject</id> be CreateBuiltinFunction ( <id>stepsReject</id> , « [[Promise]], [[AlreadyResolved]] »).</step>
  <step>Set <id>reject</id> .[[Promise]] to <id>promise</id> .</step>
  <step>Set <id>reject</id> .[[AlreadyResolved]] to <id>alreadyResolved</id> .</step>
  <step>Return a new Record { [[Resolve]]: <id>resolve</id> , [[Reject]]: <id>reject</id> }.</step>
</step-list>
<step-list>
  <step>Assert : <id>F</id> has a [[Promise]] internal slot whose value is an Object.</step>
  <step>Let <id>promise</id> be <id>F</id> .[[Promise]].</step>
  <step>Let <id>alreadyResolved</id> be <id>F</id> .[[AlreadyResolved]].</step>
  <step>If <id>alreadyResolved</id> .[[Value]] is <value>true</value> , return <value>undefined</value> .</step>
  <step>Set <id>alreadyResolved</id> .[[Value]] to <value>true</value> .</step>
  <step>Return RejectPromise ( <id>promise</id> , <id>reason</id> ).</step>
</step-list>
<step-list>
  <step>Assert : <id>F</id> has a [[Promise]] internal slot whose value is an Object.</step>
  <step>Let <id>promise</id> be <id>F</id> .[[Promise]].</step>
  <step>Let <id>alreadyResolved</id> be <id>F</id> .[[AlreadyResolved]].</step>
  <step>If <id>alreadyResolved</id> .[[Value]] is <value>true</value> , return <value>undefined</value> .</step>
  <step>Set <id>alreadyResolved</id> .[[Value]] to <value>true</value> .</step>
  <step>If SameValue ( <id>resolution</id> , <id>promise</id> ) is <value>true</value> , then   <step-list>
    <step>Let <id>selfResolutionError</id> be a newly created <value>TypeError</value> object.</step>
    <step>Return RejectPromise ( <id>promise</id> , <id>selfResolutionError</id> ).</step>
  </step-list></step>
  <step>If Type ( <id>resolution</id> ) is not Object, then   <step-list>
    <step>Return FulfillPromise ( <id>promise</id> , <id>resolution</id> ).</step>
  </step-list></step>
  <step>Let <id>then</id> be Get ( <id>resolution</id> , <value>"then"</value> ).</step>
  <step>If <id>then</id> is an abrupt completion , then   <step-list>
    <step>Return RejectPromise ( <id>promise</id> , <id>then</id> .[[Value]]).</step>
  </step-list></step>
  <step>Let <id>thenAction</id> be <id>then</id> .[[Value]].</step>
  <step>If IsCallable ( <id>thenAction</id> ) is <value>false</value> , then   <step-list>
    <step>Return FulfillPromise ( <id>promise</id> , <id>resolution</id> ).</step>
  </step-list></step>
  <step>Perform EnqueueJob ( <value>"PromiseJobs"</value> , PromiseResolveThenableJob , « <id>promise</id> , <id>resolution</id> , <id>thenAction</id> »).</step>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Assert : The value of <id>promise</id> .[[PromiseState]] is <value>"pending"</value> .</step>
  <step>Let <id>reactions</id> be <id>promise</id> .[[PromiseFulfillReactions]].</step>
  <step>Set <id>promise</id> .[[PromiseResult]] to <id>value</id> .</step>
  <step>Set <id>promise</id> .[[PromiseFulfillReactions]] to <value>undefined</value> .</step>
  <step>Set <id>promise</id> .[[PromiseRejectReactions]] to <value>undefined</value> .</step>
  <step>Set <id>promise</id> .[[PromiseState]] to <value>"fulfilled"</value> .</step>
  <step>Return TriggerPromiseReactions ( <id>reactions</id> , <id>value</id> ).</step>
</step-list>
<step-list>
  <step>If IsConstructor ( <id>C</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>NOTE: <id>C</id> is assumed to be a constructor function that supports the parameter conventions of the <value>Promise</value>  constructor (see 25.6.3.1 ).</step>
  <step>Let <id>promiseCapability</id> be a new PromiseCapability { [[Promise]]: <value>undefined</value> , [[Resolve]]: <value>undefined</value> , [[Reject]]: <value>undefined</value> }.</step>
  <step>Let <id>steps</id> be the algorithm steps defined in GetCapabilitiesExecutor Functions .</step>
  <step>Let <id>executor</id> be CreateBuiltinFunction ( <id>steps</id> , « [[Capability]] »).</step>
  <step>Set <id>executor</id> .[[Capability]] to <id>promiseCapability</id> .</step>
  <step>Let <id>promise</id> be ? Construct ( <id>C</id> , « <id>executor</id> »).</step>
  <step>If IsCallable ( <id>promiseCapability</id> .[[Resolve]]) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>If IsCallable ( <id>promiseCapability</id> .[[Reject]]) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Set <id>promiseCapability</id> .[[Promise]] to <id>promise</id> .</step>
  <step>Return <id>promiseCapability</id> .</step>
</step-list>
<step-list>
  <step>Assert : <id>F</id> has a [[Capability]] internal slot whose value is a PromiseCapability Record .</step>
  <step>Let <id>promiseCapability</id> be <id>F</id> .[[Capability]].</step>
  <step>If <id>promiseCapability</id> .[[Resolve]] is not <value>undefined</value> , throw a <value>TypeError</value> exception.</step>
  <step>If <id>promiseCapability</id> .[[Reject]] is not <value>undefined</value> , throw a <value>TypeError</value> exception.</step>
  <step>Set <id>promiseCapability</id> .[[Resolve]] to <id>resolve</id> .</step>
  <step>Set <id>promiseCapability</id> .[[Reject]] to <id>reject</id> .</step>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>If Type ( <id>x</id> ) is not Object, return <value>false</value> .</step>
  <step>If <id>x</id> does not have a [[PromiseState]] internal slot, return <value>false</value> .</step>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>Assert : The value of <id>promise</id> .[[PromiseState]] is <value>"pending"</value> .</step>
  <step>Let <id>reactions</id> be <id>promise</id> .[[PromiseRejectReactions]].</step>
  <step>Set <id>promise</id> .[[PromiseResult]] to <id>reason</id> .</step>
  <step>Set <id>promise</id> .[[PromiseFulfillReactions]] to <value>undefined</value> .</step>
  <step>Set <id>promise</id> .[[PromiseRejectReactions]] to <value>undefined</value> .</step>
  <step>Set <id>promise</id> .[[PromiseState]] to <value>"rejected"</value> .</step>
  <step>If <id>promise</id> .[[PromiseIsHandled]] is <value>false</value> , perform HostPromiseRejectionTracker ( <id>promise</id> , <value>"reject"</value> ).</step>
  <step>Return TriggerPromiseReactions ( <id>reactions</id> , <id>reason</id> ).</step>
</step-list>
<step-list>
  <step>For each <id>reaction</id> in <id>reactions</id> , in original insertion order, do   <step-list>
    <step>Perform EnqueueJob ( <value>"PromiseJobs"</value> , PromiseReactionJob , « <id>reaction</id> , <id>argument</id> »).</step>
  </step-list></step>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Assert : <id>reaction</id> is a PromiseReaction Record .</step>
  <step>Let <id>promiseCapability</id> be <id>reaction</id> .[[Capability]].</step>
  <step>Let <id>type</id> be <id>reaction</id> .[[Type]].</step>
  <step>Let <id>handler</id> be <id>reaction</id> .[[Handler]].</step>
  <step>If <id>handler</id> is <value>undefined</value> , then   <step-list>
    <step>If <id>type</id> is <value>"Fulfill"</value> , let <id>handlerResult</id> be NormalCompletion ( <id>argument</id> ).</step>
    <step>Else,     <step-list>
      <step>Assert : <id>type</id> is <value>"Reject"</value> .</step>
      <step>Let <id>handlerResult</id> be ThrowCompletion ( <id>argument</id> ).</step>
    </step-list></step>
  </step-list></step>
  <step>Else, let <id>handlerResult</id> be Call ( <id>handler</id> , <value>undefined</value> , « <id>argument</id> »).</step>
  <step>If <id>handlerResult</id> is an abrupt completion , then   <step-list>
    <step>Let <id>status</id> be Call ( <id>promiseCapability</id> .[[Reject]], <value>undefined</value> , « <id>handlerResult</id> .[[Value]] »).</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>status</id> be Call ( <id>promiseCapability</id> .[[Resolve]], <value>undefined</value> , « <id>handlerResult</id> .[[Value]] »).</step>
  </step-list></step>
  <step>Return Completion ( <id>status</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>resolvingFunctions</id> be CreateResolvingFunctions ( <id>promiseToResolve</id> ).</step>
  <step>Let <id>thenCallResult</id> be Call ( <id>then</id> , <id>thenable</id> , « <id>resolvingFunctions</id> .[[Resolve]], <id>resolvingFunctions</id> .[[Reject]] »).</step>
  <step>If <id>thenCallResult</id> is an abrupt completion , then   <step-list>
    <step>Let <id>status</id> be Call ( <id>resolvingFunctions</id> .[[Reject]], <value>undefined</value> , « <id>thenCallResult</id> .[[Value]] »).</step>
    <step>Return Completion ( <id>status</id> ).</step>
  </step-list></step>
  <step>Return Completion ( <id>thenCallResult</id> ).</step>
</step-list>
<step-list>
  <step>If NewTarget is <value>undefined</value> , throw a <value>TypeError</value> exception.</step>
  <step>If IsCallable ( <id>executor</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>promise</id> be ? OrdinaryCreateFromConstructor (NewTarget, <value>"%PromisePrototype%"</value> , « [[PromiseState]], [[PromiseResult]], [[PromiseFulfillReactions]], [[PromiseRejectReactions]], [[PromiseIsHandled]] »).</step>
  <step>Set <id>promise</id> .[[PromiseState]] to <value>"pending"</value> .</step>
  <step>Set <id>promise</id> .[[PromiseFulfillReactions]] to a new empty List .</step>
  <step>Set <id>promise</id> .[[PromiseRejectReactions]] to a new empty List .</step>
  <step>Set <id>promise</id> .[[PromiseIsHandled]] to <value>false</value> .</step>
  <step>Let <id>resolvingFunctions</id> be CreateResolvingFunctions ( <id>promise</id> ).</step>
  <step>Let <id>completion</id> be Call ( <id>executor</id> , <value>undefined</value> , « <id>resolvingFunctions</id> .[[Resolve]], <id>resolvingFunctions</id> .[[Reject]] »).</step>
  <step>If <id>completion</id> is an abrupt completion , then   <step-list>
    <step>Perform ? Call ( <id>resolvingFunctions</id> .[[Reject]], <value>undefined</value> , « <id>completion</id> .[[Value]] »).</step>
  </step-list></step>
  <step>Return <id>promise</id> .</step>
</step-list>
<step-list>
  <step>Let <id>C</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>C</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>promiseCapability</id> be ? NewPromiseCapability ( <id>C</id> ).</step>
  <step>Let <id>iteratorRecord</id> be GetIterator ( <id>iterable</id> ).</step>
  <step>IfAbruptRejectPromise ( <id>iteratorRecord</id> , <id>promiseCapability</id> ).</step>
  <step>Let <id>result</id> be PerformPromiseAll ( <id>iteratorRecord</id> , <id>C</id> , <id>promiseCapability</id> ).</step>
  <step>If <id>result</id> is an abrupt completion , then   <step-list>
    <step>If <id>iteratorRecord</id> .[[Done]] is <value>false</value> , let <id>result</id> be IteratorClose ( <id>iteratorRecord</id> , <id>result</id> ).</step>
    <step>IfAbruptRejectPromise ( <id>result</id> , <id>promiseCapability</id> ).</step>
  </step-list></step>
  <step>Return Completion ( <id>result</id> ).</step>
</step-list>
<step-list>
  <step>Assert : <id>constructor</id> is a constructor function.</step>
  <step>Assert : <id>resultCapability</id> is a PromiseCapability Record .</step>
  <step>Let <id>values</id> be a new empty List .</step>
  <step>Let <id>remainingElementsCount</id> be a new Record { [[Value]]: 1 }.</step>
  <step>Let <id>index</id> be 0.</step>
  <step>Repeat,   <step-list>
    <step>Let <id>next</id> be IteratorStep ( <id>iteratorRecord</id> ).</step>
    <step>If <id>next</id> is an abrupt completion , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
    <step>ReturnIfAbrupt ( <id>next</id> ).</step>
    <step>If <id>next</id> is <value>false</value> , then     <step-list>
      <step>Set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
      <step>Set <id>remainingElementsCount</id> .[[Value]] to <id>remainingElementsCount</id> .[[Value]] - 1.</step>
      <step>If <id>remainingElementsCount</id> .[[Value]] is 0, then       <step-list>
        <step>Let <id>valuesArray</id> be CreateArrayFromList ( <id>values</id> ).</step>
        <step>Perform ? Call ( <id>resultCapability</id> .[[Resolve]], <value>undefined</value> , « <id>valuesArray</id> »).</step>
      </step-list></step>
      <step>Return <id>resultCapability</id> .[[Promise]].</step>
    </step-list></step>
    <step>Let <id>nextValue</id> be IteratorValue ( <id>next</id> ).</step>
    <step>If <id>nextValue</id> is an abrupt completion , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
    <step>ReturnIfAbrupt ( <id>nextValue</id> ).</step>
    <step>Append <value>undefined</value> to <id>values</id> .</step>
    <step>Let <id>nextPromise</id> be ? Invoke ( <id>constructor</id> , <value>"resolve"</value> , « <id>nextValue</id> »).</step>
    <step>Let <id>steps</id> be the algorithm steps defined in Promise.all Resolve Element Functions .</step>
    <step>Let <id>resolveElement</id> be CreateBuiltinFunction ( <id>steps</id> , « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] »).</step>
    <step>Set <id>resolveElement</id> .[[AlreadyCalled]] to a new Record { [[Value]]: <value>false</value> }.</step>
    <step>Set <id>resolveElement</id> .[[Index]] to <id>index</id> .</step>
    <step>Set <id>resolveElement</id> .[[Values]] to <id>values</id> .</step>
    <step>Set <id>resolveElement</id> .[[Capability]] to <id>resultCapability</id> .</step>
    <step>Set <id>resolveElement</id> .[[RemainingElements]] to <id>remainingElementsCount</id> .</step>
    <step>Set <id>remainingElementsCount</id> .[[Value]] to <id>remainingElementsCount</id> .[[Value]] + 1.</step>
    <step>Perform ? Invoke ( <id>nextPromise</id> , <value>"then"</value> , « <id>resolveElement</id> , <id>resultCapability</id> .[[Reject]] »).</step>
    <step>Set <id>index</id> to <id>index</id> + 1.</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>alreadyCalled</id> be <id>F</id> .[[AlreadyCalled]].</step>
  <step>If <id>alreadyCalled</id> .[[Value]] is <value>true</value> , return <value>undefined</value> .</step>
  <step>Set <id>alreadyCalled</id> .[[Value]] to <value>true</value> .</step>
  <step>Let <id>index</id> be <id>F</id> .[[Index]].</step>
  <step>Let <id>values</id> be <id>F</id> .[[Values]].</step>
  <step>Let <id>promiseCapability</id> be <id>F</id> .[[Capability]].</step>
  <step>Let <id>remainingElementsCount</id> be <id>F</id> .[[RemainingElements]].</step>
  <step>Set <id>values</id> [ <id>index</id> ] to <id>x</id> .</step>
  <step>Set <id>remainingElementsCount</id> .[[Value]] to <id>remainingElementsCount</id> .[[Value]] - 1.</step>
  <step>If <id>remainingElementsCount</id> .[[Value]] is 0, then   <step-list>
    <step>Let <id>valuesArray</id> be CreateArrayFromList ( <id>values</id> ).</step>
    <step>Return ? Call ( <id>promiseCapability</id> .[[Resolve]], <value>undefined</value> , « <id>valuesArray</id> »).</step>
  </step-list></step>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Let <id>C</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>C</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>promiseCapability</id> be ? NewPromiseCapability ( <id>C</id> ).</step>
  <step>Let <id>iteratorRecord</id> be GetIterator ( <id>iterable</id> ).</step>
  <step>IfAbruptRejectPromise ( <id>iteratorRecord</id> , <id>promiseCapability</id> ).</step>
  <step>Let <id>result</id> be PerformPromiseRace ( <id>iteratorRecord</id> , <id>C</id> , <id>promiseCapability</id> ).</step>
  <step>If <id>result</id> is an abrupt completion , then   <step-list>
    <step>If <id>iteratorRecord</id> .[[Done]] is <value>false</value> , let <id>result</id> be IteratorClose ( <id>iterator</id> , <id>result</id> ).</step>
    <step>IfAbruptRejectPromise ( <id>result</id> , <id>promiseCapability</id> ).</step>
  </step-list></step>
  <step>Return Completion ( <id>result</id> ).</step>
</step-list>
<step-list>
  <step>Assert : <id>constructor</id> is a constructor function.</step>
  <step>Assert : <id>resultCapability</id> is a PromiseCapability Record .</step>
  <step>Repeat,   <step-list>
    <step>Let <id>next</id> be IteratorStep ( <id>iteratorRecord</id> ).</step>
    <step>If <id>next</id> is an abrupt completion , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
    <step>ReturnIfAbrupt ( <id>next</id> ).</step>
    <step>If <id>next</id> is <value>false</value> , then     <step-list>
      <step>Set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
      <step>Return <id>resultCapability</id> .[[Promise]].</step>
    </step-list></step>
    <step>Let <id>nextValue</id> be IteratorValue ( <id>next</id> ).</step>
    <step>If <id>nextValue</id> is an abrupt completion , set <id>iteratorRecord</id> .[[Done]] to <value>true</value> .</step>
    <step>ReturnIfAbrupt ( <id>nextValue</id> ).</step>
    <step>Let <id>nextPromise</id> be ? Invoke ( <id>constructor</id> , <value>"resolve"</value> , « <id>nextValue</id> »).</step>
    <step>Perform ? Invoke ( <id>nextPromise</id> , <value>"then"</value> , « <id>resultCapability</id> .[[Resolve]], <id>resultCapability</id> .[[Reject]] »).</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>C</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>C</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>promiseCapability</id> be ? NewPromiseCapability ( <id>C</id> ).</step>
  <step>Perform ? Call ( <id>promiseCapability</id> .[[Reject]], <value>undefined</value> , « <id>r</id> »).</step>
  <step>Return <id>promiseCapability</id> .[[Promise]].</step>
</step-list>
<step-list>
  <step>Let <id>C</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>C</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Return ? PromiseResolve ( <id>C</id> , <id>x</id> ).</step>
</step-list>
<step-list>
  <step>Assert : Type ( <id>C</id> ) is Object.</step>
  <step>If IsPromise ( <id>x</id> ) is <value>true</value> , then   <step-list>
    <step>Let <id>xConstructor</id> be ? Get ( <id>x</id> , <value>"constructor"</value> ).</step>
    <step>If SameValue ( <id>xConstructor</id> , <id>C</id> ) is <value>true</value> , return <id>x</id> .</step>
  </step-list></step>
  <step>Let <id>promiseCapability</id> be ? NewPromiseCapability ( <id>C</id> ).</step>
  <step>Perform ? Call ( <id>promiseCapability</id> .[[Resolve]], <value>undefined</value> , « <id>x</id> »).</step>
  <step>Return <id>promiseCapability</id> .[[Promise]].</step>
</step-list>
<step-list>
  <step>Return the <value>this</value> value.</step>
</step-list>
<step-list>
  <step>Let <id>promise</id> be the <value>this</value> value.</step>
  <step>Return ? Invoke ( <id>promise</id> , <value>"then"</value> , « <value>undefined</value> , <id>onRejected</id> »).</step>
</step-list>
<step-list>
  <step>Let <id>promise</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>promise</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>C</id> be ? SpeciesConstructor ( <id>promise</id> , %Promise% ).</step>
  <step>Assert : IsConstructor ( <id>C</id> ) is <value>true</value> .</step>
  <step>If IsCallable ( <id>onFinally</id> ) is <value>false</value> , then   <step-list>
    <step>Let <id>thenFinally</id> be <id>onFinally</id> .</step>
    <step>Let <id>catchFinally</id> be <id>onFinally</id> .</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>stepsThenFinally</id> be the algorithm steps defined in Then Finally Functions .</step>
    <step>Let <id>thenFinally</id> be CreateBuiltinFunction ( <id>stepsThenFinally</id> , « [[Constructor]], [[OnFinally]] »).</step>
    <step>Set <id>thenFinally</id> .[[Constructor]] to <id>C</id> .</step>
    <step>Set <id>thenFinally</id> .[[OnFinally]] to <id>onFinally</id> .</step>
    <step>Let <id>stepsCatchFinally</id> be the algorithm steps defined in Catch Finally Functions .</step>
    <step>Let <id>catchFinally</id> be CreateBuiltinFunction ( <id>stepsCatchFinally</id> , « [[Constructor]], [[OnFinally]] »).</step>
    <step>Set <id>catchFinally</id> .[[Constructor]] to <id>C</id> .</step>
    <step>Set <id>catchFinally</id> .[[OnFinally]] to <id>onFinally</id> .</step>
  </step-list></step>
  <step>Return ? Invoke ( <id>promise</id> , <value>"then"</value> , « <id>thenFinally</id> , <id>catchFinally</id> »).</step>
</step-list>
<step-list>
  <step>Let <id>onFinally</id> be <id>F</id> .[[OnFinally]].</step>
  <step>Assert : IsCallable ( <id>onFinally</id> ) is <value>true</value> .</step>
  <step>Let <id>result</id> be ? Call ( <id>onFinally</id> , <value>undefined</value> ).</step>
  <step>Let <id>C</id> be <id>F</id> .[[Constructor]].</step>
  <step>Assert : IsConstructor ( <id>C</id> ) is <value>true</value> .</step>
  <step>Let <id>promise</id> be ? PromiseResolve ( <id>C</id> , <id>result</id> ).</step>
  <step>Let <id>valueThunk</id> be equivalent to a function that returns <id>value</id> .</step>
  <step>Return ? Invoke ( <id>promise</id> , <value>"then"</value> , « <id>valueThunk</id> »).</step>
</step-list>
<step-list>
  <step>Let <id>onFinally</id> be <id>F</id> .[[OnFinally]].</step>
  <step>Assert : IsCallable ( <id>onFinally</id> ) is <value>true</value> .</step>
  <step>Let <id>result</id> be ? Call ( <id>onFinally</id> , <value>undefined</value> ).</step>
  <step>Let <id>C</id> be <id>F</id> .[[Constructor]].</step>
  <step>Assert : IsConstructor ( <id>C</id> ) is <value>true</value> .</step>
  <step>Let <id>promise</id> be ? PromiseResolve ( <id>C</id> , <id>result</id> ).</step>
  <step>Let <id>thrower</id> be equivalent to a function that throws <id>reason</id> .</step>
  <step>Return ? Invoke ( <id>promise</id> , <value>"then"</value> , « <id>thrower</id> »).</step>
</step-list>
<step-list>
  <step>Let <id>promise</id> be the <value>this</value> value.</step>
  <step>If IsPromise ( <id>promise</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>C</id> be ? SpeciesConstructor ( <id>promise</id> , %Promise% ).</step>
  <step>Let <id>resultCapability</id> be ? NewPromiseCapability ( <id>C</id> ).</step>
  <step>Return PerformPromiseThen ( <id>promise</id> , <id>onFulfilled</id> , <id>onRejected</id> , <id>resultCapability</id> ).</step>
</step-list>
<step-list>
  <step>Assert : IsPromise ( <id>promise</id> ) is <value>true</value> .</step>
  <step>Assert : <id>resultCapability</id> is a PromiseCapability Record .</step>
  <step>If IsCallable ( <id>onFulfilled</id> ) is <value>false</value> , then   <step-list>
    <step>Set <id>onFulfilled</id> to <value>undefined</value> .</step>
  </step-list></step>
  <step>If IsCallable ( <id>onRejected</id> ) is <value>false</value> , then   <step-list>
    <step>Set <id>onRejected</id> to <value>undefined</value> .</step>
  </step-list></step>
  <step>Let <id>fulfillReaction</id> be the PromiseReaction { [[Capability]]: <id>resultCapability</id> , [[Type]]: <value>"Fulfill"</value> , [[Handler]]: <id>onFulfilled</id> }.</step>
  <step>Let <id>rejectReaction</id> be the PromiseReaction { [[Capability]]: <id>resultCapability</id> , [[Type]]: <value>"Reject"</value> , [[Handler]]: <id>onRejected</id> }.</step>
  <step>If <id>promise</id> .[[PromiseState]] is <value>"pending"</value> , then   <step-list>
    <step>Append <id>fulfillReaction</id> as the last element of the List that is <id>promise</id> .[[PromiseFulfillReactions]].</step>
    <step>Append <id>rejectReaction</id> as the last element of the List that is <id>promise</id> .[[PromiseRejectReactions]].</step>
  </step-list></step>
  <step>Else if <id>promise</id> .[[PromiseState]] is <value>"fulfilled"</value> , then   <step-list>
    <step>Let <id>value</id> be <id>promise</id> .[[PromiseResult]].</step>
    <step>Perform EnqueueJob ( <value>"PromiseJobs"</value> , PromiseReactionJob , « <id>fulfillReaction</id> , <id>value</id> »).</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Assert : The value of <id>promise</id> .[[PromiseState]] is <value>"rejected"</value> .</step>
    <step>Let <id>reason</id> be <id>promise</id> .[[PromiseResult]].</step>
    <step>If <id>promise</id> .[[PromiseIsHandled]] is <value>false</value> , perform HostPromiseRejectionTracker ( <id>promise</id> , <value>"handle"</value> ).</step>
    <step>Perform EnqueueJob ( <value>"PromiseJobs"</value> , PromiseReactionJob , « <id>rejectReaction</id> , <id>reason</id> »).</step>
  </step-list></step>
  <step>Set <id>promise</id> .[[PromiseIsHandled]] to <value>true</value> .</step>
  <step>Return <id>resultCapability</id> .[[Promise]].</step>
</step-list>
<step-list>
  <step>Let <id>C</id> be the active function object .</step>
  <step>Let <id>args</id> be the <id>argumentsList</id> that was passed to this function by [[Call]] or [[Construct]].</step>
  <step>Return CreateDynamicFunction ( <id>C</id> , NewTarget, <value>"async"</value> , <id>args</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>runningContext</id> be the running execution context .</step>
  <step>Let <id>asyncContext</id> be a copy of <id>runningContext</id> .</step>
  <step>Set the code evaluation state of <id>asyncContext</id> such that when evaluation is resumed for that execution context the following steps will be performed:   <step-list>
    <step>Let <id>result</id> be the result of evaluating <id>asyncFunctionBody</id> .</step>
    <step>Assert :
 If we return here, the async function either threw an exception or 
performed an implicit or explicit return; all awaiting is done.</step>
    <step>Remove <id>asyncContext</id> from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context .</step>
    <step>If <id>result</id> .[[Type]] is <value>normal</value> , then     <step-list>
      <step>Perform ! Call ( <id>promiseCapability</id> .[[Resolve]], <value>undefined</value> , « <value>undefined</value> »).</step>
    </step-list></step>
    <step>Else if <id>result</id> .[[Type]] is <value>return</value> , then     <step-list>
      <step>Perform ! Call ( <id>promiseCapability</id> .[[Resolve]], <value>undefined</value> , « <id>result</id> .[[Value]] »).</step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>Assert : <id>result</id> .[[Type]] is <value>throw</value> .</step>
      <step>Perform ! Call ( <id>promiseCapability</id> .[[Reject]], <value>undefined</value> , « <id>result</id> .[[Value]] »).</step>
    </step-list></step>
    <step>Return.</step>
  </step-list></step>
  <step>Push <id>asyncContext</id> onto the execution context stack ; <id>asyncContext</id> is now the running execution context .</step>
  <step>Resume the suspended evaluation of <id>asyncContext</id> . Let <id>result</id> be the value returned by the resumed computation.</step>
  <step>Assert : When we return here, <id>asyncContext</id> has already been removed from the execution context stack and <id>runningContext</id> is the currently running execution context .</step>
  <step>Assert : <id>result</id> is a normal completion with a value of <value>undefined</value> . The possible sources of completion values are Await or, if the async function doesn't await anything, the step 3.g above.</step>
  <step>Return.</step>
</step-list>
<step-list>
  <step>If IsCallable ( <id>target</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>args</id> be ? CreateListFromArrayLike ( <id>argumentsList</id> ).</step>
  <step>Perform PrepareForTailCall ().</step>
  <step>Return ? Call ( <id>target</id> , <id>thisArgument</id> , <id>args</id> ).</step>
</step-list>
<step-list>
  <step>If IsConstructor ( <id>target</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>If <id>newTarget</id> is not present, let <id>newTarget</id> be <id>target</id> .</step>
  <step>Else if IsConstructor ( <id>newTarget</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>args</id> be ? CreateListFromArrayLike ( <id>argumentsList</id> ).</step>
  <step>Return ? Construct ( <id>target</id> , <id>args</id> , <id>newTarget</id> ).</step>
</step-list>
<step-list>
  <step>If Type ( <id>target</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>key</id> be ? ToPropertyKey ( <id>propertyKey</id> ).</step>
  <step>Let <id>desc</id> be ? ToPropertyDescriptor ( <id>attributes</id> ).</step>
  <step>Return ? <id>target</id> .[[DefineOwnProperty]]( <id>key</id> , <id>desc</id> ).</step>
</step-list>
<step-list>
  <step>If Type ( <id>target</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>key</id> be ? ToPropertyKey ( <id>propertyKey</id> ).</step>
  <step>Return ? <id>target</id> .[[Delete]]( <id>key</id> ).</step>
</step-list>
<step-list>
  <step>If Type ( <id>target</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>key</id> be ? ToPropertyKey ( <id>propertyKey</id> ).</step>
  <step>If <id>receiver</id> is not present, then   <step-list>
    <step>Let <id>receiver</id> be <id>target</id> .</step>
  </step-list></step>
  <step>Return ? <id>target</id> .[[Get]]( <id>key</id> , <id>receiver</id> ).</step>
</step-list>
<step-list>
  <step>If Type ( <id>target</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>key</id> be ? ToPropertyKey ( <id>propertyKey</id> ).</step>
  <step>Let <id>desc</id> be ? <id>target</id> .[[GetOwnProperty]]( <id>key</id> ).</step>
  <step>Return FromPropertyDescriptor ( <id>desc</id> ).</step>
</step-list>
<step-list>
  <step>If Type ( <id>target</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Return ? <id>target</id> .[[GetPrototypeOf]]().</step>
</step-list>
<step-list>
  <step>If Type ( <id>target</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>key</id> be ? ToPropertyKey ( <id>propertyKey</id> ).</step>
  <step>Return ? <id>target</id> .[[HasProperty]]( <id>key</id> ).</step>
</step-list>
<step-list>
  <step>If Type ( <id>target</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Return ? <id>target</id> .[[IsExtensible]]().</step>
</step-list>
<step-list>
  <step>If Type ( <id>target</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>keys</id> be ? <id>target</id> .[[OwnPropertyKeys]]().</step>
  <step>Return CreateArrayFromList ( <id>keys</id> ).</step>
</step-list>
<step-list>
  <step>If Type ( <id>target</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Return ? <id>target</id> .[[PreventExtensions]]().</step>
</step-list>
<step-list>
  <step>If Type ( <id>target</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>Let <id>key</id> be ? ToPropertyKey ( <id>propertyKey</id> ).</step>
  <step>If <id>receiver</id> is not present, then   <step-list>
    <step>Let <id>receiver</id> be <id>target</id> .</step>
  </step-list></step>
  <step>Return ? <id>target</id> .[[Set]]( <id>key</id> , <id>V</id> , <id>receiver</id> ).</step>
</step-list>
<step-list>
  <step>If Type ( <id>target</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
  <step>If Type ( <id>proto</id> ) is not Object and <id>proto</id> is not <value>null</value> , throw a <value>TypeError</value> exception.</step>
  <step>Return ? <id>target</id> .[[SetPrototypeOf]]( <id>proto</id> ).</step>
</step-list>
<step-list>
  <step>If NewTarget is <value>undefined</value> , throw a <value>TypeError</value> exception.</step>
  <step>Return ? ProxyCreate ( <id>target</id> , <id>handler</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>p</id> be ? ProxyCreate ( <id>target</id> , <id>handler</id> ).</step>
  <step>Let <id>steps</id> be the algorithm steps defined in Proxy Revocation Functions .</step>
  <step>Let <id>revoker</id> be CreateBuiltinFunction ( <id>steps</id> , « [[RevocableProxy]] »).</step>
  <step>Set <id>revoker</id> .[[RevocableProxy]] to <id>p</id> .</step>
  <step>Let <id>result</id> be ObjectCreate ( %ObjectPrototype% ).</step>
  <step>Perform CreateDataProperty ( <id>result</id> , <value>"proxy"</value> , <id>p</id> ).</step>
  <step>Perform CreateDataProperty ( <id>result</id> , <value>"revoke"</value> , <id>revoker</id> ).</step>
  <step>Return <id>result</id> .</step>
</step-list>
<step-list>
  <step>Let <id>p</id> be <id>F</id> .[[RevocableProxy]].</step>
  <step>If <id>p</id> is <value>null</value> , return <value>undefined</value> .</step>
  <step>Set <id>F</id> .[[RevocableProxy]] to <value>null</value> .</step>
  <step>Assert : <id>p</id> is a Proxy object.</step>
  <step>Set <id>p</id> .[[ProxyTarget]] to <value>null</value> .</step>
  <step>Set <id>p</id> .[[ProxyHandler]] to <value>null</value> .</step>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Let <id>events</id> be an empty Set.</step>
  <step>For each Agent Events Record  <id>aer</id> in <id>execution</id> .[[EventLists]], do   <step-list>
    <step>For each event <id>E</id> in <id>aer</id> .[[EventList]], do     <step-list>
      <step>Add <id>E</id> to <id>events</id> .</step>
    </step-list></step>
  </step-list></step>
  <step>Return <id>events</id> .</step>
</step-list>
<step-list>
  <step>Let <id>events</id> be an empty Set.</step>
  <step>For each event <id>E</id> in EventSet ( <id>execution</id> ), do   <step-list>
    <step>If <id>E</id> is a ReadSharedMemory , WriteSharedMemory , or ReadModifyWriteSharedMemory event, add <id>E</id> to <id>events</id> .</step>
  </step-list></step>
  <step>Return <id>events</id> .</step>
</step-list>
<step-list>
  <step>Let <id>events</id> be an empty Set.</step>
  <step>For each event <id>E</id> in EventSet ( <id>execution</id> ), do   <step-list>
    <step>If <id>E</id> is not in SharedDataBlockEventSet ( <id>execution</id> ), add <id>E</id> to <id>events</id> .</step>
  </step-list></step>
  <step>Return <id>events</id> .</step>
</step-list>
<step-list>
  <step>Let <id>byteLocation</id> be <id>byteIndex</id> .</step>
  <step>Let <id>bytesRead</id> be a new empty List .</step>
  <step>For each element <id>W</id> of <id>Ws</id> in List order, do   <step-list>
    <step>Assert : <id>W</id> has <id>byteLocation</id> in its range.</step>
    <step>Let <id>payloadIndex</id> be <id>byteLocation</id> - <id>W</id> .[[ByteIndex]].</step>
    <step>If <id>W</id> is a WriteSharedMemory event, then     <step-list>
      <step>Let <id>byte</id> be <id>W</id> .[[Payload]][ <id>payloadIndex</id> ].</step>
    </step-list></step>
    <step>Else,     <step-list>
      <step>Assert : <id>W</id> is a ReadModifyWriteSharedMemory event.</step>
      <step>Let <id>bytes</id> be ValueOfReadEvent ( <id>execution</id> , <id>W</id> ).</step>
      <step>Let <id>bytesModified</id> be <id>W</id> .[[ModifyOp]]( <id>bytes</id> , <id>W</id> .[[Payload]]).</step>
      <step>Let <id>byte</id> be <id>bytesModified</id> [ <id>payloadIndex</id> ].</step>
    </step-list></step>
    <step>Append <id>byte</id> to <id>bytesRead</id> .</step>
    <step>Increment <id>byteLocation</id> by 1.</step>
  </step-list></step>
  <step>Return <id>bytesRead</id> .</step>
</step-list>
<step-list>
  <step>Assert : <id>R</id> is a ReadSharedMemory or ReadModifyWriteSharedMemory event.</step>
  <step>Let <id>Ws</id> be <id>execution</id> .[[ReadsBytesFrom]]( <id>R</id> ).</step>
  <step>Assert : <id>Ws</id> is a List of WriteSharedMemory or ReadModifyWriteSharedMemory events with length equal to <id>R</id> .[[ElementSize]].</step>
  <step>Return ComposeWriteEventBytes ( <id>execution</id> , <id>R</id> .[[ByteIndex]], <id>Ws</id> ).</step>
</step-list>
<step-list>
  <step>For each ReadSharedMemory or ReadModifyWriteSharedMemory event <id>R</id> in SharedDataBlockEventSet ( <id>execution</id> ), do   <step-list>
    <step>Let <id>chosenValue</id> be the element of <id>execution</id> .[[ChosenValues]] whose [[Event]] field is <id>R</id> .</step>
    <step>Let <id>readValue</id> be ValueOfReadEvent ( <id>execution</id> , <id>R</id> ).</step>
    <step>Let <id>chosenLen</id> be the number of elements of <id>chosenValue</id> .</step>
    <step>Let <id>readLen</id> be the number of elements of <id>readValue</id> .</step>
    <step>If <id>chosenLen</id> is not equal to <id>readLen</id> , then     <step-list>
      <step>Return <value>false</value> .</step>
    </step-list></step>
    <step>If <id>chosenValue</id> [ <id>i</id> ] is not equal to <id>readValue</id> [ <id>i</id> ] for any integer value <id>i</id> in the range 0 through <id>chosenLen</id> , exclusive, then     <step-list>
      <step>Return <value>false</value> .</step>
    </step-list></step>
    <step>Return <value>true</value> .</step>
  </step-list></step>
</step-list>
<step-list>
  <step>For each ReadSharedMemory or ReadModifyWriteSharedMemory event <id>R</id> in SharedDataBlockEventSet ( <id>execution</id> ), do   <step-list>
    <step>Let <id>Ws</id> be <id>execution</id> .[[ReadsBytesFrom]]( <id>R</id> ).</step>
    <step>Let <id>byteLocation</id> be <id>R</id> .[[ByteIndex]].</step>
    <step>For each element <id>W</id> of <id>Ws</id> in List order, do     <step-list>
      <step>If ( <id>R</id> , <id>W</id> ) is in <id>execution</id> .[[HappensBefore]], then       <step-list>
        <step>Return <value>false</value> .</step>
      </step-list></step>
      <step>If there is a WriteSharedMemory or ReadModifyWriteSharedMemory event <id>V</id> that has <id>byteLocation</id> in its range such that the pairs ( <id>W</id> , <id>V</id> ) and ( <id>V</id> , <id>R</id> ) are in <id>execution</id> .[[HappensBefore]], then       <step-list>
        <step>Return <value>false</value> .</step>
      </step-list></step>
      <step>Increment <id>byteLocation</id> by 1.</step>
    </step-list></step>
    <step>Return <value>true</value> .</step>
  </step-list></step>
</step-list>
<step-list>
  <step>For each ReadSharedMemory or ReadModifyWriteSharedMemory event <id>R</id> in SharedDataBlockEventSet ( <id>execution</id> ), do   <step-list>
    <step>If <id>R</id> .[[NoTear]] is <value>true</value> , then     <step-list>
      <step>Assert : The remainder of dividing <id>R</id> .[[ByteIndex]] by <id>R</id> .[[ElementSize]] is 0.</step>
      <step>For each event <id>W</id> such that ( <id>R</id> , <id>W</id> ) is in <id>execution</id> .[[ReadsFrom]] and <id>W</id> .[[NoTear]] is <value>true</value> , do       <step-list>
        <step>If <id>R</id> and <id>W</id> have equal ranges, and there is an event <id>V</id> such that <id>V</id> and <id>W</id> have equal ranges, <id>V</id> .[[NoTear]] is <value>true</value> , <id>W</id> is not <id>V</id> , and ( <id>R</id> , <id>V</id> ) is in <id>execution</id> .[[ReadsFrom]], then         <step-list>
          <step>Return <value>false</value> .</step>
        </step-list></step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>If <id>E</id> is not <id>D</id> , then   <step-list>
    <step>If the pairs ( <id>E</id> , <id>D</id> ) and ( <id>D</id> , <id>E</id> ) are not in <id>execution</id> .[[HappensBefore]], then     <step-list>
      <step>If <id>E</id> and <id>D</id> are both WriteSharedMemory or ReadModifyWriteSharedMemory events and <id>E</id> and <id>D</id> do not have disjoint ranges, then       <step-list>
        <step>Return <value>true</value> .</step>
      </step-list></step>
      <step>If either ( <id>E</id> , <id>D</id> ) or ( <id>D</id> , <id>E</id> ) is in <id>execution</id> .[[ReadsFrom]], then       <step-list>
        <step>Return <value>true</value> .</step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>If <id>E</id> and <id>D</id> are in a race in <id>execution</id> , then   <step-list>
    <step>If <id>E</id> .[[Order]] is not <value>"SeqCst"</value> or <id>D</id> .[[Order]] is not <value>"SeqCst"</value> , then     <step-list>
      <step>Return <value>true</value> .</step>
    </step-list></step>
    <step>If <id>E</id> and <id>D</id> have overlapping ranges, then     <step-list>
      <step>Return <value>true</value> .</step>
    </step-list></step>
  </step-list></step>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Return the code point value of U+005C (REVERSE SOLIDUS).</step>
</step-list>
<step-list>
  <step>Let <id>ch</id> be the code point matched by ClassControlLetter .</step>
  <step>Let <id>i</id> be <id>ch</id> 's code point value.</step>
  <step>Return the remainder of dividing <id>i</id> by 32.</step>
</step-list>
<step-list>
  <step>Evaluate the SV of the LegacyOctalEscapeSequence (see B.1.2 ) to obtain a code unit <id>cu</id> .</step>
  <step>Return the numeric value of <id>cu</id> .</step>
</step-list>
<step-list>
  <step>Evaluate QuantifiableAssertion to obtain a Matcher <id>m</id> .</step>
  <step>Return <id>m</id> .</step>
</step-list>
<step-list>
  <step>Let <id>A</id> be the CharSet containing the single character <value>\</value> U+005C (REVERSE SOLIDUS).</step>
  <step>Call CharacterSetMatcher ( <id>A</id> , <value>false</value> ) and return its Matcher result.</step>
</step-list>
<step-list>
  <step>Let <id>ch</id> be the character represented by ExtendedPatternCharacter .</step>
  <step>Let <id>A</id> be a one-element CharSet containing the character <id>ch</id> .</step>
  <step>Call CharacterSetMatcher ( <id>A</id> , <value>false</value> ) and return its Matcher result.</step>
</step-list>
<step-list>
  <step>Let <id>cv</id> be the CharacterValue of this CharacterEscape .</step>
  <step>Return the character whose character value is <id>cv</id> .</step>
</step-list>
<step-list>
  <step>Evaluate the first ClassAtom to obtain a CharSet <id>A</id> .</step>
  <step>Evaluate the second ClassAtom to obtain a CharSet <id>B</id> .</step>
  <step>Evaluate ClassRanges to obtain a CharSet <id>C</id> .</step>
  <step>Call CharacterRangeOrUnion ( <id>A</id> , <id>B</id> ) and let <id>D</id> be the resulting CharSet.</step>
  <step>Return the union of CharSets <id>D</id> and <id>C</id> .</step>
</step-list>
<step-list>
  <step>Evaluate ClassAtomNoDash to obtain a CharSet <id>A</id> .</step>
  <step>Evaluate ClassAtom to obtain a CharSet <id>B</id> .</step>
  <step>Evaluate ClassRanges to obtain a CharSet <id>C</id> .</step>
  <step>Call CharacterRangeOrUnion ( <id>A</id> , <id>B</id> ) and let <id>D</id> be the resulting CharSet.</step>
  <step>Return the union of CharSets <id>D</id> and <id>C</id> .</step>
</step-list>
<step-list>
  <step>Let <id>cv</id> be the CharacterValue of this ClassEscape .</step>
  <step>Let <id>c</id> be the character whose character value is <id>cv</id> .</step>
  <step>Return the CharSet containing the single character <id>c</id> .</step>
</step-list>
<step-list>
  <step>Return the CharSet containing the single character <value>\</value> U+005C (REVERSE SOLIDUS).</step>
</step-list>
<step-list>
  <step>If <id>Unicode</id> is <value>false</value> , then   <step-list>
    <step>If <id>A</id> does not contain exactly one character or <id>B</id> does not contain exactly one character, then     <step-list>
      <step>Let <id>C</id> be the CharSet containing the single character <value>-</value> U+002D (HYPHEN-MINUS).</step>
      <step>Return the union of CharSets <id>A</id> , <id>B</id> and <id>C</id> .</step>
    </step-list></step>
  </step-list></step>
  <step>Return CharacterRange ( <id>A</id> , <id>B</id> ).</step>
</step-list>
<step-list>
  <step>Set <id>string</id> to ? ToString ( <id>string</id> ).</step>
  <step>Let <id>length</id> be the number of code units in <id>string</id> .</step>
  <step>Let <id>R</id> be the empty string.</step>
  <step>Let <id>k</id> be 0.</step>
  <step>Repeat, while <id>k</id> < <id>length</id> ,   <step-list>
    <step>Let <id>char</id> be the code unit (represented as a 16-bit unsigned integer) at index <id>k</id> within <id>string</id> .</step>
    <step>If <id>char</id> is one of the code units in <value>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@*_+-./"</value> , then     <step-list>
      <step>Let <id>S</id> be the String value containing the single code unit <id>char</id> .</step>
    </step-list></step>
    <step>Else if <id>char</id> ≥ 256, then     <step-list>
      <step>Let <id>n</id> be the numeric value of <id>char</id> .</step>
      <step>Let <id>S</id> be the string-concatenation of: "%u"
the String representation of n, formatted as a four-digit uppercase hexadecimal number, padded to the left with zeroes if necessary</step>
    </step-list></step>
    <step>Else <id>char</id> < 256,     <step-list>
      <step>Let <id>n</id> be the numeric value of <id>char</id> .</step>
      <step>Let <id>S</id> be the string-concatenation of: "%"
the String representation of n, formatted as a two-digit uppercase hexadecimal number, padded to the left with a zero if necessary</step>
    </step-list></step>
    <step>Set <id>R</id> to the string-concatenation of the previous value of <id>R</id> and <id>S</id> .</step>
    <step>Increase <id>k</id> by 1.</step>
  </step-list></step>
  <step>Return <id>R</id> .</step>
</step-list>
<step-list>
  <step>Set <id>string</id> to ? ToString ( <id>string</id> ).</step>
  <step>Let <id>length</id> be the number of code units in <id>string</id> .</step>
  <step>Let <id>R</id> be the empty String.</step>
  <step>Let <id>k</id> be 0.</step>
  <step>Repeat, while <id>k</id> ≠ <id>length</id>   <step-list>
    <step>Let <id>c</id> be the code unit at index <id>k</id> within <id>string</id> .</step>
    <step>If <id>c</id> is the code unit 0x0025 (PERCENT SIGN), then     <step-list>
      <step>If <id>k</id> ≤ <id>length</id> -6 and the code unit at index <id>k</id> +1 within <id>string</id> is the code unit 0x0075 (LATIN SMALL LETTER U) and the four code units at indices <id>k</id> +2, <id>k</id> +3, <id>k</id> +4, and <id>k</id> +5 within <id>string</id> are all hexadecimal digits, then       <step-list>
        <step>Let <id>c</id> be the code unit whose value is the integer represented by the four hexadecimal digits at indices <id>k</id> +2, <id>k</id> +3, <id>k</id> +4, and <id>k</id> +5 within <id>string</id> .</step>
        <step>Increase <id>k</id> by 5.</step>
      </step-list></step>
      <step>Else if <id>k</id> ≤ <id>length</id> -3 and the two code units at indices <id>k</id> +1 and <id>k</id> +2 within <id>string</id> are both hexadecimal digits, then       <step-list>
        <step>Let <id>c</id> be the code unit whose value is the integer represented by two zeroes plus the two hexadecimal digits at indices <id>k</id> +1 and <id>k</id> +2 within <id>string</id> .</step>
        <step>Increase <id>k</id> by 2.</step>
      </step-list></step>
    </step-list></step>
    <step>Set <id>R</id> to the string-concatenation of the previous value of <id>R</id> and <id>c</id> .</step>
    <step>Increase <id>k</id> by 1.</step>
  </step-list></step>
  <step>Return <id>R</id> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Return ? <id>O</id> .[[GetPrototypeOf]]().</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? RequireObjectCoercible ( <value>this</value> value).</step>
  <step>If Type ( <id>proto</id> ) is neither Object nor Null, return <value>undefined</value> .</step>
  <step>If Type ( <id>O</id> ) is not Object, return <value>undefined</value> .</step>
  <step>Let <id>status</id> be ? <id>O</id> .[[SetPrototypeOf]]( <id>proto</id> ).</step>
  <step>If <id>status</id> is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>If IsCallable ( <id>getter</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>desc</id> be PropertyDescriptor { [[Get]]: <id>getter</id> , [[Enumerable]]: <value>true</value> , [[Configurable]]: <value>true</value> }.</step>
  <step>Let <id>key</id> be ? ToPropertyKey ( <id>P</id> ).</step>
  <step>Perform ? DefinePropertyOrThrow ( <id>O</id> , <id>key</id> , <id>desc</id> ).</step>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>If IsCallable ( <id>setter</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
  <step>Let <id>desc</id> be PropertyDescriptor { [[Set]]: <id>setter</id> , [[Enumerable]]: <value>true</value> , [[Configurable]]: <value>true</value> }.</step>
  <step>Let <id>key</id> be ? ToPropertyKey ( <id>P</id> ).</step>
  <step>Perform ? DefinePropertyOrThrow ( <id>O</id> , <id>key</id> , <id>desc</id> ).</step>
  <step>Return <value>undefined</value> .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Let <id>key</id> be ? ToPropertyKey ( <id>P</id> ).</step>
  <step>Repeat,   <step-list>
    <step>Let <id>desc</id> be ? <id>O</id> .[[GetOwnProperty]]( <id>key</id> ).</step>
    <step>If <id>desc</id> is not <value>undefined</value> , then     <step-list>
      <step>If IsAccessorDescriptor ( <id>desc</id> ) is <value>true</value> , return <id>desc</id> .[[Get]].</step>
      <step>Return <value>undefined</value> .</step>
    </step-list></step>
    <step>Set <id>O</id> to ? <id>O</id> .[[GetPrototypeOf]]().</step>
    <step>If <id>O</id> is <value>null</value> , return <value>undefined</value> .</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? ToObject ( <value>this</value> value).</step>
  <step>Let <id>key</id> be ? ToPropertyKey ( <id>P</id> ).</step>
  <step>Repeat,   <step-list>
    <step>Let <id>desc</id> be ? <id>O</id> .[[GetOwnProperty]]( <id>key</id> ).</step>
    <step>If <id>desc</id> is not <value>undefined</value> , then     <step-list>
      <step>If IsAccessorDescriptor ( <id>desc</id> ) is <value>true</value> , return <id>desc</id> .[[Set]].</step>
      <step>Return <value>undefined</value> .</step>
    </step-list></step>
    <step>Set <id>O</id> to ? <id>O</id> .[[GetPrototypeOf]]().</step>
    <step>If <id>O</id> is <value>null</value> , return <value>undefined</value> .</step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>O</id> be ? RequireObjectCoercible ( <value>this</value> value).</step>
  <step>Let <id>S</id> be ? ToString ( <id>O</id> ).</step>
  <step>Let <id>intStart</id> be ? ToInteger ( <id>start</id> ).</step>
  <step>If <id>length</id> is <value>undefined</value> , let <id>end</id> be <value>+∞</value> ; otherwise let <id>end</id> be ? ToInteger ( <id>length</id> ).</step>
  <step>Let <id>size</id> be the number of code units in <id>S</id> .</step>
  <step>If <id>intStart</id> < 0, let <id>intStart</id> be max ( <id>size</id> + <id>intStart</id> , 0).</step>
  <step>Let <id>resultLength</id> be min ( max ( <id>end</id> , 0), <id>size</id> - <id>intStart</id> ).</step>
  <step>If <id>resultLength</id> ≤ 0, return the empty String <value>""</value> .</step>
  <step>Return the String value containing <id>resultLength</id> consecutive code units from <id>S</id> beginning with the code unit at index <id>intStart</id> .</step>
</step-list>
<step-list>
  <step>Let <id>S</id> be the <value>this</value> value.</step>
  <step>Return ? CreateHTML ( <id>S</id> , <value>"a"</value> , <value>"name"</value> , <id>name</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>str</id> be ? RequireObjectCoercible ( <id>string</id> ).</step>
  <step>Let <id>S</id> be ? ToString ( <id>str</id> ).</step>
  <step>Let <id>p1</id> be the string-concatenation of <value>"<"</value> and <id>tag</id> .</step>
  <step>If <id>attribute</id> is not the empty String, then   <step-list>
    <step>Let <id>V</id> be ? ToString ( <id>value</id> ).</step>
    <step>Let <id>escapedV</id> be the String value that is the same as <id>V</id> except that each occurrence of the code unit 0x0022 (QUOTATION MARK) in <id>V</id> has been replaced with the six code unit sequence <value>"&quot;"</value> .</step>
    <step>Set <id>p1</id> to the string-concatenation of: p1
the code unit 0x0020 (SPACE)
attribute
the code unit 0x003D (EQUALS SIGN)
the code unit 0x0022 (QUOTATION MARK)
escapedV
the code unit 0x0022 (QUOTATION MARK)</step>
  </step-list></step>
  <step>Let <id>p2</id> be the string-concatenation of <id>p1</id> and <value>">"</value> .</step>
  <step>Let <id>p3</id> be the string-concatenation of <id>p2</id> and <id>S</id> .</step>
  <step>Let <id>p4</id> be the string-concatenation of <id>p3</id> , <value>"</"</value> , <id>tag</id> , and <value>">"</value> .</step>
  <step>Return <id>p4</id> .</step>
</step-list>
<step-list>
  <step>Let <id>S</id> be the <value>this</value> value.</step>
  <step>Return ? CreateHTML ( <id>S</id> , <value>"big"</value> , <value>""</value> , <value>""</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>S</id> be the <value>this</value> value.</step>
  <step>Return ? CreateHTML ( <id>S</id> , <value>"blink"</value> , <value>""</value> , <value>""</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>S</id> be the <value>this</value> value.</step>
  <step>Return ? CreateHTML ( <id>S</id> , <value>"b"</value> , <value>""</value> , <value>""</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>S</id> be the <value>this</value> value.</step>
  <step>Return ? CreateHTML ( <id>S</id> , <value>"tt"</value> , <value>""</value> , <value>""</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>S</id> be the <value>this</value> value.</step>
  <step>Return ? CreateHTML ( <id>S</id> , <value>"font"</value> , <value>"color"</value> , <id>color</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>S</id> be the <value>this</value> value.</step>
  <step>Return ? CreateHTML ( <id>S</id> , <value>"font"</value> , <value>"size"</value> , <id>size</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>S</id> be the <value>this</value> value.</step>
  <step>Return ? CreateHTML ( <id>S</id> , <value>"i"</value> , <value>""</value> , <value>""</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>S</id> be the <value>this</value> value.</step>
  <step>Return ? CreateHTML ( <id>S</id> , <value>"a"</value> , <value>"href"</value> , <id>url</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>S</id> be the <value>this</value> value.</step>
  <step>Return ? CreateHTML ( <id>S</id> , <value>"small"</value> , <value>""</value> , <value>""</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>S</id> be the <value>this</value> value.</step>
  <step>Return ? CreateHTML ( <id>S</id> , <value>"strike"</value> , <value>""</value> , <value>""</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>S</id> be the <value>this</value> value.</step>
  <step>Return ? CreateHTML ( <id>S</id> , <value>"sub"</value> , <value>""</value> , <value>""</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>S</id> be the <value>this</value> value.</step>
  <step>Return ? CreateHTML ( <id>S</id> , <value>"sup"</value> , <value>""</value> , <value>""</value> ).</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be ? thisTimeValue ( <value>this</value> value).</step>
  <step>If <id>t</id> is <value>NaN</value> , return <value>NaN</value> .</step>
  <step>Return YearFromTime ( LocalTime ( <id>t</id> )) - 1900.</step>
</step-list>
<step-list>
  <step>Let <id>t</id> be ? thisTimeValue ( <value>this</value> value).</step>
  <step>If <id>t</id> is <value>NaN</value> , let <id>t</id> be <value>+0</value> ; otherwise, let <id>t</id> be LocalTime ( <id>t</id> ).</step>
  <step>Let <id>y</id> be ? ToNumber ( <id>year</id> ).</step>
  <step>If <id>y</id> is <value>NaN</value> , set the [[DateValue]] internal slot of this Date object to <value>NaN</value> and return <value>NaN</value> .</step>
  <step>If 0 ≤ ToInteger ( <id>y</id> ) ≤ 99, let <id>yyyy</id> be ToInteger ( <id>y</id> ) + 1900.</step>
  <step>Else, let <id>yyyy</id> be <id>y</id> .</step>
  <step>Let <id>d</id> be MakeDay ( <id>yyyy</id> , MonthFromTime ( <id>t</id> ), DateFromTime ( <id>t</id> )).</step>
  <step>Let <id>date</id> be UTC ( MakeDate ( <id>d</id> , TimeWithinDay ( <id>t</id> ))).</step>
  <step>Set the [[DateValue]] internal slot of this Date object to TimeClip ( <id>date</id> ).</step>
  <step>Return the value of the [[DateValue]] internal slot of this Date object .</step>
</step-list>
<step-list>
  <step>Let <id>O</id> be the <value>this</value> value.</step>
  <step>If Type ( <id>O</id> ) is not Object or Type ( <id>O</id> ) is Object and <id>O</id> does not have a [[RegExpMatcher]] internal slot, then   <step-list>
    <step>Throw a <value>TypeError</value> exception.</step>
  </step-list></step>
  <step>If Type ( <id>pattern</id> ) is Object and <id>pattern</id> has a [[RegExpMatcher]] internal slot, then   <step-list>
    <step>If <id>flags</id> is not <value>undefined</value> , throw a <value>TypeError</value> exception.</step>
    <step>Let <id>P</id> be <id>pattern</id> .[[OriginalSource]].</step>
    <step>Let <id>F</id> be <id>pattern</id> .[[OriginalFlags]].</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Let <id>P</id> be <id>pattern</id> .</step>
    <step>Let <id>F</id> be <id>flags</id> .</step>
  </step-list></step>
  <step>Return ? RegExpInitialize ( <id>O</id> , <id>P</id> , <id>F</id> ).</step>
</step-list>
<step-list>
  <step>Let <id>propKey</id> be the result of evaluating PropertyName .</step>
  <step>ReturnIfAbrupt ( <id>propKey</id> ).</step>
  <step>Let <id>exprValueRef</id> be the result of evaluating AssignmentExpression .</step>
  <step>Let <id>propValue</id> be ? GetValue ( <id>exprValueRef</id> ).</step>
  <step>If <id>propKey</id> is the String value <value>"__proto__"</value> and if IsComputedPropertyKey( PropertyName ) is <value>false</value> , then   <step-list>
    <step>If Type ( <id>propValue</id> ) is either Object or Null, then     <step-list>
      <step>Return <id>object</id> .[[SetPrototypeOf]]( <id>propValue</id> ).</step>
    </step-list></step>
    <step>Return NormalCompletion ( <value>empty</value> ).</step>
  </step-list></step>
  <step>If IsAnonymousFunctionDefinition ( AssignmentExpression ) is <value>true</value> , then   <step-list>
    <step>Let <id>hasNameProperty</id> be ? HasOwnProperty ( <id>propValue</id> , <value>"name"</value> ).</step>
    <step>If <id>hasNameProperty</id> is <value>false</value> , perform SetFunctionName ( <id>propValue</id> , <id>propKey</id> ).</step>
  </step-list></step>
  <step>Assert : <id>enumerable</id> is <value>true</value> .</step>
  <step>Return CreateDataPropertyOrThrow ( <id>object</id> , <id>propKey</id> , <id>propValue</id> ).</step>
</step-list>
<step-list>
  <step>If <id>strict</id> is <value>false</value> , then   <step-list>
    <step>For each FunctionDeclaration  <id>f</id> that is directly contained in the StatementList of a Block , CaseClause , or DefaultClause , do     <step-list>
      <step>Let <id>F</id> be StringValue of the BindingIdentifier of FunctionDeclaration  <id>f</id> .</step>
      <step>If replacing the FunctionDeclaration  <id>f</id> with a VariableStatement that has <id>F</id> as a BindingIdentifier would not produce any Early Errors for <id>func</id> and <id>F</id> is not an element of <id>parameterNames</id> , then       <step-list>
        <step>NOTE: A var binding for <id>F</id> is only instantiated here if it is neither a VarDeclaredName, the name of a formal parameter, or another FunctionDeclaration .</step>
        <step>If <id>initializedBindings</id> does not contain <id>F</id> and <id>F</id> is not <value>"arguments"</value> , then         <step-list>
          <step>Perform ! <id>varEnvRec</id> .CreateMutableBinding( <id>F</id> , <value>false</value> ).</step>
          <step>Perform <id>varEnvRec</id> .InitializeBinding( <id>F</id> , <value>undefined</value> ).</step>
          <step>Append <id>F</id> to <id>instantiatedVarNames</id> .</step>
        </step-list></step>
        <step>When the FunctionDeclaration  <id>f</id> is evaluated, perform the following steps in place of the FunctionDeclaration Evaluation algorithm provided in 14.1.21 :         <step-list>
          <step>Let <id>fenv</id> be the running execution context 's VariableEnvironment.</step>
          <step>Let <id>fenvRec</id> be <id>fenv</id> 's EnvironmentRecord .</step>
          <step>Let <id>benv</id> be the running execution context 's LexicalEnvironment.</step>
          <step>Let <id>benvRec</id> be <id>benv</id> 's EnvironmentRecord .</step>
          <step>Let <id>fobj</id> be ! <id>benvRec</id> .GetBindingValue( <id>F</id> , <value>false</value> ).</step>
          <step>Perform ! <id>fenvRec</id> .SetMutableBinding( <id>F</id> , <id>fobj</id> , <value>false</value> ).</step>
          <step>Return NormalCompletion ( <value>empty</value> ).</step>
        </step-list></step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
</step-list>
<step-list>
  <step>Let <id>strict</id> be IsStrict of <id>script</id> .</step>
  <step>If <id>strict</id> is <value>false</value> , then   <step-list>
    <step>Let <id>declaredFunctionOrVarNames</id> be a new empty List .</step>
    <step>Append to <id>declaredFunctionOrVarNames</id> the elements of <id>declaredFunctionNames</id> .</step>
    <step>Append to <id>declaredFunctionOrVarNames</id> the elements of <id>declaredVarNames</id> .</step>
    <step>For each FunctionDeclaration  <id>f</id> that is directly contained in the StatementList of a Block , CaseClause , or DefaultClause Contained within <id>script</id> , do     <step-list>
      <step>Let <id>F</id> be StringValue of the BindingIdentifier of FunctionDeclaration  <id>f</id> .</step>
      <step>If replacing the FunctionDeclaration  <id>f</id> with a VariableStatement that has <id>F</id> as a BindingIdentifier would not produce any Early Errors for <id>script</id> , then       <step-list>
        <step>If <id>envRec</id> .HasLexicalDeclaration( <id>F</id> ) is <value>false</value> , then         <step-list>
          <step>Let <id>fnDefinable</id> be ? <id>envRec</id> .CanDeclareGlobalFunction( <id>F</id> ).</step>
          <step>If <id>fnDefinable</id> is <value>true</value> , then           <step-list>
            <step>NOTE: A var binding for <id>F</id> is only instantiated here if it is neither a VarDeclaredName nor the name of another FunctionDeclaration .</step>
            <step>If <id>declaredFunctionOrVarNames</id> does not contain <id>F</id> , then             <step-list>
              <step>Perform ? <id>envRec</id> .CreateGlobalFunctionBinding( <id>F</id> , <value>undefined</value> , <value>false</value> ).</step>
              <step>Append <id>F</id> to <id>declaredFunctionOrVarNames</id> .</step>
            </step-list></step>
            <step>When the FunctionDeclaration  <id>f</id> is evaluated, perform the following steps in place of the FunctionDeclaration Evaluation algorithm provided in 14.1.21 :             <step-list>
              <step>Let <id>genv</id> be the running execution context 's VariableEnvironment.</step>
              <step>Let <id>genvRec</id> be <id>genv</id> 's EnvironmentRecord .</step>
              <step>Let <id>benv</id> be the running execution context 's LexicalEnvironment.</step>
              <step>Let <id>benvRec</id> be <id>benv</id> 's EnvironmentRecord .</step>
              <step>Let <id>fobj</id> be ! <id>benvRec</id> .GetBindingValue( <id>F</id> , <value>false</value> ).</step>
              <step>Perform ? <id>genvRec</id> .SetMutableBinding( <id>F</id> , <id>fobj</id> , <value>false</value> ).</step>
              <step>Return NormalCompletion ( <value>empty</value> ).</step>
            </step-list></step>
          </step-list></step>
        </step-list></step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
</step-list>
<step-list>
  <step>If <id>strict</id> is <value>false</value> , then   <step-list>
    <step>Let <id>declaredFunctionOrVarNames</id> be a new empty List .</step>
    <step>Append to <id>declaredFunctionOrVarNames</id> the elements of <id>declaredFunctionNames</id> .</step>
    <step>Append to <id>declaredFunctionOrVarNames</id> the elements of <id>declaredVarNames</id> .</step>
    <step>For each FunctionDeclaration  <id>f</id> that is directly contained in the StatementList of a Block , CaseClause , or DefaultClause Contained within <id>body</id> , do     <step-list>
      <step>Let <id>F</id> be StringValue of the BindingIdentifier of FunctionDeclaration  <id>f</id> .</step>
      <step>If replacing the FunctionDeclaration  <id>f</id> with a VariableStatement that has <id>F</id> as a BindingIdentifier would not produce any Early Errors for <id>body</id> , then       <step-list>
        <step>Let <id>bindingExists</id> be <value>false</value> .</step>
        <step>Let <id>thisLex</id> be <id>lexEnv</id> .</step>
        <step>Assert : The following loop will terminate.</step>
        <step>Repeat, while <id>thisLex</id> is not the same as <id>varEnv</id> ,         <step-list>
          <step>Let <id>thisEnvRec</id> be <id>thisLex</id> 's EnvironmentRecord .</step>
          <step>If <id>thisEnvRec</id> is not an object Environment Record , then           <step-list>
            <step>If <id>thisEnvRec</id> .HasBinding( <id>F</id> ) is <value>true</value> , then             <step-list>
              <step>Let <id>bindingExists</id> be <value>true</value> .</step>
            </step-list></step>
          </step-list></step>
          <step>Let <id>thisLex</id> be <id>thisLex</id> 's outer environment reference.</step>
        </step-list></step>
        <step>If <id>bindingExists</id> is <value>false</value> and <id>varEnvRec</id> is a global Environment Record , then         <step-list>
          <step>If <id>varEnvRec</id> .HasLexicalDeclaration( <id>F</id> ) is <value>false</value> , then           <step-list>
            <step>Let <id>fnDefinable</id> be ? <id>varEnvRec</id> .CanDeclareGlobalFunction( <id>F</id> ).</step>
          </step-list></step>
          <step>Else,           <step-list>
            <step>Let <id>fnDefinable</id> be <value>false</value> .</step>
          </step-list></step>
        </step-list></step>
        <step>Else,         <step-list>
          <step>Let <id>fnDefinable</id> be <value>true</value> .</step>
        </step-list></step>
        <step>If <id>bindingExists</id> is <value>false</value> and <id>fnDefinable</id> is <value>true</value> , then         <step-list>
          <step>If <id>declaredFunctionOrVarNames</id> does not contain <id>F</id> , then           <step-list>
            <step>If <id>varEnvRec</id> is a global Environment Record , then             <step-list>
              <step>Perform ? <id>varEnvRec</id> .CreateGlobalFunctionBinding( <id>F</id> , <value>undefined</value> , <value>true</value> ).</step>
            </step-list></step>
            <step>Else,             <step-list>
              <step>Let <id>bindingExists</id> be <id>varEnvRec</id> .HasBinding( <id>F</id> ).</step>
              <step>If <id>bindingExists</id> is <value>false</value> , then               <step-list>
                <step>Perform ! <id>varEnvRec</id> .CreateMutableBinding( <id>F</id> , <value>true</value> ).</step>
                <step>Perform ! <id>varEnvRec</id> .InitializeBinding( <id>F</id> , <value>undefined</value> ).</step>
              </step-list></step>
            </step-list></step>
            <step>Append <id>F</id> to <id>declaredFunctionOrVarNames</id> .</step>
          </step-list></step>
          <step>When the FunctionDeclaration  <id>f</id> is evaluated, perform the following steps in place of the FunctionDeclaration Evaluation algorithm provided in 14.1.21 :           <step-list>
            <step>Let <id>genv</id> be the running execution context 's VariableEnvironment.</step>
            <step>Let <id>genvRec</id> be <id>genv</id> 's EnvironmentRecord .</step>
            <step>Let <id>benv</id> be the running execution context 's LexicalEnvironment.</step>
            <step>Let <id>benvRec</id> be <id>benv</id> 's EnvironmentRecord .</step>
            <step>Let <id>fobj</id> be ! <id>benvRec</id> .GetBindingValue( <id>F</id> , <value>false</value> ).</step>
            <step>Perform ? <id>genvRec</id> .SetMutableBinding( <id>F</id> , <id>fobj</id> , <value>false</value> ).</step>
            <step>Return NormalCompletion ( <value>empty</value> ).</step>
          </step-list></step>
        </step-list></step>
      </step-list></step>
    </step-list></step>
  </step-list></step>
</step-list>
<step-list>
  <step>If <id>envRec</id> .HasBinding( <id>dn</id> ) is <value>false</value> , then   <step-list>
    <step>Perform ! <id>envRec</id> .CreateMutableBinding( <id>dn</id> , <value>false</value> ).</step>
  </step-list></step>
</step-list>
<step-list>
  <step>If <id>envRec</id> .HasBinding( <id>fn</id> ) is <value>false</value> , then   <step-list>
    <step>Perform <id>envRec</id> .InitializeBinding( <id>fn</id> , <id>fo</id> ).</step>
  </step-list></step>
  <step>Else,   <step-list>
    <step>Assert : <id>d</id> is a FunctionDeclaration .</step>
    <step>Perform <id>envRec</id> .SetMutableBinding( <id>fn</id> , <id>fo</id> , <value>false</value> ).</step>
  </step-list></step>
</step-list>
<step-list>
  <step>If <id>thisEnvRec</id> is not the Environment Record for a Catch clause, throw a <value>SyntaxError</value> exception.</step>
  <step>If <id>name</id> is bound by any syntactic form other than a FunctionDeclaration , a VariableStatement , the VariableDeclarationList of a for statement, the ForBinding of a for-in statement, or the BindingIdentifier of a for-in statement, throw a <value>SyntaxError</value> exception.</step>
</step-list>
<step-list>
  <step>If <id>thisEnvRec</id> is not the Environment Record for a Catch clause, let <id>bindingExists</id> be <value>true</value> .</step>
</step-list>
<step-list>
  <step>Return ContainsDuplicateLabels of Statement with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Return ContainsUndefinedBreakTarget of Statement with argument <id>labelSet</id> .</step>
</step-list>
<step-list>
  <step>Return ContainsUndefinedContinueTarget of Statement with arguments <id>iterationSet</id> and « ».</step>
</step-list>
<step-list>
  <step>Return <value>false</value> .</step>
</step-list>
<step-list>
  <step>Let <id>names</id> be the BoundNames of BindingIdentifier .</step>
  <step>Append to <id>names</id> the elements of the VarDeclaredNames of Statement .</step>
  <step>Return <id>names</id> .</step>
</step-list>
<step-list>
  <step>Let <id>declarations</id> be a List containing BindingIdentifier .</step>
  <step>Append to <id>declarations</id> the elements of the VarScopedDeclarations of Statement .</step>
  <step>Return <id>declarations</id> .</step>
</step-list>
<step-list>
  <step>Let <id>bindingId</id> be StringValue of BindingIdentifier .</step>
  <step>Let <id>lhs</id> be ? ResolveBinding ( <id>bindingId</id> ).</step>
  <step>Let <id>rhs</id> be the result of evaluating Initializer .</step>
  <step>Let <id>value</id> be ? GetValue ( <id>rhs</id> ).</step>
  <step>If IsAnonymousFunctionDefinition ( Initializer ) is <value>true</value> , then   <step-list>
    <step>Let <id>hasNameProperty</id> be ? HasOwnProperty ( <id>value</id> , <value>"name"</value> ).</step>
    <step>If <id>hasNameProperty</id> is <value>false</value> , perform SetFunctionName ( <id>value</id> , <id>bindingId</id> ).</step>
  </step-list></step>
  <step>Perform ? PutValue ( <id>lhs</id> , <id>value</id> ).</step>
  <step>Let <id>keyResult</id> be ? ForIn/OfHeadEvaluation (« », Expression , <value>enumerate</value> ).</step>
  <step>Return ? ForIn/OfBodyEvaluation ( BindingIdentifier , Statement , <id>keyResult</id> , <value>enumerate</value> , <value>varBinding</value> , <id>labelSet</id> ).</step>
</step-list>
<step-list>
  <step>If <id>argument</id> has an [[IsHTMLDDA]] internal slot , return <value>false</value> .</step>
  <step>Return <value>true</value> .</step>
</step-list>
<step-list>
  <step>If Type ( <id>x</id> ) is Object and <id>x</id> has an [[IsHTMLDDA]] internal slot and <id>y</id> is either <value>null</value> or <value>undefined</value> , return <value>true</value> .</step>
  <step>If <id>x</id> is either <value>null</value> or <value>undefined</value> and Type ( <id>y</id> ) is Object and <id>y</id> has an [[IsHTMLDDA]] internal slot , return <value>true</value> .</step>
</step-list>
\section{Semantic generation}

\subsection{Core language}
실행 가능한 specification을 만들기 위한 langauge.
algorithm들의 공통된 행동을 실행할 수 있게 잘 설계함
ex) let X be ... => let X = ...

\subsubsection{다른 rewriting system 또는 compiler와 다른 점}
특징으로는 Parser에서 만들어진 AST를 하나의 값으로 들고 다니면서 관련 함수를 호출하거나 subAST를 가져올수 있게 만들어짐. 이는 Syntax function 실행을 위해선데 이후 initial state organization에서 설명 
또한 ES specification에서 공통적으로 동작하는 복잡한 연산을 expression으로 지원함, 특히 문서에 covered by에 있는 것처럼 AST Value를 Goal symbol로 다시 parse해야 하는 경우도 있고, eval이나 Class creation 관련 함수에서처럼 string을 AST로 parse해야하는 경우도 있음. 그런 경우를 parse-syntax 를 넣어서 처리할 수 있게
해줌.

\subsection{semantic 컴파일하기 위해 하는 것 + specification 구조}
기본적인 원칙 :
\begin{itemize} 
\item 자바스크립트로 알고리즘 이름이랑 파라미터, 스텝을 가져와서 코어의 글로벌 ID에 매치 시켜줌
\item initial Heap을 생성해줌
\end{itemize}
매치를 시킨다는 뜻은 코어의 글로벌 ID에 코어 함수 형태로 알고리즘을 넣는 것임

\subsection{함수의 의미 번역 (algorithm => Function)}
Function은 parameter와 body로 나뉨
\subsubsection{parameter extraction} : HTML에 써있음 + 여러 특별한 말들 (with parameter * )
Builtin function의 경우 specification 내에서 implicit하게 전해지는 parameter들이 있는데, (thisValue, newTarget) 이것을
core에서 모두 명시적으로 받게 (지금은 javascript 단에서) 자동으로 고쳐준다.

\subsubsection{body extraction ( AlgoCompiler )} : 이부분이 Human resource 많이 들어감
여기서 rule에 따라 step을 만들어줌
나눌 수도 있을 것 같은데 지금은 일단 instruction, expression, condition, type, value, reference을 나타내는 position을 분리하고 거기에 맞춰서 case별로 parser를 짬
근데 똑같은 의미도 여러 다른 말로 표현하기 떄문에 지금은 모든 경우를 하나씩 써놓음
또 같은 말도 context에 따라 의미가 다른 경우가 있음 (Return할때), 지금은 알고리즘의 종류에만 dependent하므로 알고리즘에 flag를 둬서 구분

간단하지 않은 알고리즘의 경우는 1) core 내에서 표현될 수 있는 경우 Function을 만들어 모델링하거나 
2) 지원하지 않는 경우가 있다


\begin{itemize}
  \item Formal definition of Core language
    \begin{itemize}
      \item Syntax
      \item Semantics
    \end{itemize}
  \item Abstract algorithms
    \begin{itemize}
      \item syntax-directed / internal method
      \item Converted into Core
    \end{itemize}
\end{itemize}

\section{ Initial state configuration ( generator ) }

In this section, we describre how to generate initial environment for ECMAScript to run defined semantics. 
We can extract programming language's AST, Parser, and executable algorithm in the specification with minimal human effort.
With these primitives, we can build entire system for evaluating target language.

Initial environment of language is mostly about initialization of builtin types, or entry point of the program, etc.
In our diagram, we categorized these part as language-dependent environment.
For ECMAScript Specification, initial environment consists of the Builtin objects, Intrinsincs, and Algorithm scope. We will describe how to generate each component.

\subsection{Builtin objects}

 In ECMAScript, there is the object which have references of builtin object. Each Builtin Object provides fields and function, just as ordinary object. When its function is called,
 the corresponding algorithm specified in the document should be called. To support builtin object, we make structure of builtin object and its attributes, and then we autoamtically map corresponding field to the algorithm in specification by matching its function name.
 
 \subsection{Intrinsics}

 While builtin objects has canonical name to refer itself in ECMAScript language, It is also frequently refered in specification. But name of builtin objects
 are defiend for reference in Host language, so it needs another name to refer it in specification langauge. Intrinsics are alias for built-in objects. 
 Map between Intrinsic name and Builtin objects are available in speicificaion as table form , so we parse this table to generate global identifier to object.

 \subsection{Algorithm scope}

 In specification, All algorithm has name to refer it, but some algorithms have same names and they are called in context-dependent way.
 There is four types of algorithm. 
 \begin{itemize}
  \item Global algorithm: they can be called by name in any context
  \item Type-dependent algorithm: they are bounded in specific type of object
  \item Syntax-dependent algorithm: they are bounded in AST
  \item Builtin function algorithm: they correspond to builtin function
  \end{itemize}

  First, we categorized sections by types of algorithm. Builtin object has several own sections to describe its functions,
so it is easy to extract builtin object algorithms. Type-dependent algorithms and syntax-dependent algorithms has their own layout, so it
can be extracted. Rest algorithms are considered as global algorithm.

We mapped builtin function algorithms in environment when initialzing builtin object, so we descibe about rest three algorithms. 

\subsubsection{Global algorithm}

We just convert global algorithms to function, and bind global identifier to that function to call it by algorithm name.

\subsubsection{Type-dependent algorithm}

For type-denpendent algorithms, we organized map from algorithm name to function for each type,
 and we insert functions as propertiy of object when such type of object is created.

 \subsubsection{Syntax-dependent algorithm}
For syntax-dependent algorithm, we insert converted functions in AST structure, and add special expression to call AST-dependent algorithm which requires AST Value and algorithm name.
To insert functions, we gather which AST can be applied to a function. Also, to use subAST structure, we passes subAST in function as argument.



<algorithm>
  <param>Obj</param>
  <step-list>
    <step>If Type ( <id>Obj</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
    <step>Let <id>desc</id> be a new Property Descriptor that initially has no fields.</step>
    <step>Let <id>hasEnumerable</id> be ? HasProperty ( <id>Obj</id> , <value>"enumerable"</value> ).</step>
    <step>If <id>hasEnumerable</id> is <value>true</value> , then     <step-list>
      <step>Let <id>enum</id> be ToBoolean (? Get ( <id>Obj</id> , <value>"enumerable"</value> )).</step>
      <step>Set <id>desc</id> .[[Enumerable]] to <id>enum</id> .</step>
    </step-list></step>
    <step>Let <id>hasConfigurable</id> be ? HasProperty ( <id>Obj</id> , <value>"configurable"</value> ).</step>
    <step>If <id>hasConfigurable</id> is <value>true</value> , then     <step-list>
      <step>Let <id>conf</id> be ToBoolean (? Get ( <id>Obj</id> , <value>"configurable"</value> )).</step>
      <step>Set <id>desc</id> .[[Configurable]] to <id>conf</id> .</step>
    </step-list></step>
    <step>Let <id>hasValue</id> be ? HasProperty ( <id>Obj</id> , <value>"value"</value> ).</step>
    <step>If <id>hasValue</id> is <value>true</value> , then     <step-list>
      <step>Let <id>value</id> be ? Get ( <id>Obj</id> , <value>"value"</value> ).</step>
      <step>Set <id>desc</id> .[[Value]] to <id>value</id> .</step>
    </step-list></step>
    <step>Let <id>hasWritable</id> be ? HasProperty ( <id>Obj</id> , <value>"writable"</value> ).</step>
    <step>If <id>hasWritable</id> is <value>true</value> , then     <step-list>
      <step>Let <id>writable</id> be ToBoolean (? Get ( <id>Obj</id> , <value>"writable"</value> )).</step>
      <step>Set <id>desc</id> .[[Writable]] to <id>writable</id> .</step>
    </step-list></step>
    <step>Let <id>hasGet</id> be ? HasProperty ( <id>Obj</id> , <value>"get"</value> ).</step>
    <step>If <id>hasGet</id> is <value>true</value> , then     <step-list>
      <step>Let <id>getter</id> be ? Get ( <id>Obj</id> , <value>"get"</value> ).</step>
      <step>If IsCallable ( <id>getter</id> ) is <value>false</value> and <id>getter</id> is not <value>undefined</value> , throw a <value>TypeError</value> exception.</step>
      <step>Set <id>desc</id> .[[Get]] to <id>getter</id> .</step>
    </step-list></step>
    <step>Let <id>hasSet</id> be ? HasProperty ( <id>Obj</id> , <value>"set"</value> ).</step>
    <step>If <id>hasSet</id> is <value>true</value> , then     <step-list>
      <step>Let <id>setter</id> be ? Get ( <id>Obj</id> , <value>"set"</value> ).</step>
      <step>If IsCallable ( <id>setter</id> ) is <value>false</value> and <id>setter</id> is not <value>undefined</value> , throw a <value>TypeError</value> exception.</step>
      <step>Set <id>desc</id> .[[Set]] to <id>setter</id> .</step>
    </step-list></step>
    <step>If <id>desc</id> .[[Get]] is present or <id>desc</id> .[[Set]] is present, then     <step-list>
      <step>If <id>desc</id> .[[Value]] is present or <id>desc</id> .[[Writable]] is present, throw a <value>TypeError</value> exception.</step>
    </step-list></step>
    <step>Return <id>desc</id> .</step>
  </step-list>
</algorithm>
\section{Building entire system to evaluate code}\label{sec:framework}

In this section, we will demonstrate how our idea can be implemented to evaluate programming language. Although it is hard to generalize the process because the format of specification or 
environment of the programming language is varying, We shows the possibility to build entire system for evaluating target language with minimal human effort by giving end-to-end example of ECMAScript language.

\subsection{Extracting specification}
First step is to collect language specification and extract component that we can process automatically. For our target language, ECMAScript, has HTML format of specification in their website, and
in the specification they have BNF form of syntax, highly structured algorithm steps, and verbose texts to describe additional environment to evaluating ECMAScript source code.
We get these information by parsing HTML document, and passing these result to our previous module to get AST, Parser, and executable algorithms.

To organize these primitives and running the program, we have to model initial environment of language such as initialization of builtin types, or entry point of the program, etc.

\subsection{Generating initial environment for evaluating}
For ECMAScript Specification, initial environment consists of the Builtin objects, Intrinsic objects. We will describe how to generate each component.

\subsubsection{Builtin objects}

 Builtin object is pre-defined object with many built-in functions. For example, In ECMAScript \( \code{Array} \) refers an object which can generate an array by
 calling it. Each Builtin Object provides fields and function, just as ordinary object. When its function is called,
 the corresponding algorithm specified in the document should be called. 
 
 In specification, a built-in function object usually matches to abstract algorithm. Its algorithm name
 describes the hierarchy about object it should be contained. For example, there is an abstract algorithm named \( \code{ Object.prototype.propertyIsEnumerable } \). With its name,
 we can know that it corresponds to builtin function in the object \( \code{ Object.prototype } \) as attribute. 
 To support builtin object, we make structure of builtin object and its attributes.
 After we correctly organizes structure, then we made algorithm that automatically map corresponding field to the abstract algorithm in specification by matching its function name.
 
 \subsubsection{Intrinsic objects}

 While builtin objects has canonical name to refer itself in ECMAScript language, It is also frequently referred in specification. But name of builtin objects
 are defined for reference in Host language, so it needs another name to refer it in specification language. For example, \( \code{Array} \) is a name for
 ECMAScript reference, so abstract algorithm should call \\
 \( \code{realm.[[GlobalObject]].[[GetOwnProperty]]("Array")} \) to get ECMAScript \( \code{Array} \) object. Instead of this verbose way, abstract algorithm introduces Intrinsic objects, which
are alias for built-in objects. For example it is referred as \( \code{\%Array\%} \) to refer Array Object.
 Map between Intrinsic name and Builtin objects are available in specification as table form in section "6.1.7.4 Well-Known Intrinsic Objects", so we parse this table to generate global identifier to object.

\subsection{Algorithm scope}

 In specification, All algorithm has name to refer it, but some algorithms have same names and they are called in context-dependent way.
In "5.2 Algorithm Conventions", it defines three types of abstract operation.
 \begin{itemize}
  \item Abstract operation: they can be called by name in any context
  \item Method-like abstract operation: algorithm dispatch depends on receiver object
  \item Syntax-directed operation: algorithm dispatch depends on receiver AST
  \end{itemize}

First, we categorized sections by types of algorithm.
Method-like abstract operation has separate sections to describe it, so we manually add these sections to treat differently.
Also Syntax-directed operations are described in distinct sections, so both case is easy to extract it.
Rest algorithms are considered as ordinary Abstract operation.

\subsubsection{Abstract operation}

We just convert abstract operations to function, and bind global identifier to that function to call it by algorithm name.

\subsubsection{Method-like abstract operation}

In ECMAScript specification, there are some objects which has similar interface, but they have different algorithms. 

For Example, Ordinary Object and String Exotic Object is different object in specification, but they have same name of algorithm(i.e. \( \code{[[getOwnProperty]](N)} \))

In this case, algorithm dispatching should consider receiver Object(i.e. \( \code{x.[[GetOwnProperty]](N)} \)).
For method-like abstract operation, we organized map from algorithm name to function for each type,
 and we insert functions as property of object when such type of object is created. So In our example, when  \( \code{x} \) is created with Ordinary Object type,
 then we insert attributes with name \( \code{[[GetOwnProperty]]} \) and function from method-like abstract operation "[[GetOwnProperty]]" in Ordinary Object Internal method section, at the time of map creation.

 \subsubsection{Syntax-directed operation}
 
 Like Method-like abstract operation, many AST Value (in specification, it is called Parse Node) uses same name of algorithm but the content is different.
The most frequent example is Evaluation of the AST Value. Evaluation is described as \( \code{result of evaluating Expression} \), but Non-terminal
\( \code{ Expression } \) did not has specific algorithm \( \code{ Evaluation } \). Instead of this, some non-terminal that can be derived from \( \code{ Expression } \) has \( \code{ Evaluation }\),
(i.e. \( \code{ CallExpression } \)). Also in Syntax-directed operation, the sub-component of AST can be used as values. For example, In the
Evaluation algorithm of\\ \( \code{CallExpression : CallExpression Arguments} \), algorithm can uses \( \code{CallExpression}\) or \( \code{Arguments}\) to refer sub-component of AST.
 For Syntax-directed operation, we insert converted functions in AST structure, and add special expression to call Syntax-directed operation which requires AST Value and algorithm name.
We gather which AST can be applied to a function. Also, to use child node of AST, we passes child node of AST to function as argument.

% \begin{itemize}
%   \item \textbf{Global Algorithms} Global algorithms are possible to be accessed
%     by any other algorithms. The top-level algorithm \( \code{RunJobs} \) is also global.
%   \item \textbf{Type-dependent Algorithms} Several algorithms have different
%     bodies dependent on types of their owner data. In ECMAScript specifications,
%     there are two different data types; language types and specification types.
%     The language types are explicitly used in JavaScript languages such as
%     \( \code{Boolean}, \code{Number}, \code{String} \), and \( \code{Object} \).
%     However, specification types are only used in specifications such as
%     Lists, Records, and Lexical Environments. Among them, some data types
%     have their own member algorithms. For example, language type \( \code{Object} \)
%     has several internal methods described in abstract algorithms. It depends
%     on 
% 
%     several data types have their own member algorithms. For example, 
%     
%     For example, the internal method
%     \( \code{[[Call]]} \) has different semantics dependent on its owner object.
%     Moreover, the owner objects are used in the body of algorithms as well.
%     Thus, we extend the parameters to accept its owner object as an implicit argument.
%   \item \textbf{Syntax-directed Algorithms} The semantics of each JavaScript syntax
%     are written in 
% \end{itemize}

% \subsection{semantic 컴파일하기 위해 하는 것 + specification 구조}
% 기본적인 원칙 :
% \begin{itemize} 
% \item 자바스크립트로 알고리즘 이름이랑 파라미터, 스텝을 가져와서 코어의 글로벌 ID에 매치 시켜줌
% \item initial Heap을 생성해줌
% \end{itemize}
% 매치를 시킨다는 뜻은 코어의 글로벌 ID에 코어 함수 형태로 알고리즘을 넣는 것임
% 

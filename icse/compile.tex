\section{Semantic generation}

\subsection{Core language}
실행 가능한 specification을 만들기 위한 langauge.
algorithm들의 공통된 행동을 실행할 수 있게 잘 설계함
ex) let X be ... => let X = ...

\subsubsection{다른 rewriting system 또는 compiler와 다른 점}
특징으로는 Parser에서 만들어진 AST를 하나의 값으로 들고 다니면서 관련 함수를 호출하거나 subAST를 가져올수 있게 만들어짐. 이는 Syntax function 실행을 위해선데 이후 initial state organization에서 설명 
또한 ES specification에서 공통적으로 동작하는 복잡한 연산을 expression으로 지원함, 특히 문서에 covered by에 있는 것처럼 AST Value를 Goal symbol로 다시 parse해야 하는 경우도 있고, eval이나 Class creation 관련 함수에서처럼 string을 AST로 parse해야하는 경우도 있음. 그런 경우를 parse-syntax 를 넣어서 처리할 수 있게
해줌.

\subsection{semantic 컴파일하기 위해 하는 것 + specification 구조}
기본적인 원칙 :
\begin{itemize} 
\item 자바스크립트로 알고리즘 이름이랑 파라미터, 스텝을 가져와서 코어의 글로벌 ID에 매치 시켜줌
\item initial Heap을 생성해줌
\end{itemize}
매치를 시킨다는 뜻은 코어의 글로벌 ID에 코어 함수 형태로 알고리즘을 넣는 것임

\subsection{함수의 의미 번역 (algorithm => Function)}
Function은 parameter와 body로 나뉨
\subsubsection{parameter extraction} : HTML에 써있음 + 여러 특별한 말들 (with parameter * )
Builtin function의 경우 specification 내에서 implicit하게 전해지는 parameter들이 있는데, (thisValue, newTarget) 이것을
core에서 모두 명시적으로 받게 (지금은 javascript 단에서) 자동으로 고쳐준다.

\subsubsection{body extraction ( AlgoCompiler )} : 이부분이 Human resource 많이 들어감
여기서 rule에 따라 step을 만들어줌
나눌 수도 있을 것 같은데 지금은 일단 instruction, expression, condition, type, value, reference을 나타내는 position을 분리하고 거기에 맞춰서 case별로 parser를 짬
근데 똑같은 의미도 여러 다른 말로 표현하기 떄문에 지금은 모든 경우를 하나씩 써놓음
또 같은 말도 context에 따라 의미가 다른 경우가 있음 (Return할때), 지금은 알고리즘의 종류에만 dependent하므로 알고리즘에 flag를 둬서 구분

간단하지 않은 알고리즘의 경우는 1) core 내에서 표현될 수 있는 경우 Function을 만들어 모델링하거나 
2) 지원하지 않는 경우가 있다


\begin{itemize}
  \item Formal definition of Core language
    \begin{itemize}
      \item Syntax
      \item Semantics
    \end{itemize}
  \item Abstract algorithms
    \begin{itemize}
      \item syntax-directed / internal method
      \item Converted into Core
    \end{itemize}
\end{itemize}

\section{ Initial state configuration ( generator ) }

By above techniques, we can get the programming language's AST, Parser, and executable steps to run the abstract algorithm in the specification.
But, to run the program with these primitives, Many languages need initial environment to run the program. It is mostly about initialization of builtin types, and it also includes specifying entry point of the program (fetch main function and fill arguments in Java, C, ..)
These environments are sometimes described as steps of algorithm, but mostly it is not. 
In our diagram, we categorized these part as language-dependent environment. It is hard to generate environment automatically, but it is relativly not too heavy to model it compared to modeling numerous algorithms used in runtime.
In this section, we describre how to generate initial environment for ECMAScript to run defined semantics. 


Convert to
\begin{itemize}
\item algorithm name => Global Id
\item Builtin Object function name => Heap Object .Code
\item Type function name => Internal Map field
\item Syntax function name => Internal AST semantics field
\end{itemize}


For ECMAScript Specification, initial environment consists of the builtin objects, Intrinsinc objects, and mapping from specification steps to corresponding reference.

 Global Object

 In ECMAScript, there is a initial object which have references of builtin object. Each Builtin Object provides fields and function, just as ordinary object. But when its function is called,
 the corresponding step specified in document should be called. To support global object, we make shape of builtin object and its attributes, and then we autoamtically match the step in specification to corresponding field in object by considering its function name.
 
 Intrinsic Object

 While Global Object is used for reference in ECMAScript language, It is also frequently used in ECMAScript specification. But Global Object layout is
 formed for reference in Host language, it needs another name to refer it in specification langauge. Intrinsics are alias for built-in objects. 
 Correspondence between Intrinsic name and Builtin objects are shown in table, so we parse this table to generate global ID to object.
 
 Binding environment

 절차를 참조하여 실행하기 위한 방법은 크게 세 가지가 있다. 첫 번째로 이름을 탑 레벨에서 불러 실행할 수 있고, 두 번째로 Object에 종속적인 절차를 이름으로 부를 수 있다. Object에 종속적인 절차는 Type에 종속적인 절차 또는 AST의 모양에 종속적인 절차로 나뉜다.
 
 기본적으로 함수는 모두 Global Id로 넣어놓고 필요할때 호출하는데, 필요한 함수가 정적이지 않고
context-dependent하게 호출될 필요가 있다.

 
\begin{itemize}
  \item Default Algorithm
  \item Type-dependent algorithm
  \item Syntax-dependent algorithm
  \item Builtin object algorithm
  \end{itemize}
  

일단 (Type, Object, Syntax)-dependent algorithm 구역을 나누는건 manual

Type에 종속적인 절차와 AST 모양에 종속적인 절차가 기술된 범위를 수동으로 지정하고, 이후 자동으로 그 Type과 AST 구조를 추출해서 각각 필요한 시점에 불릴 수 있게 할 수 있었다. AST 모양에 종속적인 절차를 예로 들면, 그 절차의 이름에 AST 모양을 serialization한 값을 붙여 유일한 이름을 만들고, AST에서 특정 절차를 수행할 때 그 모양을 serialization한 것과 이름을 합하여 그 AST에 종속적인 절차를 가져온다. Type의 경우도 같은 방법으로 절차를 가져올 수 있다.

1. Type의 경우 Core에 Type을 넣고 Type name => internal property를 자동 생성

Internal method를 그 타입 이름과 같이 등록해서 그 타입 Obj를 생성할때 자동으로 field에 넣어줌

2. Syntax의 경우 Core에 ASTVal을 넣고 semantic을 쓸수 있게 해줌
Syntax - directed algorithm을 실제 AST와 매칭 (AST node를 대상으로 실행해야 하는 알고리즘이 있으면 그 알고리즘을 찾아서 실행해 주는 것)
specification을 보면 알고리즘 이름과 Syntax가 붙어 있기 떄문에 자동으로 뽑아낼 수 있음
그 알고리즘을 실행할 떄 subAST 이름을 지칭하면서 사용하는데, 이를 subAST이름을 가진 argument를 넘겨줌으로써 실행할 수 있게 함
있음



\subsubsection{Js script evaluation}
 마지막으로 Parser를 통해 만들어진 AST를 참조할 수 있는 Id를 Core의 초기 환경에 추가한 후 실제 ECMAScript를 실행하기 위한 RunJobs 절차를 최초 실행 절차로 설정해 놓으면 실행하기 위한 모든 환경 설정이 끝난다.


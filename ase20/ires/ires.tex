\documentclass[11pt]{article}
\usepackage[a4paper,left=20mm,right=20mm,top=30mm,bottom=25mm]{geometry}

\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{mathpartir}
\usepackage{verbatim}
\usepackage{hyperref}
\usepackage{xspace}
\usepackage{stmaryrd}
\usepackage{tikz}
\usepackage{dirtree}
\usepackage{multicol}
\usepackage{array}

\usetikzlibrary{arrows}
\tikzset{
  treenode/.style = {align=center, inner sep=0pt, text centered},
  arn_n/.style = {treenode, circle, black, draw=black, text width=1.5em},
}

\newcommand{\irnameb}[0]{\textbf{IR\textsubscript{ES}}\xspace}
\newcommand{\irname}[0]{IR\textsubscript{ES}\xspace}
\newcommand{\Acd}[1]{\mathsf{#1}}
\newcommand{\Term}[1]{\texttt{#1}}

\newcommand{\dom}[1]{\mathit{Domain}(#1)}
\newcommand{\cs}[0]{\quad}

\newcommand{\symstate}[0]{\delta}
\newcommand{\symctx}[0]{\Delta}
\newcommand{\symctxstack}[0]{\sqcup}
\newcommand{\symglb}[0]{\mathbb{G}}
\newcommand{\symenv}[0]{\sigma}
\newcommand{\symheap}[0]{\Sigma}
\newcommand{\symuop}[0]{\odot}
\newcommand{\symbop}[0]{\oplus}
% \newcommand{\symconv}][0]{$\triangleright$}

\newcommand{\eval}[3]{#1\vdash #2\Rightarrow #3}
\newcommand{\evald}[2]{\eval{\symstate}{#1}{#2}}

\newcommand{\evaluop}[2]{\symuop #1 \Rightarrow #2}
\newcommand{\evalbop}[3]{#1 \symbop #2 \Rightarrow #3}
\newcommand{\evalinst}[3]{#1 \vdash #2 \Rightarrow #3}
\newcommand{\evalexpr}[4]{#1 \vdash #2 \Rightarrow #3,\ #4}
\newcommand{\evalescexpr}[4]{#1 \vdash_{escape} #2 \Rightarrow #3,\ #4}
\newcommand{\evalref}[4]{#1 \vdash #2 \Rightarrow #3,\ #4}
\newcommand{\evalrefv}[4]{#1 \vdash #2 \Rightarrow #3,\ #4}


\begin{document}

% \title{\irname : Intermediate Representation for ECMAScript Specification}
% \maketitle

% This document explains abstract syntax and operational semantic of \irnameb.


\section{Abstract Syntax}

This section explains abstract syntax of \irname.

% Domain
\[
\begin{array}{rrl}
n & \in & \textit{FloatingPoint} \\
d & \in & \textit{Integer} \\
s & \in & \textit{String} \\
b & \in & \textit{Boolean} \\
r & \in & \textit{Reference} \\
x & \in & \textit{Identifier} \\
t & \in & \textit{Type} \\
\end{array}
\]

% Abstract Syntax
\[
\begin{array}{rrrll}
\text{Program} & p & ::= & i\Term{;}\ \cdots \Term{;}\ i & \\
\\

\text{Instruction} & i & ::= & e & \text{(expression)} \\
&&|& \Term{let}\ x\ \Term{=}\ e & \text{(let)}\\
&&|& r \Term{:=} e & \text{(assign)}\\
&&|& \Term{delete}\ r & \text{(delete)}\\
&&|& \Term{append}\ e\ \to\ e & \text{(append)}\\
&&|& \Term{prepend}\ e\ \to\ e & \text{(prepend)}\\
&&|& \Term{return}\ e & \text{(return)}\\
&&|& \Term{if}\ e\ i\ i\ & \text{(if-then-else)}\\
&&|& \Term{while}\ e\ i & \text{(while)}\\
% &&|& \{ i\Term{;}\ \cdots\ i\Term{;}  \} & \text{(sequence)}\\
&&|& \{ i^* \} & \text{(sequence)}\\
&&|& \Term{assert}\ e & \text{(assert)}\\
&&|& \Term{print}\ e & \text{(print)}\\
&&|& \Term{app}\ x\ \Term{=}\ (e\ e^*) & \text{(function application)}\\
&&|& \Term{access}\ x\ \Term{=}\ (e\ e) & \text{(access)}\\
&&|& \Term{withcont}\ x\ (x^*)\ =\ i & \text{(continuation)}\\ 
\\

\text{Reference} & r & ::= & x & \text{(identifier)}\\
&&|& r\Term{[} e \Term{]} & \text{(reference to value of field in heap)}\\
\\
\end{array}
\]

\newpage

\[
\begin{array}{rrrll}
\text{Expression} & e & ::= & n & \text{(number)}\\
&&|& d & \text{(integer)}\\
&&|& s & \text{(string)}\\
&&|& b & \text{(boolean)}\\
&&|& r & \text{(reference)}\\
&&|& \Term{undefined} & \text{(undefined)}\\
&&|& \Term{null} & \text{(null)}\\
&&|& \Term{absent} & \text{(absent)}\\
&&|& \Term{new}\ s & \text{(symbol)}\\ % ESymbol
&&|& \Term{new}\ \Term{[} e^* \Term{]} & \text{(list)}\\ %EList
&&|& \Term{new}\ t\ \Term{(} e\ \mapsto\ e,\ \cdots,\
e\ \mapsto\ e \Term{)} & \text{(map)}\\ %EMap
&&|& \Term{pop}\ e\ e & \text{(pop)}\\
&&|& \Term{typeof}\ e & \text{(typeof)}\\
&&|& \Term{is-instance-of}\ e\ s& \text{(is-instance-of)}\\
&&|& \Term{get-elems}\ e\ s& \text{(get-elements)}\\
&&|& \Term{get-syntax}\ e& \text{(get-syntax)}\\
&&|& \Term{parse-syntax}\ e\ e\ e^*\ & \text{(parse-syntax)}\\
&&|& \Term{convert}\ e\ \triangleright\ e^*& \text{(convert)}\\
&&|& \Term{contains}\ e\ e& \text{(contains)}\\
&&|& \Term{copy-obj}\ e& \text{(copy-object)}\\
&&|& \Term{map-keys}\ e& \text{(map-keys)}\\
&&|& \Term{!!!}\ s& \text{(not supported)}\\
&&|& \odot\ e& \text{(unary operation)}\\ %Uop
&&|& e\ \oplus\ e& \text{(binary operation)}\\ %Bop
&&|& \Term{(} x^* \Term{)}\ \Term{[} \Rightarrow \Term{]}\ i
& \text{(continuation)}\\ %Cont\\
\\

\end{array}
\]

\newpage

\[
\begin{array}{rrrll}
\text{UnaryOperator}& \odot & ::=
& \Term{-} & \text{(negation)}\\
&&|& \Term{!} & \text{(boolean not)}\\
&&|& \sim & \text{(bitwise not)}\\
\\

\text{BinaryOperator}& \oplus & ::=
& \Term{+} & \text{(addition)}\\
&&|& \Term{-} & \text{(subtraction)}\\
&&|& \Term{*} & \text{(multiplication)}\\
&&|& \Term{**} & \text{(power)}\\
&&|& \Term{/} & \text{(division)}\\
&&|& \verb|%| & \text{(modulo)}\\
&&|& \verb|%| & \text{(modulo)}\\
&&|& \Term{=} & \text{(equals)}\\
&&|& \verb|&&| & \text{(boolean and)}\\
&&|& \Term{||} & \text{(boolean or)}\\
&&|& \verb|^^| & \text{(boolean xor)}\\
&&|& \verb|&| & \text{(bitwise and)}\\
&&|& \Term{|} & \text{(bitwise or)}\\
&&|& \verb|^| & \text{(bitwise xor)}\\
&&|& \verb|<<| & \text{(shift left)}\\
&&|& \Term{<} & \text{(less-then)}\\
&&|& \verb|>>>| & \text{(unsigned shift right)}\\
&&|& \verb|>>| & \text{(shift right)}\\
\\

\text{ConvertOperator} & \triangleright
& ::= & \Term{str2num}& \text{(string to number)}\\
&&|& \Term{num2str} & \text{(number to string)}\\
&&|& \Term{num2int} & \text{(number to integer)}\\
\\
\end{array}
\]

\newpage

\section{Operational Semantic}

This section explains operational semantic of \irname.

\subsection{Domain}

Semantic domain of \irname.

\[
\begin{array}{rrrl}
%State
\text{State} & \symstate & \in &
\textit{Context}\ \times\ \textit{ContextStack}\
\times\ \textit{Global}\ \times\ \textit{Heap}
\\
%Context
\text{Context} & \symctx & \in &
\textit{Identifier}\ \times\ \textit{String}\
\times\ \textit{Instruction}^*\ \times\ \textit{Environment}
\\
%ContextStack
\text{ContextStack} & \symctxstack & \in & \textit{Context}^*
\\
%Global
\text{Global} & \symglb & \in &
\textit{Identifier}\ \to\ \textit{Value}
\\
%Environment
\text{Environment} & \symenv & \in &
\textit{Identifier}\ \to\ \textit{Value}
\\
%Heap
\text{Heap} & \symheap & \in &
\textit{Address}\ \to\ \textit{Object}
\\
%Value
\text{Value} & v & \in & \textit{Value}
\\
%Address
\text{Address} & a & \in & \textit{Address}
\\
%Object
\text{Object} & o & \in & \textit{Object}
\\

\end{array}
\]

\[
\begin{array}{rrrll}
%Constant
\text{Constant} & c & ::= & n\ |\ d\ |\ s\ |\ b\ |\
\Term{undefined}\ |\ \Term{null}\ |\ \Term{absent}\ & \\
\\
%Address
\text{Address} & a & ::= & s & \text{(named address)} \\
&&|& d & \text{(dynamic address)}\\
\\
%Object
\text{Object} & o & ::= & \Term{symbol}\ v & \text{(symbol)}\\
&&|& \Term{map}\ t\ \Term{(} v\ \mapsto\ v,\ \cdots,\
v\ \mapsto\ v \Term{)} & \text{(map)}\\
&&|& \Term{list}\ \Term{[} v^* \Term{]} & \text{(list)}\\
&&|& \Term{not-supported}\ s & \text{(not supported)}\\
\\
%Value
\text{Value} & v & ::= & a & \text{(address)} \\
&&|& c & \text{(constant)}\\
&&|& s\ \Term{(} x^*,\ \Term{[}x\Term{]} \Term{)}\ \Rightarrow\ i
& \text{(function)}\\
&&|& \symctx,\ \symctxstack,\ x^*\ \Term{[} \Rightarrow \Term{]}\ i
& \text{(continuation)}\\
&&|& ASTVal? & \text{(AST value)}\\
&&|& ASTMethod? & \text{(AST method)}\\
\\

%RefValue
\text{RefValue} & rv & ::= & x & \text{(identifier)}\\
&&|& a\Term{[} v \Term{]} & \text{(reference to value of map in heap)}\\
&&|& s\Term{.}v & \text{(reference to ???)}\\
\\

% \textit{RefValue} & rv & ::= & id & \text{(id)}\\
% &&|& prop & \text{(prop)}\\
% &&|& string & \text{(string)}\\
% \\

\end{array}
\]

\subsubsection{Global, Environment, Heap Description}

.

[[description of initial configuration of \irname]]

Heap = (Base + Built-in) $\rightarrow$ named addr + Dynamic $\rightarrow$
dynamic addr

[[description of operators used in state, context, heap]]

\newpage

\subsection{Semantic of \irname}

\begin{itemize}
  \item program : [[description of program execution]]
  \item instruction : $\evalinst{\symstate}{i}{\symstate}$
  \item expression : $\evalexpr{\symstate}{e}{v}{\symstate}$
  \item expression - escape completion :
  $\evalescexpr{\symstate}{e}{v}{\symstate}$
  \item reference : $\evalref{\symstate}{r}{rv}{\symstate}$
  \item reference value : $\evalrefv{\symstate}{rv}{v}{\symstate}$
  \item unary operator : $\evaluop{v}{v}$
  \item binary operator : $\evalbop{v}{v}{v}$
\end{itemize}

[[description of semantic relation]] 

[[description of escape completion]] : result of abstract algorithm in ECMAScript
is represented by completion record. "Escape completion" means "use value of 
completion record(\irname object), instead of record itself".

\newpage

\subsubsection{Instruction}

% instruction semantic rule
\[
\begin{array}{c}
\multicolumn{1}{c}{\begin{array}{ccccc}
\fbox{$\evalinst{\symstate}{i}{\symstate}$}
&
\cs
&
% expression
\infer
{ \evalexpr{\symstate}{e}{v}{\symstate_0} }
{ \evalinst{\symstate}{e}{\symstate_0} }
&
\cs
&
% let
\infer
{ \evalexpr{\symstate}{e}{v}{\symstate_0}\ \ \ \
\Term{define}( \symstate_0,\ x,\ v ) = \symstate_1}
{ \evalinst{\symstate}{\Term{let}\ x\ \Term{=}\ e}{\symstate_1} }
\end{array}}
\\ \\
% assign - refv:id
\infer
{ \evalref{\symstate}{r}{x}{\symstate_0}\ \ \ \
\evalexpr{\symstate_0}{e}{v}{\symstate_1}\ \ \ \
\Term{updated}(\symstate_1,\ x,\ v ) = \symstate_2}
{ \evalinst{\symstate}{r \Term{:=}\ e}{\symstate_2} }
\\ \\
% assign - refv:prop
\infer
{ \evalref{\symstate}{r}{a\Term{[} v \Term{]}}{\symstate_0}\ \ \ \
\evalescexpr{\symstate_0}{e}{v_0}{\symstate_1}\ \ \ \
\Term{updated}(\symstate_1,\ a\Term{[} v \Term{]},\ v_0 ) = \symstate_2 }
{ \evalinst{\symstate}{r \Term{:=}\ e}{\symstate_2} }
\\ \\
% assign - refv:str
\infer
{ \evalref{\symstate}{r}{s\Term{.}v}{\symstate_0}\ \ \ \
\evalescexpr{\symstate_0}{e}{v_0}{\symstate_1}\ \ \ \
\Term{updated}(\symstate_1,\ s\Term{.}v,\ v_0 ) = \symstate_2}
{ \evalinst{\symstate}{r \Term{:=}\ e}{\symstate_2} }
\\ \\
% delete
\infer
{ \evalref{\symstate}{r}{rv}{\symstate_0}\ \ \ \
\Term{deleted}(\symstate_0,\ rv) = \symstate_1}
{ \evalinst{\symstate}{\Term{delete}\ r}{\symstate_1} }
\\ \\
% append
\infer
{ \evalescexpr{\symstate}{e_0}{v_0}{\symstate_0}\ \ \ \
\evalescexpr{\symstate_0}{e_1}{v_1}{\symstate_1}\ \ \ \
\Term{append}(\symstate_0 ??,\ v_1,\ v_0) = \symstate_2}
{ \evalinst{\symstate}{\Term{append}\ e_0 \to e_1}{\symstate_2} }
\\ \\
% prepend
\infer
{ \evalescexpr{\symstate}{e_0}{v_0}{\symstate_0}\ \ \ \
\evalescexpr{\symstate_0}{e_1}{v_1}{\symstate_1}\ \ \ \
\Term{prepend}(\symstate_0 ??,\ v_1,\ v_0) = \symstate_2}
{ \evalinst{\symstate}{\Term{prepend}\ e_0 \to e_1}{\symstate_2} }
\\ \\
% return
\infer
{ \evalexpr{\symstate}{e}{v}{\symstate_0}\ \ \ \
\Term{updateCtxStack}(\symstate_0,\ v) = \symstate_1 }
{ \evalinst{\symstate}{\Term{return}\ e}{\symstate_1} }
\\ \\
% if - true
\infer
{ \evalescexpr{\symstate}{e}{\Term{true}}{\symstate_0}\ \ \ \
\Term{updateCtx}(\symstate_0,\ i_0) = \symstate_1 }
{ \evalinst{\symstate}{\Term{if}\ e\ i_0\ i_1}{\symstate_1} }
\\ \\
% if - false
\infer
{ \evalescexpr{\symstate}{e}{\Term{false}}{\symstate_0}\ \ \ \
\Term{updateCtx}(\symstate_0,\ i_1) = \symstate_1 }
{ \evalinst{\symstate}{\Term{if}\ e\ i_0\ i_1}{\symstate_1} }
\\ \\
\multicolumn{1}{c}{\begin{array}{ccc}
% while - true
\infer
{ \evalescexpr{\symstate}{e}{\Term{true}}{\symstate_0}\ \ \ \
\Term{updateCtx}(\symstate_0,\ i) = \symstate_1 }
{ \evalinst{\symstate}{\Term{while}\ e\ i}{\symstate_1} }
&
\cs
&
% while - false
\infer
{ \evalescexpr{\symstate}{e}{\Term{false}}{\symstate_0} }
{ \evalinst{\symstate}{\Term{while}\ e\ i}{\symstate_0} }
\end{array}}
\\ \\
\multicolumn{1}{c}{\begin{array}{ccccc}
% seq 
\infer
{ \Term{updateCtx2}(\symstate,\ i^*) = \symstate_0 }
{ \evalinst{\symstate}{\{ i^* \}}{\symstate_0} }
&
\cs
&
% assert
\infer
{ \evalexpr{\symstate}{e}{\Term{true}}{\symstate_0} }
{ \evalinst{\symstate}{\Term{assert}\ e}{\symstate_0} }
&
\cs
&
% print
\infer
{ \evalexpr{\symstate}{e}{v}{\symstate_0} \ \ \ \
\Term{print}(v) }
{ \evalinst{\symstate}{\Term{print}\ e}{\symstate_0} }
\end{array}}
\\ \\
% with cont
\infer
{ \symctx = \Term{getCtx}(\symstate) \ \ \ \
\symctxstack = \Term{getCtxStack}(\symstate) \ \ \ \
v_{c} = \symctx,\ \symctxstack,\ x^*\ \Term{[} \Rightarrow \Term{]}\ i
 \ \ \ \ \Term{define}(\symstate,\ x_{id},\ v_{c}) = \symstate_0 }
{ \evalinst
{\symstate}
{\Term{withcont}\ x_{id}\ \Term{(}x^*\Term{)}\ \Term{=}\ i}
{\symstate_0} }
% end of array
\end{array}
\]

\newpage
% instruction semantic rule cont
\[
\begin{array}{c}
% app - function
\infer
{ \evalexpr{\symstate}{e_{f}}{v_f}{\symstate_f} \ \ \ \ \ \ \
v_f = s\ \Term{(} x^*,\ \Term{[}x_{var}\Term{]} \Term{)}\ \Rightarrow\ i
\\ \\ 
\evalexpr{\symstate_f}{e_0}{v_0}{\symstate_0}\ \ \ \ \cdots\ \ \ \
\evalexpr{\symstate_{n-1}}{e_n}{v_n}{\symstate_n}\ \ \ \
\\ \\
\Term{updateCtxRetId}(\symstate_n,\ x) = \symstate_{\alpha}\ \ \ \
\Term{createCtx}(s,\ i,\ x^*,\ v^*) = \symctx_{\alpha}\ \ \ \
\Term{pushCtx}(\symstate_{\alpha},\ \symctx_{\alpha}) = \symstate_{next}
}
{ \evalinst{\symstate}{\Term{app}\ x\ \Term{=}\ (e_{f}\ e^*)}{\symstate_{next}} }
\\ \\
% app - AST method
\infer
{ \evalexpr{\symstate}{e_{f}}{v}{\symstate_0} }
{ \evalinst{\symstate}{\Term{app}\ x\ \Term{=}\ (e_{f}\ e^*)}{\symstate_0} }
\\ \\
% app - continuation
\infer
{ \evalexpr{\symstate}{e_{f}}{v_f}{\symstate_f} \ \ \ \ \ \ \
v_f = \symctx,\ \symctxstack,\ x^*\ \Term{[} \Rightarrow \Term{]}\ i
\\ \\ 
\evalexpr{\symstate_f}{e_0}{v_0}{\symstate_0}\ \ \ \ \cdots\ \ \ \
\evalexpr{\symstate_{n-1}}{e_n}{v_n}{\symstate_n}\ \ \ \
\\ \\
\Term{setCtxInst}(\symctx,\ i) = \symctx_0\ \ \ \
\Term{updateCtxEnv}(\symctx_0,\ x^*,\ v^*) = \symctx_1\ \ \ \
\Term{updateState}(\symstate_n,\ \symctx_1,\ \symctxstack) = \symstate_{next}}
{ \evalinst{\symstate}{\Term{app}\ x\ \Term{=}\ (e_{f}\ e^*)}{\symstate_{next}} }
\end{array}
\]

\newpage

\subsubsection{Expression}

\[
\begin{array}{ccc}
\multicolumn{1}{c}{\begin{array}{ccc}
\fbox{$\evalexpr{\symstate}{e}{v}{\symstate}$}
&\cs&
\infer
{ x\in\dom{\sigma} }
{ \evald{x}{\sigma(x)} }
\end{array}}
&
\multicolumn{2}{c}{\begin{array}{ccc}
\evald{n}{n}
&\cs&
\evald{b}{b}
\end{array}}
\end{array}
\]


\end{document}
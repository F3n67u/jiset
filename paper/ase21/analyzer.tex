\section{Type Analyzer}\label{sec:analyzer}

In this section, we explain the detail of the type analyzer in $\tool$. We first
formally define a modified $\ires$ and explain how to perform type analysis for
the its functions.  Moreover, we also explain a condition-based refinement of
type analysis based on conditions of assertions and branches to increase
analysis precision.

\subsection{Intermediate Representation}\label{sec:ires}

\begin{figure}
  \centering
  \includegraphics[width=0.48\textwidth]{img/record-fields-table}
  \caption{Fields of completion records in ES11.}
  \label{fig:record-fields-table}
  \vspace*{-1.5em}
\end{figure}

$\ires$ is an untyped intermediate representation introduced by \citet{jiset}.
To make it more suitable for type analysis, we modify it as a label-based
language as follows:
\begin{figure}[H]
  \centering
  \vspace{-0.5em}
  \resizebox{\columnwidth}{!}{$
    \begin{array}{l@{~}r@{~}c@{~}r@{~}r@{~}l}
      \text{Functions}
      &\funcset&\ni&\func&::=&\kwdef \; \x (\x^*, \kwsl \x^* \kwsr). \; \lab\\

      \text{Instructions}
      &\instset&\ni&\inst&::=&
      \kwlet \; \x = \expr \mid
      \x = \kwrl \expr \; \expr^* \kwrr \mid
      \kwassert \; \expr \\

      &&&&\mid&
      \kwif \; \expr \; \lab \; \lab \mid
      \kwreturn \; \expr \mid
      \refer = \expr \\

      \text{References}
      &&&\refer&::=&
      \x \mid
      \refer \kwsl \expr \kwsr \\

      \text{Expressions}
      &&&\expr&::=&
      \tname \; \kwcl [\x: \expr]^* \kwcr \mid
      \clist{\expr^*} \mid
      \expr: \ty \mid
      \refer \kwexists \\

      &&&&\mid&
      \expr \bop \expr \mid
      \uop \; \expr \mid
      \refer \mid
      \const \mid
      \prim \\

      \text{Primitives}
      &\primset&\ni&\prim&::=&
      \undefval \mid \nullval \mid \bool \mid
      \num \mid \bigint \mid \str \mid \symb \\

      \text{Types} &\tyset&\ni&\ty&::=&\tname \mid \clist{} \mid \clist{\ty} \mid
      \tjs \mid \tprim\\

      &&&&\mid&
      \undefval \mid \nullval \mid \tbool \mid \tnumeric\\

      &&&&\mid&
      \tnum \mid \tbigint \mid \tstr \mid \tsymb \\
    \end{array}
  $}
  \vspace{-0.5em}
\end{figure} \noindent
A modified $\ires$ program $\prog = (\getfunc, \getinst, \getnext)$ is consists
of three mappings from labels;  $\getfunc: \labset \rightarrow \funcset$
represents that labels are in which functions, $\getinst: \labset \rightarrow
\instset$ represents instructions attached to labels, and $\getnext: \labset
\rightarrow \labset$ denotes next labels where a label $\lab \in \labset$
denotes a program point.  function $\kwdef \; \f (\x^*, \kwsl \y^* \kwsr). \;
\lab \in \funcset$ consists of its name $\f$, normal parameters $\x^*$, optional
parameters $\y^*$, and a body label $\lab$.  Although global variables exist in
ECMAScript, we assume that only local variables exist in this paper for brevity.
An instruction $\inst$ is a variable declaration, a function call, an assertion,
a branch, a return, or a reference update.  Each invocation of an abstract
algorithm in ECMAScript is compiled to a function call instruction with a newly
introduced temporal variable.  We represent loops using branch instructions with
cyclic pointing of labels in the next mapping $\getnext$.  A reference $\refer$
is a variable $\x$ or a field access $\refer \kwsl \expr \kwsr$.  We use the
notation $\refer.\f$ to briefly represent $\refer \kwsl \code{"f"} \kwsr$. An
expression $\expr$ is a record, a list, a type check, an existence check, a
binary operation, a unary operation, a reference, a constant, or a primitive,
which is either $\undefval$, $\nullval$, a \jscode{Boolean} $\bool$, a
\jscode{Number} $\num$, a \jscode{BigInt} $\bigint$, a \jscode{String} $\str$,
or a \jscode{Symbol} $\symb$.

\begin{figure}
  \centering
  \includegraphics[width=0.4\textwidth]{img/subtype}
  \caption{A graphical representation of subtype relation $\subtype$.}
  \label{fig:subtype}
  \vspace*{-1.5em}
\end{figure}

\begin{figure*}[t]
  \centering
  \begin{subfigure}[b]{\textwidth}
    \[
      \footnotesize
      \begin{array}{r@{~}c@{~}ll}
        \asemi{\kwlet \; \x = \expr}
        (\lab, \tys)(\aelem) &=&
        (\{ (\getnext(\lab), \tys) \mapsto \aenv_\x \}, \emp) &
        \text{where} \;
        \aenv_\x = \aenv[\x \mapsto \aty] \wedge
        \aty = \aseme{\expr}(\aenv)\\

        \asemi{\x = \kwrl \expr_0 \; \expr_1 \cdots \expr_n \kwrr}
        (\lab, \tys)(\aelem) &=&
        \left(
          \begin{array}{@{}l@{}}
            \{ (\lab_\func, \tys_a) \mapsto \aenv_{\func, \tys_a} \mid \func \in
              F \wedge \tys_a \in T_a
            \},\\
            \{ (\func, \tys_a) \mapsto \{ (\getnext(\lab), \tys, \x) \} \mid
              \func \in F \wedge \tys_a \in T_a
            \}\\
          \end{array}
        \right) &
        \text{where} \;
        \left\{
          \begin{array}{@{}l@{}}
            \aty_i = \aseme{\expr_i}(\aenv) \wedge T_a = \{ \upcasts([ \ty_1,
            \cdots, \ty_n ] \mid \ty_i \in \aty_i \} \wedge\\
            F = \{ \func \in \aty_0 \mid \func = \kwdef \; \_ (\p_1, \cdots,
            \kwsl \cdots, \p_m \kwsr). \; \lab_\func \} \wedge\\
            \aenv_{\func, \tys_a} = \aenv[\p_1 \mapsto \{ \tys_a[1] \}, \cdots,
            \p_m \mapsto \{ \tys_a[m] \}]\\
          \end{array}
        \right.\\

        \asemi{\kwassert \; \expr}
        (\lab, \tys)(\aelem) &=&
        (\{ (\getnext(\lab), \tys) \mapsto \aenv_\mt \}, \emp) &
        \text{where} \; \aenv_\mt = \refine(\expr, \true)(\aenv)\\

        \asemi{\kwif \; \expr \; \lab_\mt \; \lab_\mf}
        (\lab, \tys)(\aelem) &=&
        (\{ (\lab_\mt, \tys) \mapsto \aenv_\mt, (\lab_\mf, \tys) \mapsto
        \aenv_\mf \}, \emp) &
        \text{where} \;
        \aenv_\mt = \refine(\expr, \true)(\aenv) \wedge
        \aenv_\mf = \refine(\expr, \false)(\aenv)\\

        \asemi{\kwreturn \; \expr}
        (\lab, \tys)(\aelem) &=&
        (\{ (\lab_r, \tys_r) \mapsto \aenv_r \mid (\lab_r, \tys_r, \x) \in
        \retp(\getfunc(\lab), \tys)\}, \emp) &
        \text{where} \;
        \aenv_r = \rmap(\lab_r, \tys_r)[\x \mapsto \aty] \wedge
        \aty = \aseme{\expr}(\aenv)\\

        \asemi{\x = \expr}
        (\lab, \tys)(\aelem) &=&
        (\{ (\getnext(\lab), \tys) \mapsto \aenv_\x \}, \emp) &
        \text{where} \;
        \aenv_\x = \aenv[\x \mapsto \aty] \wedge
        \aty = \aseme{\expr}(\aenv)\\

        \asemi{\refer \kwsl \expr_0 \kwsr = \expr_1}
        (\lab, \tys)(\aelem) &=&
        (\{ (\getnext(\lab), \tys) \mapsto \aenv \}, \emp)
      \end{array}
    \]
    \caption{Instructions with $\asemi{\inst}: (\labset \times \tyset^*)
    \rightarrow \adom \rightarrow \adom$ where $\aelem = (\rmap, \retp) \wedge
    \aenv = \aelem(\lab, \tys)$.}
  \end{subfigure}
  \begin{subfigure}[b]{0.48\textwidth}
    \[
      \footnotesize
      \asemr{\x}(\aenv) = \aenv(\x)
      \qquad
      \asemr{\refer \kwsl \expr \kwsr}(\aenv) = \{ \ty[\str] \mid \ty \in
      \asemr{\refer}(\aenv) \wedge \str \in \aseme{\expr}(\aenv) \}
    \]
    \caption{References with $\asemr{\refer}: \aenvset \rightarrow \atyset$.}
  \end{subfigure}
  \begin{subfigure}[b]{\textwidth}
    \[
      \footnotesize
      \begin{array}{r@{~}c@{~}lr@{~}c@{~}lr@{~}c@{~}l}
        \aseme{\tname \; \kwcl \fields \kwcr}(\aenv)
        &=& \multicolumn{7}{@{}l}{
          \left\{
            \begin{array}{ll}
              \{ \tnormal(\ty) \mid \ty \in \aseme{\fields(\code{Value})}(\aenv)
              \} & \text{if} \; \tname = \text{Completion} \wedge
              \fields(\code{Type}) = \nconst{normal}\\

              \{ \tabrupt \} & \text{if} \; \tname = \text{Completion} \wedge
              \fields(\code{Type}) \neq \nconst{normal}\\

              \{ \tname \} & \text{otherwise}\\
            \end{array}
          \right.
          \quad \aseme{\prim}(\aenv) =
          \left\{
            \begin{array}{ll}
              \{ \tnum \} & \text{if} \; \prim = \num\\
              \{ \tbigint \} & \text{if} \; \prim = \bigint\\
              \{ \tsymb \} & \text{if} \; \prim = \symb\\
              \{ \prim \} & \text{otherwise}\\
            \end{array}
          \right.
        }

        \\

        \aseme{\const}(\aenv) &=& \const &

        \aseme{\clist{}}(\aenv) &=& \clist{} &

        \aseme{\clist{\expr_0, \cdots, \expr_n}}(\aenv)
        &=& \{ \clist{\ty} \mid \ty \in \bigjoin_{0 \leq i
        \leq n} \aseme{\expr_i}(\aenv) \}

        \\

        \aseme{\expr: \ty}(\aenv)
        &=& \{ \ty' \subtype \ty \mid \ty' \in
        \aseme{\expr}(\aenv) \} &

        \aseme{\refer \kwexists}(\aenv)
        &=& \{ \ty \neq \tabsent \mid \ty \in
        \aseme{\expr}(\aenv) \} &

        \aseme{\refer}(\aenv)
        &=& \asemr{\refer}(\aenv) \setminus \{ \tabsent \}

        \\

        \aseme{\uop \; \expr}(\aenv)
        &=& \{ \abs{\uop} \ty \mid \ty \in
        \aseme{\expr}(\aenv) \} &

        \aseme{\expr_0 \bop \expr_1}(\aenv)
        &=& \multicolumn{4}{@{}l}{\{ \ty_0 \abs{\bop} \ty_1 \mid \ty_0 \in
        \aseme{\expr_0}(\aenv) \wedge \ty_1 \in \aseme{\expr_1}(\aenv) \}}

        \\
      \end{array}
    \]
    \caption{Expressions with $\aseme{\expr}: \aenvset \rightarrow \atyset$.}
  \end{subfigure}
  \caption{Abstract semantics of the modified $\ires$ for a program $\prog =
  (\getfunc, \getinst, \getnext)$.}
  \vspace*{-1.5em}
  \label{fig:abs-sem}
\end{figure*}


A type $\ty \in \tyset$ is either a norminal type $\tname$, an empty list type
$\clist{}$, a parametric list type $\clist{\ty}$, or a pre-defined type; $\tjs$
denotes JavaScript values, $\tprim$ primitives, $\tnumeric$ either
\jscode{Number} or \jscode{BigInt} values, and $\tnum$, $\tbigint$, $\tstr$, and
$\tsymb$ denote \jscode{Number}, \jscode{BigInt}, \jscode{String}, and
\jscode{Symbol} values, respectively.  A norminal type $\tname$ is either 1) an
\textit{AST type} having corresponding syntax-directed algorithms as its fields,
or 2) a \textit{record type} having specific fields with possible values
described in the corresponding table and additional description in ECMAScript.
AST types are automatically extracted but we manually model fields of record
types.  For example, Figure~\ref{fig:record-fields-table} is an excerpt from
ES11 that describes fields of completion records%
\footnote{https://262.ecma-international.org/11.0/\#table-8} and we manually
model them as follows:

\begin{figure}[H]
  \centering
  \vspace{-0.5em}
  \resizebox{\columnwidth}{!}{$
    \begin{array}{l}
      \code{Completion} \code{=} \; \kwcl\\
        \quad \Type: \{ \nconst{normal}, \nconst{break}, \nconst{continue},
        \nconst{return}, \nconst{throw} \},\\
        \quad \Value: \{ \tjs, \nconst{empty} \},
        \quad \Target: \{ \tstr, \nconst{empty} \}\\
      \kwcr\\
    \end{array}
  $}
  \vspace{-0.5em}
\end{figure}

The subtype relation $\subtype \subseteq \tyset \times \tyset$ between types is
depicted in Figure~\ref{fig:subtype}; the directed edge from $\ty'$ to $\ty$
denotes $\ty' \subtype \ty$ and the relation is reflexive and transitive.  The
subtype relation is dependent on the norminal types defined in ECMAScript.  We
extract subtypes for AST types from the JavaScript syntax and manually model
subtypes for record types.  For example, consider the syntax-directed abstract
algorithm at the lower-right in Figure~\ref{fig:example}.  The non-terminal
\textit{BindingElement} is the unique token in an alternative of
\textit{FormalParameter} production thus we automatically extract the subtype
relation: \textit{BindingElement} $\subtype$ \textit{FormalParameter}.  Based on
this subtype relation, a type check expression $\expr: \ty$ checks whether the
evaluation result of $\expr$ has a type $\ty'$ satisfying $\ty' \subtype \ty$.

We define a denotational semantics of the modified $\ires$ for instructions
$\semi{\inst}: \dom \rightarrow \dom$, references $\semr{\refer}: \dom
\rightarrow \valset$, and expressions $\seme{\expr}: \dom \rightarrow \valset$.
For presentation brevity, we omit it in this paper and include it in a companion
report~\inred{\cite{report}}.


\subsection{Type Analysis}\label{sec:analysis}

We design a type analysis for the modified $\ires$ based on abstract
interpretation framework~\cite{ai1977, ai1992} with analysis
sensitivity~\cite{sens-toplas}.  We first extend types $\tyset$ as follows:
\begin{figure}[H]
  \centering
  \vspace{-0.5em}
  \resizebox{0.8\columnwidth}{!}{$
    \tyset \ni \ty ::=
    \cdots \mid
    \func \mid
    \const \mid
    \tnormal(\ty) \mid
    \tabrupt \mid
    \bool \mid
    \str \mid
    \tabsent
  $}
  \vspace{-0.5em}
\end{figure} \noindent
There are three reasons why we extend types.  First, the original types $\tyset$
do not cover all types of values thus we add functions and constants.  Second,
we add more specific types to increase the precision of type analysis.  A
completion record is a \textit{normal completion} when its \code{Type} field is
$\nconst{normal}$ or an \textit{abrupt completion} otherwise.  We add
$\tnormal(\ty)$ for normal completions whose \code{Value} field is a value of
the type $\ty$, and $\tabrupt$ for abrupt completions.  Moreover, we also add
\jscode{Boolean} values $\bool$, and \jscode{String} values $\str$ to precisely
handle the control flows of branches and field accesses, respectively.  Third,
we add the absent type $\tabsent$ to represent the existence of variables.
Using such extended types, we define abstract states with flow-sensitivity and
type-sensitivity for arguments:

\begin{figure}[H]
  \centering
  \vspace{-0.5em}
  \resizebox{\columnwidth}{!}{$
    \begin{array}{lr@{~}c@{~}c@{~}r@{~}l}
      \text{Abstract States}
      &\aelem&\in&\adom&=& \rmapset \times \retpset\\

      \text{Result Maps}
      &\rmap&\in&\rmapset&=& \labset \times \tyset^* \rightarrow \aenvset\\

      \text{Return Points}
      &\retp&\in&\retpset&=& \funcset \times \tyset^*
      \rightarrow \partsof{\labset \times \tyset^* \times \varset} \\

      \text{Abstract Environments}
      &\aenv&\in&\aenvset&=&\varset \rightarrow \atyset\\

      \text{Abstract Types}
      &\aty&\in&\atyset&=&\partsof{\tyset}\\
    \end{array}
  $}
  \vspace{-0.5em}
\end{figure}

An abstract state $\aelem \in \adom$ is a pair of a result map and a return
point mapping.  A result map $\rmap \in \rmapset$ represents an abstract
environment for each flow- and type-sensitive view, and a return point mapping
$\retp \in \retpset$ represents possible return points of each function
with a type-sensitive context; each return point consists of a view for the
caller function and a variable that represents the return value.  An abstract
environment $\aenv \in \aenvset$ represents possible types for variables, and
$\aenv(\x) = \{ \tabsent \}$ when $\x$ is not defined in $\aenv$.  An abstract
type $\aty \in \atyset$ is a set of types.  While we define the join operator
$\join$, the meet operator $\meet$, and the partial order $\order$ for most of
abstract domains in a point-wise manner, we define the operators for types with
a normalization function $\norm$ because of their subtype relations:
\begin{figure}[H]
  \centering
  \vspace{-0.5em}
  \resizebox{\columnwidth}{!}{$
    \begin{array}{l}
      \aty_0 \join \aty_1 = \norm(\aty_0 \cup \aty_1)\\
      \aty_0 \meet \aty_1 = \norm(
      \{\ty_0 \in \aty_0 \mid \{ \ty_0 \} \order \aty_1 \} \cup
      \{\ty_1 \in \aty_1 \mid \{ \ty_1 \} \order \aty_0 \}
      )\\
      \aty_0 \order \aty_1 \Leftrightarrow \forall \ty_0 \in \aty_0. \; \exists
      \ty_1 \in \norm(\aty_1). \; \text{s.t.} \; \ty_0 \subtype \ty_1\\
    \end{array}
  $}
  \vspace{-0.5em}
\end{figure} \noindent
where $\small{\norm(\aty) = \{ \ty \mid \ty \in \aty \wedge \nexists \ty' \in
\aty. \setminus \{ \ty \}\; \text{s.t.} \; \ty \subtype \ty' \}}$.

Based on abstract states, we define the abstract semantics of instructions,
references, and expressions in the modified $\ires$ described in
Figure~\ref{fig:abs-sem}.  To prevent the explosion of the number of type-sensitive
views, we upcast the type of each argument before function calls with the
following function:
\begin{figure}[H]
  \centering
  \vspace{-0.5em}
  \resizebox{0.8\columnwidth}{!}{$
    \upcast(\ty) = \left\{
      \begin{array}{ll}
        \tnormal(\upcast(\ty')) & \text{if} \; \ty = \tnormal(\ty')\\
        \clist{\upcast(\ty')} & \text{if} \; \ty = \clist{\ty'}\\
        \tstr & \text{if} \; \ty = \str\\
        \tbool & \text{if} \; \ty = \bool\\
        \ty & \text{otherwise}\\
      \end{array}
    \right.
  $}
  \vspace{-0.5em}
\end{figure} \noindent
and $\upcasts$ denotes a point-wise extension of $\upcast$ for type sequences.
For branches and assertions, we apply the $\refine$ function that prunes out
infeasible parts in abstract environments based on their conditions to increase
analysis precision.  We will explain its detail in Section~\ref{sec:refine}.
Then, we define the abstract semantics $\asem{\prog}$ of a program $\prog =
(\getfunc, \getinst, \getnext)$ as the least fixpoint of abstract transfer
$\atransfer: \adom \rightarrow \adom$:
\begin{figure}[H]
  \centering
  \vspace{-0.5em}
  \resizebox{0.9\columnwidth}{!}{$
    \begin{array}{r@{~}c@{~}l}
      \asem{\prog} &=& \lim_{n \rightarrow \infty}(\atransfer)^n(\iaelem)\\
      \atransfer(\aelem) &=& \aelem \join \left(
        \bigjoin_{(\lab, \tys) \in \domain{\rmap}}
        \asemi{\getinst(\lab)}(\lab, \tys)(\aelem)
      \right)\\
    \end{array}
  $}
  \vspace{-0.5em}
\end{figure} \noindent
where $\aelem = (\rmap, \_)$ and $\iaelem$ denotes the initial abstract state.
As described in Section~\ref{sec:overview}, $\iaelem$ contains entry points of
all syntax-directed algorithms having no additional parameters and built-in
algorithms with appropriate abstract environments.  For syntax-directed
algorithms, we construct its abstract environment containing the variable
$\this$ with a production type and other variables for non-terminals.  For
example, the upper-left syntax-directed algorithm in Figure~\ref{fig:example} is
initialized with the following abstract environment:
\begin{figure}[H]
  \centering
  \vspace{-0.5em}
  \resizebox{\columnwidth}{!}{$
    \begin{array}{r@{~}c@{~}l}
      \this &\mapsto& \{ \code{AssignmentExpression} \},\\
      \code{LeftHandSideExpression} &\mapsto& \{ \code{LeftHandSideExpression} \},\\
      \code{AssignmentExpression} &\mapsto& \{ \code{AssignmentExpression} \}
    \end{array}
  $}
  \vspace{-0.5em}
\end{figure} \noindent
For built-in algorithms, we assign pre-defined variables $\this$, $\args$, and
$\NewTarget$ with corresponding types and parameters with $\tjs$ types.  For
example, the following abstract environment is for the built-in
algorithm $\jscode{Math.round}$ at the upper-right in Figure~\ref{fig:example}:
\begin{figure}[H]
  \centering
  \vspace{-0.5em}
  \resizebox{0.9\columnwidth}{!}{$
    \begin{array}{r@{~}c@{~}lr@{~}c@{~}l}
      \this &\mapsto& \{ \tjs \}, &
      \args &\mapsto& \{ \clist{\tjs} \},\\
      \NewTarget &\mapsto& \{ \code{Object}, \undefval \}, &
      \x &\mapsto& \tjs\\
    \end{array}
  $}
  \vspace{-0.5em}
\end{figure}


\subsection{Condition-based Refinement}\label{sec:refine}

We present a \textit{condition-based refinement} of type analysis for the
modified $\ires$ to increase analysis precision.  It prunes out infeasible parts
in abstract environments based on conditions of branches of assertions, and we
formally define the $\refine$ function as follows:
\begin{figure}[H]
  \centering
  \vspace{-0.5em}
  \resizebox{\columnwidth}{!}{$
    \begin{array}{@{}r@{~}c@{~}l@{}}
      \refine(\code{!} \expr, \bool)(\aenv) &=&
      \refine(\expr, \neg \bool)(\aenv)\\

      \refine(\expr_0 \; \code{||} \; \expr_1, \bool)(\aenv) &=&
      \left\{
        \begin{array}{ll}
          \aenv_0 \join \aenv_1 & \text{if} \; \bool\\
          \aenv_0 \meet \aenv_1 & \text{if} \; \neg\bool\\
        \end{array}
      \right.\\
      \refine(\expr_0 \; \code{\&\&} \; \expr_1, \bool)(\aenv) &=&
      \left\{
        \begin{array}{ll}
          \aenv_0 \meet \aenv_1 & \text{if} \; \bool\\
          \aenv_0 \join \aenv_1 & \text{if} \; \neg\bool\\
        \end{array}
      \right.\\

      \refine(\x.\Type \; \code{==} \; \nconst{normal}, \true)(\aenv) &=&
      \aenv[ \x \mapsto \aty_\x \cap \tnormal(\tyset) ]\\
      \refine(\x.\Type \; \code{==} \; \nconst{normal}, \false)(\aenv) &=&
      \aenv[ \x \mapsto \aty_\x \cap \{ \tabrupt \} ]\\

      \refine(\x \; \code{==} \; \expr, \true)(\aenv) &=&
      \aenv[ \x \mapsto \aty_\x \meet \aty_\expr ]\\
      \refine(\x \; \code{==} \; \expr, \false)(\aenv) &=&
      \aenv[ \x \mapsto \aty_\x \setminus
      \lfloor\aty_\expr\rfloor ]\\

      \refine(\x : \ty, \true)(\aenv) &=&
      \aenv[ \x \mapsto \aty_\x \meet \{ \ty \} ]\\
      \refine(\x : \ty, \false)(\aenv) &=&
      \aenv[ \x \mapsto \aty_\x \setminus \{ \ty' \mid \ty' \subtype \ty
      \}]\\
      \refine(\expr, \true)(\aenv) &=& \aenv\\
    \end{array}
  $}
  \vspace{-0.5em}
\end{figure} \noindent
where $\aenv_i = \refine(\expr_i, \bool)(\aenv)$ and $\aty_\expr =
\aseme{\expr}(\aenv)$.  The notation $\getSingle{\aty}$ denotes to check whether
$\aty$ is a singleton; $\getSingle{\aty} = \aty$ if $\aty = \{ \ty \}$ and $\ty$
is a singleton type such as a constant $\const$, an empty list $\clist{}$, an
absent value $\tabsent$, a primitive value, etc., or $\getSingle{\aty} = \emp$
otherwise.

[
  {
    "tokens": "Let id:{idTextUnescaped} be the result of replacing any occurrences of code:{\\\\} nt:{UnicodeEscapeSequence} in id:{idText} with the code point represented by the nt:{UnicodeEscapeSequence} .",
    "inst": "let idTextUnescaped = AnyStr"
  },
  {
    "tokens": "Let id:{idTextUnescaped} be the result of replacing any occurrences of code:{\\\\} nt:{RegExpUnicodeEscapeSequence} in id:{idText} with the code point represented by the nt:{RegExpUnicodeEscapeSequence} .",
    "inst": "let idTextUnescaped = AnyStr"
  },
  {
    "tokens": "If no such execution context exists , return value:{null} . Otherwise , return id:{ec} ' s ScriptOrModule .",
    "inst": "return ec.ScriptOrModule"
  },
  {
    "tokens": "Create an immutable binding in id:{envRec} for id:{N} and record that it is uninitialized . If id:{S} is value:{true} , record that the newly created binding is a strict binding .",
    "inst": "envRec.SubMap[N] = absent"
  },
  {
    "tokens": "Let id:{internalSlotsList} be the internal slots listed in link:{unhandled: table-internal-slots-of-ecmascript-function-objects} .",
    "inst": "let internalSlotsList = (new [AnyStr])"
  },
  {
    "tokens": "Let id:{ec} be the topmost execution context on the execution context stack whose ScriptOrModule component is not value:{null} .",
    "inst": "let ec = GLOBAL_executionStack[(- GLOBAL_executionStack 1i)]"
  },
  {
    "tokens": "Return the String value consisting of the code units of the digits of the decimal representation of id:{x} .",
    "inst": "return (convert x num2str)"
  },
  {
    "tokens": "Return the source text that was recognized as nt:{RegularExpressionBody} .",
    "inst": "return AnyStr"
  },
  {
    "tokens": "Return the source text that was recognized as nt:{RegularExpressionFlags} .",
    "inst": "return AnyStr"
  },
  {
    "tokens": "If FlagText of id:{literal} contains any code points other than code:{g} , code:{i} , code:{m} , code:{s} , code:{u} , or code:{y} , or if it contains the same code point more than once , return value:{false} .",
    "inst": "if AnyBool return false else {}"
  },
  {
    "tokens": "Let id:{constructorText} be the source text in:{} out:{}",
    "inst": "let constructorText = AnyStr"
  },
  {
    "tokens": "Set id:{constructor} to ParseText ( id:{constructorText} , | MethodDefinition [ ~ Yield , ~ Await ] | ) .",
    "inst": "constructor = (parse-syntax constructorText \"MethodDefinition\" (new [false, false]))"
  },
  {
    "tokens": "If id:{declarationNames} does not include the element value:{\"*default*\"} , append value:{\"*default*\"} to id:{declarationNames} .",
    "inst": "if (contains declarationNames \"*default*\") {} else append \"*default*\" -> declarationNames"
  }
]

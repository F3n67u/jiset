\section{Building entire system to evaluate code}

In this section, we will demonstrate how our idea can be implemented to evaluate programming language. Although it is hard to generalize the process because the format of specification or 
environment of the programming language is varying, We shows the possibility to build entire system for evaluating target language with minimal human effort by giving end-to-end example of ECMAScript langauge.

\subsection{Extracting specification}
First step is to collect language specification and extract component that we can process autoamtically. For our target langauge, ECMAScript, has HTML format of specification in their website, and
in the specification they have BNF form of syntax, highly structured algorithm steps, and verbose texts to describe additional environment to evaluating ECMAScript source code.
We get these information by parsing HTML document, and passing these result to our previous moudle to get AST, Parser, and executable algorithms automatically.

Rest part is initial environment of language such as initialization of builtin types, or entry point of the program, etc.

\subsection{Generating initial environment for evaluating}
For ECMAScript Specification, initial environment consists of the Builtin objects, Intrinsincs. We will describe how to generate each component.

\subsubsection{Builtin objects}

 In ECMAScript, there is the object which have references of builtin object. Each Builtin Object provides fields and function, just as ordinary object. When its function is called,
 the corresponding algorithm specified in the document should be called. To support builtin object, we make structure of builtin object and its attributes, and then we autoamtically map corresponding field to the algorithm in specification by matching its function name.
 
 \subsubsection{Intrinsics}

 While builtin objects has canonical name to refer itself in ECMAScript language, It is also frequently refered in specification. But name of builtin objects
 are defiend for reference in Host language, so it needs another name to refer it in specification langauge. Intrinsics are alias for built-in objects. 
 Map between Intrinsic name and Builtin objects are available in speicificaion as table form , so we parse this table to generate global identifier to object.

\subsection{Algorithm scope}

 In specification, All algorithm has name to refer it, but some algorithms have same names and they are called in context-dependent way.
 There is four types of algorithm. 
 \begin{itemize}
  \item Global algorithm: they can be called by name in any context
  \item Type-dependent algorithm: they are bounded in specific type of object
  \item Syntax-dependent algorithm: they are bounded in AST
  \item Builtin function algorithm: they correspond to builtin function
  \end{itemize}

  First, we categorized sections by types of algorithm. Builtin object has several own sections to describe its functions,
so it is easy to extract builtin object algorithms. Type-dependent algorithms and syntax-dependent algorithms has their own layout, so it
can be extracted. Rest algorithms are considered as global algorithm.

We mapped builtin function algorithms in environment when initialzing builtin object, so we descibe about rest three algorithms. 

\subsubsection{Global algorithm}

We just convert global algorithms to function, and bind global identifier to that function to call it by algorithm name.

\subsubsection{Type-dependent algorithm}

In ECMAScript specification, there are some objects which has similar interface, but they have different algorithms. 

For Example, Object Environment Record and Declarative Environment Record is different object in specification, but they have same name of algorithm(i.e. HasBinding(N))

In this case, algorithm is called in context of calling Object(i.e. x.HasBinding(N)). We name it type-dependent algorithm.
For type-denpendent algorithms, we organized map from algorithm name to function for each type,
 and we insert functions as propertiy of object when such type of object is created.

 \subsubsection{Syntax-dependent algorithm}
 
 Like type-dependent algorithm, there are many AST Value (in specification, it is called Parse Node) which uses same name of algorithm but the content is differnt.
The most frequent example is Evaluation of the AST Value. every Evaluation algorithm has same name, but each algorithm can be applied for specific syntax. We name it syntax-dependent algorithm.
For syntax-dependent algorithm, we insert converted functions in AST structure, and add special expression to call syntax-dependent algorithm which requires AST Value and algorithm name.
We gather which AST can be applied to a function. Also, to use child node of AST, we passes child node of AST to function as argument.

% \begin{itemize}
%   \item \textbf{Global Algorithms} Global algorithms are possible to be accessed
%     by any other algorithms. The top-level algorithm \( \code{RunJobs} \) is also global.
%   \item \textbf{Type-dependent Algorithms} Several algorithms have different
%     bodies dependent on types of their owner data. In ECMAScript specifications,
%     there are two different data types; language types and specification types.
%     The language types are explicitly used in JavaScript languages such as
%     \( \code{Boolean}, \code{Number}, \code{String} \), and \( \code{Object} \).
%     However, specification types are only used in specifications such as
%     Lists, Records, and Lexical Environments. Among them, some data types
%     have their own member algorithms. For example, language type \( \code{Object} \)
%     has several internal methods described in abstract algorithms. It depends
%     on 
% 
%     several data types have their own member algorithms. For example, 
%     
%     For example, the internal method
%     \( \code{[[Call]]} \) has different semantics dependent on its owner object.
%     Moreover, the owner objects are used in the body of algorithms as well.
%     Thus, we extend the parameters to accept its owner object as an implicit argument.
%   \item \textbf{Syntax-directed Algorithms} The semantics of each JavaScript syntax
%     are written in 
% \end{itemize}

% \subsection{semantic 컴파일하기 위해 하는 것 + specification 구조}
% 기본적인 원칙 :
% \begin{itemize} 
% \item 자바스크립트로 알고리즘 이름이랑 파라미터, 스텝을 가져와서 코어의 글로벌 ID에 매치 시켜줌
% \item initial Heap을 생성해줌
% \end{itemize}
% 매치를 시킨다는 뜻은 코어의 글로벌 ID에 코어 함수 형태로 알고리즘을 넣는 것임
% 

\documentclass[sigconf,review,anonymous=true]{acmart}

\usepackage{kotex}
\usepackage[T1]{fontenc}
\usepackage{beramono}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{qtree}
\usepackage{multirow}
\usepackage{colortbl}
\usepackage{ulem}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{booktabs}

% color
\definecolor{gainsboro}{rgb}{0.86, 0.86, 0.86}
\newcommand*{\belowrulesepcolor}[1]{%
  \noalign{%
    \kern-\belowrulesep
    \begingroup
      \color{#1}%
      \hrule height\belowrulesep
    \endgroup
  }%
}
\newcommand*{\aboverulesepcolor}[1]{%
  \noalign{%
    \begingroup
      \color{#1}%
      \hrule height\aboverulesep
    \endgroup
    \kern-\aboverulesep
  }%
}

% dashed line
\usepackage{array}
\usepackage{arydshln}
\setlength\dashlinedash{0.2pt}
\setlength\dashlinegap{1.5pt}
\setlength\arrayrulewidth{0.3pt}

% removed ACM references
\settopmatter{printacmref=false}

% Scala code style
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstdefinestyle{myScalastyle}{
  frame=tb,
  language=scala,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=fixed,
  basicstyle={\footnotesize\ttfamily},
  numbers=none,
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  frame=single,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
}
\lstdefinestyle{smallScalastyle}{
  frame=tb,
  language=scala,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=fixed,
  basicstyle={\scriptsize\ttfamily},
  numbers=none,
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  frame=single,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
}

% ECMAScript Intermediate Reprentations
\lstdefinestyle{ires}{
  frame=tb,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=fixed,
  basicstyle={\footnotesize\ttfamily},
  numbers=none,
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  frame=single,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
}

% JavaScript code style
\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstdefinestyle{myJSstyle}{
  language=JavaScript,
  extendedchars=true,
  basicstyle=\footnotesize\ttfamily,
  showstringspaces=false,
  showspaces=false,
  numbers=none,
  tabsize=2,
  breaklines=true,
  showtabs=false,
  captionpos=b
}

% thicker vertical line
\newcolumntype{?}{!{\vrule width 1pt}}

% load macros
\input{macros}

\begin{document}

\title{\( \tool \): JavaScript IR-based Semantics Extraction Toolchain}

\author{Jihyeok Park}
\email{jhpark0223@kaist.ac.kr}
\affiliation{\institution{KAIST}}

\author{Jihee Park}
\email{j31d0@kaist.ac.kr}
\affiliation{\institution{KAIST}}

\author{Sukyoung Ryu}
\email{sryu.cs@kaist.ac.kr}
\affiliation{\institution{KAIST}}

\begin{abstract}
JavaScript was initially designed for client-side code in web browsers,
but its engine is now embedded in various kinds of host software.
Despite its popularity, since the JavaScript semantics is complex
especially due to its dynamic nature, understanding and reasoning
about JavaScript programs are challenging tasks.  Thus,
researchers have proposed several attempts to define the formal semantics
of JavaScript based on ECMAScript, the official JavaScript specification.
However, the existing approaches are manual, labor-intensive, and
error-prone, and they all target only the ECMAScript 5.1 version.
This problem is critical in understanding recent JavaScript programs
because ECMAScript has been annually released since 2015, which made
already five updates after ECMAScript 5.1.

To alleviate the problem, we propose \( \tool \), a JavaScript IR-based Semantics
Extraction Toolchain. It \textit{synthesizes} a JavaScript
parser for a given grammar written in \( \bnfes \), an extended BNF
used in ECMAScript. It also \textit{automatically} extracts
semantics based on rule-based compilations. Each \textit{compile rule}
describes how to convert each abstract algorithm written in a structured natural language
into functions written in \( \ires \), an Intermediate Representation
for ECMAScript. \( \tool \) successfully synthesizes
parsers and compiles 91.60\% of algorithm steps for five recent
ECMAScript versions. We tested the extracted semantics from the next version
ECMAScript 2020 using Test262, the official ECMAScript conformance test
suite. It passed 19,220 of 19,282 tests and we found three specification errors
using our tool. Moreover, we check the adaptability of \( \tool \)
via a case study for an incomplete proposal.
\end{abstract}

\keywords{
  JavaScript,
  mechanized formal semantics,
  program synthesis
}

\maketitle

\input{intro}
\input{overview}
\input{parser}
\input{compiler}
\input{impl}
\input{eval}
\input{related}
\input{conclusion}

\normalem
\bibliographystyle{ACM-Reference-Format}
\bibliography{ref}

\end{document}

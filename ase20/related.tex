\section{Related Work}\label{sec:related}
Our technique is closely related to three fields: parser generation,
automatic model generation, and formal semantics of JavaScript.

From Packrat parsing~\cite{packrat} with PEG~\cite{peg}, recursive-descent
parsers with backtracking support linear-time parsing.  However, it
has the fundamental problem of ordered choices: \( ab \) is silently
unmatched with \( a ~/~ ab \).  While Generalized LL (GLL) parsing~\cite{gll}
is basically recursive-descent with backtracking that can support general
context-free grammars (CFGs) even in the presence of ambiguous grammars,
its worst-time complexity is \( O(n^3) \) for the input size \( n \) and it
does not support context-sensitive features.  Unlike GLL parsing, our lookahead
parsing is applicable for JavaScript parsers having context sensitive features
such as positive/negative lookaheads. Moreover, The complexity of lookahead
parsing is \( O(k \cdot n) \) for the input size \( n \) and the constant
number of tokens \( k \). We experimentally showed that it can generate parsers
for the most recent four versions of ECMAScript.

In the field of automatic model generation, the closest related work to
ours is \citet{javadoc}'s, which generates Java code from Javadoc comments
for API functions.  Using NLP techniques and various heuristic methods,
it produces several candidate code tests them with actual implementation
of the API functions to find correct modeling.  Unlike their approach, we
introduce semi-automatic synthesis based on general compile rules that
represent the common writing patterns to support future language updates and to
provide correct meaning of specification.  The extracted semantics via our tool
is also executable that helps to bridge gaps between the specification written
in a natural language and tests.

Several approaches have defined the formal semantics of JavaScript.
\citet{lambdajs} defined a core calculus of JavaScript, and expressed the
rest as desugaring.  While it presents the core JavaScript semantics in
an extension of the $\lambda$ calculus, it does not show the semantics
correspondence defined in ECMAScript.  KJS~\cite{kjs} and
JaVerT~\cite{javert} defined formal semantics of JavaScript by manually converting
ECMAScript to their own formal languages.  KJS mapped
ES5.1 in the K framework~\cite{kframework}, which can be used
for program verification and analysis.  Similarly, JaVerT converts the
specification to their own IR called JSIL to make further analysis.
However, all of them targets only ES5.1 or former versions of ECMAScript and
they do not provide solution for annual updates of ECMAScript. Our approach
provides a mechanized framework to synthesize JavaScript parsers and to
automatically extract semantics using a rule-based compilation technique, which
significantly reduces human efforts.

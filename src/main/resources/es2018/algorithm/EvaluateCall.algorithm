<algorithm>
  <param>func</param>
  <param>ref</param>
  <param>arguments</param>
  <param>tailPosition</param>
  <step-list>
    <step>If Type ( <id>ref</id> ) is Reference , then     <step-list>
      <step>If IsPropertyReference ( <id>ref</id> ) is <value>true</value> , then       <step-list>
        <step>Let <id>thisValue</id> be GetThisValue ( <id>ref</id> ).</step>
      </step-list></step>
      <step>Else the base of <id>ref</id> is an Environment Record ,       <step-list>
        <step>Let <id>refEnv</id> be GetBase ( <id>ref</id> ).</step>
        <step>Let <id>thisValue</id> be <id>refEnv</id> .WithBaseObject().</step>
      </step-list></step>
    </step-list></step>
    <step>Else Type ( <id>ref</id> ) is not Reference ,     <step-list>
      <step>Let <id>thisValue</id> be <value>undefined</value> .</step>
    </step-list></step>
    <step>Let <id>argList</id> be ArgumentListEvaluation of <id>arguments</id> .</step>
    <step>ReturnIfAbrupt ( <id>argList</id> ).</step>
    <step>If Type ( <id>func</id> ) is not Object, throw a <value>TypeError</value> exception.</step>
    <step>If IsCallable ( <id>func</id> ) is <value>false</value> , throw a <value>TypeError</value> exception.</step>
    <step>If <id>tailPosition</id> is <value>true</value> , perform PrepareForTailCall ().</step>
    <step>Let <id>result</id> be Call ( <id>func</id> , <id>thisValue</id> , <id>argList</id> ).</step>
    <step>Assert : If <id>tailPosition</id> is <value>true</value> , the above call will not return here, but instead evaluation will continue as if the following return has already occurred.</step>
    <step>Assert : If <id>result</id> is not an abrupt completion , then Type ( <id>result</id> ) is an ECMAScript language type .</step>
    <step>Return <id>result</id> .</step>
  </step-list>
</algorithm>
\section{$\ires$ Specialization}\label{sec:formal}

We first define $\ires$ with its abstract syntax, states, and concrete
semantics.  Then, we define syntactic views as JavaScript ASTs with abstract
nodes. Finally, we define the specialization of $\ires$ as a transformation to
specialize $\ires$ functions.  To prove the semantics preservation of the
specialization, we introduce an observational semantics of $\ires$ and prove
that each specialized $\ires$ functions has equivalent observational semantics
of the corresponding original one.

\subsection{$\ires$: Intermediate Representations for ECMAScript}

First, we define abstract syntax, states, and concrete semantics of $\ires$.

\subsubsection{Abstract Syntax}

\[
  \begin{array}{lr@{~}c@{~}c@{~}c@{~}l}
    \text{Functions} & \funcset &\ni& \func &::=&
    \kwdef \; x \; \kwrl x^* \kwrr \; \kwcl [\lab: \inst]^* \kwcr\\

    \text{Variables} & \varset &\ni& x\\

    \text{Labels} & \labset &\ni& \lab\\

    \text{Instructions} & \instset &\ni& \inst &::=&
    \refer = \expr \mid
    x = \expr \kwrl \expr^* \kwrr \mid
    \kwif \; \expr \; \lab \; \lab \mid
    \kwret \; \expr\\

    \text{Expressions} & \exprset &\ni& \expr &::=&
    \pval \mid
    \op \kwrl \expr^* \kwrr \mid
    \kwcl \kwcr \mid
    \refer\\

    \text{References} & \referset &\ni& \refer &::=&
    x \mid \refer \kwsl \expr \kwsr\\
  \end{array}
\]

\todo update explanation

A function $\func \in \funcset$ is defined with its name, parameters, and body
instructions with labels $\labset$.  An instruction $\inst \in \instset$ is
a primitive value assignment $x = \pval$,
an operation between values $x = \op \kwrl x^* \kwrr$,
a function call $x = x \kwrl x^* \kwrr$,
a object allocation $x = \kwcl \kwcr$,
a field access $x = x \kwsl x \kwsr$,
a field assignment $x \kwsl x \kwsr = x$,
a conditional branch $\kwif \; x \; \lab \; \lab$,
or a return instruction $\kwret \; x$.


\subsubsection{States}

\[
  \begin{array}{lr@{~}c@{~}l@{~}c@{~}l}
    \text{States} & \st &\in& \stset &=&
    \labset \times \ctxtset^* \times \heapset \times \envset\\

    \text{Calling Contexts} & \ctxt &\in& \ctxtset &=&
    \labset \times \envset \times \varset\\

    \text{Heaps} & \heap &\in& \heapset &=&
    \addrset \finmap \objset\\

    \text{Environments} & \env &\in& \envset &=&
    \varset \finmap \valset\\

    \text{Values} & \val &\in& \valset &=&
    \pvalset \uplus \addrset \uplus \treeset \uplus \funcset\\

    \text{Primive Values} & \pval &\in& \pvalset &=&
    \strset \uplus \cdots\\

    \text{JavaScript ASTs} & \tree &\in& \treeset\\

    \text{Objects} & \obj &\in& \objset &=&
    \strset \finmap \valset\\
  \end{array}
\]

States $\stset$ consist of heaps $\heapset$ and contexts $\ctxtset$.  A heap
$\heap \in \heapset$ is a finite mapping from addresses to objects.  Each object
allocation instruction $x = \kwcl \kwcr$ creates a unique address $\addr \in
\addrset$ different from existing addresses.  A context $\ctxt \in \ctxtset$ is
a triple of a label, a environment, and an optional calling context $\ctxtopt
\in \ctxtoptset = \ctxtset \uplus \{ \bot \}$.  An environment $\env \in
\envset$ is a finite mapping from variables to values. A value $\val \in
\valset$ is a primitive value $\pval \in \pvalset$ (e.g., a string value $\str
\in \strset$), an address $\addr \in \addrset$, a JavaScript AST $\tree \in
\treeset$, or a function $f \in \funcset$.  A object $\obj \in \objset$ is a
finite mappings from strings to values.

\subsubsection{Concrete Semantics of Functions}

\[
  \framebox{$\sem{\func}: \stset \times \valset^* \rightarrow \stset \times
  \valset$}
\]

\todo

\subsubsection{Concrete Semantics of Instructions}

\[
  \framebox{$\sem{\inst}: \stset \rightarrow \stset$}
\]

\todo
% \[
%   \begin{array}{l}
%     \sem{x = \pval}(\heap, (\lab, \env, \ctxtopt)) =\\
%     \qquad (\heap, (\lab, \env[x \mapsto \pval], \ctxtopt)) \\
%     \\
% 
%     \sem{x = \op \kwrl x_1, \cdots, x_n \kwrr}(\heap, (\lab, \env, \ctxtopt)) =\\
%     \qquad (\heap, (\lab, \env[x \mapsto \sem{\op}(x_1, \cdots, x_n)], \ctxtopt)) \\
%     \\
% 
%     \sem{x = x \kwrl x^* \kwrr}(\heap, (\lab, \env, \ctxtopt)) =\\
%     \qquad \todo \\
%     \\
% 
%     \sem{x = \kwcl \kwcr}(\heap, (\lab, \env, \ctxtopt)) =\\
%     \qquad \todo \\
%     \\
% 
%     \sem{x = x \kwsl x \kwsr}(\heap, (\lab, \env, \ctxtopt)) =\\
%     \qquad \todo \\
%     \\
% 
%     \sem{x \kwsl x \kwsr = x}(\heap, (\lab, \env, \ctxtopt)) =\\
%     \qquad \todo \\
%     \\
% 
%     \sem{\kwif \; x \; \lab \; \lab}(\heap, (\lab, \env, \ctxtopt)) =\\
%     \qquad \todo \\
%     \\
% 
%     \sem{\kwret \; x}(\heap, (\lab, \env, \ctxtopt)) =\\
%     \qquad \todo \\
% 
%   \end{array}
% \]

\subsubsection{Concrete Semantics of Expressions}

\[
  \framebox{$\sem{\expr}: \stset \rightarrow \stset \times \valset$}
\]

\todo



\subsubsection{Concrete Semantics of References}

\[
  \framebox{$\sem{\refer}: \stset \rightarrow \stset \times \valset$}
\]

\todo





\subsection{Specialization}

\todo

\subsubsection{Constant Propagation Transformation}

\todo

\subsubsection{Cleanup Transformation}

\todo




\subsection{Observational Semantics}

\todo





\subsection{Proof of Semantics Preservation}

\todo




\section{Syntatic Views}

\todo

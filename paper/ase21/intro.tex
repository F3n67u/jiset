\section{Introduction}\label{sec:intro}

JavaScript is one of the most popular programming languages.  According to the
2020 State of the Octoverse\footnote{https://octoverse.github.com/}, which is
the annual report of GitHub, the most dominated programming language in GitHub
repositories was JavaScript since 2014 to 2020.  While JavaScript was initially
designed for client-side programming in web browsers, now it is widely used in
server-side programming~\cite{nodejs} and even in embedded
systems~\cite{espruino, tessel2, moddable}.  Thus, its engines are also
developed and maintained in diverse fields conforming to ECMAScript, the
JavaScript standard specification that describes the syntax and semantics of
JavaScript.

The correctness of ECMAScript becomes more important because an incorrect
description of syntax or semantics in the specification can lead to the wrong
implementation of existing JavaScript engines used in various fields.  However,
all the specification updates are currently manually checked by the Ecma
Technical Committee 39 (TC39) without any automated tools.  This manual checking
process is obviously labor-intensive and also error-prone thus the current
JavaScript specification is vulnerable to specification bugs.  Besides, in late
2014, the committee announced yearly release cadence and open development
process of ECMAScript to quickly adapt to an evolving development environment.
According to \citet{jiset}, the average number of updated steps of abstract
algorithms between consecutive releases from ECMAScript 2016 (ES7) to 2019
(ES10) is 9645.5.  In the official repository of ECMAScript, \inred{1,355} pull
requests and \inred{2,005} commits exist in the master branch.  Therefore, it
makes more difficult to manually check all the specification updates using
limited human resources.

Unfortunately, there is no existing tool to automatically detect bugs in the
rapidly evolved JavaScript specifications.  Thus, the committee of ECMAScript
have tried to resolve this problem using additional annotations in abstract
algorithms.  Additional annotations make the specification more readable and
also they are useful for the specification-based tools such as JavaScript
engines~\cite{v8, graaljs, qjs, moddable}, debuggers~\cite{jsexplain}, static
analyzers~\cite{safe, tajs, jsai, wala}, and verification tools~\cite{javert,
javert2}.  Thus, they decided to manually insert two different annotations: 1)
\textit{assertions} to denote the assumptions in a certain point of abstract
algorithms, and 2) two different \textit{prefixes} \textbf{?} and \textbf{!} to
represent whether completion records might be abrupt or not.  For example,
``Assert: Type(\textit{O}) is Object'' denotes that the variable $\textit{O}$
always has an \jscode{Object} value at this point and ``\textbf{?}
\textbf{GetV}(\textit{V}, \textit{P})'' denotes that return values of
\textbf{GetV}(\textit{V}, \textit{P}) might be abrupt completions and directly
return them if they are.  Moreover, they recently started the internal
discussion of manual type annotations for variables, parameters, and return
values for each abstract algorithm
\footnote{https://github.com/tc39/ecma262/pull/545\#issuecomment-559292107}.
However, to manually annotate types for all of them without any automated tool
is also labor-intensive and error-prone.  Furthermore, even though such manual
type annotations can give more information for manual checking of specification
updates, it still does not provide any automatic mechanism to detect
specification bugs.

To alleviate this problem, we propose a tool $\tool$, a \textbf{J}avaScript
\textbf{S}pecification \textbf{T}ype \textbf{A}nalyzer using
\textbf{R}efinement.  The main idea of our tool is to perform \textit{type
analysis} for JavaScript specifications to statically detect type-related
specification bugs in an automatic way.  However, it is difficult to directly
perform type analysis to ECMAScript because its abstract algorithms are written
in a natural language.  For a decade, researchers~\cite{lambdajs, jscert, kjs}
have tried to formally define various JavaScript semantics for a specific
version of ECMAScript by hand.  However, the manual formalization is not
suitable for the automatic detection of bugs in the rapidly evolved JavaScript
specifications.  To lessen such burden, several approaches to utilize
information directly extracted from specifications written in a natural language
are recently presented in diverse fields including system
architectures~\cite{x86, arm}, network protocols~\cite{basespec}, and language
specifications~\cite{spectest, javadoc}.  For JavaScript, \citet{jiset} presents
$\jiset$ that automatically compiles each abstract algorithm written in a
structured natural language to the corresponding function of $\ires$, an untyped
intermediate representation for ECMAScript.  Therefore, we utilize this tool to
mechanically handle JavaScript specifications.

For the compiled mechanized specifications, $\tool$ performs type analysis for
compiled functions with specification types defined in ECMAScript.  ECMAScript
contains not only JavaScript language types but also specification types such as
abstract syntax trees (ASTs), internal records (e.g. environments, completions,
or property descriptors), and internal list-like structures.  We define their
type hierarchy and fields based on type-related tables in ECMAScript and
automatically extracted syntax-directed algorithms.  Based on such type
information, $\tool$ performs type analysis and detects specification bugs using
a \textit{bug detector} consisting of four different checkers: 1) reference
checker, 2) arity checker, 3) assertion checker, and 4) operand checker.
Moreover, to increase precision of type analysis, we also present a
\textit{condition-based refinement} for type analysis on ECMAScript. Its main
concept is to prune out infeasible parts in abstract states by using conditions
of assertions and branches.  The refinement technique can reduce the number of
false bugs caused by spurious types inferred by imprecise analysis.  We evaluate
our tool with all \inred{864} different versions existed in the official
ECMAScript repository for the recent three years from 2018 to 2021.

In summary, our main contributions are as follows:
\begin{itemize}
  \item We present $\tool$, which is the first tool that performs \textit{type
    analysis} on ECMAScript to check the correctness of JavaScript language
    specifications.  $\tool$ automatically detects type-related specification
    bugs via the \textit{bug detector} consisting of four different checkers: 1)
    reference checker, 2) arity checker, 3) assertion checker, and 4) operand
    checker.
  \item We present a \textit{condition-based refinement} for type analysis of
    ECMAScript to reduce the number of false bugs by increasing the analysis
    precision.  We show that the refinement technique increase the analysis
    precision from \inred{30.4}\% to \inred{52.0}\% by removing \inred{122}
    false bugs and detecting \inred{one} more true bug.
  \item We demonstrate the practicality of $\tool$. It takes \inred{136.1}
    seconds on average to perform type analysis for each version, and detected
    \inred{177} type-related specification bugs with \inred{52.0}\% precision;
    \inred{92} out of \inred{177} bugs are true bugs.  Among them, \inred{14}
    bugs are newly detected by $\tool$ and the committee confirmed all of them.
\end{itemize}

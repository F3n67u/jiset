package kr.ac.kaist.ase.model

import kr.ac.kaist.ase.algorithm
import algorithm.{ AlgoKind, Algorithm, Token, StaticSemantics, Method, Grammar, Text }
import kr.ac.kaist.ase.core.Parser._
import kr.ac.kaist.ase.core._
import kr.ac.kaist.ase.LINE_SEP
import scala.util.{ Try, Success, Failure }

import kr.ac.kaist.ase.error.UnexpectedShift
import kr.ac.kaist.ase.parser.TokenParsers
import kr.ac.kaist.ase.util.Useful._

case class AlgoCompiler(algoName: String, algo: Algorithm) extends AlgoCompilerHelper {
  val kind = algo.kind
  lazy val result: (Func, Map[Int, List[Token]]) = {
    val (params, varparam) = handleParams(algo.params)
    val func = Func(
      name = algoName,
      params = params,
      varparam = varparam,
      body = normalizeTempIds(flatten(ISeq(parseAll(stmts, algo.toTokenList) match {
        case Success(res, _) => res
        case NoSuccess(_, reader) => error(s"[AlgoCompilerFailed]:${algo.filename}:" + LINE_SEP + reader.toString)
      })))
    )
    (func, failed)
  }
}

trait AlgoCompilerHelper extends TokenParsers {
  val algoName: String
  val kind: AlgoKind

  // empty instruction
  lazy val emptyInst: Inst = ISeq(Nil)

  // result type
  type Result = Inst

  // list of statements
  lazy val stmts: P[List[Inst]] = rep(stmt <~ next)

  lazy val starStmt: P[Inst] = star ^^ {
    case s => IExpr(ENotYetImpl(s"stmt: $s"))
  }

  lazy val starExpr: P[List[Inst] ~ Expr] = star ^^ {
    case s => pair(Nil, ENotYetImpl(s"expr: $s"))
  }

  lazy val starCond: P[List[Inst] ~ Expr] = star ^^ {
    case s => pair(Nil, ENotYetImpl(s"cond: $s"))
  }

  type P[A] = PackratParser[A]
  type Q[A] = P[List[Inst] ~ A]

  ////////////////////////////////////////////////////////////////////////////////
  // Instructions
  ////////////////////////////////////////////////////////////////////////////////
  lazy val stmt: P[Inst] = {
    etcStmt | (
      innerStmt |||
      letStmt |||
      returnStmt |||
      ifStmt |||
      setStmt |||
      performStmt |||
      noteStmt |||
      assertStmt |||
      forEachStmt |||
      repeatStmt |||
      throwStmt |||
      appendStmt
    )
  } <~ opt(".") ~ opt(comment) ~ guard(next) | failedStep ^^ { tokens =>
    IExpr(ENotYetImpl(tokens.mkString(" ").replace("\\", "\\\\").replace("\"", "\\\"")))
  }
  lazy val comment: P[String] = (
    "See" ~ rest |
    "This call will always return" ~ value ~ "."
  ) ^^^ ""

  // etc statements
  lazy val etcStmt: P[Inst] = (
    (in ~ "If IsStringPrefix(" ~> id <~ ",") ~ id <~ rep(rest ~ next) ~ out ^^ {
      case x ~ y => IReturn(EBOp(OLt, toERef(y), toERef(x)))
    } ||| ("If the mathematical value of" ~> id <~ "is less than the mathematical value of") ~ id <~ rest ^^ {
      case x ~ y => IReturn(EBOp(OLt, toERef(x), toERef(y)))
    } ||| ("Let" ~> id <~ "be") ~ expr ~ ("; if" ~> cond <~ ", use the numeric value zero") ^^ {
      case x ~ (i0 ~ e) ~ (i1 ~ c) =>
        ISeq(i1 :+ IIf(c, ILet(Id(x), EINum(0)), ISeq(i0 :+ ILet(Id(x), e))))
    } ||| "create an own data property" ~ rest ^^^ {
      parseInst(s"""{
        dp = (new DataProperty())
        if (! (= absent Desc.Value)) dp.Value = Desc.Value else dp.Value = undefined
        if (! (= absent Desc.Writable)) dp.Writable = Desc.Writable else dp.Writable = false
        if (! (= absent Desc.Enumerable)) dp.Enumerable = Desc.Enumerable else dp.Enumerable = false
        if (! (= absent Desc.Configurable)) dp.Configurable = Desc.Configurable else dp.Configurable = false
        O.SubMap[P] = dp
      }""")
    } ||| "create an own accessor property" ~ rest ^^^ {
      parseInst(s"""{
        dp = (new AccessorProperty())
        if (! (= absent Desc.Get)) dp.Get = Desc.Get else dp.Get = undefined
        if (! (= absent Desc.Set)) dp.Set = Desc.Set else dp.Set = undefined
        if (! (= absent Desc.Enumerable)) dp.Enumerable = Desc.Enumerable else dp.Enumerable = false
        if (! (= absent Desc.Configurable)) dp.Configurable = Desc.Configurable else dp.Configurable = false
        O.SubMap[P] = dp
      }""")
    } ||| "Push" ~> expr <~ "onto the execution context stack" ~ rest ^^ {
      case i ~ e => ISeq(i ++ List(
        IAppend(e, ERef(RefId(Id(executionStack)))),
        parseInst(s"""$context = $executionStack[(- $executionStack.length 1i)]""")
      ))
    } ||| "If the host requires use of an exotic object" ~ rest ^^^ {
      parseInst("let global = undefined")
    } ||| "If the host requires that the" ~ rest ^^^ {
      parseInst("let thisValue = undefined")
    } ||| "For each property of the Global Object" ~ rest ^^^ {
      val temp = getTemp
      forEachMap(Id("name"), parseExpr("GLOBAL"), parseInst(s"""{
        let desc = GLOBAL[name]
        app $temp = (DefinePropertyOrThrow global name desc)
        if (= (typeof $temp) "Completion") {
          if (= $temp.Type CONST_normal) $temp = $temp.Value
          else return $temp
        } else {}
      }"""))
    } ||| "In an implementation-dependent manner, obtain the ECMAScript source texts" ~ rest ^^^ {
      val temp = getTemp
      parseInst(s"""app $temp = (EnqueueJob "ScriptJobs" ScriptEvaluationJob (new [script, hostDefined]))""")
    } ||| "Add" ~> id <~ "at the back of the Job Queue named by" ~ id ^^ {
      case x => IAppend(toERef(x), toERef(jobQueue))
    } ||| {
      "Suspend" ~> expr <~ "and remove it from the execution context stack" |
        "Pop" ~> expr <~ "from the execution context stack" <~ rest
    } ^^ {
      case i ~ e =>
        val idx = getTemp
        ISeq(i :+ parseInst(s"""{
          $context = null
          if (= $executionStack[(- $executionStack.length 1i)] ${beautify(e)}) {
            $idx = (- $executionStack.length 1i)
            (pop $executionStack $idx)
          } else {}
        }"""))
    } ||| "Parse" ~ id ~ "using" ~ nt.filter(_ == "Script") ~ "as the goal symbol" ~ rest ^^^ {
      parseInst(s"""let body = script""")
    } ||| "Suspend the currently running execution context" ^^^ {
      parseInst(s"""$context = null""")
    }
  ) | ignoreStmt
  lazy val ignoreStmt: P[Inst] = (
    "Perform any implementation or host environment defined processing of" |
    "Perform any implementation or host environment defined job initialization using" |
    "Set" ~ id ~ "'s essential internal methods to the default ordinary object definitions specified in 9.1" |
    "Need to defer setting the [[Writable]] attribute to" ~ value ~ "in case any elements cannot be deleted" |
    "Set fields of" ~> id <~ "with the values listed in Table 7 that have not already been handled above" |
    "Create any implementation-defined global object properties" |
    "If" ~ id ~ "is a List of errors,"
  ) ~ rest ^^^ emptyInst

  // inner statements
  lazy val innerStmt: P[Inst] = in ~> stmts <~ out ^^ { ISeq(_) }

  // lexical binding declarations
  lazy val letStmt: P[Inst] =
    (("let" | "Let") ~> id <~ "be") ~ expr ^^ { case x ~ (i ~ e) => ISeq(i :+ ILet(Id(x), e)) }

  // return statements
  lazy val returnStmt: P[Inst] = (
    ("return" | "Return") ~> expr ^^ {
      case i ~ e => ISeq(i :+ (kind match {
        case StaticSemantics => IReturn(e)
        case _ =>
          val temp = getTempId
          ISeq(List(
            IApp(temp, toERef("WrapCompletion"), List(e)),
            IReturn(toERef(temp))
          ))
      }))
    } ||| ("return" | "Return") ^^^ {
      val i ~ e = getCall(toRef("WrapCompletion"), List(pair(Nil, EUndef)))
      ISeq(i :+ IReturn(e))
    }
  )

  // if-then-else statements
  lazy val ifStmt = ("If" | "if") ~> (
    ((id | nt) <~ "is") ~ grammar ~ ("," ~ opt("then") ~> stmt) ^^ {
      case x ~ Grammar(y, ss) ~ s =>
        val pre = ss.map(s => parseInst(s"""access $s = ($x "$s")"""))
        IIf(EIsInstanceOf(toERef(x), y), ISeq(pre :+ s), emptyInst)
    } ||| {
      (cond <~ "," ~ opt("then")) ~ stmt ~
        opt(opt("." | ";" | ",") ~ opt(next) ~
          ("else" | "Else" | "otherwise" | "Otherwise") ~ opt(",") ~> stmt)
    } ^^ {
      case (i ~ c) ~ t ~ Some(e) => ISeq(i :+ IIf(c, t, e))
      case (i ~ c) ~ t ~ None => ISeq(i :+ IIf(c, t, emptyInst))
    }
  )

  // set statements
  lazy val setStmt: P[Inst] = (
    (("Set" | "set") ~> setRef) ~ ("to" ~> expr) ^^ {
      case (i0 ~ r) ~ (i1 ~ e) => ISeq(i0 ++ i1 :+ IAssign(r, e))
    } ||| ("Set" ~> setRef <~ "as" ~ ("specified" | "described") ~ "in") ~ secno ^^ {
      case (i ~ r) ~ s => ISeq(i :+ IAssign(r, toERef(s)))
    }
  )
  lazy val setRef: Q[Ref] =
    ref ||| opt("the") ~> (fieldName <~ "of") ~ refBase ^^ { case f ~ b => pair(Nil, toRef(b, f)) }

  // perform statements
  lazy val performStmt: P[Inst] = (
    ("Perform" | "perform" | "Call" | "call") ~> expr |||
    returnIfAbruptExpr
  ) ^^ { case i ~ e => ISeq(i :+ IExpr(e)) }

  // note statements
  lazy val noteStmt: P[Inst] = "NOTE:" ~ rest ^^^ emptyInst

  // assertion statements
  lazy val assertStmt: P[Inst] = "Assert:" ~ rest ^^^ emptyInst

  // for-each statements
  lazy val forEachStmt: P[Inst] = (
    {
      ("For each" ~ opt(nt | "String" | "element" | "Parse Node") ~> id) ~
        (("in order from" | "in" | "of" | "from") ~> expr) ~
        (opt(",") ~ opt("in" ~ ("list" | "List") ~ "order,") ~ "do" ~> stmt)
    } ^^ {
      case x ~ (i ~ e) ~ b => ISeq(i :+ forEachList(Id(x), e, b))
    } | ("For each" ~> id) ~ ("in" ~> expr <~ ", in reverse list order , do") ~ stmt ^^ {
      case x ~ (i ~ e) ~ b => ISeq(i :+ forEachList(Id(x), e, b, true))
    } | ("For each" ~ opt("Record { [[ Key ]], [[ Value ]] }") ~> id <~ "that is an element of") ~ (expr <~ ", do") ~ stmt ^^ {
      case x ~ (i ~ e) ~ b => ISeq(i :+ forEachList(Id(x), e, b))
    }
  )

  // repeat statements
  lazy val repeatStmt: P[Inst] = (
    ("Repeat, while" ~> cond <~ opt(",")) ~ stmt ^^ {
      case (i ~ c) ~ s => ISeq(i :+ IWhile(c, s))
    } | "Repeat," ~> stmt ^^ {
      case s => IWhile(EBool(true), s)
    }
  )

  // throw statements
  lazy val throwStmt: P[Inst] = ("Throw" | "throw") ~> (
    "a" ~> valueValue <~ "exception" ^^ {
      case e =>
        val temp = getTempId
        ISeq(List(IApp(temp, toERef("ThrowCompletion"), List(e)), IReturn(toERef(temp))))
    }
  )

  // append statements
  lazy val appendStmt: P[Inst] = "Append" ~> {
    (expr <~ {
      "to" ~ opt("the end of") |||
        "as" ~ ("an" | "the last") ~ "element of" ~ opt("the List" ~ opt("that is"))
    }) ~ expr ^^ {
      case (i0 ~ x) ~ (i1 ~ l) => ISeq(i0 ++ i1 :+ IAppend(x, l))
    } ||| ("to" ~> expr <~ opt("the elements of")) ~ expr ^^ {
      case (i0 ~ l1) ~ (i1 ~ l2) =>
        val tempId = getTempId
        ISeq(i0 ++ i1 :+ forEachList(tempId, l2, IAppend(toERef(tempId), l1)))
    } ||| ("each item in" ~> expr <~ "to the end of") ~ expr ^^ {
      case (i0 ~ l1) ~ (i1 ~ l2) =>
        val temp = getTempId
        ISeq(i0 ++ i1 :+ forEachList(temp, l1, IAppend(toERef(temp), l2)))
    }
  } | "Add" ~> {
    (expr <~ "as" ~ ("an element of the list" | "the last element of")) ~ expr ^^ {
      case (i0 ~ x) ~ (i1 ~ r) => ISeq(i0 ++ i1 :+ IAppend(x, r))
    }
  }

  ////////////////////////////////////////////////////////////////////////////////
  // Expressions
  ////////////////////////////////////////////////////////////////////////////////
  lazy val expr: Q[Expr] = opt("the") ~> {
    etcExpr | (
      returnIfAbruptExpr |||
      refExpr |||
      valueExpr |||
      callExpr |||
      listExpr |||
      accessExpr |||
      newExpr |||
      arithExpr |||
      copyExpr |||
      coveredByExpr |||
      concatExpr |||
      syntaxExpr
    )
  }

  // etc expressions
  lazy val etcExpr: Q[Expr] = (
    ("result of applying the addition operation to" ~> id <~ "and") ~ id ^^ {
      case l ~ r => pair(Nil, EBOp(OPlus, toERef(l), toERef(r)))
    } ||| ("result of applying the subtraction operation to" ~> id <~ "and") ~ id ^^ {
      case l ~ r => pair(Nil, EBOp(OSub, toERef(l), toERef(r)))
    } ||| ("result of Applying the ** operator with" ~> id <~ "and") ~ id <~ "as specified in 12.6.4" ^^ {
      case l ~ r => pair(Nil, EBOp(OPow, toERef(l), toERef(r)))
    } ||| "result of negating" ~> id <~ "; that is , compute a Number with the same magnitude but opposite sign" ^^ {
      case x => pair(Nil, EUOp(ONeg, toERef(x)))
    } ||| code.filter(_ == "@") ~ "where" ~> nt <~ "is" ~ code.filter(_ == "@=") ^^ {
      case x =>
        val syn = getTempId
        pair(List(
          ILet(syn, EGetSyntax(toERef(x))),
          IAssign(toRef(syn), EBOp(OSub, toERef(syn), EINum(1)))
        ), toERef(syn))
    } ||| ("result of applying" ~> id <~ "to") ~ (id <~ "and") ~ (id <~ "as if evaluating the expression" ~ id ~ id ~ id) ^^ {
      case op ~ l ~ r =>
        val res = getTempId
        val opERef = toERef(op)
        val list = List(
          ("*", OPlus, "ToNumber", "ToNumber"),
          ("/", ODiv, "ToNumber", "ToNumber"),
          ("%", OMod, "ToNumber", "ToNumber"),
          ("-", OSub, "ToNumber", "ToNumber"),
          ("<<", OLShift, "ToInt32", "ToUint32"),
          (">>", OSRShift, "ToInt32", "ToUint32"),
          (">>>", OURShift, "ToUint32", "ToUint32"),
          ("&", OBAnd, "ToInt32", "ToInt32"),
          ("^", OBXOr, "ToInt32", "ToInt32"),
          ("|", OBOr, "ToInt32", "ToInt32"),
          ("**", OPow, "ToNumber", "ToNumber")
        )
        def getMap(x: Expr, names: List[String]): Map[String, List[Inst] ~ Expr] =
          (Map[String, List[Inst] ~ Expr]() /: names) {
            case (m, name) =>
              val temp = getTempId
              m + (name -> returnIfAbrupt(List(IApp(temp, toERef(name), List(x))), toERef(temp)))
          }
        val names = List("ToNumber", "ToInt32", "ToUint32", "ToPrimitive")
        val lmap = getMap(toERef(l), names)
        val rmap = getMap(toERef(r), names)
        val init: Inst = IExpr(ENotSupported("assign operator"))
        val genenralCase = (init /: list) {
          case (base, (name, op, left, right)) =>
            val li ~ le = lmap(left)
            var ri ~ re = rmap(right)
            IIf(
              EBOp(OEq, opERef, EStr(name)),
              ISeq(li ++ ri :+ IAssign(toRef(res), EBOp(op, le, re))),
              base
            )
        }
        val lprimI ~ lprim = lmap("ToPrimitive")
        val rprimI ~ rprim = rmap("ToPrimitive")
        val lpstrI ~ lpstr = getMap(lprim, List("ToString"))("ToString")
        val lpnumI ~ lpnum = getMap(lprim, List("ToNumber"))("ToNumber")
        var rpstrI ~ rpstr = getMap(rprim, List("ToString"))("ToString")
        var rpnumI ~ rpnum = getMap(rprim, List("ToNumber"))("ToNumber")
        val (ltemp, rtemp) = (getTempId, getTempId)
        val str = EStr("String")
        pair(List(IIf(EBOp(OEq, opERef, EStr("+")), ISeq(lprimI ++ rprimI ++ List(
          IApp(ltemp, toERef("Type"), List(lprim)),
          IApp(rtemp, toERef("Type"), List(rprim)),
          IIf(
            EBOp(OOr, EBOp(OEq, toERef(ltemp), str), EBOp(OEq, toERef(rtemp), str)),
            ISeq(lpstrI ++ rpstrI :+ IAssign(toRef(res), EBOp(OPlus, lpstr, rpstr))),
            ISeq(lpnumI ++ rpnumI :+ IAssign(toRef(res), EBOp(OPlus, lpnum, rpnum)))
          )
        )), genenralCase)), toERef(res))
    } ||| "an empty sequence of algorithm steps" ^^^ {
      pair(Nil, EFunc(Nil, None, emptyInst))
    } ||| "algorithm steps specified in 9.2.9.1 for the" ~> intrinsicName <~ "function" ^^ {
      case x => pair(Nil, toERef(x))
    } ||| "a new built-in function object that when called performs the action described by" ~> id <~ "." ~ rest ^^ {
      case y => pair(Nil, EMap(Ty("BuiltinFunctionObject"), List(
        EStr("SubMap") -> EMap(Ty("SubMap"), Nil),
        EStr("Code") -> toERef(y)
      )))
    } ||| "a non-empty Job Queue chosen in an implementation-defined manner" ~ rest ^^^ {
      val checkInst = parseInst(s"""if (= $jobQueue.length 0) {
        return (new Completion( "Type" -> CONST_normal, "Value" -> undefined, "Target" -> CONST_empty))
      } else {}""")
      pair(List(checkInst), ERef(RefId(Id(jobQueue))))
    } ||| "PendingJob record at the front of" ~> id <~ rest ^^ {
      case x => pair(Nil, parseExpr(s"""(pop $x 0i)"""))
    } ||| ("result of performing the abstract operation named by" ~> expr) ~ ("using the elements of" ~> expr <~ "as its arguments.") ^^ {
      case (i0 ~ e0) ~ (i1 ~ e1) => {
        val tempP = getTemp
        val applyInst = parseInst(s"""app $tempP = (${beautify(e0)} ${beautify(e1)}[0i] ${beautify(e1)}[1i] ${beautify(e1)}[2i])""")
        pair(List(applyInst), ERef(RefId(Id(tempP))))
      }
    }
  )

  // return if abrupt
  lazy val returnIfAbruptExpr: Q[Expr] = (
    ("?" ~> expr ||| "ReturnIfAbrupt(" ~> expr <~ ")") ^^ {
      case i ~ e => returnIfAbrupt(i, e, true)
    } ||| "!" ~> expr ^^ {
      case i ~ e => returnIfAbrupt(i, e, false)
    }
  )

  // reference expressions
  lazy val refExpr: Q[Expr] = (
    ref ^^ { case i ~ r => pair(i, ERef(r)) }
  )

  // value expressions
  lazy val valueExpr: Q[Expr] = valueParser ^^ { pair(Nil, _) }

  // call expressions
  lazy val callExpr: Q[Expr] = (
    (word ||| "ForIn/OfHeadEvaluation" ^^^ "ForInOfHeadEvaluation" ||| "ForIn/OfBodyEvaluation" ^^^ "ForInOfBodyEvaluation") ~ ("(" ~> repsep(expr, ",") <~ ")") ^^ {
      case x ~ list => getCall(toRef(x), list)
    } ||| id ~ staticField ~ ("(" ~> repsep(expr, ",") <~ ")") ^^ {
      case x ~ y ~ list => getCall(toRef(x, y), list)
    } ||| {
      "result of" ~ ("performing" ~ word ~ word ~ "Comparison" ||| "the comparison") ~>
        expr ~ compOp ~ expr ~ opt("with" ~ id ~ "equal to" ~> expr)
    } ^^ {
      case l ~ f ~ r ~ opt => getCall(toRef(f), opt match {
        case None => List(l, r)
        case Some(p) => List(l, r, p)
      })
    }
  )
  lazy val compOp: P[String] = (
    "==" ^^^ "AbstractEqualityComparison" |||
    "===" ^^^ "StrictEqualityComparison" |||
    "<" ^^^ "AbstractRelationalComparison"
  )

  // list expressions
  lazy val argsName = "argumentsList"
  lazy val argsExpr = toERef(argsName)
  lazy val listExpr: Q[Expr] = (
    "«" ~> repsep(expr, ",") <~ "»" ^^ {
      case list =>
        val i = list.map { case i ~ _ => i }.flatten
        pair(i, EList(list.map { case _ ~ e => e }))
    } ||| "a" ~ opt("new") ~ "List containing" ~ opt("single element,") ~> expr ^^ {
      case i ~ e => pair(i, EList(List(e)))
    } ||| ("sole element of" | "string that is the only element of") ~> expr ^^ {
      case i ~ e =>
        val temp = getTempId
        pair(i :+ ILet(temp, e), toERef(temp, EINum(0)))
    } ||| "number of" ~ ("elements" | "code units") ~ "in" ~> id ^^ {
      case x => pair(Nil, toERef(x, "length"))
    } ||| "a List" ~ ("whose sole item is" | "containing only" | "containing the one element which is" | "containing the single element,") ~> expr ^^ {
      case i ~ e => pair(i, EList(List(e)))
    } ||| {
      "a List" ~ ("containing" | "whose elements are") ~ "the arguments passed to this function" |||
        "a List whose elements are , in left to right order , the arguments that were passed to this function invocation" |||
        "List of arguments passed to this function"
    } ^^^ pair(Nil, argsExpr) ||| {
      opt("actual") ~ "number of arguments passed to this function" ~ opt("call") |||
        "number of actual arguments"
    } ^^^ pair(Nil, toERef(argsName, "length")) ||| "arguments object" ^^^ {
      pair(Nil, toERef("args"))
    } ||| "a List whose elements are , in left to right order , the portion of the actual argument list starting with the third argument ." ~ rest ^^^ {
      pair(List(
        IExpr(EPop(argsExpr, EINum(0))),
        IExpr(EPop(argsExpr, EINum(0)))
      ), toERef(argsName))
    } ||| "a new empty List" ^^^ pair(Nil, EList(Nil))
  )

  // access expressions
  lazy val accessExpr: Q[Expr] = (
    "result of evaluating" ~> accessBase ^^ {
      case x => getAccess(x, "Evaluation")
    } ||| ((word | nt) <~ "of") ~ accessBase ^^ {
      case y ~ x => getAccess(x, y)
    } ||| {
      (opt("result of" ~ opt("performing")) ~> word <~ ("of" | "for")) ~
        (accessBase <~ ("with" | "using" | "passing")) ~
        (
          ("arguments" | "argument") ~> repsep(expr, sep("and")) |||
          repsep(expr, sep("and")) <~ "as" ~ opt("the") ~ ("arguments" | "argument")
        )
    } ^^ {
      case f ~ x ~ list => getAccess(x, f, list)
    } ||| (opt("result of") ~> (nt | id) <~ "Contains") ~ nt ^^ {
      case x ~ y => getAccess(x, "Contains", List(pair(Nil, EStr(y))))
    } ||| (opt("result of") ~> (nt | id) <~ "Contains") ~ id ^^ {
      case x ~ y => getAccess(x, "Contains", List(pair(Nil, toERef(y))))
    }
  )
  val accessBase: P[String] = id ||| ntWithOrdinal

  // new expressions
  lazy val newExpr: Q[Expr] = (
    ("a new" | "a newly created") ~> ty <~ opt(("containing" | "that" | "with") ~ rest) ^^ {
      case t => pair(Nil, EMap(Ty(t), List(
        EStr("SubMap") -> EMap(Ty("SubMap"), Nil) // TODO internal slots
      )))
    } ||| "a newly created" ~> valueValue <~ "object" ^^ {
      case e => pair(Nil, e)
    } ||| "a new object Environment Record containing" ~> expr <~ "as the binding object" ^^ {
      case p => p
    } ||| ty ~ ("{" ~> repsep(("[[" ~> word <~ "]]:") ~ expr, ",") <~ "}") ^^ {
      case t ~ list =>
        val i = list.map { case _ ~ (i ~ _) => i }.flatten
        pair(i, EMap(Ty(t), list.map { case x ~ (_ ~ e) => (EStr(x), e) }))
    }
  )
  lazy val ty: P[String] = (
    "Array exotic object" ^^^ "ArrayExoticObject" |||
    "Chosen Value Record" ^^^ "ChosenValueRecord" |||
    "ECMAScript function object" ^^^ "ECMAScriptFunctionObject" |||
    "Lexical Environment" ^^^ "LexicalEnvironment" |||
    "Property Descriptor" ^^^ "PropertyDescriptor" |||
    "Proxy exotic object" ^^^ "ProxyExoticObject" |||
    "Realm Record" ^^^ "RealmRecord" |||
    "Script Record" ^^^ "ScriptRecord" |||
    "String exotic object" ^^^ "StringExoticObject" |||
    "arguments exotic object" ^^^ "ArgumentsExoticObject" |||
    "bound function exotic object" ^^^ "BoundFunctionExoticObject" |||
    "declarative Environment Record" ^^^ "DeclarativeEnvironmentRecord" |||
    "function Environment Record" ^^^ "FunctionEnvironmentRecord" |||
    "global Environment Record" ^^^ "GlobalEnvironmentRecord" |||
    "module Environment Record" ^^^ "ModuleEnvironmentRecord" |||
    "module namespace exotic object" ^^^ "ModuleNamespaceExoticObject" |||
    "object Environment Record" ^^^ "ObjectEnvironmentRecord" |||
    "object" ^^^ "OrdinaryObject" |||
    opt("ECMAScript code") ~ "execution context" ^^^ "ExecutionContext"
  ) | word

  // arithmetic expressions
  lazy val arithExpr: Q[Expr] = (
    ("(" ~> expr ~ bop ~ expr <~ ")" ||| expr ~ bop ~ expr) ^^ {
      case (i0 ~ l) ~ b ~ (i1 ~ r) => pair(i0 ++ i1, EBOp(b, l, r))
    } ||| uop ~ expr ^^ {
      case u ~ (i ~ e) => pair(i, EUOp(u, e))
    }
  )
  lazy val bop: Parser[BOp] = (
    "×" ^^^ OMul |
    "/" ^^^ ODiv |
    "+" ^^^ OPlus |
    ("-" | "minus") ^^^ OSub |
    "modulo" ^^^ OMod |
    "&" ^^^ OBAnd |
    "^" ^^^ OBXOr |
    "|" ^^^ OBOr
  )
  lazy val uop: Parser[UOp] = (
    "-" ^^^ ONeg
  )

  // copy expressions
  lazy val copyExpr: Q[Expr] = (
    opt("a new List which is") ~ "a copy of" ~ opt("the List") ~> expr ~ opt("with" ~> expr <~ "appended") ^^ {
      case (i ~ e) ~ None => pair(i, ECopy(e))
      case (i0 ~ e) ~ Some(i1 ~ y) =>
        val newList = getTempId
        pair(i0 ++ i1 :+ ISeq(List(
          ILet(newList, ECopy(e)),
          IAppend(y, toERef(newList))
        )), toERef(newList))
    }
  )

  // covered-by expressions
  lazy val coveredByExpr: Q[Expr] = (nt <~ "that is covered by") ~ expr ^^ {
    case r ~ (i ~ e) => pair(i, EParseSyntax(e, EStr(r), Nil))
  }

  // concatenation expressions
  lazy val concatExpr: Q[Expr] = (
    "string-concatenation of" ~> rep1sep(expr, sep("and")) ^^ {
      case es => es.reduce[List[Inst] ~ Expr] {
        case (i0 ~ l, i1 ~ r) => pair(i0 ++ i1, EBOp(OPlus, l, r))
      }
    }
  )

  // syntax expressions
  lazy val syntaxExpr: Q[Expr] = "source text matched by this" ^^^ {
    pair(Nil, EGetSyntax(toERef("this")))
  }

  ////////////////////////////////////////////////////////////////////////////////
  // values
  ////////////////////////////////////////////////////////////////////////////////
  // value expressions
  lazy val valueParser: P[Expr] = opt("the") ~> (
    valueValue |||
    codeValue |||
    constValue |||
    numberValue |||
    stringValue |||
    expValue |||
    codeUnitValue |||
    absentValue |||
    thisValue
  )

  // values with tag `value`
  lazy val valueValue: P[Expr] = value ^^ {
    case "undefined" => EUndef
    case "NaN" => ENum(Double.NaN)
    case "null" => ENull
    case "+0" => EINum(0L)
    case "-0" => ENum(-0.0)
    case "true" => EBool(true)
    case "false" => EBool(false)
    case "+∞" => ENum(Double.PositiveInfinity)
    case "-∞" => ENum(Double.NegativeInfinity)
    case err if err.endsWith("Error") => EMap(Ty("OrdinaryObject"), List(
      EStr("Prototype") -> toERef(s"INTRINSIC_${err}Prototype"),
      EStr("ErrorData") -> EUndef,
      EStr("SubMap") -> EMap(Ty("SubMap"), Nil)
    ))
    case s => ENotYetImpl(s)
  }

  // values with tag `code`
  lazy val codeValue: P[Expr] = opt(nt) ~> code ^^ {
    case s if s.startsWith("\"") && s.endsWith("\"") => EStr(s.slice(1, s.length - 1))
    // case s if Try(s.toDouble).isSuccess => ENum(s.toDouble)
    case s @ ("super" | "this") => EStr(s)
    case s => ENotYetImpl(s)
  }

  // values with tag `const`
  lazy val constValue: P[Expr] = const ^^ {
    case "[empty]" => EAbsent
    case const => toERef("CONST_" + const.replaceAll("-", ""))
  }

  // number values
  lazy val numberValue: P[Expr] = (
    (number <~ ".") ~ number ^^ {
      case x ~ y => ENum(s"$x.$y".toDouble)
    } ||| number ^^ {
      case s => EINum(java.lang.Long.decode(s))
    }
  )

  // string values
  lazy val stringValue: P[Expr] = (
    "empty String" ^^^ "" |||
    "grammar symbol" ~> nt |||
    opt("hint") ~> ("Number" | "Undefined" | "Null" | "String" | "Boolean" | "Symbol" | "Reference" | "Object") ^^ { _.head } |||
    "[[" ~> word <~ "]]"
  ) ^^ { EStr(_) }

  // exponential values
  lazy val expValue: P[Expr] = (
    number ~ sup.filter(ts => parseAll(number, ts).successful) ^^ {
      case x ~ List(y: Text) =>
        val a = x.toInt
        val b = y.getContent.toInt
        EINum(math.pow(a, b).longValue)
    }
  )

  // code unit values
  lazy val codeUnitValue: P[Expr] = (
    "code unit" ~> text <~ "(" ~ rep(word.filter(_ != ")")) ~ ")" ^^ {
      case s => EStr(Integer.parseInt(s.substring(2), 16).toChar.toString)
    }
  )

  // absent value
  lazy val absentValue: P[Expr] = "absent" ^^^ EAbsent

  // this value
  lazy val thisValue: P[Expr] = (
    word ~ "Environment Record for which the method was invoked" |||
    value.filter(x => x == "this") ~ "value" |||
    "this this" |||
    "this" ~ opt(nt)
  ) ^^^ { toERef("this") }

  ////////////////////////////////////////////////////////////////////////////////
  // Conditions
  ////////////////////////////////////////////////////////////////////////////////
  lazy val cond: Q[Expr] = (
    expr ~ condBOp ~ expr ^^ {
      case (i0 ~ x) ~ ((b, n, r)) ~ (i1 ~ y) => pair(i0 ++ i1, calc(n, r, b, x, y))
    } ||| {
      (expr <~ ("is" ~ opt("present and its value is") | "has the value") ~ opt("either")) ~
        rep1sep(opt("has the value") ~> rhs, sep("or"))
    } ^^ {
      case (i ~ l) ~ rs => pair(i, rs.map(EBOp(OEq, l, _)).reduce(EBOp(OOr, _, _)))
    } ||| {
      (expr <~ "is" ~ ("not" ~ opt("one of") | "neither")) ~
        rep1sep(rhs, sep("nor" | "or"))
    } ^^ {
      case (i ~ l) ~ rs =>
        pair(i, rs.map(r => EUOp(ONot, EBOp(OEq, l, r))).reduce[Expr](EBOp(OAnd, _, _)))
    } ||| (expr <~ "is the same" ~ opt("Parse Node" | opt("Number") ~ "value") ~ "as") ~ expr ^^ {
      case (i0 ~ x) ~ (i1 ~ y) => pair(i0 ++ i1, EBOp(OEq, x, y))
    } ||| expr <~ "is present" ^^ {
      case (i ~ x) => pair(i, EUOp(ONot, EBOp(OEq, x, EAbsent)))
    } ||| expr <~ "is not present" ^^ {
      case (i ~ x) => pair(i, EBOp(OEq, x, EAbsent))
    } ||| (ref <~ "does not have an own property with key") ~ expr ^^ {
      case (i0 ~ r) ~ (i1 ~ p) =>
        pair(i0 ++ i1, EBOp(OEq, ERef(RefProp(RefProp(r, EStr("SubMap")), p)), EAbsent))
    } ||| expr <~ "is an array index" ^^ {
      case (i ~ e) =>
        val temp = getTempId
        pair(i :+ IApp(temp, toERef("IsArrayIndex"), List(e)), toERef(temp))
    } ||| (expr <~ "and") ~ (expr <~ ("are the same" ~ ("Object" | "Number" | "Symbol") ~ "value")) ^^ {
      case (i0 ~ x) ~ (i1 ~ y) => pair(i0 ++ i1, EBOp(OEq, x, y))
    } ||| (expr <~ "and") ~ (expr <~ "are not the same Realm Record") ^^ {
      case (i0 ~ x) ~ (i1 ~ y) => pair(i0 ++ i1, EUOp(ONot, EBOp(OEq, x, y)))
    } ||| opt("both") ~> (expr <~ "and") ~ (expr <~ "are" ~ opt("both")) ~ rhs ^^ {
      case (i0 ~ x) ~ (i1 ~ y) ~ v => pair(i0 ++ i1, EBOp(OAnd, EBOp(OEq, x, v), EBOp(OEq, y, v)))
    } ||| (cond ~ condOp <~ opt("if")) ~ cond ^^ {
      case (i ~ l) ~ ((op, _)) ~ (Nil ~ r) => pair(i, EBOp(op, l, r))
      case (i0 ~ l) ~ ((op, f)) ~ (i1 ~ r) =>
        val temp = getTempId
        val (t, e) = f(ISeq(i1 :+ IAssign(toRef(temp), r)))
        pair(i0 ++ List(ILet(temp, l), IIf(toERef(temp), t, e)), toERef(temp))
    } ||| (id <~ "is") ~ opt("not") <~ "an abrupt completion" ^^ {
      case x ~ None => pair(Nil, isAbruptCompletion(x))
      case x ~ Some(_) => pair(Nil, EUOp(ONot, isAbruptCompletion(x)))
    }
  )
  val condOp: P[(BOp, Inst => (Inst, Inst))] = (
    "or" ^^^ { (OOr, (x: Inst) => (emptyInst, x)) } |||
    "and" ^^^ { (OAnd, (x: Inst) => (x, emptyInst)) }
  )
  val condBOp: P[(BOp, Boolean, Boolean)] = (
    "=" ^^^ (OEq, false, false) |||
    ("≠" | "is different from") ^^^ (OEq, true, false) |||
    "<" ^^^ (OLt, false, false) |||
    "≥" ^^^ (OLt, true, false) |||
    ">" ^^^ (OLt, false, true) |||
    "≤" ^^^ (OLt, true, true)
  )
  val rhs: P[Expr] = (
    valueParser |||
    id ^^ { toERef(_) } |||
    opt("a" | "an") ~> nt ^^ { EStr(_) } |||
    "the ordinary object internal method defined in" ~> secno ^^ { toERef(_) }
  )

  ////////////////////////////////////////////////////////////////////////////////
  // References
  ////////////////////////////////////////////////////////////////////////////////
  lazy val ref: Q[Ref] = opt("the") ~> (
    refBase ~ rep(field) ^^ {
      case x ~ es =>
        val i = es.map { case i ~ _ => i }.flatten
        val list = es.map { case _ ~ e => e }
        pair(i, (toRef(x) /: list)(RefProp(_, _)))
    } ||| id <~ "flag" ^^ {
      case x => pair(Nil, toRef(x))
    } ||| ntWithOrdinal ^^ {
      case x => pair(Nil, toRef(x))
    } ||| refBase ~ ("'s" ~> fieldName) ^^ {
      case x ~ y => pair(Nil, toRef(x, y))
    } ||| opt("intrinsic object") ~> intrinsicName ^^ {
      case x => pair(Nil, toRef(x))
    } ||| symbolName ^^ {
      case x => pair(Nil, toRef(x))
    } ||| word <~ "of" ~ contextDesc ^^ {
      case x => pair(Nil, toRef(context, x))
    } ||| "active function object" ^^^ {
      pair(Nil, toRef(context, "Function"))
    } ||| ("value currently bound to" ~> id <~ "in") ~ id ^^ {
      case x ~ y => pair(Nil, RefProp(RefProp(toRef(y, "SubMap"), toERef(x)), EStr("BoundValue")))
    }
  )
  val refBase: P[String] = nt ||| id ||| contextDesc ^^^ context ||| "current Realm Record" ^^^ realm

  // context expressions
  lazy val contextDesc: P[List[String]] = opt("the") ~> "running execution context"
  val executionStack: String = "GLOBAL_executionStack"
  val context: String = "GLOBAL_context"
  val jobQueue = "GLOBAL_jobQueue"
  val realm: String = "REALM"

  // fileds
  lazy val field: Q[Expr] = staticField ^^ { x => pair(Nil, EStr(x)) } ||| dynamicField
  lazy val staticField: P[String] = "." ~> ("[[" ~> (intrinsicName ||| word) <~ "]]" ||| word)
  lazy val dynamicField: Q[Expr] = "[" ~> expr <~ "]"
  lazy val fieldName: P[String] = (
    "outer" ~ opt("lexical") ~ "environment reference" ^^^ "Outer" |||
    word
  )

  // ordinals
  lazy val ntWithOrdinal: P[String] = opt("the") ~> (
    ordinal ~ nt ^^ { case k ~ x => x + k } |||
    nt |||
    "this this" ^^^ "this"
  )
  lazy val ordinal: P[String] = opt("the") ~> (
    "first" ^^^ "0" |||
    "second" ^^^ "1" |||
    "third" ^^^ "2"
  )

  // intrinsics
  lazy val intrinsicName: P[String] = "%" ~> word <~ "%" ^^ { "INTRINSIC_" + _ }

  // symbols
  lazy val symbolName: P[String] = "@@" ~> word ^^ { "SYMBOL_" + _ }

  // section numbers
  lazy val secno: P[Id] = (
    "9.1.1" ^^^ "OrdinaryObject.GetPrototypeOf" |
    "9.4.1.1" ^^^ "BoundFunctionExoticObject.Call" |
    "9.4.1.2" ^^^ "BoundFunctionExoticObject.Construct" |
    "9.4.2.1" ^^^ "ArrayExoticObject.DefineOwnProperty" |
    "9.4.3.1" ^^^ "StringExoticObject.GetOwnProperty" |
    "9.4.3.2" ^^^ "StringExoticObject.DefineOwnProperty" |
    "9.4.3.3" ^^^ "StringExoticObject.OwnPropertyKeys" |
    "9.4.4.1" ^^^ "ArgumentsExoticObject.GetOwnProperty" |
    "9.4.4.2" ^^^ "ArgumentsExoticObject.DefineOwnProperty" |
    "9.4.4.3" ^^^ "ArgumentsExoticObject.Get" |
    "9.4.4.4" ^^^ "ArgumentsExoticObject.Set" |
    "9.4.4.5" ^^^ "ArgumentsExoticObject.Delete" |
    "9.4.5.1" ^^^ "IntegerIndexedExoticObject.GetOwnProperty" |
    "9.4.5.2" ^^^ "IntegerIndexedExoticObject.HasProperty" |
    "9.4.5.3" ^^^ "IntegerIndexedExoticObject.DefineOwnProperty" |
    "9.4.5.4" ^^^ "IntegerIndexedExoticObject.Get" |
    "9.4.5.5" ^^^ "IntegerIndexedExoticObject.Set" |
    "9.4.5.6" ^^^ "IntegerIndexedExoticObject.OwnPropertyKeys" |
    "9.5.12" ^^^ "ProxyExoticObject.Call" |
    "9.5.13" ^^^ "ProxyExoticObject.Construct"
  ) ^^ { case x => Id(getScalaName(x)) }

  ////////////////////////////////////////////////////////////////////////////////
  // Helpers
  ////////////////////////////////////////////////////////////////////////////////
  // get temporal identifiers
  private var idCount: Int = 0
  private val TEMP_PRE: String = "__x"
  private val TEMP_POST: String = "__"
  private def getTemp: String = {
    val i = idCount
    idCount += 1
    s"$TEMP_PRE$i$TEMP_POST"
  }
  private def getTempId: Id = Id(getTemp)

  // several checks
  protected def checkEq(l: Expr, r: Expr): Expr = EBOp(OEq, l, r)
  protected def checkNot(e: Expr): Expr = EUOp(ONot, e)
  protected def checkNEq(l: Expr, r: Expr): Expr = checkNot(checkEq(l, r))

  // for-each instrutions for lists
  protected def forEachList(id: Id, expr: Expr, body: Inst, reversed: Boolean = false): Inst = {
    val list = getTemp
    val idx = getTemp
    parseInst(
      if (reversed) s"""{
        let $list = ${beautify(expr)}
        let $idx = $list.length
        while (< 0i $idx) {
          $idx = (- $idx 1i)
          let ${beautify(id)} = $list[$idx]
          ${beautify(body)}
        }
      }"""
      else s"""{
        let $list = ${beautify(expr)}
        let $idx = 0i
        while (< $idx $list.length) {
          let ${beautify(id)} = $list[$idx]
          ${beautify(body)}
          $idx = (+ $idx 1i)
        }
      }"""
    )
  }

  // for-each instrutions for maps
  protected def forEachMap(id: Id, expr: Expr, body: Inst, reversed: Boolean = false): Inst = {
    val list = getTemp
    val idx = getTemp
    parseInst(s"""{
      let $list = (map-keys ${beautify(expr)})
      let $idx = 0i
      while (< $idx $list.length) {
        let ${beautify(id)} = $list[$idx]
        ${beautify(body)}
        $idx = (+ $idx 1i)
      }
    }""")
  }

  // handle duplicated params and variable-length params
  protected def handleParams(l: List[String]): (List[Id], Option[Id]) = {
    def aux(scnt: Map[String, Int], lprev: List[Id], lnext: List[String]): List[Id] = lnext match {
      case Nil => lprev
      case s :: rest => {
        scnt.lift(s) match {
          case Some(n) => aux(scnt + (s -> (n + 1)), Id(s"$s$n") :: lprev, rest)
          case None => if (rest contains s) {
            aux(scnt + (s -> 1), Id(s + "0") :: lprev, rest)
          } else {
            aux(scnt, Id(s) :: lprev, rest)
          }
        }
      }
    }
    aux(Map(), Nil, l) match {
      case Id(x) :: tl if x.startsWith("...") =>
        (tl.reverse, Some(Id(x.substring(3))))
      case l => (l.reverse, None)
    }
  }

  // ReturnIfAbrupt
  protected def returnIfAbrupt(
    insts: List[Inst],
    expr: Expr,
    vulnerable: Boolean = true
  ): List[Inst] ~ Expr = (insts, expr) match {
    case (i, (e @ ERef(RefId(Id(x))))) => pair(i :+ parseInst(s"""
      if (= (typeof $x) "Completion") {
        if (= $x.Type CONST_normal) $x = $x.Value
        else return $x
      } else {}"""), e)
    case (i, e) =>
      val temp = getTemp
      pair(i :+ parseInst(
        if (vulnerable) s"""{
        let $temp = ${beautify(e)}
        if (= (typeof $temp) "Completion") {
          if (= $temp.Type CONST_normal) $temp = $temp.Value
          else return $temp
        } else {}
      }"""
        else s"""{
        let $temp = ${beautify(e)}
        if (= (typeof $temp) "Completion") {
          $temp = $temp.Value
        } else {}
      }"""
      ), toERef(temp))
  }

  // normalize temporal identifiers
  protected def normalizeTempIds(inst: Inst): Inst = (new Walker {
    var count: Int = 0
    def newId: String = {
      val s = s"$TEMP_PRE$count$TEMP_POST"
      count += 1
      s
    }
    var idMap: Map[String, String] = Map()
    override def walk(id: Id): Id = id.name match {
      case s if s.startsWith(TEMP_PRE) && s.endsWith(TEMP_POST) => Id(idMap.getOrElse(s, {
        val newS = newId
        idMap += (s -> newS)
        newS
      }))
      case _ => id
    }
  }).walk(inst)

  // flatten instructions
  protected def flatten(inst: Inst): Inst = inst match {
    case IIf(cond, thenInst, elseInst) =>
      IIf(cond, flatten(thenInst), flatten(elseInst))
    case IWhile(cond, body) =>
      IWhile(cond, flatten(body))
    case ISeq(insts) =>
      def aux(cur: List[Inst], remain: List[Inst]): List[Inst] = remain match {
        case Nil => cur.reverse
        case ISeq(list) :: rest => aux(cur, list ++ rest)
        case inst :: rest => aux(flatten(inst) :: cur, rest)
      }
      aux(Nil, insts) match {
        case List(inst) => inst
        case insts => ISeq(insts)
      }
    case i => i
  }

  // conversions
  def toERef(x: Id, y: Expr): ERef = ERef(toRef(x, y))
  def toERef(x: String, y: Expr): ERef = ERef(toRef(x, y))
  def toERef(x: Id, y: String): ERef = ERef(toRef(x, y))
  def toERef(x: String, y: String): ERef = ERef(toRef(x, y))
  def toERef(id: Id): ERef = ERef(toRef(id))
  def toERef(str: String): ERef = ERef(toRef(str))
  def toRef(x: Id, y: Expr): Ref = RefProp(toRef(x), y)
  def toRef(x: String, y: Expr): Ref = RefProp(toRef(x), y)
  def toRef(x: Id, y: String): Ref = RefProp(toRef(x), EStr(y))
  def toRef(x: String, y: String): Ref = RefProp(toRef(x), EStr(y))
  def toRef(id: Id): Ref = RefId(id)
  def toRef(str: String): Ref = toRef(Id(str))

  // create pair of parsing results
  protected val pair = `~`

  // get access
  def getAccess(x: String, y: String): List[Inst] ~ Expr = {
    val temp = getTemp
    pair(List(IAccess(Id(temp), toERef(x), EStr(y))), toERef(temp))
  }

  // get access
  def getAccess(
    x: String,
    f: String,
    list: List[List[Inst] ~ Expr]
  ): List[Inst] ~ Expr = {
    val temp = getTempId
    val temp2 = getTempId
    val i = list.map { case i ~ _ => i }.flatten
    val r = IAccess(temp, toERef(x), EStr(f))
    val e = IApp(temp2, toERef(temp), list.map { case _ ~ e => e })
    pair(i ++ List(r, e), toERef(temp2))
  }

  // get call
  def getCall(r: Ref, list: List[List[Inst] ~ Expr]): List[Inst] ~ Expr = {
    val temp = getTempId
    val i = list.map { case i ~ _ => i }.flatten
    val args = list.map { case i ~ e => e }
    val app = IApp(temp, ERef(r), r match {
      case RefId(_) => args
      case RefProp(b, _) => ERef(b) :: args
    })
    pair(i :+ app, toERef(temp))
  }

  // binary operator calculations
  def calc(not: Boolean, rev: Boolean, bop: BOp, left: Expr, right: Expr): Expr = {
    val (l, r) =
      if (rev) (right, left)
      else (left, right)
    val expr = EBOp(bop, l, r)
    if (not) EUOp(ONot, expr) else expr
  }

  // check abrupt completion
  def isAbruptCompletion(x: String): Expr = {
    EBOp(OAnd, checkEq(ETypeOf(toERef(x)), EStr("Completion")), checkNEq(toERef(x, "Type"), toERef("CONST_normal")))
  }

  // separators
  def sep(s: P[Any]): P[String] = (
    "," ||| "," ~ s ||| s
  ) ^^^ ""
}

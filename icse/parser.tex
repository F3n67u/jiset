\section{Parser Generation}

In this section, we introduce a way to automatically generate JavaScript parsers
from given ECMAScript specifications. First, we explain \( \bnfes \), an extension
of BNF used in ECMAScript to describe lexical and syntactic grammars of JavaScript.
We defined a recursive descent parser generator to support \( \bnfes \) notations.
We implemented our idea by extending the basic Scala parser combinator.
The implementation also support the automatic semicolon insertion,
one of the most distinct parsing feautres in ECMAScript.

\subsection{\( \bnfes \): Grammars for ECMAScripts}

ECMAScript provides their lexical and syntactic grammars as grammars
based on \( \bnfes \), an extension of Backus-Naur form for ECMAScript.
\( \bnfes \) consists of a number of \textit{productions}
with the following forms:
\[
  \nt(\param_1, \cdots, \param_k) ::=
  (\cond_1 \Rightarrow)^? \rhs_1 \mid
  \cdots \mid
  (\cond_n \Rightarrow)^? \rhs_n
\]
The left-hand side represents a parametric nonterminal \( \nt \) with
multiple boolean parameters \( \param_1, \cdots, \param_n \).
A production has multiple right-hand sides with optional conditions.
The condition \( \cond \) is either \( \param_i \) or \( ! \param_i \),
the negation of \( \param_i \).
For example, consider the following production:
\[
  \nt(\param) ::= \param \Rightarrow \code{a}
  \mid \; !\param \Rightarrow \code{b}
  \mid  \code{c}
\]
Then, \( \nt(\kwt) \) means \( \code{a} \mid \code{c} \)
and \( \nt(\kwf) \) means \( \code{b} \mid \code{c} \).

Each right-hand side \( \rhs \) is a sequence of the following symbols:
\begin{itemize}
  \item \( \boxed{\symb} \):
    basic symbols; terminal \( \code{x} \) or
    non-terminal \( \nt(\argument_1, \cdots, \argument_k) \)
  \item \( \boxed{\symb?} \): optional symbols
  \item \( \boxed{\pm \symb} \): positive/negative lookahead symbols
  \item \( \boxed{\symb \butnot \symb'} \): exclusive symbols
  \item \( \boxed{\nolt} \): no line terminator symbols
\end{itemize}

Basic symbols are either terminal or non-terminal.
A non-terminal symbol \( \nt(\argument_1, \cdots, \argument_k) \)
has multiple parameters and each argument \( \argument_i \) is
a boolean value \( \kwt \), \( \kwf \) or a parameter \( \param_i \).
An optional symbol \( \symb? \) is same with \( \epsilon \mid \symb \)
where \( \epsilon \) denotes the empty sequence.
A positive(negative) lookahead symbol \( +\symb \)(\( -\symb \))
checks that the symbol \( \symb \) succeeds(fails) and
\textit{never consumes any input}.
The exclusive symbols \( \symb \butnot \symb' \)
first checks that the symbol \( \symb \) succeeds
and then checks that the result does not correspond to \( \symb' \).
The no line terminal symbol \( \nolt \) is a special symbol
that restricts the white spaces between two other symbols.

\subsection{First/Follow Packrat Parsing}

Our goal is to automatically generate JavaScript parsers from ECMAScript
grammars written in \( \bnfes \). However, there are several problems
to use traditional lex/yacc style parser generator.
\begin{itemize}
  \item \textbf{Context-Sensitive Tokens} ECMAScript tokens are context-sensitive
    because of the regular expressions and template strings.
    For example, the code \( \code{/x/g} \) might be a regular expression token
    or four tokens to represent divided by the variable \( \code{x} \) and \( \code{g} \).
\end{itemize}

% There are two different parsing approaches:
% ``top-down'' approach (LL-style parsing) and
% ``bottom-up'' approach (LR-style parsing).
% Top-down approach support 
% 
% There are two different kinds of parsers: top-down parsing, bottom-up parsing.
% 
% 
% 
% Such features could be easily represented in Parsing Expression Grammars (PEGs).
% 
% 
% 
% Backus–Naur form(BNF)에 다섯 가지의 방식을 추가한 형태로 lexical 및 syntactic grammar를 제공한다.
% 각각의 
combination of recursive descent parsers with predictive parsers

first terms and follow terms

\subsection{Generating Parsers for \( \bnfes \)}
how to handle each \( \bnfes \) features
% \begin{table}
%   \centering
%   \[
%     \begin{array}{l|l}
%       \bnfes & \peg
%       \\\hline
%       \code{T}_\code{opt} & \code{T?}
%       \\\hline
%       \code{T but not T'} & \code{-T'} \; \code{\textasciitilde} \; \code{T}
%       \\\hline
%       \code{[lookahead} = \code{T]} & \code{+T}
%       \\\hline
%       \code{[lookahead} \neq \code{T]} & \code{-T}
%       \\\hline
%       % \code{T[P}^\code{*}\code{]} & \text{parameters}
%       % \\\hline
%       % \begin{itemize}
%       %   \item \code{?P} & \text{passing argument} \code{P}
%       %   \item \code{+P} & \kwtrue
%       %   \item \code{\textasciitilde}\code{P} &  \kwfalse
%       % \end{itemize}
%       % \code{[+P] T} & \text{if} \; \code{P} \; \text{is} \; \kwtrue \;\text{, added} \; \code{T}
%       % \\\hline
%       % \code{[\textasciitilde}\code{P] T} & if  \code{P}  is  \kwfalse , added  \code{T}
%       % \\\hline
%     \end{array}
%   \]
%   \caption{Conversion from \( \bnfes \) into \( \peg \)}
%   \label{table:bnfes}
% \end{table}

% \begin{figure}
%   \centering
%   \[
%     \begin{array}{rcrcl}
%       Call[Await] &::=& 
%       A(p, q, r) &::=& && a A(p, \kwt, \kwf)\\
%                  &\mid& p &Rightarrow& b\\
%     \end{array}
%   \]
%   \caption{Example of \( \bnfes \)}
%   \label{figure:bnfes}
% \end{figure}

% code size 줄이기 위해서 모두 풀어헤치지 않고 함수로 변환했다.

% PEG를 그대로 사용하면 backtrack을 이미 성공한 곳에서는 하지 않기 때문에
% 생기는 문제를 CFG로 적혀있는 것을 해결하기 위해서 lookahead를 추가함
% Lexical Grammar는 context-sensitive하기 때문에 먼저 lexer를 돌리지 못함
% gll에서 비슷하게 first/follow를 한 것을 보고 PEG parser를 extend함

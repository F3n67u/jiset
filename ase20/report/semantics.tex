\section{Semantics of \( \ires \)}\label{sec:semantics}

\subsection{Notations}

\[
  \begin{array}{lr@{~}c@{~}l@{~}c@{~}l}
    \text{States} & (\ctxt, \ctxtstack, \env, \heap) = \st &\in& \stset &=&
    \ctxtset \times \ctxtset^* \times \envset \times \heapset\\
    \text{Contexts} & (\id, \insts, \env) = \ctxt &\in& \ctxtset &=&
    \idset \times \instset^* \times \envset\\
    \text{Environments} & \env &\in& \envset &=&
    \idset \finmap \valset\\
    \text{Heaps} & \heap &\in& \heapset &=&
    \addrset \finmap \objset\\
    \text{Values} & \val &\in& \valset\\
    \text{Addresses} & \addr &\in& \addrset\\
    \text{Objects} & \obj &\in& \objset\\
    \text{Reference Values} & \refval &\in& \refvalset\\
  \end{array}
\]

\[
  \begin{array}{lrclrll}
    \text{Values} & \valset &\ni& \val &
    ::= & \double \mid \intvalue \mid \str \mid \bool \mid
          \C{undefined} \mid \C{null} \mid \C{absent}        & \text{(primitives)}\\
    &&&&\mid& \addr                                          & \text{(addresses)}\\
    &&&&\mid& \AST                                           & \text{(ECMAScript ASTs)}\\
    &&&&\mid& \langle \lambda \C{(}\id^*
              [, \C{*}\id]^?\C{)}.\ \inst, \env \rangle      & \text{(closures)}\\
    &&&&\mid& \langle \kappa \C{(}\id^*
              \C{)}.\ \inst, \ctxt, \ctxtstack \rangle       & \text{(continuations)}\\
    \\
    \text{Objects} & \objset &\ni& \obj &
    ::= & \str\ \C{\{} [\val\mapsto\val]^*\C{\}}             & \text{(maps)}\\
    &&&&\mid& \C{[} \val^* \C{]}                             & \text{(lists)}\\
    &&&&\mid& \C{symbol}\ \val                               & \text{(symbols)}\\
    \\
    \text{Reference Values} & \refvalset &\ni& \refval &
    ::= & \id                                                & \text{(identifiers)}\\
    &&&&\mid& \addr \C{[} \val \C{]}                         & \text{(address fields)}\\
    &&&&\mid& \str \C{[} \val \C{]}                          & \text{(string fields)}\\
  \end{array}
\]

\subsection{Semantics of Programs}

The semantics of an \( \ires \) program \( \pr \) is defined with a state
transition system \( (\stset, \trans, \stinit) \). The transition relation
\( \trans \subseteq \stset \times \stset \) describes how states are transformed
into other states as follows:
\[
  \infer
  { \st = (\ctxt, \_, \_, \_) \quad
    \ctxt = (\_, \insts = \langle \inst_0, \inst_1, \cdots, \inst_n \rangle, \_)
    \\\\
    \ctxt' = \ctxt[\insts / \langle \inst_1, \cdots, \inst_n \rangle] \quad
    \st' = \st[\ctxt / \ctxt'] \quad
    \evalinst{\st'}{\inst_0}{\st''}}
  { \st \trans \st'' }
\]
where \( x[y / z] \) denotes substituting \( y \) in \( x
\) with \( z \).  The notation \( \transrep \) is zero or more repetitions of
the transition relation \( \trans \). The initial state \( \stinit \) is defined
as follows:
\[
  \begin{array}{r@{~}c@{~}l}
    \stinit   &=& (\ctxtinit, \epsilon, \envinit, \heapinit)\\
    \ctxtinit &=& (\idret, \pr, \epsilon)\\
    \envinit  &=& \text{an initial global environment given by \( \tool \).}\\
    \heapinit &=& \text{an initial heap given by \( \tool \).}\\
    \pr       &=& \text{a given program.}\\
    \idret    &=& \text{a special identifier for return instructions.}\\
  \end{array}
\]
The collecting semantics \( \sem{p} \) of the program \( \pr \) is defined as
follows:
\[
  \sem{p} = \{ \st \mid \stinit \transrep \st \}
\]
Now, we define the operational semantics of each \( \ires \) component:
(instructions in Section~\ref{sec:inst}, expressions in Section~\ref{sec:expr},
references in Section~\ref{sec:refer}, and reference values in
Section~\ref{sec:refer-val}. We utilize several helper functions defined in
Section~\ref{sec:helper}.

\newpage

\subsection{
  Semantics of Instructions: \fbox{\( \evalinst{\st}{\inst}{\st} \)}
}\label{sec:inst}

\begin{itemize}
  \item expressions:
    \[
      \infer
      { \evalexpr{\st}{\expr}{\val}{\st_0} }
      { \evalinst{\st}{\expr}{\st_0} }
    \]
  \item let bindings:
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val}{\st_0} \quad
        \hdefine{\st_0}{\id}{\val}{\st_1}
      }
      { \evalinst{\st}{\C{let}\ \id\ \C{=}\ \expr }{\st_1} }
    \]
  \item assignments:
    \[
      \infer
      {
        \evalref{\st}{\refer}{\refval}{\st_0} \quad
        \evalexpr{\st_0}{\expr}{\val}{\st_1} \quad
        \hupdated{\st_1}{\refval}{\val}{\st_2}
      }
      { \evalinst{\st}{\refer\ \C{:=}\ \expr }{\st_2} }
    \]
  \item deletions:
    \[
      \infer
      {
        \evalref{\st}{\refer}{\refval}{\st_0} \quad
        \hdeleted{\st_0}{\refval}{\st_1}
      }
      { \evalinst{\st}{\C{delete}\ \refer }{\st_1} }
    \]
  \item append instructions:
    \[
      \infer
      {
        \evalexpr{\st}{\expr_0}{\val_0}{\st_0} \quad
        \hescape{\val_0}{\st_0}{\addr} \\\\
        \evalexpr{\st_0}{\expr_1}{\val_1}{\st_1} \quad
        \hescape{\val_1}{\st_1}{\val_2} \quad
        \happend{\st_1}{\addr}{\val_2}{\st_2}
      }
      { \evalinst{\st}{\C{append}\ \expr_0\ \leftarrow\ \expr_1}{\st_2}}
    \]
  \item prepend instructions:
    \[
      \infer
      {
        \evalexpr{\st}{\expr_0}{\val_0}{\st_0} \quad
        \hescape{\val_0}{\st_0}{\val_1} \\\\
        \evalexpr{\st_0}{\expr_1}{\val_2}{\st_1} \quad
        \hescape{\val_2}{\st_1}{\addr} \quad
        \hprepend{\st_1}{\addr}{\val_1}{\st_2}
      }
      { \evalinst{\st}{\C{prepend}\ \expr_0\ \rightarrow\ \expr_1}{\st_2}}
    \]
  \item return instructions:
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val}{\st_0} \quad
        \hreturn{\st_0}{\val}{\st_1}
      }
      { \evalinst{\st}{\C{return}\ \expr}{\st_1}}
    \]
  \item branches:
    \[
      \infer
      {
        \evalexpr{\st_0}{\expr}{\val}{\st_0} \quad
        \hescape{\val}{\st_0}{\C{true}} \quad
        \st_0 = (\ctxt_0, \_, \_, \_) \\\\
        \ctxt_0 = (\_, \insts = \langle \inst_0, \cdots, \inst_n \rangle, \_) \quad
        \ctxt_1 = \ctxt_0[\insts / \langle \inst_\C{then}, \inst_0, \cdots, \inst_n \rangle] \quad
        \st_1 = \st_0[\ctxt_0 / \ctxt_1]
      }
      { \evalinst{\st}{\C{if}\ \expr\ \inst_\C{then}\ \inst_\C{else}}{\st_1}}
    \]
    \[
      \infer
      {
        \evalexpr{\st_0}{\expr}{\val}{\st_0} \quad
        \hescape{\val}{\st_0}{\C{false}} \quad
        \st_0 = (\ctxt_0, \_, \_, \_) \\\\
        \ctxt_0 = (\_, \insts = \langle \inst_0, \cdots, \inst_n \rangle, \_) \quad
        \ctxt_1 = \ctxt_0[\insts / \langle \inst_\C{else}, \inst_0, \cdots, \inst_n \rangle] \quad
        \st_1 = \st_0[\ctxt_0 / \ctxt_1]
      }
      { \evalinst{\st}{\C{if}\ \expr\ \inst_\C{then}\ \inst_\C{else}}{\st_1}}
    \]
  \item loops:
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val}{\st_0} \quad
        \hescape{\val}{\st_0}{\C{true}} \quad
        \st_0 = (\ctxt_0, \_, \_, \_) \\\\
        \ctxt_0 = (\_, \insts = \langle \inst_0, \cdots, \inst_n \rangle, \_) \quad
        \ctxt_1 = \ctxt_0[\insts / \langle \inst, \C{while}\ \expr\ \inst, \inst_0, \cdots, \inst_n \rangle] \quad
        \st_1 = \st_0[\ctxt_0 / \ctxt_1]
      }
      { \evalinst{\st}{\C{while}\ \expr\ \inst}{\st_1}}
    \]
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val}{\st_0} \quad
        \hescape{\val}{\st_0}{\C{false}} \quad
      }
      { \evalinst{\st}{\C{while}\ \expr\ \inst}{\st_0}}
    \]
  \item sequences:
    \[
      \infer
      {
        \st = (\ctxt, \_, \_, \_) \\\\
        \ctxt = (\_, \insts' = \langle \inst'_0, \cdots, \inst'_m \rangle, \_) \quad
        \ctxt_0 = \ctxt[\insts' / \langle \inst_0, \cdots, \inst_n,
                          \inst'_0, \cdots, \inst'_m \rangle] \quad
        \st_0 = \st[\ctxt / \ctxt_0]
      }
      { \evalinst{\st}{\C{\{}\ \inst_0 \cdots \inst_n\ \C{\}}}{\st_0}}
    \]
  \item assertions:
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val}{\st_0} \quad
        \hescape{\val}{\st_0}{\C{true}}
      }
      { \evalinst{\st}{\C{assert}\ \expr}{\st_0}}
    \]
  \item print instructions:
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val}{\st_0} \quad
        \hprint{\val}
      }
      { \evalinst{\st}{\C{print}\ \expr}{\st_0}}
    \]
  \item function calls:
    \[
      \infer
      {
        \evalexpr{\st}{\expr_0}{
          \langle \lambda \C{(}\id_1, \cdots, \id_m\C{)}.\ \inst_\C{body},
          \env \rangle
        }{\st_0} \\\\
        \evalexpr{\st_0}{\expr_1}{\val_1}{\st_1} \quad
        \cdots \quad
        \evalexpr{\st_{n-1}}{\expr_n}{\val_n}{\st_n} \quad
        n < m\\\\
        \env_0 = \env[\id_1 \mapsto \val_1, \cdots, \id_n \mapsto \val_n,
        \id_{n+1} \mapsto \C{absent}, \cdots, \id_m \mapsto \C{absent}] \\\\
        \st_n = (\ctxt, \ctxtstack' = \langle \ctxt'_0, \cdots, \ctxt'_k \rangle, \_, \_)\quad
        \ctxt = (\id_\C{ret}, \_, \_) \\\\
        \ctxt_0 = \ctxt[\id_\C{ret} / \id] \quad
        \ctxt_1 = (\idret, \langle \inst_\C{body} \rangle, \env_0) \quad
        \st' = \st_n[\ctxt / \ctxt_1]
                    [\ctxtstack' / \langle \ctxt_0, \ctxt'_0, \cdots, \ctxt'_k \rangle]
      }
      { \evalinst{\st}{\C{call}\ \id\ \C{=}\ \expr_0 \C{(} \expr_1, \cdots, \expr_n \C{)} }{\st'}}
    \]
    \[
      \infer
      {
        \evalexpr{\st}{\expr_0}{
          \langle \lambda \C{(}\id_1, \cdots, \id_m\C{)}.\ \inst_\C{body},
          \env \rangle
        }{\st_0} \\\\
        \evalexpr{\st_0}{\expr_1}{\val_1}{\st_1} \quad
        \cdots \quad
        \evalexpr{\st_{n-1}}{\expr_n}{\val_n}{\st_n} \quad
        n \geq m\\\\
        \env_0 = \env[\id_1 \mapsto \val_1, \cdots, \id_m \mapsto \val_m] \\\\
        \st_n = (\ctxt, \ctxtstack' = \langle \ctxt'_0, \cdots, \ctxt'_k \rangle, \_, \_)\quad
        \ctxt = (\id_\C{ret}, \_, \_) \\\\
        \ctxt_0 = \ctxt[\id_\C{ret} / \id] \quad
        \ctxt_1 = (\idret, \langle \inst_\C{body} \rangle, \env_0) \quad
        \st' = \st_n[\ctxt / \ctxt_1]
                    [\ctxtstack' / \langle \ctxt_0, \ctxt'_0, \cdots, \ctxt'_k \rangle]
      }
      { \evalinst{\st}{\C{call}\ \id\ \C{=}\ \expr_0 \C{(} \expr_1, \cdots, \expr_n \C{)} }{\st'}}
    \]
    \[
      \infer
      {
        \evalexpr{\st}{\expr_0}{
          \langle \lambda \C{(}\id_1, \cdots, \id_m, \C{*}\id'\C{)}.\ \inst_\C{body},
          \env \rangle
        }{\st_0} \\\\
        \evalexpr{\st_0}{\expr_1}{\val_1}{\st_1} \quad
        \cdots \quad
        \evalexpr{\st_{n-1}}{\expr_n}{\val_n}{\st_n} \quad
        n < m\\\\
        \env_0 = \env[\id_1 \mapsto \val_1, \cdots, \id_n \mapsto \val_n,
        \id_{n+1} \mapsto \C{absent}, \cdots, \id_m \mapsto \C{absent}] \quad
        \env_1 = \env_0[\id' \mapsto \code{[} \code{]}] \\\\
        \st_n = (\ctxt, \ctxtstack' = \langle \ctxt'_0, \cdots, \ctxt'_k \rangle, \_, \_)\quad
        \ctxt = (\id_\C{ret}, \_, \_) \\\\
        \ctxt_0 = \ctxt[\id_\C{ret} / \id] \quad
        \ctxt_1 = (\idret, \langle \inst_\C{body} \rangle, \env_1) \quad
        \st' = \st_n[\ctxt / \ctxt_1]
                    [\ctxtstack' / \langle \ctxt_0, \ctxt'_0, \cdots, \ctxt'_k \rangle]
      }
      { \evalinst{\st}{\C{call}\ \id\ \C{=}\ \expr_0 \C{(} \expr_1, \cdots, \expr_n \C{)} }{\st'}}
    \]
    \[
      \infer
      {
        \evalexpr{\st}{\expr_0}{
          \langle \lambda \C{(}\id_1, \cdots, \id_m, \C{*}\id'\C{)}.\ \inst_\C{body},
          \env \rangle
        }{\st_0} \\\\
        \evalexpr{\st_0}{\expr_1}{\val_1}{\st_1} \quad
        \cdots \quad
        \evalexpr{\st_{n-1}}{\expr_n}{\val_n}{\st_n} \quad
        n \geq m\\\\
        \env_0 = \env[\id_1 \mapsto \val_1, \cdots, \id_m \mapsto \val_m] \quad
        \env_1 = \env_0[\id' \mapsto \code{[}\val_{m+1}, \cdots, \val_n \code{]}]\\\
        \st_n = (\ctxt, \ctxtstack' = \langle \ctxt'_0, \cdots, \ctxt'_k \rangle, \_, \_)\quad
        \ctxt = (\id_\C{ret}, \_, \_) \\\\
        \ctxt_0 = \ctxt[\id_\C{ret} / \id] \quad
        \ctxt_1 = (\idret, \langle \inst_\C{body} \rangle, \env_1) \quad
        \st' = \st_n[\ctxt / \ctxt_1]
                    [\ctxtstack' / \langle \ctxt_0, \ctxt'_0, \cdots, \ctxt'_k \rangle]
      }
      { \evalinst{\st}{\C{call}\ \id\ \C{=}\ \expr_0 \C{(} \expr_1, \cdots, \expr_n \C{)} }{\st'}}
    \]
    \[
      \infer
      {
        \evalexpr{\st}{\expr_0}{
          \langle \kappa \C{(}\id_1, \cdots, \id_m\C{)}.\ \inst_\C{body},
          \ctxt, \ctxtstack \rangle
        }{\st_0} \\\\
        \evalexpr{\st_0}{\expr_1}{\val_1}{\st_1} \quad
        \cdots \quad
        \evalexpr{\st_{n-1}}{\expr_n}{\val_n}{\st_n} \quad
        n < m\\\\
        \env_0 = \env[\id_1 \mapsto \val_1, \cdots, \id_n \mapsto \val_n,
        \id_{n+1} \mapsto \C{absent}, \cdots, \id_m \mapsto \C{absent}] \\\\
        \st_n = (\ctxt', \ctxtstack', \_, \_) \quad
        \ctxt = (\_, \insts, \env) \quad
        \ctxt_0 = \ctxt[\insts / \langle \inst_\C{body} \rangle][\env / \env_0] \quad
        \st' = \st_n[\ctxt' / \ctxt_0][\ctxtstack' / \ctxtstack]
      }
      { \evalinst{\st}{\C{call}\ \id\ \C{=}\ \expr_0 \C{(} \expr_1, \cdots, \expr_n \C{)} }{\st'}}
    \]
    \[
      \infer
      {
        \evalexpr{\st}{\expr_0}{
          \langle \kappa \C{(}\id_1, \cdots, \id_m\C{)}.\ \inst_\C{body},
          \ctxt, \ctxtstack \rangle
        }{\st_0} \\\\
        \evalexpr{\st_0}{\expr_1}{\val_1}{\st_1} \quad
        \cdots \quad
        \evalexpr{\st_{n-1}}{\expr_n}{\val_n}{\st_n} \quad
        n \geq m\\\\
        \env_0 = \env[\id_1 \mapsto \val_1, \cdots, \id_m \mapsto \val_m] \\\\
        \st_n = (\ctxt', \ctxtstack', \_, \_) \quad
        \ctxt = (\_, \insts, \env) \quad
        \ctxt_0 = \ctxt[\insts / \langle \inst_\C{body} \rangle][\env / \env_0] \quad
        \st' = \st_n[\ctxt' / \ctxt_0][\ctxtstack' / \ctxtstack]
      }
      { \evalinst{\st}{\C{call}\ \id\ \C{=}\ \expr_0 \C{(} \expr_1, \cdots, \expr_n \C{)} }{\st'}}
    \]
  \item field accesses:
    \[
      \infer
      {
        \evalexpr{\st}{\expr_0}{\val_0}{\st_0} \quad
        \hescape{\val_0}{\st_0}{\addr} \quad
        \evalexpr{\st_0}{\expr_1}{\val_1}{\st_1} \quad
        \hescape{\val_1}{\st_1}{\val_2} \\\\
        \hgetaddrfield{\st_1}{\addr}{\val_2}{\val'} \quad
        \hdefine{\st_1}{\id}{\val'}{\st_2}
      }
      { \evalinst{\st}{\C{access}\ \id\ \C{=}\ \expr_0 \C{[} \expr_1 \C{]} }{\st_2}}
    \]
    \[
      \infer
      {
        \evalexpr{\st}{\expr_0}{\val_0}{\st_0} \quad
        \hescape{\val_0}{\st_0}{\str} \quad
        \evalexpr{\st_0}{\expr_1}{\val_1}{\st_1} \quad
        \hescape{\val_1}{\st_1}{\val_2} \\\\
        \hgetstrfield{\str}{\val_2}{\val'} \quad
        \hdefine{\st_1}{\id}{\val'}{\st_2}
      }
      { \evalinst{\st}{\C{access}\ \id\ \C{=}\ \expr_0 \C{[} \expr_1 \C{]} }{\st_2}}
    \]
    \[
      \infer
      {
        \evalexpr{\st}{\expr_0}{\val_0}{\st_0} \quad
        \hescape{\val_0}{\st_0}{\AST} \quad
        \evalexpr{\st_0}{\expr_1}{\val_1}{\st_1} \quad
        \hescape{\val_1}{\st_1}{\val_2} \\\\
        \hgetastfield{\AST}{\val_2}{\val'} \quad
        \hdefine{\st_1}{\id}{\val'}{\st_2}
      }
      { \evalinst{\st}{\C{access}\ \id\ \C{=}\ \expr_0 \C{[} \expr_1 \C{]} }{\st_2}}
    \]
  \item continuation bindings:
    \[
      \infer
      {
        \st = (\ctxt, \ctxtstack, \_, \_) \quad
        \hdefine{\st}{\id_0}{
          \langle \kappa \C{(}\id_1, \cdots, \id_n\C{)}.\ \inst, \ctxt, \ctxtstack \rangle
        }{\st_0}
      }
      { \evalinst{\st}{\C{withcont}\ \id_0 \C{(} \id_1, \cdots, \id_n \C{)}\ \C{=}\ \inst}{\st_0} }
    \]
\end{itemize}

\newpage


\subsection{
  Semantics of Expressions: \fbox{\( \evalexpr{\st}{\expr}{\val}{\st} \)}
}\label{sec:expr}

\begin{itemize}
  \item primitives:
    \[
      \evalexpr{\st}{\double}{\double}{\st} \quad
      \evalexpr{\st}{\intvalue}{\intvalue}{\st} \quad
      \evalexpr{\st}{\str}{\str}{\st} \quad
      \evalexpr{\st}{\bool}{\bool}{\st}
    \]
    \[
      \evalexpr{\st}{\C{undefined}}{\C{undefined}}{\st} \quad
      \evalexpr{\st}{\C{null}}{\C{null}}{\st} \quad
      \evalexpr{\st}{\C{absent}}{\C{absent}}{\st}
    \]
  \item maps:
    \[
      \infer
      {
        \hallocmap{\st}{\str}{\addr}{\st_0} \\\\
        \evalexpr{\st_0}{\expr_{k_1}}{\val_{k_1}}{\sigma_{k_1}}\quad
        \hescape{\val_{k_1}}{\sigma_{k_1}}{\val'_{k_1}} \\\\
        \evalexpr{\st_{k_1}}{\expr_{v_1}}{\val_{v_1}}{\sigma_{v_1}} \quad
        \hupdated{\st_{v_1}}{\addr\C{[}\val'_{k_1}\C{]}}{\val_{v_1}}{\st_1} \\\\
        \cdots \\\\
        \evalexpr{\st_{n-1}}{\expr_{k_n}}{\val_{k_n}}{\sigma_{k_n}}\quad
        \hescape{\val_{k_n}}{\sigma_{k_n}}{\val'_{k_n}} \\\\
        \evalexpr{\st_{k_n}}{\expr_{v_n}}{\val_{v_n}}{\sigma_{v_n}} \quad
        \hupdated{\st_{v_n}}{\addr\C{[}\val'_{k_n}\C{]}}{\val_{v_n}}{\st_n}
      }
      {\evalexpr{\st}{\C{new}\ \str\ \C{\{}\expr_{k_1} \mapsto \expr_{v_1},
      \cdots, \expr_{k_n} \mapsto \expr_{v_n}\C{\}}}{\addr}{\st_n}}
    \]
  \item lists:
    \[
      \infer
      {
        \evalexpr{\st}{\expr_0}{\val_0}{\st_0} \quad
        \cdots \quad
        \evalexpr{\st_{n-1}}{\expr_n}{\val_n}{\st_n} \quad
        \halloclist{\st_n}{\langle \val_0, \cdots, \val_n \rangle}{\addr}{\st'} \quad
      }
      {\evalexpr{\st}{\C{new}\ \C{[} \expr_0, \cdots, \expr_n \C{]}}{\addr}{\st'}}
    \]
  \item symbols:
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val}{\st_0} \quad
        \hescape{\val}{\st_0}{\val'} \quad
        \hallocsym{\st_0}{\val'}{\addr}{\st'} \quad
      }
      {\evalexpr{\st}{\C{new}\ \expr}{\addr}{\st'}}
    \]
  \item pop expressions:
    \[
      \infer
      {
        \evalexpr{\st}{\expr_0}{\val_0}{\st_0} \quad
        \hescape{\val_0}{\st_0}{\addr} \\\\
        \evalexpr{\st_0}{\expr_1}{\val_1}{\st_1} \quad
        \hescape{\val_1}{\st_1}{\intvalue} \quad
        \hpop{\st_1}{\addr}{\intvalue}{\val'}{\st'}
      }
      {\evalexpr{\st}{\C{pop}\ \expr_0\ \expr_1}{\val'}{\st'}}
    \]
  \item references:
    \[
      \infer
      {
        \evalref{\st}{\refer}{\refval}{\st_0} \quad
        \evalrefv{\st_0}{\refval}{\val}{\st_1}
      }
      {\evalexpr{\st}{\refer}{\val}{\st_1}}
    \]
  \item continuations:
    \[
      \infer
      {
        \st = (\ctxt, \ctxtstack, \_, \_)
      }
      {\evalexpr{\st}{\C{(} \id_0, \cdots, \id_n \C{)}\ \C{=>}\ \inst}{
          \langle \kappa \C{(}\id_0, \cdots, \id_n  \C{)}.\ \inst, \ctxt, \ctxtstack \rangle
      }{\st}}
    \]
  \item unary operations:
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val}{\st'}
      }
      {\evalexpr{\st}{\uop\ \expr}{\uop\ \val}{\st'}}
    \]
  \item binary operations:
    \[
      \infer
      {
        \evalexpr{\st}{\expr_0}{\val_0}{\st_0} \quad
        \evalexpr{\st_0}{\expr_1}{\val_1}{\st_1} \quad
      }
      {\evalexpr{\st}{\expr_0 \bop \expr_1}{\val_0 \bop \val_1}{\st_1}}
    \]
  \item typeof expressions:
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val}{\st'} \quad
        \hgettype{\st'}{\val}{\str}
      }
      {\evalexpr{\st}{\C{typeof}\ \expr}{\str}{\st'}}
    \]
  \item completion checks:
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val}{\st'} \quad
        \hiscompletion{\st'}{\val}{\bool}
      }
      {\evalexpr{\st}{\C{is-completion}\ \expr}{\bool}{\st'}}
    \]
  \item instance checks:
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val}{\st'} \quad
        \hescape{\val}{\st'}{\AST} \quad
        \hisinstanceof{\AST}{\str}{\bool}
      }
      {\evalexpr{\st}{\C{is-instance-of}\ \expr\ \str}{\bool}{\st'}}
    \]
  \item element getters:
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val}{\st_0} \quad
        \hescape{\val}{\st_0}{\AST} \quad
        \hgetelems{\st_0}{\AST}{\str}{\addr}{\st_1}
      }
      {\evalexpr{\st}{\C{get-elems}\ \expr\ \str}{\addr}{\st_1}}
    \]
  \item syntax getters:
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val}{\st'} \quad
        \hescape{\val}{\st'}{\AST} \quad
        \hgetsyntax{\AST}{\str}
      }
      {\evalexpr{\st}{\C{get-syntax}\ \expr}{\str}{\st'}}
    \]
  \item parse expressions:
    \[
      \infer
      {
        \evalexpr{\st}{\expr_\C{code}}{\val_\C{code}}{\st_0} \quad
        \hescape{\val_\C{code}}{\st_0}{\val} \quad
        \evalexpr{\st_0}{\expr_\C{rule}}{\val_\C{rule}}{\st_1} \quad
        \hescape{\val_\C{rule}}{\st_1}{\str} \\\\
        \evalexpr{\st_1}{\expr_1}{\bool_1}{\st_2} \quad
        \cdots \quad
        \evalexpr{\st_n}{\expr_n}{\bool_n}{\st'} \quad
        \hparse{\val}{\str}{\langle \bool_1, \cdots, \bool_n \rangle}{\AST}
      }
      {\evalexpr{\st}{\C{parse-syntax}\ \expr_\C{code}\ \expr_\C{rule}\ \expr_1 \cdots \expr_n}{\AST}{\st'}}
    \]
  \item conversions:
    \[
      \infer
      {
        \evalexpr{\st}{\expr_0}{\val_0}{\st_0} \quad
        \hescape{\val_0}{\st_0}{\val'_0} \quad
        \evalexpr{\st_0}{\expr_1}{\val_1}{\st_1} \quad
        \hescape{\val_1}{\st_1}{\val'_1} \\\\
        \hconvert{\C{num2str}}{\val'_0}{\val'_1}{\str}
      }
      {\evalexpr{\st}{\C{convert}\ \expr_0\ \C{num2str}\ \expr_1}{\str}{\st_1}}
    \]
    \[
      \infer
      {
        \evalexpr{\st}{\expr_0}{\val_0}{\st_0} \quad
        \hescape{\val_0}{\st_0}{\val_1} \quad
        \cop \neq \C{num2str} \quad
        \hconvert{\cop}{\val_1}{\C{absent}}{\val}
      }
      {\evalexpr{\st}{\C{convert}\ \expr_0\ \cop}{\val}{\st_0}}
    \]
  \item contain checks:
    \[
      \infer
      {
        \evalexpr{\st}{\expr_0}{\val_0}{\st_0} \quad
        \hescape{\val_0}{\st_0}{\addr} \quad
        \evalexpr{\st_0}{\expr_1}{\val_1}{\st_1} \quad
        \hescape{\val_1}{\st_1}{\val} \\\\
        \hcontains{\st_1}{\addr}{\val}{\bool}
      }
      {\evalexpr{\st}{\C{contains}\ \expr_0\ \expr_1}{\bool}{\st_1}}
    \]
  \item object copies:
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val}{\st_0} \quad
        \hescape{\val}{\st_0}{\addr} \quad
        \st_0 = (\_, \_, \_, \heap) \quad
        \addr' \not\in \dom{\heap} \\\\
        \heap' = \heap[\addr' \mapsto \heap(\addr)] \quad
        \st' = \st_0[\heap / \heap']
      }
      {\evalexpr{\st}{\C{copy}\ \expr}{\addr'}{\st'}}
    \]
  \item key collections:
    \[
      \infer
      {
        \evalexpr{\st}{\expr}{\val}{\st_0} \quad
        \hescape{\val}{\st_0}{\addr} \quad
        \hkeys{\st_0}{\addr}{\addr'}{\st'}
      }
      {\evalexpr{\st}{\C{keys}\ \expr}{\addr'}{\st'}}
    \]
\end{itemize}

\newpage


\subsection{
  Semantics of References: \fbox{\( \evalref{\st}{\refer}{\refval}{\st} \)}
}\label{sec:refer}

\begin{itemize}
  \item identifier references:
    \[
      \evalref{\st}{\id}{\id}{\st}
    \]
  \item field references:
    \[
      \infer
      {
        \evalref{\st}{\refer}{\refval}{\st_0} \quad
        \evalrefv{\st_0}{\refval}{\val_0}{\st_1} \quad
        \hescape{\val_0}{\st_1}{\addr} \\\\
        \evalexpr{\st_1}{\expr}{\val_1}{\st_2} \quad
        \hescape{\val_1}{\st_2}{\val}
      }
      {\evalref{\st}{\refer \C{[} \expr \C{]}}{\addr \C{[} \val \C{]}}{\st_2}}
    \]
    \[
      \infer
      {
        \evalref{\st}{\refer}{\refval}{\st_0} \quad
        \evalrefv{\st_0}{\refval}{\val_0}{\st_1} \quad
        \hescape{\val_0}{\st_1}{\str} \\\\
        \evalexpr{\st_1}{\expr}{\val_1}{\st_2} \quad
        \hescape{\val_1}{\st_2}{\val}
      }
      {\evalref{\st}{\refer \C{[} \expr \C{]}}{\str \C{[} \val \C{]}}{\st_2}}
    \]
\end{itemize}


\subsection{
  Semantics of Reference Values: \fbox{\( \evalrefv{\st}{\refval}{\val}{\st} \)}
}\label{sec:refer-val}

\begin{itemize}
  \item identifiers:
    \[
      \infer
      {
        \hlookup{\st}{\id}{\val}
      }
      {\evalrefv{\st}{\id}{\val}{\st}}
    \]
  \item address fields:
    \[
      \infer
      {
        \hgetaddrfield{\st}{\addr}{\val}{\val'} \quad
      }
      {\evalrefv{\st}{\addr \C{[} \val \C{]}}{\val'}{\st}}
    \]
  \item string fields:
    \[
      \infer
      {
        \hgetstrfield{\str}{\val}{\val'}
      }
      {\evalrefv{\st}{\str \C{[} \val \C{]}}{\val'}{\st}}
    \]
\end{itemize}

\newpage


\subsection{Helper Functions}\label{sec:helper}

\[
  \begin{array}{lcl}
    \cescape(\val, \st) &=& \left\{
      \begin{array}{ll}
        \val' & \text{if}\
        \val = \addr \wedge
        \cget(\st, \addr) = \obj \wedge
        \obj = \C{"Completion"}\ \C{\{} \cdots, \C{"Value"} \mapsto \val', \cdots \C{\}}\\
        \val & \text{otherwise}\\
      \end{array}
    \right.\\\\

    \cget(\st, \addr) &=& \left\{
      \begin{array}{ll}
        \obj & \text{if}\
        \st = (\_, \_, \_, \heap) \wedge
        \heap(\addr) = \obj\\
        \bot & \text{otherwise}\\
      \end{array}
    \right.\\\\

    \cset(\st, \addr, \obj) &=& \left\{
      \begin{array}{ll}
        \st' & \text{if}\
        \st = (\_, \_, \_, \heap) \wedge
        \heap' = \heap[\addr \mapsto \obj] \wedge
        \st' = \st[\heap / \heap']\\
        \bot & \text{otherwise}\\
      \end{array}
    \right.\\\\

    \cdefine(\st, \id, \val) &=& \st'\ \text{where}\ \left\{
      \begin{array}{ll}
        \st = (\ctxt, \_, \_, \_) \wedge
        \ctxt = (\_, \_, \env) \wedge\\
        \env' = \env[\id \mapsto \val] \wedge
        \ctxt' = \ctxt[\env / \env'] \wedge
        \st' = \st[\ctxt / \ctxt']\\
      \end{array}
    \right.\\\\

    \cupdated(\st, \refval, \val) &=& \left\{
      \begin{array}{ll}
        \st' & \text{if}\
        \refval = \id \wedge
        \st = (\_, \_, \env, \_) \wedge
        \id \in \dom{\env} \wedge
        \env' = \env[\id \mapsto \val] \wedge
        \st' = \st[\env / \env']\\

        \st' & \text{if}\
        \refval = \id \wedge
        \st = (\_, \_, \env, \_) \wedge
        \id \not\in \dom{\env} \wedge
        \st' = \cdefine(\st, \id, \val)\\

        \st' & \text{if}\
        \refval = \addr \C{[} \val' \C{]} \wedge
        \st = (\_, \_, \_, \heap) \wedge
        \heap(\addr) = \obj \wedge
        \obj = \str\ \C{\{} \cdots \C{\}} \wedge\\
        & \phantom{\text{if}}\
        \obj' = \obj[\val' \mapsto \val] \wedge
        \heap' = \heap[\addr \mapsto \obj'] \wedge
        \st' = \st[\heap / \heap']\\

        \bot & \text{otherwise}\\
      \end{array}
    \right.\\\\

    \cdeleted(\st, \refval) &=& \left\{
      \begin{array}{ll}
        \st' & \text{if}\
        \refval = \id \wedge
        \st = (\ctxt, \_, \_, \_) \wedge
        \ctxt = (\_, \_, \env) \\
        & \phantom{\text{if}}\
        \env' = \env - \id \wedge
        \ctxt' = \ctxt[\env / \env'] \wedge
        \st' = \st[\ctxt / \ctxt']\\

        \st' & \text{if}\
        \refval = \addr \C{[} \val \C{]} \wedge
        \cget(\st, \addr) = \obj \wedge
        \obj = \str\ \C{\{} \cdots \C{\}} \wedge\\
        & \phantom{\text{if}}\
        \obj' = \obj - \val \wedge
        \st' = \cset(\st, \addr, \obj')\\

        \bot & \text{otherwise}\\
      \end{array}
    \right.\\\\

    \cappend(\st, \addr, \val) &=& \left\{
      \begin{array}{ll}
        \st' & \text{if}\
        \cget(\st, \addr) = \C{[} \val_1, \cdots, \val_n \C{]} \wedge
        \obj = \C{[} \val_1, \cdots, \val_n, \val \C{]} \wedge
        \st' = \cset(\st, \addr, \obj)\\

        \bot & \text{otherwise}\\
      \end{array}
    \right.\\\\

    \cprepend(\st, \addr, \val) &=& \left\{
      \begin{array}{ll}
        \st' & \text{if}\
        \cget(\st, \addr) = \C{[} \val_1, \cdots, \val_n \C{]} \wedge
        \obj = \C{[} \val, \val_1, \cdots, \val_n \C{]} \wedge
        \st' = \cset(\st, \addr, \obj)\\

        \bot & \text{otherwise}\\
      \end{array}
    \right.\\\\

    \creturn(\st, \val) &=& \left\{
      \begin{array}{ll}
        \st'' & \text{if}\
        \st = (\ctxt, \ctxtstack = \langle \ctxt_0, \cdots, \ctxt_n \rangle, \_, \_) \wedge
        \ctxt_0 = (\id, \_, \_) \\
        & \phantom{\text{if}}\
        \st' = \cdefine(\st, \id, \val) \wedge
        \st'' = \st'[\ctxtstack / \langle \ctxt_1, \cdots, \ctxt_n \rangle]\\

        \bot & \text{otherwise}\\
      \end{array}
    \right.\\\\

    \cprint(\val) &=& \text{print the given value}\ \val\\\\

    \cgetaddrfield(\st, \addr, \val) &=& \left\{
      \begin{array}{ll}
        \val' & \text{if}\
        \cget(\st, \addr) = \obj = \str\ \C{\{} \cdots \C{\}} \wedge
        \val \in \dom{\obj} \wedge
        \val' = \obj(\val)\\

        \C{absent} & \text{if}\
        \cget(\st, \addr) = \obj = \str\ \C{\{} \cdots \C{\}} \wedge
        \val \not\in \dom{\obj}\\

        \val_\intvalue & \text{if}\
        \cget(\st, \addr) = \obj = \C{[} \val_0, \cdots, \val_{m-1} \C{]} \wedge
        \val = \intvalue \wedge
        0 \leq \intvalue < m\\

        \C{absent} & \text{if}\
        \cget(\st, \addr) = \obj = \C{[} \val_0, \cdots, \val_{m-1} \C{]} \wedge
        \val = \intvalue \wedge
        (\intvalue < 0 \vee m \leq \intvalue)\\

        m & \text{if}\
        \cget(\st, \addr) = \obj = \C{[} \val_0, \cdots, \val_{m-1} \C{]} \wedge
        \val = \C{"length"}\\

        \val' & \text{if}\
        \cget(\st, \addr) = \obj = \C{symbol}\ \val' \wedge
        \val = \C{"Description"}\\

        \bot & \text{otherwise}\\
      \end{array}
    \right.\\\\

    \cgetstrfield(\str, \val) &=& \left\{
      \begin{array}{ll}
        \intvalue & \text{if}\
        \val = \C{"length"} \wedge
        \intvalue = (\text{the length of}\ \str)\\

        \str' & \text{if}\
        \val = \double \wedge
        \intvalue = (\text{the corresponding integer value of}\ \double)\ \wedge \\
        & \phantom{\text{if}}\
        \str' = (\text{a string consisting of only the}\ \intvalue\text{'th
        character of}\ \str)\\

        \str' & \text{if}\
        \val = \intvalue \wedge
        \str' = (\text{a string consisting of only the}\ \intvalue\text{'th
        character of}\ \str)\\

        \bot & \text{otherwise}\\
      \end{array}
    \right.\\
  \end{array}
\]

\[
  \begin{array}{lcl}
    \cgetastfield(\AST, \val) &=& \left\{
      \begin{array}{ll}
        \val' & \text{if}\
        \val = \str \wedge
        \val' = (\AST\text{'s member of name $\str$, which is unique})\\

        \bot & \text{otherwise}\\
      \end{array}
    \right.\\\\

    \callocmap(\st, \str) &=& (\addr, \st')\ \text{where}\ \left\{
      \begin{array}{ll}
        \addr = (\text{a new address not in}\ \st) \\
        \st' = \cset(\st, \addr, \str\ \C{\{}\C{\}})\\
      \end{array}
    \right.\\\\

    \calloclist(\st, \langle \val_1, \cdots, \val_n \rangle) &=& (\addr, \st')\ \text{where}\ \left\{
      \begin{array}{ll}
        \addr = (\text{a new address not in}\ \st) \\
        \st' = \cset(\st, \addr, \C{[}\val_1, \cdots, \val_n\C{]})\\
      \end{array}
    \right.\\\\

    \callocsym(\st, \val) &=& (\addr, \st')\ \text{where}\ \left\{
      \begin{array}{ll}
        \addr = (\text{a new address not in}\ \st) \\
        \st' = \cset(\st, \addr, \C{symbol}\ \val)\\
      \end{array}
    \right.\\\\

    \cpop(\st, \addr, \intvalue) &=& \left\{
      \begin{array}{ll}
        (\val_\intvalue, \st') & \text{if}\
        \cget(\st, \addr) = \obj = \C{[} \val_0, \cdots, \val_{m-1} \C{]} \wedge
        0 \leq \intvalue < m \wedge \\
        & \phantom{\text{if}}\
        \obj' = \C{[} \val_0, \cdots, \val_{\intvalue-1}, \val_{\intvalue+1},
        \cdots, \val_{m-1} \C{]} \wedge
        \st' = \cset(\st, \addr, \obj')\\

        \bot & \text{otherwise}\\
      \end{array}
    \right.\\\\

    \cgettype(\st, \val) &=& \left\{
      \begin{array}{ll}
        \C{"Number"}        & \text{if}\ \val = \double \vee \val = \intvalue\\
        \C{"String"}        & \text{if}\ \val = \str\\
        \C{"Boolean"}       & \text{if}\ \val = \bool\\
        \C{"Undefined"}     & \text{if}\ \val = \C{undefined}\\
        \C{"Null"}          & \text{if}\ \val = \C{null}\\
        \C{"Absent"}        & \text{if}\ \val = \C{absent}\\
        \C{"Function"}      & \text{if}\
        \val = \langle \lambda \C{(}\cdots\C{)}.\ \inst, \env \rangle\\
        \C{"Continuation"}  & \text{if}\
        \val = \langle \kappa \C{(}\cdots\C{)}.\ \inst, \ctxt, \ctxtstack \rangle\\
        \C{"AST"}           & \text{if}\ \val = \AST\\
        \str                & \text{if}\
        \val = \addr \wedge \cget(\st, \addr) = \str\ \C{\{} \cdots \C{\}})\\
        \C{"List"}          & \text{if}\
        \val = \addr \wedge \cget(\st, \addr) = \C{[} \cdots \C{]})\\
        \C{"Symbol"}        & \text{if}\
        \val = \addr \wedge \cget(\st, \addr) = \C{symbol}\ \val')\\
        \bot                & \text{otherwise}\\
      \end{array}
    \right.\\\\

    \ciscompletion(\st, \val) &=& \left\{
      \begin{array}{ll}
        \C{true} & \text{if}\
        \val = \addr \wedge
        \cget(\st, \addr) = \C{"Completion"}\ \C{\{} \cdots \C{\}}\\

        \C{false} & \text{otherwise}\\
      \end{array}
    \right.\\\\

    \cisinstanceof(\AST, \str) &=& \left\{
      \begin{array}{ll}
        \C{true} & \text{if}\
        \AST\ \text{is the syntax element whose kind is}\ \str\\
        \C{false} & \text{otherwise}\\
      \end{array}
    \right.\\\\

    \cgetelems(\st, \AST, \str) &=& (\addr, \st')\ \text{where}\ \left\{
      \begin{array}{ll}
        \langle \AST_1, \cdots, \AST_n \rangle =
        (\text{the list of syntax elements,}\\
        \text{whose kind is $\str$, of $\AST$ with pre-order traversal})\\
        \halloclist{\st}{\langle \AST_1, \cdots, \AST_n \rangle}{\addr}{\st'}\\
      \end{array}
    \right.\\\\

    \cgetsyntax(\AST) &=& (\text{the beautified form of string for $AST$})\\\\
     
    \cparse(\val, \str, \langle \bool_1, \cdots, \bool_n \rangle) &=& \left\{
      \begin{array}{ll}
        \AST & \text{if}\ \val = \str_\C{rule} \wedge\\
        & \phantom{\text{if}}\
        \AST = (\text{the parsing result of $\str$ based on the rule $\str_\C{rule}$}\\
        & \phantom{\text{if}\ \AST = (}
        \text{with boolean arguments $\langle \bool_1, \cdots, \bool_n \rangle$})\\

        \AST' & \text{if}\
        \val = \AST \wedge
        \langle \bool'_1, \cdots, \bool'_n \rangle = (\text{boolean parameters
        stored in $\AST$})\wedge\\
        & \phantom{\text{if}}\
        \AST' = (\text{the parsing result of $\str$ based on the rule $\str_\C{rule}$}\\
        & \phantom{\text{if}\ \AST = (}
        \text{with boolean arguments $\langle \bool'_1, \cdots, \bool'_n \rangle$})\\

        \bot & \text{otherwise}\\
      \end{array}
    \right.\\\\

  \end{array}
\]
\[
  \begin{array}{lcl}
    \cconvert(\cop, \val, \val') &=& \left\{
      \begin{array}{ll}
        \double & \text{if}\
        \cop = \C{str2num}\ \wedge
        \val = \str \wedge
        \val' = \C{absent} \wedge\\
        & \phantom{\text{if}}\
        \double = (\text{the corresponding floating point of $\str$})\\

        \str & \text{if}\
        \cop = \C{num2str}\ \wedge
        \val = \double \wedge
        \val' = \intvalue\wedge\\
        & \phantom{\text{if}}\
        \str = (\text{the corresponding string of $\double$ with the radix $\intvalue$})\\

        \intvalue & \text{if}\
        \cop = \C{num2int}\ \wedge
        \val = \double \wedge
        \val' = \C{absent} \wedge\\
        & \phantom{\text{if}}\
        \intvalue = (\text{the corresponding integer value of $\double$})\ \wedge \\

        \bot & \text{otherwise}\\
      \end{array}
    \right.\\\\

    \ccontains(\st, \addr, \val) &=& \left\{
      \begin{array}{ll}
        \C{true} & \text{if}\
        \cget(\st, \addr) = \C{[} \val_1, \cdots, \val_n \C{]}) \wedge
        \exists 1 \leq i \leq n.\ \val_i = \val\\

        \C{false} & \text{if}\
        \cget(\st, \addr) = \C{[} \val_1, \cdots, \val_n \C{]}) \wedge
        \forall 1 \leq i \leq n.\ \val_i \neq \val\\

        \bot & \text{otherwise}\\
      \end{array}
    \right.\\\\

    \ckeys(\st, \addr) &=& \left\{
      \begin{array}{ll}
        (\addr', \st') & \text{if}\
        \cget(\st, \addr) = \str \C{\{} \val_1 \mapsto \_, \cdots, \val_n
        \mapsto \_\C{\}}) \wedge \\
        & \phantom{\text{if}}\
        \langle \val'_1, \cdots, \val'_n \rangle =
        (\text{the list consisting of $\val_1, \cdots, \val_n$}\\
        & \phantom{\text{if}\ \langle \val'_1, \cdots, \val'_n \rangle = (}
        \text{ordered by their creation time.}) \\
        & \phantom{\text{if}}\
        (\addr', \st') = \calloclist(\st, \langle \val'_1, \cdots, \val'_n \rangle) \\

        \bot & \text{otherwise}\\
      \end{array}
    \right.\\\\

    \clookup(\st, \id) &=& \left\{
      \begin{array}{ll}
        \env(\id) & \text{if}\
        \st = (\ctxt, \_, \_, \_) \wedge
        \ctxt = (\_, \_, \env) \wedge
        \id \in \dom{\env}\\

        \env(\id) & \text{if}\
        \st = (\_, \_, \env, \_) \wedge
        \id \in \dom{\env}\\

        \C{absent} & \text{otherwise}\\
      \end{array}
    \right.\\
  \end{array}
\]
